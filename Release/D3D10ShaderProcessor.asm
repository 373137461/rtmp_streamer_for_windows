; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

	TITLE	F:\songmm_moon_stone_obs\OBS\Source\D3D10ShaderProcessor.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_R0?AUD3D10_INPUT_ELEMENT_DESC@@@8		; D3D10_INPUT_ELEMENT_DESC `RTTI Type Descriptor'
PUBLIC	?validSemanticStrings@@3PAPBDA			; validSemanticStrings
PUBLIC	?validSemanticTStrings@@3PAPB_WA		; validSemanticTStrings
EXTRN	__imp_??0BufferOutputSerializer@@QAE@AAV?$List@E@@H@Z:PROC
EXTRN	__imp_??1BufferOutputSerializer@@UAE@XZ:PROC
EXTRN	__imp_?IsValid@String@@QBEHXZ:PROC
EXTRN	__imp_??0Vect4@@QAE@XZ:PROC
EXTRN	__imp_??4Vect4@@QAEAAU0@ABU0@@Z:PROC
EXTRN	__imp_?MakeFromRGBA@Vect4@@QAEAAU1@K@Z:PROC
EXTRN	__imp_?ReadFileToString@XFile@@QAEXAAVString@@@Z:PROC
EXTRN	__imp_?FindReplace@String@@QAEAAV1@PB_W0@Z:PROC
EXTRN	__imp_?NumTokens@String@@QBEH_W@Z:PROC
EXTRN	__imp_?GetTokenOffset@String@@QBEPB_WH_W@Z:PROC
EXTRN	__imp_?Mid@String@@QAE?AV1@II@Z:PROC
EXTRN	_stricmp:PROC
EXTRN	__imp_?scmp_n@@YGHPB_W0I@Z:PROC
EXTRN	_isdigit:PROC
EXTRN	__imp_?supr@@YGXPA_W@Z:PROC
EXTRN	__imp_?scmpi_n@@YGHPB_W0I@Z:PROC
?validSemanticStrings@@3PAPBDA DD FLAT:$SG4294914688	; validSemanticStrings
	DD	FLAT:$SG4294914687
	DD	FLAT:$SG4294914686
	DD	FLAT:$SG4294914685
	DD	FLAT:$SG4294914684
?validSemanticTStrings@@3PAPB_WA DD FLAT:$SG4294914693	; validSemanticTStrings
	DD	FLAT:$SG4294914692
	DD	FLAT:$SG4294914691
	DD	FLAT:$SG4294914690
	DD	FLAT:$SG4294914689
_DATA	ENDS
;	COMDAT ??_R0?AUD3D10_INPUT_ELEMENT_DESC@@@8
data$r	SEGMENT
??_R0?AUD3D10_INPUT_ELEMENT_DESC@@@8 DD FLAT:??_7type_info@@6B@ ; D3D10_INPUT_ELEMENT_DESC `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUD3D10_INPUT_ELEMENT_DESC@@', 00H
	ORG $+2
$SG4294914693 DB 'S', 00H, 'V', 00H, '_', 00H, 'P', 00H, 'o', 00H, 's', 00H
	DB	'i', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 00H, 00H
$SG4294914691 DB 'C', 00H, 'O', 00H, 'L', 00H, 'O', 00H, 'R', 00H, 00H, 00H
	ORG $+3
$SG4294914692 DB 'N', 00H, 'O', 00H, 'R', 00H, 'M', 00H, 'A', 00H, 'L', 00H
	DB	00H, 00H
	ORG $+2
$SG4294914690 DB 'T', 00H, 'A', 00H, 'N', 00H, 'G', 00H, 'E', 00H, 'N', 00H
	DB	'T', 00H, 00H, 00H
$SG4294914689 DB 'T', 00H, 'E', 00H, 'X', 00H, 'C', 00H, 'O', 00H, 'O', 00H
	DB	'R', 00H, 'D', 00H, 00H, 00H
	ORG $+2
$SG4294914688 DB 'SV_Position', 00H
	ORG $+2
$SG4294914687 DB 'NORMAL', 00H
	ORG $+1
$SG4294914685 DB 'TANGENT', 00H
$SG4294914684 DB 'TEXCOORD', 00H
	ORG $+3
$SG4294914686 DB 'COLOR', 00H
	ORG $+2
$SG4294914683 DB 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H, 'u', 00H, 'd', 00H
	DB	'e', 00H, 00H, 00H
$SG4294914682 DB '>', 00H, 00H, 00H
	ORG $+2
$SG4294914681 DB 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG4294914679 DB '{', 00H, 00H, 00H
	ORG $+2
$SG4294914680 DB 's', 00H, 't', 00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H
	DB	00H, 00H
	ORG $+2
$SG4294914678 DB 'f', 00H, 'l', 00H, 'o', 00H, 'a', 00H, 't', 00H, 00H, 00H
$SG4294914677 DB 'c', 00H, 'o', 00H, 'l', 00H, 'o', 00H, 'r', 00H, 00H, 00H
$SG4294914676 DB ';', 00H, 00H, 00H
$SG4294914675 DB ';', 00H, 00H, 00H
$SG4294914674 DB 'SV_Position', 00H
$SG4294914673 DB 'NORMAL', 00H
	ORG $+1
$SG4294914672 DB 'COLOR', 00H
	ORG $+2
$SG4294914671 DB 'TANGENT', 00H
$SG4294914670 DB 'TEXCOORD', 00H
	ORG $+3
$SG4294914669 DB 'c', 00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, 00H, 00H
$SG4294914668 DB 'v', 00H, 'o', 00H, 'i', 00H, 'd', 00H, 00H, 00H
	ORG $+2
$SG4294914667 DB ';', 00H, 00H, 00H
$SG4294914666 DB 'u', 00H, 'n', 00H, 'i', 00H, 'f', 00H, 'o', 00H, 'r', 00H
	DB	'm', 00H, 00H, 00H
$SG4294914665 DB 's', 00H, 'a', 00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, 00H
	DB	00H
	ORG $+2
$SG4294914664 DB '{', 00H, 00H, 00H
$SG4294914663 DB ';', 00H, 00H, 00H
$SG4294914662 DB '}', 00H, 00H, 00H
$SG4294914661 DB '=', 00H, 00H, 00H
$SG4294914660 DB ';', 00H, 00H, 00H
$SG4294914659 DB ';', 00H, 00H, 00H
$SG4294914658 DB ';', 00H, 00H, 00H
$SG4294914657 DB ';', 00H, 00H, 00H
$SG4294914656 DB '}', 00H, 00H, 00H
$SG4294914655 DB '}', 00H, 00H, 00H
$SG4294914654 DB ';', 00H, 00H, 00H
$SG4294914653 DB ']', 00H, 00H, 00H
$SG4294914652 DB ';', 00H, 00H, 00H
$SG4294914651 DB 't', 00H, 'e', 00H, 'x', 00H, 't', 00H, 'u', 00H, 'r', 00H
	DB	'e', 00H, 00H, 00H
$SG4294914650 DB '1', 00H, 'D', 00H, 00H, 00H
	ORG $+2
$SG4294914649 DB '2', 00H, 'D', 00H, 00H, 00H
	ORG $+2
$SG4294914648 DB '3', 00H, 'D', 00H, 00H, 00H
	ORG $+2
$SG4294914647 DB 'C', 00H, 'U', 00H, 'B', 00H, 'E', 00H, 00H, 00H
	ORG $+2
$SG4294914646 DB 's', 00H, 'a', 00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H
	DB	'r', 00H, 00H, 00H
$SG4294914645 DB 'f', 00H, 'l', 00H, 'o', 00H, 'a', 00H, 't', 00H, 00H, 00H
$SG4294914644 DB '2', 00H, 00H, 00H
$SG4294914643 DB '3', 00H, 00H, 00H
$SG4294914642 DB '4', 00H, 00H, 00H
$SG4294914641 DB '3', 00H, 'x', 00H, '3', 00H, 00H, 00H
$SG4294914640 DB '4', 00H, 'x', 00H, '4', 00H, 00H, 00H
$SG4294914639 DB 'i', 00H, 'n', 00H, 't', 00H, 00H, 00H
$SG4294914638 DB 'b', 00H, 'o', 00H, 'o', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG4294914637 DB '=', 00H, 00H, 00H
$SG4294914636 DB 'f', 00H, 'l', 00H, 'o', 00H, 'a', 00H, 't', 00H, 00H, 00H
$SG4294914635 DB 'i', 00H, 'n', 00H, 't', 00H, 00H, 00H
$SG4294914634 DB 'f', 00H, 'l', 00H, 'o', 00H, 'a', 00H, 't', 00H, 00H, 00H
$SG4294914633 DB '{', 00H, 00H, 00H
$SG4294914632 DB ';', 00H, 00H, 00H
$SG4294914631 DB ';', 00H, 00H, 00H
$SG4294914630 DB '}', 00H, 00H, 00H
$SG4294914629 DB ';', 00H, 00H, 00H
$SG4294914628 DB 'A', 00H, 'd', 00H, 'd', 00H, 'r', 00H, 'e', 00H, 's', 00H
	DB	's', 00H, 00H, 00H
$SG4294914627 DB 'I', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 's', 00H, 'h', 00H, 'a', 00H, 'd', 00H, 'e'
	DB	00H, 'r', 00H, ' ', 00H, 'a', 00H, 'd', 00H, 'd', 00H, 'r', 00H
	DB	'e', 00H, 's', 00H, 's', 00H, ' ', 00H, 't', 00H, 'y', 00H, 'p'
	DB	00H, 'e', 00H, ' ', 00H, '%', 00H, 'd', 00H, 00H, 00H
	ORG $+2
$SG4294914626 DB 'W', 00H, 'r', 00H, 'a', 00H, 'p', 00H, 00H, 00H
	ORG $+2
$SG4294914625 DB 'R', 00H, 'e', 00H, 'p', 00H, 'e', 00H, 'a', 00H, 't', 00H
	DB	00H, 00H
	ORG $+2
$SG4294914624 DB 'C', 00H, 'l', 00H, 'a', 00H, 'm', 00H, 'p', 00H, 00H, 00H
$SG4294914623 DB 'N', 00H, 'o', 00H, 'n', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG4294914622 DB 'M', 00H, 'i', 00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H
	DB	00H, 00H
	ORG $+2
$SG4294914621 DB 'B', 00H, 'o', 00H, 'r', 00H, 'd', 00H, 'e', 00H, 'r', 00H
	DB	00H, 00H
	ORG $+2
$SG4294914620 DB 'M', 00H, 'i', 00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H
	DB	'O', 00H, 'n', 00H, 'c', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG4294914619 DB 'M', 00H, 'a', 00H, 'x', 00H, 'A', 00H, 'n', 00H, 'i', 00H
	DB	's', 00H, 'o', 00H, 't', 00H, 'r', 00H, 'o', 00H, 'p', 00H, 'y'
	DB	00H, 00H, 00H
$SG4294914618 DB 'F', 00H, 'i', 00H, 'l', 00H, 't', 00H, 'e', 00H, 'r', 00H
	DB	00H, 00H
	ORG $+2
$SG4294914617 DB 'A', 00H, 'n', 00H, 'i', 00H, 's', 00H, 'o', 00H, 't', 00H
	DB	'r', 00H, 'o', 00H, 'p', 00H, 'i', 00H, 'c', 00H, 00H, 00H
$SG4294914616 DB 'P', 00H, 'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, 00H, 00H
$SG4294914615 DB 'M', 00H, 'I', 00H, 'N', 00H, '_', 00H, 'M', 00H, 'A', 00H
	DB	'G', 00H, '_', 00H, 'M', 00H, 'I', 00H, 'P', 00H, '_', 00H, 'P'
	DB	00H, 'O', 00H, 'I', 00H, 'N', 00H, 'T', 00H, 00H, 00H
$SG4294914614 DB 'L', 00H, 'i', 00H, 'n', 00H, 'e', 00H, 'a', 00H, 'r', 00H
	DB	00H, 00H
	ORG $+2
$SG4294914613 DB 'M', 00H, 'I', 00H, 'N', 00H, '_', 00H, 'M', 00H, 'A', 00H
	DB	'G', 00H, '_', 00H, 'M', 00H, 'I', 00H, 'P', 00H, '_', 00H, 'L'
	DB	00H, 'I', 00H, 'N', 00H, 'E', 00H, 'A', 00H, 'R', 00H, 00H, 00H
	ORG $+2
$SG4294914612 DB 'M', 00H, 'I', 00H, 'N', 00H, '_', 00H, 'M', 00H, 'A', 00H
	DB	'G', 00H, '_', 00H, 'P', 00H, 'O', 00H, 'I', 00H, 'N', 00H, 'T'
	DB	00H, '_', 00H, 'M', 00H, 'I', 00H, 'P', 00H, '_', 00H, 'L', 00H
	DB	'I', 00H, 'N', 00H, 'E', 00H, 'A', 00H, 'R', 00H, 00H, 00H
	ORG $+2
$SG4294914611 DB 'M', 00H, 'I', 00H, 'N', 00H, '_', 00H, 'P', 00H, 'O', 00H
	DB	'I', 00H, 'N', 00H, 'T', 00H, '_', 00H, 'M', 00H, 'A', 00H, 'G'
	DB	00H, '_', 00H, 'L', 00H, 'I', 00H, 'N', 00H, 'E', 00H, 'A', 00H
	DB	'R', 00H, '_', 00H, 'M', 00H, 'I', 00H, 'P', 00H, '_', 00H, 'P'
	DB	00H, 'O', 00H, 'I', 00H, 'N', 00H, 'T', 00H, 00H, 00H
	ORG $+2
$SG4294914610 DB 'M', 00H, 'I', 00H, 'N', 00H, '_', 00H, 'P', 00H, 'O', 00H
	DB	'I', 00H, 'N', 00H, 'T', 00H, '_', 00H, 'M', 00H, 'A', 00H, 'G'
	DB	00H, '_', 00H, 'M', 00H, 'I', 00H, 'P', 00H, '_', 00H, 'L', 00H
	DB	'I', 00H, 'N', 00H, 'E', 00H, 'A', 00H, 'R', 00H, 00H, 00H
	ORG $+2
$SG4294914609 DB 'M', 00H, 'I', 00H, 'N', 00H, '_', 00H, 'L', 00H, 'I', 00H
	DB	'N', 00H, 'E', 00H, 'A', 00H, 'R', 00H, '_', 00H, 'M', 00H, 'A'
	DB	00H, 'G', 00H, '_', 00H, 'M', 00H, 'I', 00H, 'P', 00H, '_', 00H
	DB	'P', 00H, 'O', 00H, 'I', 00H, 'N', 00H, 'T', 00H, 00H, 00H
	ORG $+2
$SG4294914607 DB 'M', 00H, 'I', 00H, 'N', 00H, '_', 00H, 'M', 00H, 'A', 00H
	DB	'G', 00H, '_', 00H, 'L', 00H, 'I', 00H, 'N', 00H, 'E', 00H, 'A'
	DB	00H, 'R', 00H, '_', 00H, 'M', 00H, 'I', 00H, 'P', 00H, '_', 00H
	DB	'P', 00H, 'O', 00H, 'I', 00H, 'N', 00H, 'T', 00H, 00H, 00H
	ORG $+2
$SG4294914608 DB 'M', 00H, 'I', 00H, 'N', 00H, '_', 00H, 'L', 00H, 'I', 00H
	DB	'N', 00H, 'E', 00H, 'A', 00H, 'R', 00H, '_', 00H, 'M', 00H, 'A'
	DB	00H, 'G', 00H, '_', 00H, 'P', 00H, 'O', 00H, 'I', 00H, 'N', 00H
	DB	'T', 00H, '_', 00H, 'M', 00H, 'I', 00H, 'P', 00H, '_', 00H, 'L'
	DB	00H, 'I', 00H, 'N', 00H, 'E', 00H, 'A', 00H, 'R', 00H, 00H, 00H
$SG4294914606 DB 'B', 00H, 'o', 00H, 'r', 00H, 'd', 00H, 'e', 00H, 'r', 00H
	DB	'C', 00H, 'o', 00H, 'l', 00H, 'o', 00H, 'r', 00H, 00H, 00H
$SG4294914605 DB ',', 00H, 00H, 00H
$SG4294914604 DB ',', 00H, 00H, 00H
$SG4294914603 DB ',', 00H, 00H, 00H
$SG4294914602 DB '}', 00H, 00H, 00H
PUBLIC	?Add@?$List@UD3D10_INPUT_ELEMENT_DESC@@@@QAEIABUD3D10_INPUT_ELEMENT_DESC@@@Z ; List<D3D10_INPUT_ELEMENT_DESC>::Add
PUBLIC	?SetSize@?$List@UShaderParam@@@@QAEHI@Z		; List<ShaderParam>::SetSize
PUBLIC	?SetSize@?$List@UShaderSampler@@@@QAEHI@Z	; List<ShaderSampler>::SetSize
PUBLIC	??A?$List@UD3D10_INPUT_ELEMENT_DESC@@@@QAEAAUD3D10_INPUT_ELEMENT_DESC@@I@Z ; List<D3D10_INPUT_ELEMENT_DESC>::operator[]
PUBLIC	??6?$List@UD3D10_INPUT_ELEMENT_DESC@@@@QAEAAV0@ABUD3D10_INPUT_ELEMENT_DESC@@@Z ; List<D3D10_INPUT_ELEMENT_DESC>::operator<<
PUBLIC	?CreateNew@?$List@UShaderParam@@@@QAEPAUShaderParam@@XZ ; List<ShaderParam>::CreateNew
PUBLIC	?CreateNew@?$List@UShaderSampler@@@@QAEPAUShaderSampler@@XZ ; List<ShaderSampler>::CreateNew
PUBLIC	?AddState@ShaderProcessor@@QAEHAAUSamplerInfo@@AAVString@@1@Z ; ShaderProcessor::AddState
PUBLIC	?GetSemanticInfo@@YA_NABVString@@AAUSemanticInfo@@@Z ; GetSemanticInfo
PUBLIC	?SetCodeStart@CodeTokenizer@@QAEXPB_W@Z		; CodeTokenizer::SetCodeStart
PUBLIC	?CreateSamplerState@@YAPAVSamplerState@@AAUSamplerInfo@@@Z ; CreateSamplerState
PUBLIC	??0SamplerInfo@@QAE@XZ				; SamplerInfo::SamplerInfo
PUBLIC	??6@YAAAVSerializer@@AAV0@AAM@Z			; operator<<
PUBLIC	??6@YAAAVSerializer@@AAV0@AAH@Z			; operator<<
PUBLIC	?ProcessShader@ShaderProcessor@@QAEHPB_W0@Z	; ShaderProcessor::ProcessShader
	ALIGN	4

__Tuple_alloc DB 01H DUP (?)
	ALIGN	4

_ignore	DB	01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
	ALIGN	4

_piecewise_construct DB 01H DUP (?)
_BSS	ENDS
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
_ignore$initializer$ DD FLAT:??__Eignore@std@@YAXXZ
__Tuple_alloc$initializer$ DD FLAT:??__E_Tuple_alloc@std@@YAXXZ
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10shaderprocessor.cpp
;	COMDAT ?ProcessShader@ShaderProcessor@@QAEHPB_W0@Z
_TEXT	SEGMENT
_info$1 = -512						; size = 48
_ShaderFile$2 = -464					; size = 24
_lpCurPos$3 = -436					; size = 4
_semanticInfo$4 = -432					; size = 8
_inputElement$5 = -424					; size = 28
_loadFile$6 = -396					; size = 8
$T7 = -388						; size = 4
_strShader$8 = -384					; size = 8
$T9 = -376						; size = 4
$T10 = -372						; size = 4
_iValue$11 = -368					; size = 4
$T12 = -364						; size = 4
$T13 = -360						; size = 4
$T14 = -356						; size = 4
$T15 = -352						; size = 4
$T16 = -348						; size = 4
_fValue$17 = -344					; size = 4
$T18 = -340						; size = 4
$T19 = -336						; size = 4
$T20 = -332						; size = 4
$T21 = -328						; size = 4
$T22 = -324						; size = 4
$T23 = -320						; size = 4
$T24 = -316						; size = 4
$T25 = -312						; size = 4
$T26 = -308						; size = 4
$T27 = -304						; size = 4
_num$28 = -300						; size = 4
$T29 = -296						; size = 4
$T30 = -292						; size = 4
$T31 = -288						; size = 4
$T32 = -284						; size = 4
$T33 = -280						; size = 4
$T34 = -276						; size = 4
$T35 = -272						; size = 4
$T36 = -268						; size = 4
$T37 = -264						; size = 4
$T38 = -260						; size = 4
_lpSavedPos$39 = -256					; size = 4
$T40 = -252						; size = 4
$T41 = -248						; size = 4
$T42 = -244						; size = 4
$T43 = -240						; size = 4
$T44 = -236						; size = 4
$T45 = -232						; size = 4
$T46 = -228						; size = 4
_fValue$47 = -224					; size = 4
$T48 = -220						; size = 4
$T49 = -216						; size = 4
$T50 = -212						; size = 4
$T51 = -208						; size = 4
$T52 = -204						; size = 4
$T53 = -200						; size = 4
$T54 = -196						; size = 4
$T55 = -192						; size = 4
$T56 = -188						; size = 4
tv1377 = -184						; size = 4
tv1375 = -180						; size = 4
_curSampler$57 = -176					; size = 4
tv419 = -172						; size = 4
_lpLastPos$ = -168					; size = 4
_bNewCodeLine$ = -164					; size = 4
_parent$58 = -160					; size = 8
_strSemantic$59 = -152					; size = 8
_strValue$60 = -144					; size = 8
_sOut$61 = -136						; size = 12
_strName$62 = -124					; size = 8
_strType$63 = -116					; size = 8
_i$64 = -108						; size = 4
_i$65 = -104						; size = 4
_i$66 = -100						; size = 4
_i$67 = -96						; size = 4
_j$68 = -92						; size = 4
_i$69 = -88						; size = 4
_lpType$70 = -84					; size = 4
_lpType$71 = -80					; size = 4
_strState$72 = -76					; size = 8
_bError$ = -68						; size = 4
_lpFloatType$73 = -64					; size = 4
_bFoundTexCoord$74 = -57				; size = 1
_param$75 = -56						; size = 4
_floatCount$76 = -52					; size = 4
_curInsideCount$ = -48					; size = 4
_curSlot$77 = -44					; size = 4
_savedToken$78 = -40					; size = 8
_strName$79 = -32					; size = 8
_bFoundDefinitionStruct$80 = -21			; size = 1
_strType$81 = -20					; size = 8
_curToken$ = -12					; size = 8
_this$ = -4						; size = 4
_input$ = 8						; size = 4
_filename$ = 12						; size = 4
?ProcessShader@ShaderProcessor@@QAEHPB_W0@Z PROC	; ShaderProcessor::ProcessShader, COMDAT
; _this$ = ecx

; 66   : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 512				; 00000200H
	mov	DWORD PTR _this$[ebp], ecx

; 67   :     String curToken;

	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 68   : 
; 69   :     BOOL bError = FALSE;

	mov	DWORD PTR _bError$[ebp], 0

; 70   : 
; 71   :     SetCodeStart(input);

	mov	eax, DWORD PTR _input$[ebx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCodeStart@CodeTokenizer@@QAEXPB_W@Z	; CodeTokenizer::SetCodeStart

; 72   : 
; 73   :     TSTR lpLastPos = lpTemp;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _lpLastPos$[ebp], edx

; 74   : 
; 75   :     DWORD curInsideCount = 0;

	mov	DWORD PTR _curInsideCount$[ebp], 0

; 76   :     BOOL  bNewCodeLine = TRUE;

	mov	DWORD PTR _bNewCodeLine$[ebp], 1
$LN201@ProcessSha:

; 77   : 
; 78   :     while(GetNextToken(curToken))

	push	0
	lea	eax, DWORD PTR _curToken$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	je	$LN181@ProcessSha

; 79   :     {
; 80   :         TSTR lpCurPos = lpTemp-curToken.Length();

	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_?Length@String@@QBEIXZ
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	sub	edx, eax
	mov	DWORD PTR _lpCurPos$3[ebp], edx

; 81   : 
; 82   :         if(curToken[0] == '{')

	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	ecx, 2
	imul	edx, ecx, 0
	movzx	eax, WORD PTR [eax+edx]
	cmp	eax, 123				; 0000007bH
	jne	SHORT $LN180@ProcessSha

; 83   :             ++curInsideCount;

	mov	ecx, DWORD PTR _curInsideCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _curInsideCount$[ebp], ecx
	jmp	$LN102@ProcessSha
$LN180@ProcessSha:

; 84   :         else if(curToken[0] == '}')

	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	edx, 2
	imul	ecx, edx, 0
	movzx	edx, WORD PTR [eax+ecx]
	cmp	edx, 125				; 0000007dH
	jne	SHORT $LN178@ProcessSha

; 85   :             --curInsideCount;

	mov	eax, DWORD PTR _curInsideCount$[ebp]
	sub	eax, 1
	mov	DWORD PTR _curInsideCount$[ebp], eax
	jmp	$LN102@ProcessSha
$LN178@ProcessSha:

; 86   :         else if(curToken[0] == '(')

	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	ecx, 2
	imul	edx, ecx, 0
	movzx	eax, WORD PTR [eax+edx]
	cmp	eax, 40					; 00000028H
	jne	SHORT $LN176@ProcessSha

; 87   :             ++curInsideCount;

	mov	ecx, DWORD PTR _curInsideCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _curInsideCount$[ebp], ecx
	jmp	$LN102@ProcessSha
$LN176@ProcessSha:

; 88   :         else if(curToken[0] == ')')

	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	edx, 2
	imul	ecx, edx, 0
	movzx	edx, WORD PTR [eax+ecx]
	cmp	edx, 41					; 00000029H
	jne	SHORT $LN174@ProcessSha

; 89   :             --curInsideCount;

	mov	eax, DWORD PTR _curInsideCount$[ebp]
	sub	eax, 1
	mov	DWORD PTR _curInsideCount$[ebp], eax
	jmp	$LN102@ProcessSha
$LN174@ProcessSha:

; 90   :         else if(curToken[0] == '#') //preprocessor

	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	ecx, 2
	imul	edx, ecx, 0
	movzx	eax, WORD PTR [eax+edx]
	cmp	eax, 35					; 00000023H
	jne	$LN172@ProcessSha

; 91   :         {
; 92   :             HandMeAToken(curToken);

	push	0
	lea	ecx, DWORD PTR _curToken$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN171@ProcessSha
	mov	DWORD PTR $T23[ebp], 0
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T23[ebp]
	jmp	$LN183@ProcessSha
$LN171@ProcessSha:

; 93   :             if(scmpi_n(curToken, TEXT("include"), 7) == 0)

	push	7
	push	OFFSET $SG4294914683
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?scmpi_n@@YGHPB_W0I@Z
	test	eax, eax
	jne	$LN170@ProcessSha

; 94   :             {
; 95   :                 GetNextToken(curToken);

	push	0
	lea	edx, DWORD PTR _curToken$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken

; 96   :                 if(curToken[0] == '<')

	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	ecx, 2
	imul	edx, ecx, 0
	movzx	eax, WORD PTR [eax+edx]
	cmp	eax, 60					; 0000003cH
	jne	SHORT $LN169@ProcessSha

; 97   :                     EscapeLikeTheWind(TEXT(">")); //TODO: handle #include <foo> directives

	push	1
	push	OFFSET $SG4294914682
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GotoToken@CodeTokenizer@@QAEHPB_WH@Z	; CodeTokenizer::GotoToken
	test	eax, eax
	jne	SHORT $LN168@ProcessSha
	mov	DWORD PTR $T30[ebp], 0
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T30[ebp]
	jmp	$LN183@ProcessSha
$LN168@ProcessSha:
	jmp	$LN201@ProcessSha
$LN169@ProcessSha:

; 98   :                 String parent(filename);

	mov	ecx, DWORD PTR _filename$[ebx]
	push	ecx
	lea	ecx, DWORD PTR _parent$58[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PB_W@Z

; 99   :                 int num = parent.NumTokens('/');

	push	47					; 0000002fH
	lea	ecx, DWORD PTR _parent$58[ebp]
	call	DWORD PTR __imp_?NumTokens@String@@QBEH_W@Z
	mov	DWORD PTR _num$28[ebp], eax

; 100  :                 String loadFile = curToken.Mid(1, curToken.Length()-1);

	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_?Length@String@@QBEIXZ
	sub	eax, 1
	push	eax
	push	1
	lea	edx, DWORD PTR _loadFile$6[ebp]
	push	edx
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_?Mid@String@@QAE?AV1@II@Z

; 101  :                 parent.FindReplace(parent.GetTokenOffset(num-1, '/'), loadFile);

	lea	ecx, DWORD PTR _loadFile$6[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	push	47					; 0000002fH
	mov	eax, DWORD PTR _num$28[ebp]
	sub	eax, 1
	push	eax
	lea	ecx, DWORD PTR _parent$58[ebp]
	call	DWORD PTR __imp_?GetTokenOffset@String@@QBEPB_WH_W@Z
	push	eax
	lea	ecx, DWORD PTR _parent$58[ebp]
	call	DWORD PTR __imp_?FindReplace@String@@QAEAAV1@PB_W0@Z

; 102  :                 
; 103  :                 XFile ShaderFile;

	lea	ecx, DWORD PTR _ShaderFile$2[ebp]
	call	DWORD PTR __imp_??0XFile@@QAE@XZ

; 104  : 
; 105  :                 if(!ShaderFile.Open(parent, XFILE_READ, XFILE_OPENEXISTING))

	push	3
	push	1
	lea	ecx, DWORD PTR _parent$58[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	lea	ecx, DWORD PTR _ShaderFile$2[ebp]
	call	DWORD PTR __imp_?Open@XFile@@QAEHPB_WKK@Z
	test	eax, eax
	jne	SHORT $LN167@ProcessSha

; 106  :                     continue;

	lea	ecx, DWORD PTR _ShaderFile$2[ebp]
	call	DWORD PTR __imp_??1XFile@@QAE@XZ
	lea	ecx, DWORD PTR _loadFile$6[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _parent$58[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	jmp	$LN201@ProcessSha
$LN167@ProcessSha:

; 107  : 
; 108  :                 String strShader;

	lea	ecx, DWORD PTR _strShader$8[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 109  :                 ShaderFile.ReadFileToString(strShader);

	lea	ecx, DWORD PTR _strShader$8[ebp]
	push	ecx
	lea	ecx, DWORD PTR _ShaderFile$2[ebp]
	call	DWORD PTR __imp_?ReadFileToString@XFile@@QAEXAAVString@@@Z

; 110  :                 ProcessShader(strShader, parent);

	lea	ecx, DWORD PTR _parent$58[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	lea	ecx, DWORD PTR _strShader$8[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ProcessShader@ShaderProcessor@@QAEHPB_W0@Z ; ShaderProcessor::ProcessShader

; 111  :             }

	lea	ecx, DWORD PTR _strShader$8[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _ShaderFile$2[ebp]
	call	DWORD PTR __imp_??1XFile@@QAE@XZ
	lea	ecx, DWORD PTR _loadFile$6[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _parent$58[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN170@ProcessSha:

; 112  :         }

	jmp	$LN102@ProcessSha
$LN172@ProcessSha:

; 113  :         else if(!curInsideCount && bNewCodeLine) //not inside any code, so this is some sort of declaration (function/struct/var)

	cmp	DWORD PTR _curInsideCount$[ebp], 0
	jne	$LN102@ProcessSha
	cmp	DWORD PTR _bNewCodeLine$[ebp], 0
	je	$LN102@ProcessSha

; 114  :         {
; 115  :             if(curToken == TEXT("class"))

	push	OFFSET $SG4294914681
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??8String@@QBEHPB_W@Z
	test	eax, eax
	je	$LN164@ProcessSha
$LN202@ProcessSha:

; 116  :             {
; 117  :                 while(GetNextToken(curToken))

	push	0
	lea	edx, DWORD PTR _curToken$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	je	SHORT $LN162@ProcessSha

; 118  :                 {
; 119  :                     if(curToken[0] == '{')

	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	ecx, 2
	imul	edx, ecx, 0
	movzx	eax, WORD PTR [eax+edx]
	cmp	eax, 123				; 0000007bH
	jne	SHORT $LN161@ProcessSha

; 120  :                         curInsideCount++;

	mov	ecx, DWORD PTR _curInsideCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _curInsideCount$[ebp], ecx
	jmp	SHORT $LN156@ProcessSha
$LN161@ProcessSha:

; 121  :                     else if(curToken[0] == '}')

	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	edx, 2
	imul	ecx, edx, 0
	movzx	edx, WORD PTR [eax+ecx]
	cmp	edx, 125				; 0000007dH
	jne	SHORT $LN159@ProcessSha

; 122  :                         curInsideCount--;

	mov	eax, DWORD PTR _curInsideCount$[ebp]
	sub	eax, 1
	mov	DWORD PTR _curInsideCount$[ebp], eax
	jmp	SHORT $LN156@ProcessSha
$LN159@ProcessSha:

; 123  :                     else if(curToken[0] == ';')

	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	ecx, 2
	imul	edx, ecx, 0
	movzx	eax, WORD PTR [eax+edx]
	cmp	eax, 59					; 0000003bH
	jne	SHORT $LN156@ProcessSha

; 124  :                         if(curInsideCount == 0)

	cmp	DWORD PTR _curInsideCount$[ebp], 0
	jne	SHORT $LN156@ProcessSha

; 125  :                             continue;

	jmp	SHORT $LN202@ProcessSha
$LN156@ProcessSha:

; 126  :                 }

	jmp	SHORT $LN202@ProcessSha
$LN162@ProcessSha:

; 127  :             }
; 128  :             else if(curToken == TEXT("struct"))

	jmp	$LN102@ProcessSha
$LN164@ProcessSha:
	push	OFFSET $SG4294914680
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??8String@@QBEHPB_W@Z
	test	eax, eax
	je	$LN154@ProcessSha

; 129  :             {
; 130  :                 //try to see if this is the vertex definition structure
; 131  :                 bool bFoundDefinitionStruct = false;

	mov	BYTE PTR _bFoundDefinitionStruct$80[ebp], 0

; 132  : 
; 133  :                 HandMeAToken(curToken);

	push	0
	lea	ecx, DWORD PTR _curToken$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN153@ProcessSha
	mov	DWORD PTR $T26[ebp], 0
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T26[ebp]
	jmp	$LN183@ProcessSha
$LN153@ProcessSha:

; 134  :                 ExpectTokenIgnore(TEXT("{"));

	push	0
	lea	edx, DWORD PTR _curToken$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN152@ProcessSha
	mov	DWORD PTR $T24[ebp], 0
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T24[ebp]
	jmp	$LN183@ProcessSha
$LN152@ProcessSha:
	push	OFFSET $SG4294914679
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??9String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN151@ProcessSha
	jmp	$LN201@ProcessSha
$LN151@ProcessSha:

; 135  :                 curInsideCount = 1;

	mov	DWORD PTR _curInsideCount$[ebp], 1
$LN150@ProcessSha:

; 136  : 
; 137  :                 do 
; 138  :                 {
; 139  :                     HandMeAToken(curToken);

	push	0
	lea	eax, DWORD PTR _curToken$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN147@ProcessSha
	mov	DWORD PTR $T22[ebp], 0
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T22[ebp]
	jmp	$LN183@ProcessSha
$LN147@ProcessSha:

; 140  :                     if(curToken.Length() <= 6 && scmpi_n(curToken, TEXT("float"), 5) == 0)

	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_?Length@String@@QBEIXZ
	cmp	eax, 6
	ja	$LN146@ProcessSha
	push	5
	push	OFFSET $SG4294914678
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?scmpi_n@@YGHPB_W0I@Z
	test	eax, eax
	jne	$LN146@ProcessSha

; 141  :                     {
; 142  :                         String strType = curToken;

	lea	ecx, DWORD PTR _curToken$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strType$63[ebp]
	call	DWORD PTR __imp_??0String@@QAE@ABV0@@Z

; 143  : 
; 144  :                         String strName;

	lea	ecx, DWORD PTR _strName$62[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 145  :                         HandMeAToken(strName);

	push	0
	lea	edx, DWORD PTR _strName$62[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN145@ProcessSha
	mov	DWORD PTR $T20[ebp], 0
	lea	ecx, DWORD PTR _strName$62[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$63[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T20[ebp]
	jmp	$LN183@ProcessSha
$LN145@ProcessSha:

; 146  : 
; 147  :                         HandMeAToken(curToken);

	push	0
	lea	eax, DWORD PTR _curToken$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN144@ProcessSha
	mov	DWORD PTR $T16[ebp], 0
	lea	ecx, DWORD PTR _strName$62[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$63[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T16[ebp]
	jmp	$LN183@ProcessSha
$LN144@ProcessSha:

; 148  :                         if(curToken[0] != ':') //cancel if not a vertex definition structure

	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	ecx, 2
	imul	edx, ecx, 0
	movzx	eax, WORD PTR [eax+edx]
	cmp	eax, 58					; 0000003aH
	je	SHORT $LN143@ProcessSha

; 149  :                         {
; 150  :                             bFoundDefinitionStruct = false;

	mov	BYTE PTR _bFoundDefinitionStruct$80[ebp], 0

; 151  :                             break;

	lea	ecx, DWORD PTR _strName$62[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$63[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	jmp	$LN148@ProcessSha
$LN143@ProcessSha:

; 152  :                         }
; 153  : 
; 154  :                         String strSemantic;

	lea	ecx, DWORD PTR _strSemantic$59[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 155  :                         HandMeAToken(strSemantic);

	push	0
	lea	ecx, DWORD PTR _strSemantic$59[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN142@ProcessSha
	mov	DWORD PTR $T14[ebp], 0
	lea	ecx, DWORD PTR _strSemantic$59[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strName$62[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$63[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T14[ebp]
	jmp	$LN183@ProcessSha
$LN142@ProcessSha:

; 156  : 
; 157  :                         SemanticInfo semanticInfo;
; 158  :                         if(!GetSemanticInfo(strSemantic, semanticInfo))

	lea	edx, DWORD PTR _semanticInfo$4[ebp]
	push	edx
	lea	eax, DWORD PTR _strSemantic$59[ebp]
	push	eax
	call	?GetSemanticInfo@@YA_NABVString@@AAUSemanticInfo@@@Z ; GetSemanticInfo
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN141@ProcessSha

; 159  :                         {
; 160  :                             bFoundDefinitionStruct = false;

	mov	BYTE PTR _bFoundDefinitionStruct$80[ebp], 0

; 161  :                             break;

	lea	ecx, DWORD PTR _strSemantic$59[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strName$62[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$63[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	jmp	$LN148@ProcessSha
$LN141@ProcessSha:

; 162  :                         }
; 163  : 
; 164  :                         D3D10_INPUT_ELEMENT_DESC inputElement;
; 165  :                         inputElement.SemanticName           = semanticInfo.lpName;

	mov	edx, DWORD PTR _semanticInfo$4[ebp]
	mov	DWORD PTR _inputElement$5[ebp], edx

; 166  :                         inputElement.SemanticIndex          = semanticInfo.index;

	mov	eax, DWORD PTR _semanticInfo$4[ebp+4]
	mov	DWORD PTR _inputElement$5[ebp+4], eax

; 167  :                         inputElement.InputSlot              = 0;

	mov	DWORD PTR _inputElement$5[ebp+12], 0

; 168  :                         inputElement.AlignedByteOffset      = 0;

	mov	DWORD PTR _inputElement$5[ebp+16], 0

; 169  :                         inputElement.InputSlotClass         = D3D10_INPUT_PER_VERTEX_DATA;

	mov	DWORD PTR _inputElement$5[ebp+20], 0

; 170  :                         inputElement.InstanceDataStepRate   = 0;

	mov	DWORD PTR _inputElement$5[ebp+24], 0

; 171  : 
; 172  :                         if(strSemantic.CompareI(TEXT("color")))

	push	OFFSET $SG4294914677
	lea	ecx, DWORD PTR _strSemantic$59[ebp]
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN140@ProcessSha

; 173  :                             inputElement.Format = DXGI_FORMAT_R8G8B8A8_UNORM;

	mov	DWORD PTR _inputElement$5[ebp+8], 28	; 0000001cH

; 174  :                         else

	jmp	SHORT $LN137@ProcessSha
$LN140@ProcessSha:

; 175  :                         {
; 176  :                             switch(strType[5])

	lea	ecx, DWORD PTR _strType$63[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	ecx, 2
	imul	edx, ecx, 5
	movzx	eax, WORD PTR [eax+edx]
	mov	DWORD PTR tv419[ebp], eax
	cmp	DWORD PTR tv419[ebp], 52		; 00000034H
	ja	SHORT $LN137@ProcessSha
	mov	ecx, DWORD PTR tv419[ebp]
	movzx	edx, BYTE PTR $LN206@ProcessSha[ecx]
	jmp	DWORD PTR $LN207@ProcessSha[edx*4]
$LN136@ProcessSha:

; 177  :                             {
; 178  :                                 case 0:   inputElement.Format = DXGI_FORMAT_R32_FLOAT;          break;

	mov	DWORD PTR _inputElement$5[ebp+8], 41	; 00000029H
	jmp	SHORT $LN137@ProcessSha
$LN135@ProcessSha:

; 179  :                                 case '2': inputElement.Format = DXGI_FORMAT_R32G32_FLOAT;       break;

	mov	DWORD PTR _inputElement$5[ebp+8], 16	; 00000010H
	jmp	SHORT $LN137@ProcessSha
$LN134@ProcessSha:

; 180  :                                 case '3': inputElement.Format = DXGI_FORMAT_R32G32B32A32_FLOAT; break; //todo: check this some time

	mov	DWORD PTR _inputElement$5[ebp+8], 2
	jmp	SHORT $LN137@ProcessSha
$LN133@ProcessSha:

; 181  :                                 case '4': inputElement.Format = DXGI_FORMAT_R32G32B32A32_FLOAT; break;

	mov	DWORD PTR _inputElement$5[ebp+8], 2
$LN137@ProcessSha:

; 182  :                             }
; 183  :                         }
; 184  : 
; 185  :                         ExpectToken(TEXT(";"), TEXT(";"));

	push	0
	lea	eax, DWORD PTR _curToken$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN132@ProcessSha
	mov	DWORD PTR $T12[ebp], 0
	lea	ecx, DWORD PTR _strSemantic$59[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strName$62[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$63[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T12[ebp]
	jmp	$LN183@ProcessSha
$LN132@ProcessSha:
	push	OFFSET $SG4294914676
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??9String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN131@ProcessSha
	push	1
	push	OFFSET $SG4294914675
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GotoToken@CodeTokenizer@@QAEHPB_WH@Z	; CodeTokenizer::GotoToken
	test	eax, eax
	jne	SHORT $LN130@ProcessSha
	mov	DWORD PTR $T10[ebp], 0
	lea	ecx, DWORD PTR _strSemantic$59[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strName$62[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$63[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T10[ebp]
	jmp	$LN183@ProcessSha
$LN130@ProcessSha:
	lea	ecx, DWORD PTR _strSemantic$59[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strName$62[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$63[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	jmp	$LN128@ProcessSha
$LN131@ProcessSha:

; 186  : 
; 187  :                         PeekAtAToken(curToken);

	push	1
	lea	ecx, DWORD PTR _curToken$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN129@ProcessSha
	mov	DWORD PTR $T9[ebp], 0
	lea	ecx, DWORD PTR _strSemantic$59[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strName$62[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$63[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T9[ebp]
	jmp	$LN183@ProcessSha
$LN129@ProcessSha:

; 188  : 
; 189  :                         generatedLayout << inputElement;

	lea	edx, DWORD PTR _inputElement$5[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??6?$List@UD3D10_INPUT_ELEMENT_DESC@@@@QAEAAV0@ABUD3D10_INPUT_ELEMENT_DESC@@@Z ; List<D3D10_INPUT_ELEMENT_DESC>::operator<<

; 190  : 
; 191  :                         bFoundDefinitionStruct = true;

	mov	BYTE PTR _bFoundDefinitionStruct$80[ebp], 1

; 192  :                     }

	lea	ecx, DWORD PTR _strSemantic$59[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strName$62[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$63[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 193  :                     else

	jmp	SHORT $LN128@ProcessSha
$LN146@ProcessSha:

; 194  :                     {
; 195  :                         bFoundDefinitionStruct = false;

	mov	BYTE PTR _bFoundDefinitionStruct$80[ebp], 0

; 196  :                         break; //vertex definition structures should really only ever have float values

	jmp	SHORT $LN148@ProcessSha
$LN128@ProcessSha:

; 197  :                     }
; 198  :                 } while (curToken[0] != '}');

	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	ecx, 2
	imul	edx, ecx, 0
	movzx	eax, WORD PTR [eax+edx]
	cmp	eax, 125				; 0000007dH
	jne	$LN150@ProcessSha
$LN148@ProcessSha:

; 199  : 
; 200  :                 //set up the slots so they match up with vertex buffers
; 201  :                 if(bFoundDefinitionStruct)

	movzx	ecx, BYTE PTR _bFoundDefinitionStruct$80[ebp]
	test	ecx, ecx
	je	$LN108@ProcessSha

; 202  :                 {
; 203  :                     UINT curSlot = 0;

	mov	DWORD PTR _curSlot$77[ebp], 0

; 204  : 
; 205  :                     for(UINT i=0; i<generatedLayout.Num(); i++)

	mov	DWORD PTR _i$65[ebp], 0
	jmp	SHORT $LN126@ProcessSha
$LN125@ProcessSha:
	mov	edx, DWORD PTR _i$65[ebp]
	add	edx, 1
	mov	DWORD PTR _i$65[ebp], edx
$LN126@ProcessSha:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?Num@?$List@UD3D10_INPUT_ELEMENT_DESC@@@@QBEIXZ ; List<D3D10_INPUT_ELEMENT_DESC>::Num
	cmp	DWORD PTR _i$65[ebp], eax
	jae	SHORT $LN124@ProcessSha

; 206  :                     {
; 207  :                         if(stricmp(generatedLayout[i].SemanticName, "SV_Position") == 0)

	push	OFFSET $SG4294914674
	mov	eax, DWORD PTR _i$65[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$List@UD3D10_INPUT_ELEMENT_DESC@@@@QAEAAUD3D10_INPUT_ELEMENT_DESC@@I@Z ; List<D3D10_INPUT_ELEMENT_DESC>::operator[]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN123@ProcessSha

; 208  :                         {
; 209  :                             generatedLayout[i].InputSlot = curSlot++;

	mov	edx, DWORD PTR _i$65[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$List@UD3D10_INPUT_ELEMENT_DESC@@@@QAEAAUD3D10_INPUT_ELEMENT_DESC@@I@Z ; List<D3D10_INPUT_ELEMENT_DESC>::operator[]
	mov	ecx, DWORD PTR _curSlot$77[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR _curSlot$77[ebp]
	add	edx, 1
	mov	DWORD PTR _curSlot$77[ebp], edx

; 210  :                             break;

	jmp	SHORT $LN124@ProcessSha
$LN123@ProcessSha:

; 211  :                         }
; 212  :                     }

	jmp	SHORT $LN125@ProcessSha
$LN124@ProcessSha:

; 213  : 
; 214  :                     for(UINT i=0; i<generatedLayout.Num(); i++)

	mov	DWORD PTR _i$64[ebp], 0
	jmp	SHORT $LN122@ProcessSha
$LN121@ProcessSha:
	mov	eax, DWORD PTR _i$64[ebp]
	add	eax, 1
	mov	DWORD PTR _i$64[ebp], eax
$LN122@ProcessSha:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?Num@?$List@UD3D10_INPUT_ELEMENT_DESC@@@@QBEIXZ ; List<D3D10_INPUT_ELEMENT_DESC>::Num
	cmp	DWORD PTR _i$64[ebp], eax
	jae	SHORT $LN120@ProcessSha

; 215  :                     {
; 216  :                         if(stricmp(generatedLayout[i].SemanticName, "NORMAL") == 0)

	push	OFFSET $SG4294914673
	mov	ecx, DWORD PTR _i$64[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$List@UD3D10_INPUT_ELEMENT_DESC@@@@QAEAAUD3D10_INPUT_ELEMENT_DESC@@I@Z ; List<D3D10_INPUT_ELEMENT_DESC>::operator[]
	mov	edx, DWORD PTR [eax]
	push	edx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN119@ProcessSha

; 217  :                         {
; 218  :                             generatedLayout[i].InputSlot = curSlot++;

	mov	eax, DWORD PTR _i$64[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$List@UD3D10_INPUT_ELEMENT_DESC@@@@QAEAAUD3D10_INPUT_ELEMENT_DESC@@I@Z ; List<D3D10_INPUT_ELEMENT_DESC>::operator[]
	mov	ecx, DWORD PTR _curSlot$77[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR _curSlot$77[ebp]
	add	edx, 1
	mov	DWORD PTR _curSlot$77[ebp], edx

; 219  :                             bHasNormals = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+44], 1

; 220  :                             break;

	jmp	SHORT $LN120@ProcessSha
$LN119@ProcessSha:

; 221  :                         }
; 222  :                     }

	jmp	SHORT $LN121@ProcessSha
$LN120@ProcessSha:

; 223  : 
; 224  :                     for(UINT i=0; i<generatedLayout.Num(); i++)

	mov	DWORD PTR _i$67[ebp], 0
	jmp	SHORT $LN118@ProcessSha
$LN117@ProcessSha:
	mov	ecx, DWORD PTR _i$67[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$67[ebp], ecx
$LN118@ProcessSha:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?Num@?$List@UD3D10_INPUT_ELEMENT_DESC@@@@QBEIXZ ; List<D3D10_INPUT_ELEMENT_DESC>::Num
	cmp	DWORD PTR _i$67[ebp], eax
	jae	SHORT $LN116@ProcessSha

; 225  :                     {
; 226  :                         if(stricmp(generatedLayout[i].SemanticName, "COLOR") == 0)

	push	OFFSET $SG4294914672
	mov	edx, DWORD PTR _i$67[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$List@UD3D10_INPUT_ELEMENT_DESC@@@@QAEAAUD3D10_INPUT_ELEMENT_DESC@@I@Z ; List<D3D10_INPUT_ELEMENT_DESC>::operator[]
	mov	eax, DWORD PTR [eax]
	push	eax
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN115@ProcessSha

; 227  :                         {
; 228  :                             generatedLayout[i].InputSlot = curSlot++;

	mov	ecx, DWORD PTR _i$67[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$List@UD3D10_INPUT_ELEMENT_DESC@@@@QAEAAUD3D10_INPUT_ELEMENT_DESC@@I@Z ; List<D3D10_INPUT_ELEMENT_DESC>::operator[]
	mov	edx, DWORD PTR _curSlot$77[ebp]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _curSlot$77[ebp]
	add	eax, 1
	mov	DWORD PTR _curSlot$77[ebp], eax

; 229  :                             bHasColors = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+45], 1

; 230  :                             break;

	jmp	SHORT $LN116@ProcessSha
$LN115@ProcessSha:

; 231  :                         }
; 232  :                     }

	jmp	SHORT $LN117@ProcessSha
$LN116@ProcessSha:

; 233  : 
; 234  :                     for(UINT i=0; i<generatedLayout.Num(); i++)

	mov	DWORD PTR _i$66[ebp], 0
	jmp	SHORT $LN114@ProcessSha
$LN113@ProcessSha:
	mov	edx, DWORD PTR _i$66[ebp]
	add	edx, 1
	mov	DWORD PTR _i$66[ebp], edx
$LN114@ProcessSha:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?Num@?$List@UD3D10_INPUT_ELEMENT_DESC@@@@QBEIXZ ; List<D3D10_INPUT_ELEMENT_DESC>::Num
	cmp	DWORD PTR _i$66[ebp], eax
	jae	SHORT $LN112@ProcessSha

; 235  :                     {
; 236  :                         if(stricmp(generatedLayout[i].SemanticName, "TANGENT") == 0)

	push	OFFSET $SG4294914671
	mov	eax, DWORD PTR _i$66[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$List@UD3D10_INPUT_ELEMENT_DESC@@@@QAEAAUD3D10_INPUT_ELEMENT_DESC@@I@Z ; List<D3D10_INPUT_ELEMENT_DESC>::operator[]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN111@ProcessSha

; 237  :                         {
; 238  :                             generatedLayout[i].InputSlot = curSlot++;

	mov	edx, DWORD PTR _i$66[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$List@UD3D10_INPUT_ELEMENT_DESC@@@@QAEAAUD3D10_INPUT_ELEMENT_DESC@@I@Z ; List<D3D10_INPUT_ELEMENT_DESC>::operator[]
	mov	ecx, DWORD PTR _curSlot$77[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR _curSlot$77[ebp]
	add	edx, 1
	mov	DWORD PTR _curSlot$77[ebp], edx

; 239  :                             bHasTangents = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+46], 1

; 240  :                             break;

	jmp	SHORT $LN112@ProcessSha
$LN111@ProcessSha:

; 241  :                         }
; 242  :                     }

	jmp	SHORT $LN113@ProcessSha
$LN112@ProcessSha:

; 243  : 
; 244  :                     bool bFoundTexCoord;
; 245  : 
; 246  :                     do
; 247  :                     {
; 248  :                         bFoundTexCoord = false;

	mov	BYTE PTR _bFoundTexCoord$74[ebp], 0

; 249  : 
; 250  :                         for(UINT i=0; i<generatedLayout.Num(); i++)

	mov	DWORD PTR _i$69[ebp], 0
	jmp	SHORT $LN107@ProcessSha
$LN106@ProcessSha:
	mov	ecx, DWORD PTR _i$69[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$69[ebp], ecx
$LN107@ProcessSha:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?Num@?$List@UD3D10_INPUT_ELEMENT_DESC@@@@QBEIXZ ; List<D3D10_INPUT_ELEMENT_DESC>::Num
	cmp	DWORD PTR _i$69[ebp], eax
	jae	SHORT $LN105@ProcessSha

; 251  :                         {
; 252  :                             if(generatedLayout[i].SemanticIndex == numTextureCoords && stricmp(generatedLayout[i].SemanticName, "TEXCOORD") == 0)

	mov	edx, DWORD PTR _i$69[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$List@UD3D10_INPUT_ELEMENT_DESC@@@@QAEAAUD3D10_INPUT_ELEMENT_DESC@@I@Z ; List<D3D10_INPUT_ELEMENT_DESC>::operator[]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+48]
	jne	SHORT $LN104@ProcessSha
	push	OFFSET $SG4294914670
	mov	eax, DWORD PTR _i$69[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$List@UD3D10_INPUT_ELEMENT_DESC@@@@QAEAAUD3D10_INPUT_ELEMENT_DESC@@I@Z ; List<D3D10_INPUT_ELEMENT_DESC>::operator[]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN104@ProcessSha

; 253  :                             {
; 254  :                                 generatedLayout[i].InputSlot = curSlot++;

	mov	edx, DWORD PTR _i$69[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$List@UD3D10_INPUT_ELEMENT_DESC@@@@QAEAAUD3D10_INPUT_ELEMENT_DESC@@I@Z ; List<D3D10_INPUT_ELEMENT_DESC>::operator[]
	mov	ecx, DWORD PTR _curSlot$77[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR _curSlot$77[ebp]
	add	edx, 1
	mov	DWORD PTR _curSlot$77[ebp], edx

; 255  :                                 numTextureCoords++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+48], ecx

; 256  :                                 bFoundTexCoord = true;

	mov	BYTE PTR _bFoundTexCoord$74[ebp], 1

; 257  :                                 break;

	jmp	SHORT $LN105@ProcessSha
$LN104@ProcessSha:

; 258  :                             }
; 259  :                         }

	jmp	$LN106@ProcessSha
$LN105@ProcessSha:

; 260  :                     } while(bFoundTexCoord);

	movzx	eax, BYTE PTR _bFoundTexCoord$74[ebp]
	test	eax, eax
	jne	$LN112@ProcessSha
$LN108@ProcessSha:

; 261  :                 }
; 262  :             }
; 263  :             else if( (curToken != TEXT("const"))     &&

	jmp	$LN102@ProcessSha
$LN154@ProcessSha:

; 264  :                      (curToken != TEXT("void"))      &&
; 265  :                      (curToken != TEXT(";"))         )

	push	OFFSET $SG4294914669
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??9String@@QBEHPB_W@Z
	test	eax, eax
	je	$LN102@ProcessSha
	push	OFFSET $SG4294914668
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??9String@@QBEHPB_W@Z
	test	eax, eax
	je	$LN102@ProcessSha
	push	OFFSET $SG4294914667
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??9String@@QBEHPB_W@Z
	test	eax, eax
	je	$LN102@ProcessSha

; 266  :             {
; 267  :                 TSTR lpSavedPos = lpTemp;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _lpSavedPos$39[ebp], edx

; 268  :                 String savedToken = curToken;

	lea	eax, DWORD PTR _curToken$[ebp]
	push	eax
	lea	ecx, DWORD PTR _savedToken$78[ebp]
	call	DWORD PTR __imp_??0String@@QAE@ABV0@@Z

; 269  : 
; 270  :                 if(curToken == TEXT("uniform"))

	push	OFFSET $SG4294914666
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??8String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN100@ProcessSha

; 271  :                     HandMeAToken(curToken);

	push	0
	lea	ecx, DWORD PTR _curToken$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN100@ProcessSha
	mov	DWORD PTR $T54[ebp], 0
	lea	ecx, DWORD PTR _savedToken$78[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T54[ebp]
	jmp	$LN183@ProcessSha
$LN100@ProcessSha:

; 272  : 
; 273  :                 String strType = curToken;

	lea	edx, DWORD PTR _curToken$[ebp]
	push	edx
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??0String@@QAE@ABV0@@Z

; 274  : 
; 275  :                 String strName;

	lea	ecx, DWORD PTR _strName$79[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 276  :                 HandMeAToken(strName);

	push	0
	lea	eax, DWORD PTR _strName$79[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN99@ProcessSha
	mov	DWORD PTR $T27[ebp], 0
	lea	ecx, DWORD PTR _strName$79[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _savedToken$78[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T27[ebp]
	jmp	$LN183@ProcessSha
$LN99@ProcessSha:

; 277  : 
; 278  :                 PeekAtAToken(curToken);

	push	1
	lea	ecx, DWORD PTR _curToken$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN98@ProcessSha
	mov	DWORD PTR $T52[ebp], 0
	lea	ecx, DWORD PTR _strName$79[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _savedToken$78[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T52[ebp]
	jmp	$LN183@ProcessSha
$LN98@ProcessSha:

; 279  :                 if(curToken[0] != '(') //verified variable

	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	edx, 2
	imul	ecx, edx, 0
	movzx	edx, WORD PTR [eax+ecx]
	cmp	edx, 40					; 00000028H
	je	$LN97@ProcessSha

; 280  :                 {
; 281  :                     if(strType.CompareI(TEXT("samplerstate")))

	push	OFFSET $SG4294914665
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	test	eax, eax
	je	$LN96@ProcessSha

; 282  :                     {
; 283  :                         ShaderSampler &curSampler = *Samplers.CreateNew();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	?CreateNew@?$List@UShaderSampler@@@@QAEPAUShaderSampler@@XZ ; List<ShaderSampler>::CreateNew
	mov	DWORD PTR _curSampler$57[ebp], eax

; 284  :                         curSampler.name = strName;

	lea	eax, DWORD PTR _strName$79[ebp]
	push	eax
	mov	ecx, DWORD PTR _curSampler$57[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@ABV0@@Z

; 285  : 
; 286  :                         SamplerInfo info;

	lea	ecx, DWORD PTR _info$1[ebp]
	call	??0SamplerInfo@@QAE@XZ			; SamplerInfo::SamplerInfo

; 287  : 
; 288  :                         ExpectToken(TEXT("{"), TEXT(";"));

	push	0
	lea	ecx, DWORD PTR _curToken$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN95@ProcessSha
	mov	DWORD PTR $T15[ebp], 0
	lea	ecx, DWORD PTR _strName$79[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _savedToken$78[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T15[ebp]
	jmp	$LN183@ProcessSha
$LN95@ProcessSha:
	push	OFFSET $SG4294914664
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??9String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN94@ProcessSha
	push	1
	push	OFFSET $SG4294914663
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GotoToken@CodeTokenizer@@QAEHPB_WH@Z	; CodeTokenizer::GotoToken
	test	eax, eax
	jne	SHORT $LN93@ProcessSha
	mov	DWORD PTR $T50[ebp], 0
	lea	ecx, DWORD PTR _strName$79[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _savedToken$78[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T50[ebp]
	jmp	$LN183@ProcessSha
$LN93@ProcessSha:
	lea	ecx, DWORD PTR _strName$79[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _savedToken$78[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	jmp	$LN201@ProcessSha
$LN94@ProcessSha:

; 289  : 
; 290  :                         PeekAtAToken(curToken);

	push	1
	lea	edx, DWORD PTR _curToken$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN92@ProcessSha
	mov	DWORD PTR $T25[ebp], 0
	lea	ecx, DWORD PTR _strName$79[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _savedToken$78[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T25[ebp]
	jmp	$LN183@ProcessSha
$LN92@ProcessSha:

; 291  : 
; 292  :                         while(curToken != TEXT("}"))

	push	OFFSET $SG4294914662
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??9String@@QBEHPB_W@Z
	test	eax, eax
	je	$LN90@ProcessSha

; 293  :                         {
; 294  :                             String strState;

	lea	ecx, DWORD PTR _strState$72[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 295  :                             HandMeAToken(strState);

	push	0
	lea	eax, DWORD PTR _strState$72[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN89@ProcessSha
	mov	DWORD PTR $T48[ebp], 0
	lea	ecx, DWORD PTR _strState$72[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strName$79[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _savedToken$78[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T48[ebp]
	jmp	$LN183@ProcessSha
$LN89@ProcessSha:

; 296  : 
; 297  :                             ExpectToken(TEXT("="), TEXT(";"));

	push	0
	lea	ecx, DWORD PTR _curToken$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN88@ProcessSha
	mov	DWORD PTR $T7[ebp], 0
	lea	ecx, DWORD PTR _strState$72[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strName$79[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _savedToken$78[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T7[ebp]
	jmp	$LN183@ProcessSha
$LN88@ProcessSha:
	push	OFFSET $SG4294914661
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??9String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN87@ProcessSha
	push	1
	push	OFFSET $SG4294914660
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GotoToken@CodeTokenizer@@QAEHPB_WH@Z	; CodeTokenizer::GotoToken
	test	eax, eax
	jne	SHORT $LN86@ProcessSha
	mov	DWORD PTR $T46[ebp], 0
	lea	ecx, DWORD PTR _strState$72[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strName$79[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _savedToken$78[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T46[ebp]
	jmp	$LN183@ProcessSha
$LN86@ProcessSha:
	lea	ecx, DWORD PTR _strState$72[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	jmp	$LN92@ProcessSha
$LN87@ProcessSha:

; 298  : 
; 299  :                             String strValue;

	lea	ecx, DWORD PTR _strValue$60[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 300  :                             HandMeAToken(strValue);

	push	0
	lea	edx, DWORD PTR _strValue$60[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN85@ProcessSha
	mov	DWORD PTR $T56[ebp], 0
	lea	ecx, DWORD PTR _strValue$60[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strState$72[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strName$79[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _savedToken$78[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T56[ebp]
	jmp	$LN183@ProcessSha
$LN85@ProcessSha:

; 301  : 
; 302  :                             if(!AddState(info, strState, strValue))

	lea	eax, DWORD PTR _strValue$60[ebp]
	push	eax
	lea	ecx, DWORD PTR _strState$72[ebp]
	push	ecx
	lea	edx, DWORD PTR _info$1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddState@ShaderProcessor@@QAEHAAUSamplerInfo@@AAVString@@1@Z ; ShaderProcessor::AddState
	test	eax, eax
	jne	SHORT $LN84@ProcessSha

; 303  :                                 EscapeLikeTheWind(TEXT(";"));

	push	1
	push	OFFSET $SG4294914659
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GotoToken@CodeTokenizer@@QAEHPB_WH@Z	; CodeTokenizer::GotoToken
	test	eax, eax
	jne	SHORT $LN83@ProcessSha
	mov	DWORD PTR $T44[ebp], 0
	lea	ecx, DWORD PTR _strValue$60[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strState$72[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strName$79[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _savedToken$78[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T44[ebp]
	jmp	$LN183@ProcessSha
$LN83@ProcessSha:
	lea	ecx, DWORD PTR _strValue$60[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strState$72[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	jmp	$LN92@ProcessSha
$LN84@ProcessSha:

; 304  : 
; 305  :                             ExpectToken(TEXT(";"), TEXT(";"));

	push	0
	lea	eax, DWORD PTR _curToken$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN82@ProcessSha
	mov	DWORD PTR $T13[ebp], 0
	lea	ecx, DWORD PTR _strValue$60[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strState$72[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strName$79[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _savedToken$78[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T13[ebp]
	jmp	$LN183@ProcessSha
$LN82@ProcessSha:
	push	OFFSET $SG4294914658
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??9String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN81@ProcessSha
	push	1
	push	OFFSET $SG4294914657
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GotoToken@CodeTokenizer@@QAEHPB_WH@Z	; CodeTokenizer::GotoToken
	test	eax, eax
	jne	SHORT $LN80@ProcessSha
	mov	DWORD PTR $T42[ebp], 0
	lea	ecx, DWORD PTR _strValue$60[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strState$72[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strName$79[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _savedToken$78[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T42[ebp]
	jmp	$LN183@ProcessSha
$LN80@ProcessSha:
	lea	ecx, DWORD PTR _strValue$60[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strState$72[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	jmp	$LN92@ProcessSha
$LN81@ProcessSha:

; 306  : 
; 307  :                             PeekAtAToken(curToken);

	push	1
	lea	ecx, DWORD PTR _curToken$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN79@ProcessSha
	mov	DWORD PTR $T21[ebp], 0
	lea	ecx, DWORD PTR _strValue$60[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strState$72[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strName$79[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _savedToken$78[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T21[ebp]
	jmp	$LN183@ProcessSha
$LN79@ProcessSha:

; 308  :                         }

	lea	ecx, DWORD PTR _strValue$60[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strState$72[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	jmp	$LN92@ProcessSha
$LN90@ProcessSha:

; 309  : 
; 310  :                         curSampler.sampler = CreateSamplerState(info);

	lea	edx, DWORD PTR _info$1[ebp]
	push	edx
	call	?CreateSamplerState@@YAPAVSamplerState@@AAUSamplerInfo@@@Z ; CreateSamplerState
	add	esp, 4
	mov	ecx, DWORD PTR _curSampler$57[ebp]
	mov	DWORD PTR [ecx+8], eax

; 311  : 
; 312  :                         ExpectToken(TEXT("}"), TEXT("}"));

	push	0
	lea	edx, DWORD PTR _curToken$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN78@ProcessSha
	mov	DWORD PTR $T40[ebp], 0
	lea	ecx, DWORD PTR _strName$79[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _savedToken$78[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T40[ebp]
	jmp	$LN183@ProcessSha
$LN78@ProcessSha:
	push	OFFSET $SG4294914656
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??9String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN77@ProcessSha
	push	1
	push	OFFSET $SG4294914655
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GotoToken@CodeTokenizer@@QAEHPB_WH@Z	; CodeTokenizer::GotoToken
	test	eax, eax
	jne	SHORT $LN76@ProcessSha
	mov	DWORD PTR $T19[ebp], 0
	lea	ecx, DWORD PTR _strName$79[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _savedToken$78[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T19[ebp]
	jmp	$LN183@ProcessSha
$LN76@ProcessSha:
	lea	ecx, DWORD PTR _strName$79[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _savedToken$78[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	jmp	$LN201@ProcessSha
$LN77@ProcessSha:

; 313  :                         ExpectTokenIgnore(TEXT(";"));

	push	0
	lea	eax, DWORD PTR _curToken$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN75@ProcessSha
	mov	DWORD PTR $T38[ebp], 0
	lea	ecx, DWORD PTR _strName$79[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _savedToken$78[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T38[ebp]
	jmp	$LN183@ProcessSha
$LN75@ProcessSha:
	push	OFFSET $SG4294914654
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??9String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN74@ProcessSha
	lea	ecx, DWORD PTR _strName$79[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _savedToken$78[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	jmp	$LN201@ProcessSha
$LN74@ProcessSha:

; 314  : 
; 315  :                         //----------------------------------------
; 316  : 
; 317  :                         lpLastPos = lpTemp;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _lpLastPos$[ebp], edx

; 318  :                         continue;

	lea	ecx, DWORD PTR _strName$79[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _savedToken$78[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	jmp	$LN201@ProcessSha

; 319  :                     }
; 320  :                     else

	jmp	$LN45@ProcessSha
$LN96@ProcessSha:

; 321  :                     {
; 322  :                         ShaderParam *param = Params.CreateNew();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?CreateNew@?$List@UShaderParam@@@@QAEPAUShaderParam@@XZ ; List<ShaderParam>::CreateNew
	mov	DWORD PTR _param$75[ebp], eax

; 323  :                         param->name = strName;

	lea	eax, DWORD PTR _strName$79[ebp]
	push	eax
	mov	ecx, DWORD PTR _param$75[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??4String@@QAEAAV0@ABV0@@Z

; 324  : 
; 325  :                         if(curToken[0] == '[')

	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	ecx, 2
	imul	edx, ecx, 0
	movzx	eax, WORD PTR [eax+edx]
	cmp	eax, 91					; 0000005bH
	jne	$LN66@ProcessSha

; 326  :                         {
; 327  :                             HandMeAToken(curToken);

	push	0
	lea	ecx, DWORD PTR _curToken$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN71@ProcessSha
	mov	DWORD PTR $T35[ebp], 0
	lea	ecx, DWORD PTR _strName$79[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _savedToken$78[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T35[ebp]
	jmp	$LN183@ProcessSha
$LN71@ProcessSha:

; 328  : 
; 329  :                             HandMeAToken(curToken);

	push	0
	lea	edx, DWORD PTR _curToken$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN70@ProcessSha
	mov	DWORD PTR $T36[ebp], 0
	lea	ecx, DWORD PTR _strName$79[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _savedToken$78[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T36[ebp]
	jmp	$LN183@ProcessSha
$LN70@ProcessSha:

; 330  :                             param->arrayCount = tstoi(curToken);

	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?tstoi@@YAHPA_W@Z
	add	esp, 4
	mov	ecx, DWORD PTR _param$75[ebp]
	mov	DWORD PTR [ecx+20], eax

; 331  : 
; 332  :                             ExpectToken(TEXT("]"), TEXT(";"));

	push	0
	lea	edx, DWORD PTR _curToken$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN69@ProcessSha
	mov	DWORD PTR $T34[ebp], 0
	lea	ecx, DWORD PTR _strName$79[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _savedToken$78[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T34[ebp]
	jmp	$LN183@ProcessSha
$LN69@ProcessSha:
	push	OFFSET $SG4294914653
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??9String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN68@ProcessSha
	push	1
	push	OFFSET $SG4294914652
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GotoToken@CodeTokenizer@@QAEHPB_WH@Z	; CodeTokenizer::GotoToken
	test	eax, eax
	jne	SHORT $LN67@ProcessSha
	mov	DWORD PTR $T32[ebp], 0
	lea	ecx, DWORD PTR _strName$79[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _savedToken$78[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T32[ebp]
	jmp	$LN183@ProcessSha
$LN67@ProcessSha:
	lea	ecx, DWORD PTR _strName$79[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _savedToken$78[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	jmp	$LN201@ProcessSha
$LN68@ProcessSha:

; 333  : 
; 334  :                             PeekAtAToken(curToken);

	push	1
	lea	eax, DWORD PTR _curToken$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN66@ProcessSha
	mov	DWORD PTR $T33[ebp], 0
	lea	ecx, DWORD PTR _strName$79[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _savedToken$78[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T33[ebp]
	jmp	$LN183@ProcessSha
$LN66@ProcessSha:

; 335  :                         }
; 336  : 
; 337  :                         if(scmpi_n(strType, TEXT("texture"), 7) == 0)

	push	7
	push	OFFSET $SG4294914651
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?scmpi_n@@YGHPB_W0I@Z
	test	eax, eax
	jne	$LN65@ProcessSha

; 338  :                         {
; 339  :                             TSTR lpType = strType.Array()+7;

	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	add	eax, 14					; 0000000eH
	mov	DWORD PTR _lpType$71[ebp], eax

; 340  :                             supr(lpType);

	mov	ecx, DWORD PTR _lpType$71[ebp]
	push	ecx
	call	DWORD PTR __imp_?supr@@YGXPA_W@Z

; 341  : 
; 342  :                             if (!*lpType ||
; 343  :                                 (scmp(lpType, TEXT("1D")) && scmp(lpType, TEXT("2D")) && scmp(lpType, TEXT("3D")) && scmp(lpType, TEXT("CUBE")))
; 344  :                                 )

	mov	edx, DWORD PTR _lpType$71[ebp]
	movzx	eax, WORD PTR [edx]
	test	eax, eax
	je	SHORT $LN63@ProcessSha
	push	OFFSET $SG4294914650
	mov	ecx, DWORD PTR _lpType$71[ebp]
	push	ecx
	call	DWORD PTR __imp_?scmp@@YGHPB_W0@Z
	test	eax, eax
	je	SHORT $LN64@ProcessSha
	push	OFFSET $SG4294914649
	mov	edx, DWORD PTR _lpType$71[ebp]
	push	edx
	call	DWORD PTR __imp_?scmp@@YGHPB_W0@Z
	test	eax, eax
	je	SHORT $LN64@ProcessSha
	push	OFFSET $SG4294914648
	mov	eax, DWORD PTR _lpType$71[ebp]
	push	eax
	call	DWORD PTR __imp_?scmp@@YGHPB_W0@Z
	test	eax, eax
	je	SHORT $LN64@ProcessSha
	push	OFFSET $SG4294914647
	mov	ecx, DWORD PTR _lpType$71[ebp]
	push	ecx
	call	DWORD PTR __imp_?scmp@@YGHPB_W0@Z
	test	eax, eax
	je	SHORT $LN64@ProcessSha
$LN63@ProcessSha:

; 345  :                             {
; 346  :                                 bError = TRUE;

	mov	DWORD PTR _bError$[ebp], 1
$LN64@ProcessSha:

; 347  :                             }
; 348  : 
; 349  :                             param->textureID = nTextures++;

	mov	edx, DWORD PTR _param$75[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 350  :                             param->type = Parameter_Texture;

	mov	edx, DWORD PTR _param$75[ebp]
	mov	DWORD PTR [edx], 10			; 0000000aH

; 351  : 
; 352  :                             strType = TEXT("sampler");

	push	OFFSET $SG4294914646
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z
	jmp	$LN46@ProcessSha
$LN65@ProcessSha:

; 353  :                         }
; 354  :                         else if(scmp_n(strType, TEXT("float"), 5) == 0)

	push	5
	push	OFFSET $SG4294914645
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?scmp_n@@YGHPB_W0I@Z
	test	eax, eax
	jne	$LN61@ProcessSha

; 355  :                         {
; 356  :                             CTSTR lpType = strType.Array()+5;

	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	add	eax, 10					; 0000000aH
	mov	DWORD PTR _lpType$70[ebp], eax

; 357  : 
; 358  :                             if(*lpType == 0)

	mov	eax, DWORD PTR _lpType$70[ebp]
	movzx	ecx, WORD PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN60@ProcessSha

; 359  :                                 param->type = Parameter_Float;

	mov	edx, DWORD PTR _param$75[ebp]
	mov	DWORD PTR [edx], 2
	jmp	$LN50@ProcessSha
$LN60@ProcessSha:

; 360  :                             else if(scmpi(lpType, TEXT("2")) == 0)

	push	OFFSET $SG4294914644
	mov	eax, DWORD PTR _lpType$70[ebp]
	push	eax
	call	DWORD PTR __imp_?scmpi@@YGHPB_W0@Z
	test	eax, eax
	jne	SHORT $LN58@ProcessSha

; 361  :                                 param->type = Parameter_Vector2;

	mov	ecx, DWORD PTR _param$75[ebp]
	mov	DWORD PTR [ecx], 5
	jmp	SHORT $LN50@ProcessSha
$LN58@ProcessSha:

; 362  :                             else if(scmpi(lpType, TEXT("3")) == 0)

	push	OFFSET $SG4294914643
	mov	edx, DWORD PTR _lpType$70[ebp]
	push	edx
	call	DWORD PTR __imp_?scmpi@@YGHPB_W0@Z
	test	eax, eax
	jne	SHORT $LN56@ProcessSha

; 363  :                                 param->type = Parameter_Vector3;

	mov	eax, DWORD PTR _param$75[ebp]
	mov	DWORD PTR [eax], 6
	jmp	SHORT $LN50@ProcessSha
$LN56@ProcessSha:

; 364  :                             else if(scmpi(lpType, TEXT("4")) == 0)

	push	OFFSET $SG4294914642
	mov	ecx, DWORD PTR _lpType$70[ebp]
	push	ecx
	call	DWORD PTR __imp_?scmpi@@YGHPB_W0@Z
	test	eax, eax
	jne	SHORT $LN54@ProcessSha

; 365  :                                 param->type = Parameter_Vector4;

	mov	edx, DWORD PTR _param$75[ebp]
	mov	DWORD PTR [edx], 7
	jmp	SHORT $LN50@ProcessSha
$LN54@ProcessSha:

; 366  :                             else if(scmpi(lpType, TEXT("3x3")) == 0)

	push	OFFSET $SG4294914641
	mov	eax, DWORD PTR _lpType$70[ebp]
	push	eax
	call	DWORD PTR __imp_?scmpi@@YGHPB_W0@Z
	test	eax, eax
	jne	SHORT $LN52@ProcessSha

; 367  :                                 param->type = Parameter_Matrix3x3;

	mov	ecx, DWORD PTR _param$75[ebp]
	mov	DWORD PTR [ecx], 8
	jmp	SHORT $LN50@ProcessSha
$LN52@ProcessSha:

; 368  :                             else if(scmpi(lpType, TEXT("4x4")) == 0)

	push	OFFSET $SG4294914640
	mov	edx, DWORD PTR _lpType$70[ebp]
	push	edx
	call	DWORD PTR __imp_?scmpi@@YGHPB_W0@Z
	test	eax, eax
	jne	SHORT $LN50@ProcessSha

; 369  :                                 param->type = Parameter_Matrix;

	mov	eax, DWORD PTR _param$75[ebp]
	mov	DWORD PTR [eax], 9
$LN50@ProcessSha:

; 370  :                         }

	jmp	SHORT $LN46@ProcessSha
$LN61@ProcessSha:

; 371  :                         else if(scmp(strType, TEXT("int")) == 0)

	push	OFFSET $SG4294914639
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?scmp@@YGHPB_W0@Z
	test	eax, eax
	jne	SHORT $LN48@ProcessSha

; 372  :                             param->type = Parameter_Int;

	mov	ecx, DWORD PTR _param$75[ebp]
	mov	DWORD PTR [ecx], 3
	jmp	SHORT $LN46@ProcessSha
$LN48@ProcessSha:

; 373  :                         else if(scmp(strType, TEXT("bool")) == 0)

	push	OFFSET $SG4294914638
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?scmp@@YGHPB_W0@Z
	test	eax, eax
	jne	SHORT $LN46@ProcessSha

; 374  :                             param->type = Parameter_Bool;

	mov	edx, DWORD PTR _param$75[ebp]
	mov	DWORD PTR [edx], 1
$LN46@ProcessSha:

; 375  : 
; 376  : 
; 377  :                         if(curToken == TEXT("="))

	push	OFFSET $SG4294914637
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??8String@@QBEHPB_W@Z
	test	eax, eax
	je	$LN45@ProcessSha

; 378  :                         {
; 379  :                             HandMeAToken(curToken);

	push	0
	lea	eax, DWORD PTR _curToken$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN44@ProcessSha
	mov	DWORD PTR $T18[ebp], 0
	lea	ecx, DWORD PTR _strName$79[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _savedToken$78[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T18[ebp]
	jmp	$LN183@ProcessSha
$LN44@ProcessSha:

; 380  : 
; 381  :                             BufferOutputSerializer sOut(param->defaultValue);

	push	1
	mov	ecx, DWORD PTR _param$75[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	lea	ecx, DWORD PTR _sOut$61[ebp]
	call	DWORD PTR __imp_??0BufferOutputSerializer@@QAE@AAV?$List@E@@H@Z

; 382  : 
; 383  :                             if(scmp(strType, TEXT("float")) == 0)

	push	OFFSET $SG4294914636
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?scmp@@YGHPB_W0@Z
	test	eax, eax
	jne	$LN43@ProcessSha

; 384  :                             {
; 385  :                                 HandMeAToken(curToken);

	push	0
	lea	edx, DWORD PTR _curToken$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN42@ProcessSha
	mov	DWORD PTR $T31[ebp], 0
	lea	ecx, DWORD PTR _sOut$61[ebp]
	call	DWORD PTR __imp_??1BufferOutputSerializer@@UAE@XZ
	lea	ecx, DWORD PTR _strName$79[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _savedToken$78[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T31[ebp]
	jmp	$LN183@ProcessSha
$LN42@ProcessSha:

; 386  : 
; 387  :                                 if(!ValidFloatString(curToken))

	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?ValidFloatString@@YGHPB_W@Z
	test	eax, eax
	jne	SHORT $LN41@ProcessSha

; 388  :                                     bError = TRUE;

	mov	DWORD PTR _bError$[ebp], 1
$LN41@ProcessSha:

; 389  : 
; 390  :                                 float fValue = (float)tstof(curToken);

	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?tstof@@YANPA_W@Z
	add	esp, 4
	fstp	DWORD PTR _fValue$17[ebp]

; 391  : 
; 392  :                                 sOut << fValue;

	lea	eax, DWORD PTR _fValue$17[ebp]
	push	eax
	lea	ecx, DWORD PTR _sOut$61[ebp]
	push	ecx
	call	??6@YAAAVSerializer@@AAV0@AAM@Z		; operator<<
	add	esp, 8
	jmp	$LN3@ProcessSha
$LN43@ProcessSha:

; 393  :                             }
; 394  :                             else if(scmp(strType, TEXT("int")) == 0)

	push	OFFSET $SG4294914635
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?scmp@@YGHPB_W0@Z
	test	eax, eax
	jne	$LN39@ProcessSha

; 395  :                             {
; 396  :                                 HandMeAToken(curToken);

	push	0
	lea	edx, DWORD PTR _curToken$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN38@ProcessSha
	mov	DWORD PTR $T29[ebp], 0
	lea	ecx, DWORD PTR _sOut$61[ebp]
	call	DWORD PTR __imp_??1BufferOutputSerializer@@UAE@XZ
	lea	ecx, DWORD PTR _strName$79[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _savedToken$78[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T29[ebp]
	jmp	$LN183@ProcessSha
$LN38@ProcessSha:

; 397  : 
; 398  :                                 if(!ValidIntString(curToken))

	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?ValidIntString@@YGHPB_W@Z
	test	eax, eax
	jne	SHORT $LN37@ProcessSha

; 399  :                                     bError = TRUE;

	mov	DWORD PTR _bError$[ebp], 1
$LN37@ProcessSha:

; 400  : 
; 401  :                                 int iValue = tstoi(curToken);

	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?tstoi@@YAHPA_W@Z
	add	esp, 4
	mov	DWORD PTR _iValue$11[ebp], eax

; 402  : 
; 403  :                                 sOut << iValue;

	lea	eax, DWORD PTR _iValue$11[ebp]
	push	eax
	lea	ecx, DWORD PTR _sOut$61[ebp]
	push	ecx
	call	??6@YAAAVSerializer@@AAV0@AAH@Z		; operator<<
	add	esp, 8
	jmp	$LN3@ProcessSha
$LN39@ProcessSha:

; 404  :                             }
; 405  :                             else if(scmp_n(strType, TEXT("float"), 5) == 0)

	push	5
	push	OFFSET $SG4294914634
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?scmp_n@@YGHPB_W0I@Z
	test	eax, eax
	jne	$LN3@ProcessSha

; 406  :                             {
; 407  :                                 CTSTR lpFloatType = strType.Array()+5;

	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	add	eax, 10					; 0000000aH
	mov	DWORD PTR _lpFloatType$73[ebp], eax

; 408  :                                 int floatCount = 0;

	mov	DWORD PTR _floatCount$76[ebp], 0

; 409  : 
; 410  :                                 if(lpFloatType[0] == '1') floatCount = 1;

	mov	edx, 2
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpFloatType$73[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	cmp	edx, 49					; 00000031H
	jne	SHORT $LN34@ProcessSha
	mov	DWORD PTR _floatCount$76[ebp], 1
	jmp	SHORT $LN27@ProcessSha
$LN34@ProcessSha:

; 411  :                                 else if(lpFloatType[0] == '2') floatCount = 2;

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpFloatType$73[ebp]
	movzx	eax, WORD PTR [edx+ecx]
	cmp	eax, 50					; 00000032H
	jne	SHORT $LN32@ProcessSha
	mov	DWORD PTR _floatCount$76[ebp], 2
	jmp	SHORT $LN27@ProcessSha
$LN32@ProcessSha:

; 412  :                                 else if(lpFloatType[0] == '3') floatCount = 3;

	mov	ecx, 2
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpFloatType$73[ebp]
	movzx	ecx, WORD PTR [eax+edx]
	cmp	ecx, 51					; 00000033H
	jne	SHORT $LN30@ProcessSha
	mov	DWORD PTR _floatCount$76[ebp], 3
	jmp	SHORT $LN27@ProcessSha
$LN30@ProcessSha:

; 413  :                                 else if(lpFloatType[0] == '4') floatCount = 4;

	mov	edx, 2
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpFloatType$73[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	cmp	edx, 52					; 00000034H
	jne	SHORT $LN28@ProcessSha
	mov	DWORD PTR _floatCount$76[ebp], 4

; 414  :                                 else

	jmp	SHORT $LN27@ProcessSha
$LN28@ProcessSha:

; 415  :                                     bError = TRUE;

	mov	DWORD PTR _bError$[ebp], 1
$LN27@ProcessSha:

; 416  : 
; 417  :                                 if(lpFloatType[1] == 'x')

	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _lpFloatType$73[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	cmp	edx, 120				; 00000078H
	jne	SHORT $LN19@ProcessSha

; 418  :                                 {
; 419  :                                     if(lpFloatType[2] != '1')

	mov	eax, 2
	shl	eax, 1
	mov	ecx, DWORD PTR _lpFloatType$73[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	cmp	edx, 49					; 00000031H
	je	SHORT $LN19@ProcessSha

; 420  :                                     {
; 421  :                                         if(lpFloatType[2] == '2') floatCount *= 2;

	mov	eax, 2
	shl	eax, 1
	mov	ecx, DWORD PTR _lpFloatType$73[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	cmp	edx, 50					; 00000032H
	jne	SHORT $LN24@ProcessSha
	mov	eax, DWORD PTR _floatCount$76[ebp]
	shl	eax, 1
	mov	DWORD PTR _floatCount$76[ebp], eax
	jmp	SHORT $LN19@ProcessSha
$LN24@ProcessSha:

; 422  :                                         else if(lpFloatType[2] == '3') floatCount *= 3;

	mov	ecx, 2
	shl	ecx, 1
	mov	edx, DWORD PTR _lpFloatType$73[ebp]
	movzx	eax, WORD PTR [edx+ecx]
	cmp	eax, 51					; 00000033H
	jne	SHORT $LN22@ProcessSha
	imul	ecx, DWORD PTR _floatCount$76[ebp], 3
	mov	DWORD PTR _floatCount$76[ebp], ecx
	jmp	SHORT $LN19@ProcessSha
$LN22@ProcessSha:

; 423  :                                         else if(lpFloatType[2] == '4') floatCount *= 4;

	mov	edx, 2
	shl	edx, 1
	mov	eax, DWORD PTR _lpFloatType$73[ebp]
	movzx	ecx, WORD PTR [eax+edx]
	cmp	ecx, 52					; 00000034H
	jne	SHORT $LN20@ProcessSha
	mov	edx, DWORD PTR _floatCount$76[ebp]
	shl	edx, 2
	mov	DWORD PTR _floatCount$76[ebp], edx

; 424  :                                         else

	jmp	SHORT $LN19@ProcessSha
$LN20@ProcessSha:

; 425  :                                             bError = TRUE;

	mov	DWORD PTR _bError$[ebp], 1
$LN19@ProcessSha:

; 426  :                                     }
; 427  :                                 }
; 428  : 
; 429  :                                 if(floatCount > 1) {ExpectToken(TEXT("{"), TEXT(";"));}

	cmp	DWORD PTR _floatCount$76[ebp], 1
	jle	$LN16@ProcessSha
	push	0
	lea	eax, DWORD PTR _curToken$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN17@ProcessSha
	mov	DWORD PTR $T55[ebp], 0
	lea	ecx, DWORD PTR _sOut$61[ebp]
	call	DWORD PTR __imp_??1BufferOutputSerializer@@UAE@XZ
	lea	ecx, DWORD PTR _strName$79[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _savedToken$78[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T55[ebp]
	jmp	$LN183@ProcessSha
$LN17@ProcessSha:
	push	OFFSET $SG4294914633
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??9String@@QBEHPB_W@Z
	test	eax, eax
	je	$LN16@ProcessSha
	push	1
	push	OFFSET $SG4294914632
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GotoToken@CodeTokenizer@@QAEHPB_WH@Z	; CodeTokenizer::GotoToken
	test	eax, eax
	jne	SHORT $LN15@ProcessSha
	mov	DWORD PTR $T53[ebp], 0
	lea	ecx, DWORD PTR _sOut$61[ebp]
	call	DWORD PTR __imp_??1BufferOutputSerializer@@UAE@XZ
	lea	ecx, DWORD PTR _strName$79[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _savedToken$78[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T53[ebp]
	jmp	$LN183@ProcessSha
$LN15@ProcessSha:
	lea	ecx, DWORD PTR _sOut$61[ebp]
	call	DWORD PTR __imp_??1BufferOutputSerializer@@UAE@XZ
	lea	ecx, DWORD PTR _strName$79[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _savedToken$78[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	jmp	$LN201@ProcessSha
$LN16@ProcessSha:

; 430  : 
; 431  :                                 int j;
; 432  :                                 for(j=0; j<floatCount; j++)

	mov	DWORD PTR _j$68[ebp], 0
	jmp	SHORT $LN14@ProcessSha
$LN13@ProcessSha:
	mov	ecx, DWORD PTR _j$68[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$68[ebp], ecx
$LN14@ProcessSha:
	mov	edx, DWORD PTR _j$68[ebp]
	cmp	edx, DWORD PTR _floatCount$76[ebp]
	jge	$LN12@ProcessSha

; 433  :                                 {
; 434  :                                     if(j)

	cmp	DWORD PTR _j$68[ebp], 0
	je	SHORT $LN9@ProcessSha

; 435  :                                     {
; 436  :                                         HandMeAToken(curToken);

	push	0
	lea	eax, DWORD PTR _curToken$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN10@ProcessSha
	mov	DWORD PTR $T51[ebp], 0
	lea	ecx, DWORD PTR _sOut$61[ebp]
	call	DWORD PTR __imp_??1BufferOutputSerializer@@UAE@XZ
	lea	ecx, DWORD PTR _strName$79[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _savedToken$78[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T51[ebp]
	jmp	$LN183@ProcessSha
$LN10@ProcessSha:

; 437  :                                         if(curToken[0] != ',')

	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	ecx, 2
	imul	edx, ecx, 0
	movzx	eax, WORD PTR [eax+edx]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN9@ProcessSha

; 438  :                                         {
; 439  :                                             bError = TRUE;

	mov	DWORD PTR _bError$[ebp], 1

; 440  :                                             break;

	jmp	$LN12@ProcessSha
$LN9@ProcessSha:

; 441  :                                         }
; 442  :                                     }
; 443  : 
; 444  :                                     HandMeAToken(curToken);

	push	0
	lea	ecx, DWORD PTR _curToken$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN8@ProcessSha
	mov	DWORD PTR $T49[ebp], 0
	lea	ecx, DWORD PTR _sOut$61[ebp]
	call	DWORD PTR __imp_??1BufferOutputSerializer@@UAE@XZ
	lea	ecx, DWORD PTR _strName$79[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _savedToken$78[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T49[ebp]
	jmp	$LN183@ProcessSha
$LN8@ProcessSha:

; 445  : 
; 446  :                                     if(!ValidFloatString(curToken))

	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?ValidFloatString@@YGHPB_W@Z
	test	eax, eax
	jne	SHORT $LN7@ProcessSha

; 447  :                                     {
; 448  :                                         bError = TRUE;

	mov	DWORD PTR _bError$[ebp], 1

; 449  :                                         break;

	jmp	SHORT $LN12@ProcessSha
$LN7@ProcessSha:

; 450  :                                     }
; 451  : 
; 452  :                                     float fValue = (float)tstof(curToken);

	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?tstof@@YANPA_W@Z
	add	esp, 4
	fstp	DWORD PTR _fValue$47[ebp]

; 453  :                                     sOut << fValue;

	lea	edx, DWORD PTR _fValue$47[ebp]
	push	edx
	lea	eax, DWORD PTR _sOut$61[ebp]
	push	eax
	call	??6@YAAAVSerializer@@AAV0@AAM@Z		; operator<<
	add	esp, 8

; 454  :                                 }

	jmp	$LN13@ProcessSha
$LN12@ProcessSha:

; 455  : 
; 456  :                                 if(j != floatCount) //processing error occured

	mov	ecx, DWORD PTR _j$68[ebp]
	cmp	ecx, DWORD PTR _floatCount$76[ebp]
	je	SHORT $LN6@ProcessSha

; 457  :                                 {
; 458  :                                     GotoToken(TEXT(";"));

	push	0
	push	OFFSET $SG4294914631
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GotoToken@CodeTokenizer@@QAEHPB_WH@Z	; CodeTokenizer::GotoToken

; 459  :                                     continue;

	lea	ecx, DWORD PTR _sOut$61[ebp]
	call	DWORD PTR __imp_??1BufferOutputSerializer@@UAE@XZ
	lea	ecx, DWORD PTR _strName$79[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _savedToken$78[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	jmp	$LN201@ProcessSha
$LN6@ProcessSha:

; 460  :                                 }
; 461  : 
; 462  :                                 if(floatCount > 1)

	cmp	DWORD PTR _floatCount$76[ebp], 1
	jle	$LN3@ProcessSha

; 463  :                                 {ExpectToken(TEXT("}"), TEXT(";"));}

	push	0
	lea	edx, DWORD PTR _curToken$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN4@ProcessSha
	mov	DWORD PTR $T45[ebp], 0
	lea	ecx, DWORD PTR _sOut$61[ebp]
	call	DWORD PTR __imp_??1BufferOutputSerializer@@UAE@XZ
	lea	ecx, DWORD PTR _strName$79[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _savedToken$78[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T45[ebp]
	jmp	$LN183@ProcessSha
$LN4@ProcessSha:
	push	OFFSET $SG4294914630
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??9String@@QBEHPB_W@Z
	test	eax, eax
	je	$LN3@ProcessSha
	push	1
	push	OFFSET $SG4294914629
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GotoToken@CodeTokenizer@@QAEHPB_WH@Z	; CodeTokenizer::GotoToken
	test	eax, eax
	jne	SHORT $LN2@ProcessSha
	mov	DWORD PTR $T43[ebp], 0
	lea	ecx, DWORD PTR _sOut$61[ebp]
	call	DWORD PTR __imp_??1BufferOutputSerializer@@UAE@XZ
	lea	ecx, DWORD PTR _strName$79[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _savedToken$78[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T43[ebp]
	jmp	$LN183@ProcessSha
$LN2@ProcessSha:
	lea	ecx, DWORD PTR _sOut$61[ebp]
	call	DWORD PTR __imp_??1BufferOutputSerializer@@UAE@XZ
	lea	ecx, DWORD PTR _strName$79[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _savedToken$78[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	jmp	$LN201@ProcessSha
$LN3@ProcessSha:

; 464  :                             }
; 465  : 
; 466  :                             PeekAtAToken(curToken);

	push	1
	lea	eax, DWORD PTR _curToken$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN1@ProcessSha
	mov	DWORD PTR $T41[ebp], 0
	lea	ecx, DWORD PTR _sOut$61[ebp]
	call	DWORD PTR __imp_??1BufferOutputSerializer@@UAE@XZ
	lea	ecx, DWORD PTR _strName$79[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _savedToken$78[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T41[ebp]
	jmp	$LN183@ProcessSha
$LN1@ProcessSha:

; 467  :                         }

	lea	ecx, DWORD PTR _sOut$61[ebp]
	call	DWORD PTR __imp_??1BufferOutputSerializer@@UAE@XZ
$LN45@ProcessSha:

; 468  :                     }
; 469  : 
; 470  :                     //--------------------------
; 471  : 
; 472  :                     lpLastPos = lpTemp;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _lpLastPos$[ebp], edx

; 473  :                     bNewCodeLine = FALSE;

	mov	DWORD PTR _bNewCodeLine$[ebp], 0

; 474  :                     continue;

	lea	ecx, DWORD PTR _strName$79[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _savedToken$78[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	jmp	$LN201@ProcessSha
$LN97@ProcessSha:

; 475  :                 }
; 476  : 
; 477  :                 lpTemp = lpSavedPos;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _lpSavedPos$39[ebp]
	mov	DWORD PTR [eax+12], ecx

; 478  :                 curToken = savedToken;

	lea	edx, DWORD PTR _savedToken$78[ebp]
	push	edx
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@ABV0@@Z

; 479  :             }

	lea	ecx, DWORD PTR _strName$79[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strType$81[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _savedToken$78[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN102@ProcessSha:

; 480  :         }
; 481  : 
; 482  :         lpLastPos = lpTemp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _lpLastPos$[ebp], ecx

; 483  : 
; 484  :         bNewCodeLine = (curToken.IsValid() && ((curToken[0] == ';') || (curToken[0] == '}')));

	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_?IsValid@String@@QBEHXZ
	test	eax, eax
	je	SHORT $LN186@ProcessSha
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	edx, 2
	imul	ecx, edx, 0
	movzx	edx, WORD PTR [eax+ecx]
	cmp	edx, 59					; 0000003bH
	je	SHORT $LN185@ProcessSha
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	ecx, 2
	imul	edx, ecx, 0
	movzx	eax, WORD PTR [eax+edx]
	cmp	eax, 125				; 0000007dH
	jne	SHORT $LN186@ProcessSha
$LN185@ProcessSha:
	mov	DWORD PTR tv1375[ebp], 1
	jmp	SHORT $LN187@ProcessSha
$LN186@ProcessSha:
	mov	DWORD PTR tv1375[ebp], 0
$LN187@ProcessSha:
	mov	ecx, DWORD PTR tv1375[ebp]
	mov	DWORD PTR _bNewCodeLine$[ebp], ecx

; 485  :     }

	jmp	$LN201@ProcessSha
$LN181@ProcessSha:

; 486  : 
; 487  :     return !bError;

	cmp	DWORD PTR _bError$[ebp], 0
	jne	SHORT $LN188@ProcessSha
	mov	DWORD PTR tv1377[ebp], 1
	jmp	SHORT $LN189@ProcessSha
$LN188@ProcessSha:
	mov	DWORD PTR tv1377[ebp], 0
$LN189@ProcessSha:
	mov	edx, DWORD PTR tv1377[ebp]
	mov	DWORD PTR $T37[ebp], edx
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T37[ebp]
$LN183@ProcessSha:

; 488  : }

	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	8
$LN207@ProcessSha:
	DD	$LN136@ProcessSha
	DD	$LN135@ProcessSha
	DD	$LN134@ProcessSha
	DD	$LN133@ProcessSha
	DD	$LN137@ProcessSha
$LN206@ProcessSha:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	2
	DB	3
?ProcessShader@ShaderProcessor@@QAEHPB_W0@Z ENDP	; ShaderProcessor::ProcessShader
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\serializer.h
;	COMDAT ??6@YAAAVSerializer@@AAV0@AAH@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_dw$ = 12						; size = 4
??6@YAAAVSerializer@@AAV0@AAH@Z PROC			; operator<<, COMDAT

; 53   :     friend inline Serializer& operator<<(Serializer &s, int   &dw)     {s.Serialize(&dw, 4); return s;}

	push	ebp
	mov	ebp, esp
	push	4
	mov	eax, DWORD PTR _dw$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	eax, DWORD PTR _s$[ebp]
	pop	ebp
	ret	0
??6@YAAAVSerializer@@AAV0@AAH@Z ENDP			; operator<<
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\serializer.h
;	COMDAT ??6@YAAAVSerializer@@AAV0@AAM@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_f$ = 12						; size = 4
??6@YAAAVSerializer@@AAV0@AAM@Z PROC			; operator<<, COMDAT

; 60   :     friend inline Serializer& operator<<(Serializer &s, float &f)      {s.Serialize(&f, 4);  return s;}

	push	ebp
	mov	ebp, esp
	push	4
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	eax, DWORD PTR _s$[ebp]
	pop	ebp
	ret	0
??6@YAAAVSerializer@@AAV0@AAM@Z ENDP			; operator<<
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 70   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3451 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\tuple
;	COMDAT ??__Eignore@std@@YAXXZ
text$di	SEGMENT
??__Eignore@std@@YAXXZ PROC				; std::`dynamic initializer for 'ignore'', COMDAT

; 59   : const _Ignore ignore;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET _ignore
	call	??0_Ignore@std@@QAE@XZ			; std::_Ignore::_Ignore
	pop	ebp
	ret	0
??__Eignore@std@@YAXXZ ENDP				; std::`dynamic initializer for 'ignore''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\tuple
;	COMDAT ??__E_Tuple_alloc@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__E_Tuple_alloc@std@@YAXXZ PROC			; std::`dynamic initializer for '_Tuple_alloc'', COMDAT

; 66   : const _Tuple_alloc_t _Tuple_alloc = _Tuple_alloc_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__E_Tuple_alloc@std@@YAXXZ ENDP			; std::`dynamic initializer for '_Tuple_alloc''
text$di	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\graphicssystem.h
;	COMDAT ??0SamplerInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0SamplerInfo@@QAE@XZ PROC				; SamplerInfo::SamplerInfo, COMDAT
; _this$ = ecx

; 149  :     inline SamplerInfo()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	DWORD PTR __imp_??0Vect4@@QAE@XZ

; 150  :     {
; 151  :         zero(this, sizeof(SamplerInfo));

	push	48					; 00000030H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?zero@@YGXPAXI@Z			; zero

; 152  :         maxAnisotropy = 16;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 16			; 00000010H

; 153  :     }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0SamplerInfo@@QAE@XZ ENDP				; SamplerInfo::SamplerInfo
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\graphicssystem.h
;	COMDAT ?CreateSamplerState@@YAPAVSamplerState@@AAUSamplerInfo@@@Z
_TEXT	SEGMENT
_info$ = 8						; size = 4
?CreateSamplerState@@YAPAVSamplerState@@AAUSamplerInfo@@@Z PROC ; CreateSamplerState, COMDAT

; 657  : inline SamplerState* CreateSamplerState(SamplerInfo &info)          {return GS->CreateSamplerState(info);}

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _info$[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp_?GS@@3PAVGraphicsSystem@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?GS@@3PAVGraphicsSystem@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+44]
	call	eax
	pop	ebp
	ret	0
?CreateSamplerState@@YAPAVSamplerState@@AAUSamplerInfo@@@Z ENDP ; CreateSamplerState
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\codetokenizer.h
;	COMDAT ?SetCodeStart@CodeTokenizer@@QAEXPB_W@Z
_TEXT	SEGMENT
tv71 = -8						; size = 4
_this$ = -4						; size = 4
_lpCodeIn$ = 8						; size = 4
?SetCodeStart@CodeTokenizer@@QAEXPB_W@Z PROC		; CodeTokenizer::SetCodeStart, COMDAT
; _this$ = ecx

; 33   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 34   :         dupString = lpCodeIn;

	mov	eax, DWORD PTR _lpCodeIn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z

; 35   :         lpTemp = lpCode = dupString;

	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	DWORD PTR tv71[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv71[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR tv71[ebp]
	mov	DWORD PTR [eax+12], ecx

; 36   :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetCodeStart@CodeTokenizer@@QAEXPB_W@Z ENDP		; CodeTokenizer::SetCodeStart
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10shaderprocessor.cpp
;	COMDAT ?GetSemanticInfo@@YA_NABVString@@AAUSemanticInfo@@@Z
_TEXT	SEGMENT
_semanticLen$1 = -8					; size = 4
_i$2 = -4						; size = 4
_strSemantic$ = 8					; size = 4
_info$ = 12						; size = 4
?GetSemanticInfo@@YA_NABVString@@AAUSemanticInfo@@@Z PROC ; GetSemanticInfo, COMDAT

; 45   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 46   :     for(UINT i=0; i<5; i++)

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN6@GetSemanti
$LN5@GetSemanti:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN6@GetSemanti:
	cmp	DWORD PTR _i$2[ebp], 5
	jae	$LN4@GetSemanti

; 47   :     {
; 48   :         UINT semanticLen = slen(validSemanticTStrings[i]);

	mov	ecx, DWORD PTR _i$2[ebp]
	mov	edx, DWORD PTR ?validSemanticTStrings@@3PAPB_WA[ecx*4]
	push	edx
	call	DWORD PTR __imp_?slen@@YGIPB_W@Z
	mov	DWORD PTR _semanticLen$1[ebp], eax

; 49   :         if(scmpi_n(strSemantic, validSemanticTStrings[i], semanticLen) == 0)

	mov	eax, DWORD PTR _semanticLen$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$2[ebp]
	mov	edx, DWORD PTR ?validSemanticTStrings@@3PAPB_WA[ecx*4]
	push	edx
	mov	ecx, DWORD PTR _strSemantic$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?scmpi_n@@YGHPB_W0I@Z
	test	eax, eax
	jne	SHORT $LN3@GetSemanti

; 50   :         {
; 51   :             if(strSemantic[semanticLen] && isdigit(strSemantic[semanticLen]))

	mov	ecx, DWORD PTR _strSemantic$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	ecx, DWORD PTR _semanticLen$1[ebp]
	movzx	edx, WORD PTR [eax+ecx*2]
	test	edx, edx
	je	SHORT $LN2@GetSemanti
	mov	ecx, DWORD PTR _strSemantic$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	ecx, DWORD PTR _semanticLen$1[ebp]
	movzx	edx, WORD PTR [eax+ecx*2]
	push	edx
	call	_isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@GetSemanti

; 52   :                 info.index = strSemantic[semanticLen]-'0';

	mov	ecx, DWORD PTR _strSemantic$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	ecx, DWORD PTR _semanticLen$1[ebp]
	movzx	edx, WORD PTR [eax+ecx*2]
	sub	edx, 48					; 00000030H
	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+4], edx

; 53   :             else

	jmp	SHORT $LN1@GetSemanti
$LN2@GetSemanti:

; 54   :                 info.index = 0;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+4], 0
$LN1@GetSemanti:

; 55   : 
; 56   :             info.lpName = validSemanticStrings[i];

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR _i$2[ebp]
	mov	ecx, DWORD PTR ?validSemanticStrings@@3PAPBDA[eax*4]
	mov	DWORD PTR [edx], ecx

; 57   :             return true;

	mov	al, 1
	jmp	SHORT $LN7@GetSemanti
$LN3@GetSemanti:

; 58   :         }
; 59   :     }

	jmp	$LN5@GetSemanti
$LN4@GetSemanti:

; 60   : 
; 61   :     return false;

	xor	al, al
$LN7@GetSemanti:

; 62   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetSemanticInfo@@YA_NABVString@@AAUSemanticInfo@@@Z ENDP ; GetSemanticInfo
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10shaderprocessor.cpp
;	COMDAT ?AddState@ShaderProcessor@@QAEHAAUSamplerInfo@@AAVString@@1@Z
_TEXT	SEGMENT
$T1 = -112						; size = 16
_curToken$2 = -88					; size = 8
$T3 = -80						; size = 4
$T4 = -76						; size = 4
$T5 = -72						; size = 4
$T6 = -68						; size = 4
$T7 = -64						; size = 4
$T8 = -60						; size = 4
$T9 = -56						; size = 4
$T10 = -52						; size = 4
$T11 = -48						; size = 4
$T12 = -44						; size = 4
$T13 = -40						; size = 4
$T14 = -36						; size = 4
$T15 = -32						; size = 4
$T16 = -28						; size = 4
$T17 = -24						; size = 4
$T18 = -20						; size = 4
_type$19 = -16						; size = 4
tv77 = -12						; size = 4
_mode$20 = -8						; size = 4
_this$ = -4						; size = 4
_info$ = 8						; size = 4
_stateName$ = 12					; size = 4
_stateVal$ = 16						; size = 4
?AddState@ShaderProcessor@@QAEHAAUSamplerInfo@@AAVString@@1@Z PROC ; ShaderProcessor::AddState, COMDAT
; _this$ = ecx

; 494  : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	DWORD PTR _this$[ebp], ecx

; 495  :     if(scmpi_n(stateName, TEXT("Address"), 7) == 0)

	push	7
	push	OFFSET $SG4294914628
	mov	ecx, DWORD PTR _stateName$[ebx]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?scmpi_n@@YGHPB_W0I@Z
	test	eax, eax
	jne	$LN62@AddState

; 496  :     {
; 497  :         int type = stateName[7]-'U';

	mov	ecx, DWORD PTR _stateName$[ebx]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	ecx, 2
	imul	edx, ecx, 7
	movzx	eax, WORD PTR [eax+edx]
	sub	eax, 85					; 00000055H
	mov	DWORD PTR _type$19[ebp], eax

; 498  : 
; 499  :         GSAddressMode *mode;
; 500  :         switch(type)

	mov	ecx, DWORD PTR _type$19[ebp]
	mov	DWORD PTR tv77[ebp], ecx
	cmp	DWORD PTR tv77[ebp], 0
	je	SHORT $LN59@AddState
	cmp	DWORD PTR tv77[ebp], 1
	je	SHORT $LN58@AddState
	cmp	DWORD PTR tv77[ebp], 2
	je	SHORT $LN57@AddState
	jmp	SHORT $LN56@AddState
$LN59@AddState:

; 501  :         {
; 502  :             case 0: mode = &info.addressU; break;

	mov	edx, DWORD PTR _info$[ebx]
	add	edx, 4
	mov	DWORD PTR _mode$20[ebp], edx
	jmp	SHORT $LN60@AddState
$LN58@AddState:

; 503  :             case 1: mode = &info.addressV; break;

	mov	eax, DWORD PTR _info$[ebx]
	add	eax, 8
	mov	DWORD PTR _mode$20[ebp], eax
	jmp	SHORT $LN60@AddState
$LN57@AddState:

; 504  :             case 2: mode = &info.addressW; break;

	mov	ecx, DWORD PTR _info$[ebx]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR _mode$20[ebp], ecx
	jmp	SHORT $LN60@AddState
$LN56@AddState:

; 505  :             default: CrashError(TEXT("Invalid shader address type %d"), type);

	mov	edx, DWORD PTR _type$19[ebp]
	push	edx
	push	OFFSET $SG4294914627
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ
$LN60@AddState:

; 506  :         }
; 507  : 
; 508  :         if(stateVal.CompareI(TEXT("Wrap")) || stateVal.CompareI(TEXT("Repeat")))

	push	OFFSET $SG4294914626
	mov	ecx, DWORD PTR _stateVal$[ebx]
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	test	eax, eax
	jne	SHORT $LN54@AddState
	push	OFFSET $SG4294914625
	mov	ecx, DWORD PTR _stateVal$[ebx]
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN55@AddState
$LN54@AddState:

; 509  :             *mode = GS_ADDRESS_WRAP;

	mov	eax, DWORD PTR _mode$20[ebp]
	mov	DWORD PTR [eax], 1
	jmp	$LN45@AddState
$LN55@AddState:

; 510  :         else if(stateVal.CompareI(TEXT("Clamp")) || stateVal.CompareI(TEXT("None")))

	push	OFFSET $SG4294914624
	mov	ecx, DWORD PTR _stateVal$[ebx]
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	test	eax, eax
	jne	SHORT $LN51@AddState
	push	OFFSET $SG4294914623
	mov	ecx, DWORD PTR _stateVal$[ebx]
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN52@AddState
$LN51@AddState:

; 511  :             *mode = GS_ADDRESS_CLAMP;

	mov	ecx, DWORD PTR _mode$20[ebp]
	mov	DWORD PTR [ecx], 0
	jmp	SHORT $LN45@AddState
$LN52@AddState:

; 512  :         else if(stateVal.CompareI(TEXT("Mirror")))

	push	OFFSET $SG4294914622
	mov	ecx, DWORD PTR _stateVal$[ebx]
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN49@AddState

; 513  :             *mode = GS_ADDRESS_MIRROR;

	mov	edx, DWORD PTR _mode$20[ebp]
	mov	DWORD PTR [edx], 2
	jmp	SHORT $LN45@AddState
$LN49@AddState:

; 514  :         else if(stateVal.CompareI(TEXT("Border")))

	push	OFFSET $SG4294914621
	mov	ecx, DWORD PTR _stateVal$[ebx]
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN47@AddState

; 515  :             *mode = GS_ADDRESS_BORDER;

	mov	eax, DWORD PTR _mode$20[ebp]
	mov	DWORD PTR [eax], 3
	jmp	SHORT $LN45@AddState
$LN47@AddState:

; 516  :         else if(stateVal.CompareI(TEXT("MirrorOnce")))

	push	OFFSET $SG4294914620
	mov	ecx, DWORD PTR _stateVal$[ebx]
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN45@AddState

; 517  :             *mode = GS_ADDRESS_MIRRORONCE;

	mov	ecx, DWORD PTR _mode$20[ebp]
	mov	DWORD PTR [ecx], 4
$LN45@AddState:

; 518  :     }

	jmp	$LN1@AddState
$LN62@AddState:

; 519  :     else if(stateName.CompareI(TEXT("MaxAnisotropy")))

	push	OFFSET $SG4294914619
	mov	ecx, DWORD PTR _stateName$[ebx]
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN43@AddState

; 520  :     {
; 521  :         info.maxAnisotropy = tstoi(stateVal);

	mov	ecx, DWORD PTR _stateVal$[ebx]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?tstoi@@YAHPA_W@Z
	add	esp, 4
	mov	edx, DWORD PTR _info$[ebx]
	mov	DWORD PTR [edx+16], eax
	jmp	$LN1@AddState
$LN43@AddState:

; 522  :     }
; 523  :     else if(stateName.CompareI(TEXT("Filter")))

	push	OFFSET $SG4294914618
	mov	ecx, DWORD PTR _stateName$[ebx]
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	test	eax, eax
	je	$LN41@AddState

; 524  :     {
; 525  :         if(stateVal.CompareI(TEXT("Anisotropic")))

	push	OFFSET $SG4294914617
	mov	ecx, DWORD PTR _stateVal$[ebx]
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN40@AddState

; 526  :             info.filter = GS_FILTER_ANISOTROPIC;

	mov	eax, DWORD PTR _info$[ebx]
	mov	DWORD PTR [eax], 2
	jmp	$LN22@AddState
$LN40@AddState:

; 527  :         else if(stateVal.CompareI(TEXT("Point")) || stateVal.CompareI(TEXT("MIN_MAG_MIP_POINT")))

	push	OFFSET $SG4294914616
	mov	ecx, DWORD PTR _stateVal$[ebx]
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	test	eax, eax
	jne	SHORT $LN37@AddState
	push	OFFSET $SG4294914615
	mov	ecx, DWORD PTR _stateVal$[ebx]
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN38@AddState
$LN37@AddState:

; 528  :             info.filter = GS_FILTER_POINT;

	mov	ecx, DWORD PTR _info$[ebx]
	mov	DWORD PTR [ecx], 1
	jmp	$LN22@AddState
$LN38@AddState:

; 529  :         else if(stateVal.CompareI(TEXT("Linear")) || stateVal.CompareI(TEXT("MIN_MAG_MIP_LINEAR")))

	push	OFFSET $SG4294914614
	mov	ecx, DWORD PTR _stateVal$[ebx]
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	test	eax, eax
	jne	SHORT $LN34@AddState
	push	OFFSET $SG4294914613
	mov	ecx, DWORD PTR _stateVal$[ebx]
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN35@AddState
$LN34@AddState:

; 530  :             info.filter = GS_FILTER_LINEAR;

	mov	edx, DWORD PTR _info$[ebx]
	mov	DWORD PTR [edx], 0
	jmp	$LN22@AddState
$LN35@AddState:

; 531  :         else if(stateVal.CompareI(TEXT("MIN_MAG_POINT_MIP_LINEAR")))

	push	OFFSET $SG4294914612
	mov	ecx, DWORD PTR _stateVal$[ebx]
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN32@AddState

; 532  :             info.filter = GS_FILTER_MIN_MAG_POINT_MIP_LINEAR;

	mov	eax, DWORD PTR _info$[ebx]
	mov	DWORD PTR [eax], 3
	jmp	$LN22@AddState
$LN32@AddState:

; 533  :         else if(stateVal.CompareI(TEXT("MIN_POINT_MAG_LINEAR_MIP_POINT")))

	push	OFFSET $SG4294914611
	mov	ecx, DWORD PTR _stateVal$[ebx]
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN30@AddState

; 534  :             info.filter = GS_FILTER_MIN_POINT_MAG_LINEAR_MIP_POINT;

	mov	ecx, DWORD PTR _info$[ebx]
	mov	DWORD PTR [ecx], 4
	jmp	SHORT $LN22@AddState
$LN30@AddState:

; 535  :         else if(stateVal.CompareI(TEXT("MIN_POINT_MAG_MIP_LINEAR")))

	push	OFFSET $SG4294914610
	mov	ecx, DWORD PTR _stateVal$[ebx]
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN28@AddState

; 536  :             info.filter = GS_FILTER_MIN_POINT_MAG_MIP_LINEAR;

	mov	edx, DWORD PTR _info$[ebx]
	mov	DWORD PTR [edx], 5
	jmp	SHORT $LN22@AddState
$LN28@AddState:

; 537  :         else if(stateVal.CompareI(TEXT("MIN_LINEAR_MAG_MIP_POINT")))

	push	OFFSET $SG4294914609
	mov	ecx, DWORD PTR _stateVal$[ebx]
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN26@AddState

; 538  :             info.filter = GS_FILTER_MIN_LINEAR_MAG_MIP_POINT;

	mov	eax, DWORD PTR _info$[ebx]
	mov	DWORD PTR [eax], 6
	jmp	SHORT $LN22@AddState
$LN26@AddState:

; 539  :         else if(stateVal.CompareI(TEXT("MIN_LINEAR_MAG_POINT_MIP_LINEAR")))

	push	OFFSET $SG4294914608
	mov	ecx, DWORD PTR _stateVal$[ebx]
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN24@AddState

; 540  :             info.filter = GS_FILTER_MIN_LINEAR_MAG_POINT_MIP_LINEAR;

	mov	ecx, DWORD PTR _info$[ebx]
	mov	DWORD PTR [ecx], 7
	jmp	SHORT $LN22@AddState
$LN24@AddState:

; 541  :         else if(stateVal.CompareI(TEXT("MIN_MAG_LINEAR_MIP_POINT")))

	push	OFFSET $SG4294914607
	mov	ecx, DWORD PTR _stateVal$[ebx]
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN22@AddState

; 542  :             info.filter = GS_FILTER_MIN_MAG_LINEAR_MIP_POINT;

	mov	edx, DWORD PTR _info$[ebx]
	mov	DWORD PTR [edx], 8
$LN22@AddState:

; 543  :     }

	jmp	$LN1@AddState
$LN41@AddState:

; 544  :     else if(stateName.CompareI(TEXT("BorderColor")))

	push	OFFSET $SG4294914606
	mov	ecx, DWORD PTR _stateName$[ebx]
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	test	eax, eax
	je	$LN1@AddState

; 545  :     {
; 546  :         if(stateVal[0] == '{')

	mov	ecx, DWORD PTR _stateVal$[ebx]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	ecx, 2
	imul	edx, ecx, 0
	movzx	eax, WORD PTR [eax+edx]
	cmp	eax, 123				; 0000007bH
	jne	$LN19@AddState

; 547  :         {
; 548  :             String curToken;

	lea	ecx, DWORD PTR _curToken$2[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 549  : 
; 550  :             HandMeAToken(curToken);

	push	0
	lea	ecx, DWORD PTR _curToken$2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN18@AddState
	mov	DWORD PTR $T18[ebp], 0
	lea	ecx, DWORD PTR _curToken$2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T18[ebp]
	jmp	$LN63@AddState
$LN18@AddState:

; 551  :             if(!ValidFloatString(curToken)) {return FALSE;}

	lea	ecx, DWORD PTR _curToken$2[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?ValidFloatString@@YGHPB_W@Z
	test	eax, eax
	jne	SHORT $LN17@AddState
	mov	DWORD PTR $T17[ebp], 0
	lea	ecx, DWORD PTR _curToken$2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T17[ebp]
	jmp	$LN63@AddState
$LN17@AddState:

; 552  :             info.borderColor.x = (float)tstof(curToken);

	lea	ecx, DWORD PTR _curToken$2[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?tstof@@YANPA_W@Z
	add	esp, 4
	mov	edx, DWORD PTR _info$[ebx]
	fstp	DWORD PTR [edx+32]

; 553  : 
; 554  :             //-------------------------------
; 555  : 
; 556  :             ExpectToken(TEXT(","));

	push	0
	lea	eax, DWORD PTR _curToken$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN16@AddState
	mov	DWORD PTR $T16[ebp], 0
	lea	ecx, DWORD PTR _curToken$2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T16[ebp]
	jmp	$LN63@AddState
$LN16@AddState:
	push	OFFSET $SG4294914605
	lea	ecx, DWORD PTR _curToken$2[ebp]
	call	DWORD PTR __imp_??9String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN15@AddState
	mov	DWORD PTR $T15[ebp], 0
	lea	ecx, DWORD PTR _curToken$2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T15[ebp]
	jmp	$LN63@AddState
$LN15@AddState:

; 557  : 
; 558  :             //-------------------------------
; 559  : 
; 560  :             HandMeAToken(curToken);

	push	0
	lea	ecx, DWORD PTR _curToken$2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN14@AddState
	mov	DWORD PTR $T14[ebp], 0
	lea	ecx, DWORD PTR _curToken$2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T14[ebp]
	jmp	$LN63@AddState
$LN14@AddState:

; 561  :             if(!ValidFloatString(curToken)) {return FALSE;}

	lea	ecx, DWORD PTR _curToken$2[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?ValidFloatString@@YGHPB_W@Z
	test	eax, eax
	jne	SHORT $LN13@AddState
	mov	DWORD PTR $T13[ebp], 0
	lea	ecx, DWORD PTR _curToken$2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T13[ebp]
	jmp	$LN63@AddState
$LN13@AddState:

; 562  :             info.borderColor.y = (float)tstof(curToken);

	lea	ecx, DWORD PTR _curToken$2[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?tstof@@YANPA_W@Z
	add	esp, 4
	mov	edx, DWORD PTR _info$[ebx]
	fstp	DWORD PTR [edx+36]

; 563  : 
; 564  :             //-------------------------------
; 565  : 
; 566  :             ExpectToken(TEXT(","));

	push	0
	lea	eax, DWORD PTR _curToken$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN12@AddState
	mov	DWORD PTR $T12[ebp], 0
	lea	ecx, DWORD PTR _curToken$2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T12[ebp]
	jmp	$LN63@AddState
$LN12@AddState:
	push	OFFSET $SG4294914604
	lea	ecx, DWORD PTR _curToken$2[ebp]
	call	DWORD PTR __imp_??9String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN11@AddState
	mov	DWORD PTR $T11[ebp], 0
	lea	ecx, DWORD PTR _curToken$2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T11[ebp]
	jmp	$LN63@AddState
$LN11@AddState:

; 567  : 
; 568  :             //-------------------------------
; 569  : 
; 570  :             HandMeAToken(curToken);

	push	0
	lea	ecx, DWORD PTR _curToken$2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN10@AddState
	mov	DWORD PTR $T10[ebp], 0
	lea	ecx, DWORD PTR _curToken$2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T10[ebp]
	jmp	$LN63@AddState
$LN10@AddState:

; 571  :             if(!ValidFloatString(curToken)) {return FALSE;}

	lea	ecx, DWORD PTR _curToken$2[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?ValidFloatString@@YGHPB_W@Z
	test	eax, eax
	jne	SHORT $LN9@AddState
	mov	DWORD PTR $T9[ebp], 0
	lea	ecx, DWORD PTR _curToken$2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T9[ebp]
	jmp	$LN63@AddState
$LN9@AddState:

; 572  :             info.borderColor.z = (float)tstof(curToken);

	lea	ecx, DWORD PTR _curToken$2[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?tstof@@YANPA_W@Z
	add	esp, 4
	mov	edx, DWORD PTR _info$[ebx]
	fstp	DWORD PTR [edx+40]

; 573  : 
; 574  :             //-------------------------------
; 575  : 
; 576  :             ExpectToken(TEXT(","));

	push	0
	lea	eax, DWORD PTR _curToken$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN8@AddState
	mov	DWORD PTR $T8[ebp], 0
	lea	ecx, DWORD PTR _curToken$2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T8[ebp]
	jmp	$LN63@AddState
$LN8@AddState:
	push	OFFSET $SG4294914603
	lea	ecx, DWORD PTR _curToken$2[ebp]
	call	DWORD PTR __imp_??9String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN7@AddState
	mov	DWORD PTR $T7[ebp], 0
	lea	ecx, DWORD PTR _curToken$2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T7[ebp]
	jmp	$LN63@AddState
$LN7@AddState:

; 577  : 
; 578  :             //-------------------------------
; 579  : 
; 580  :             HandMeAToken(curToken);

	push	0
	lea	ecx, DWORD PTR _curToken$2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN6@AddState
	mov	DWORD PTR $T6[ebp], 0
	lea	ecx, DWORD PTR _curToken$2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T6[ebp]
	jmp	$LN63@AddState
$LN6@AddState:

; 581  :             if(!ValidFloatString(curToken)) {return FALSE;}

	lea	ecx, DWORD PTR _curToken$2[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?ValidFloatString@@YGHPB_W@Z
	test	eax, eax
	jne	SHORT $LN5@AddState
	mov	DWORD PTR $T5[ebp], 0
	lea	ecx, DWORD PTR _curToken$2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T5[ebp]
	jmp	$LN63@AddState
$LN5@AddState:

; 582  :             info.borderColor.w = (float)tstof(curToken);

	lea	ecx, DWORD PTR _curToken$2[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?tstof@@YANPA_W@Z
	add	esp, 4
	mov	edx, DWORD PTR _info$[ebx]
	fstp	DWORD PTR [edx+44]

; 583  : 
; 584  :             //-------------------------------
; 585  : 
; 586  :             ExpectToken(TEXT("}"));

	push	0
	lea	eax, DWORD PTR _curToken$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN4@AddState
	mov	DWORD PTR $T4[ebp], 0
	lea	ecx, DWORD PTR _curToken$2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T4[ebp]
	jmp	SHORT $LN63@AddState
$LN4@AddState:
	push	OFFSET $SG4294914602
	lea	ecx, DWORD PTR _curToken$2[ebp]
	call	DWORD PTR __imp_??9String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN3@AddState
	mov	DWORD PTR $T3[ebp], 0
	lea	ecx, DWORD PTR _curToken$2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T3[ebp]
	jmp	SHORT $LN63@AddState
$LN3@AddState:

; 587  :         }

	lea	ecx, DWORD PTR _curToken$2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	jmp	SHORT $LN1@AddState
$LN19@AddState:

; 588  :         else if(ValidIntString(stateVal))

	mov	ecx, DWORD PTR _stateVal$[ebx]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?ValidIntString@@YGHPB_W@Z
	test	eax, eax
	je	SHORT $LN1@AddState

; 589  :             info.borderColor = Color4().MakeFromRGBA(tstoi(stateVal));

	mov	ecx, DWORD PTR _stateVal$[ebx]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?tstoi@@YAHPA_W@Z
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??0Vect4@@QAE@XZ
	mov	ecx, eax
	call	DWORD PTR __imp_?MakeFromRGBA@Vect4@@QAEAAU1@K@Z
	push	eax
	mov	ecx, DWORD PTR _info$[ebx]
	add	ecx, 32					; 00000020H
	call	DWORD PTR __imp_??4Vect4@@QAEAAU0@ABU0@@Z
$LN1@AddState:

; 590  :     }
; 591  : 
; 592  :     return TRUE;

	mov	eax, 1
$LN63@AddState:

; 593  : }

	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	12					; 0000000cH
?AddState@ShaderProcessor@@QAEHAAUSamplerInfo@@AAVString@@1@Z ENDP ; ShaderProcessor::AddState
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?CreateNew@?$List@UShaderSampler@@@@QAEPAUShaderSampler@@XZ
_TEXT	SEGMENT
_value$ = -8						; size = 4
_this$ = -4						; size = 4
?CreateNew@?$List@UShaderSampler@@@@QAEPAUShaderSampler@@XZ PROC ; List<ShaderSampler>::CreateNew, COMDAT
; _this$ = ecx

; 346  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 347  :         SetSize(num+1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSize@?$List@UShaderSampler@@@@QAEHI@Z ; List<ShaderSampler>::SetSize

; 348  : 
; 349  :         T *value = &array[num-1];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	imul	ecx, eax, 12
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR _value$[ebp], ecx

; 350  : 
; 351  :         return value;

	mov	eax, DWORD PTR _value$[ebp]

; 352  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?CreateNew@?$List@UShaderSampler@@@@QAEPAUShaderSampler@@XZ ENDP ; List<ShaderSampler>::CreateNew
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?CreateNew@?$List@UShaderParam@@@@QAEPAUShaderParam@@XZ
_TEXT	SEGMENT
_value$ = -8						; size = 4
_this$ = -4						; size = 4
?CreateNew@?$List@UShaderParam@@@@QAEPAUShaderParam@@XZ PROC ; List<ShaderParam>::CreateNew, COMDAT
; _this$ = ecx

; 346  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 347  :         SetSize(num+1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSize@?$List@UShaderParam@@@@QAEHI@Z	; List<ShaderParam>::SetSize

; 348  : 
; 349  :         T *value = &array[num-1];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	imul	ecx, eax, 44
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR _value$[ebp], ecx

; 350  : 
; 351  :         return value;

	mov	eax, DWORD PTR _value$[ebp]

; 352  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?CreateNew@?$List@UShaderParam@@@@QAEPAUShaderParam@@XZ ENDP ; List<ShaderParam>::CreateNew
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??6?$List@UD3D10_INPUT_ELEMENT_DESC@@@@QAEAAV0@ABUD3D10_INPUT_ELEMENT_DESC@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_val$ = 8						; size = 4
??6?$List@UD3D10_INPUT_ELEMENT_DESC@@@@QAEAAV0@ABUD3D10_INPUT_ELEMENT_DESC@@@Z PROC ; List<D3D10_INPUT_ELEMENT_DESC>::operator<<, COMDAT
; _this$ = ecx

; 366  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 367  :         Add(val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Add@?$List@UD3D10_INPUT_ELEMENT_DESC@@@@QAEIABUD3D10_INPUT_ELEMENT_DESC@@@Z ; List<D3D10_INPUT_ELEMENT_DESC>::Add

; 368  :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 369  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??6?$List@UD3D10_INPUT_ELEMENT_DESC@@@@QAEAAV0@ABUD3D10_INPUT_ELEMENT_DESC@@@Z ENDP ; List<D3D10_INPUT_ELEMENT_DESC>::operator<<
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??A?$List@UD3D10_INPUT_ELEMENT_DESC@@@@QAEAAUD3D10_INPUT_ELEMENT_DESC@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$List@UD3D10_INPUT_ELEMENT_DESC@@@@QAEAAUD3D10_INPUT_ELEMENT_DESC@@I@Z PROC ; List<D3D10_INPUT_ELEMENT_DESC>::operator[], COMDAT
; _this$ = ecx

; 379  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  :         assert(index < num);
; 381  :         if(index >= num) {DumpError(TEXT("Out of range!  List<%S>::operator[](%d)"), typeid(T).name(), index); return array[0];}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN1@operator
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	push	OFFSET ?__type_info_root_node@@3U__type_info_node@@A ; __type_info_root_node
	mov	ecx, OFFSET ??_R0?AUD3D10_INPUT_ELEMENT_DESC@@@8
	call	?name@type_info@@QBEPBDPAU__type_info_node@@@Z ; type_info::name
	push	eax
	push	OFFSET ??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp_?DumpError@@YAXPB_WZZ
	mov	eax, 28					; 0000001cH
	imul	eax, eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN3@operator
$LN1@operator:

; 382  :         return array[index];

	imul	eax, DWORD PTR _index$[ebp], 28
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx]
$LN3@operator:

; 383  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@UD3D10_INPUT_ELEMENT_DESC@@@@QAEAAUD3D10_INPUT_ELEMENT_DESC@@I@Z ENDP ; List<D3D10_INPUT_ELEMENT_DESC>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?SetSize@?$List@UShaderSampler@@@@QAEHI@Z
_TEXT	SEGMENT
_bClear$ = -16						; size = 4
_oldNum$ = -12						; size = 4
tv70 = -8						; size = 4
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?SetSize@?$List@UShaderSampler@@@@QAEHI@Z PROC		; List<ShaderSampler>::SetSize, COMDAT
; _this$ = ecx

; 205  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 206  :         if(num == n)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _n$[ebp]
	jne	SHORT $LN4@SetSize

; 207  :             return FALSE;

	xor	eax, eax
	jmp	$LN5@SetSize
	jmp	SHORT $LN3@SetSize
$LN4@SetSize:

; 208  :         else if(!n)

	cmp	DWORD PTR _n$[ebp], 0
	jne	SHORT $LN3@SetSize

; 209  :         {
; 210  :             Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@UShaderSampler@@@@QAEXXZ	; List<ShaderSampler>::Clear

; 211  :             return TRUE;

	mov	eax, 1
	jmp	$LN5@SetSize
$LN3@SetSize:

; 212  :         }
; 213  : 
; 214  :         BOOL bClear=(n>num);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jbe	SHORT $LN7@SetSize
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN8@SetSize
$LN7@SetSize:
	mov	DWORD PTR tv70[ebp], 0
$LN8@SetSize:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _bClear$[ebp], ecx

; 215  :         UINT oldNum=num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _oldNum$[ebp], eax

; 216  : 
; 217  :         num = n;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 218  :         array = (T*)ReAllocate(array, sizeof(T)*num);

	mov	eax, DWORD PTR _this$[ebp]
	imul	ecx, DWORD PTR [eax+4], 12
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 219  : 
; 220  :         if(bClear)

	cmp	DWORD PTR _bClear$[ebp], 0
	je	SHORT $LN1@SetSize

; 221  :             zero(&array[oldNum], sizeof(T)*(num-oldNum));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, DWORD PTR _oldNum$[ebp]
	imul	ecx, eax, 12
	push	ecx
	imul	edx, DWORD PTR _oldNum$[ebp], 12
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax]
	push	edx
	call	?zero@@YGXPAXI@Z			; zero
$LN1@SetSize:

; 222  : 
; 223  :         return TRUE;

	mov	eax, 1
$LN5@SetSize:

; 224  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetSize@?$List@UShaderSampler@@@@QAEHI@Z ENDP		; List<ShaderSampler>::SetSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?SetSize@?$List@UShaderParam@@@@QAEHI@Z
_TEXT	SEGMENT
_bClear$ = -16						; size = 4
_oldNum$ = -12						; size = 4
tv70 = -8						; size = 4
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?SetSize@?$List@UShaderParam@@@@QAEHI@Z PROC		; List<ShaderParam>::SetSize, COMDAT
; _this$ = ecx

; 205  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 206  :         if(num == n)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _n$[ebp]
	jne	SHORT $LN4@SetSize

; 207  :             return FALSE;

	xor	eax, eax
	jmp	$LN5@SetSize
	jmp	SHORT $LN3@SetSize
$LN4@SetSize:

; 208  :         else if(!n)

	cmp	DWORD PTR _n$[ebp], 0
	jne	SHORT $LN3@SetSize

; 209  :         {
; 210  :             Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@UShaderParam@@@@QAEXXZ	; List<ShaderParam>::Clear

; 211  :             return TRUE;

	mov	eax, 1
	jmp	$LN5@SetSize
$LN3@SetSize:

; 212  :         }
; 213  : 
; 214  :         BOOL bClear=(n>num);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jbe	SHORT $LN7@SetSize
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN8@SetSize
$LN7@SetSize:
	mov	DWORD PTR tv70[ebp], 0
$LN8@SetSize:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _bClear$[ebp], ecx

; 215  :         UINT oldNum=num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _oldNum$[ebp], eax

; 216  : 
; 217  :         num = n;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 218  :         array = (T*)ReAllocate(array, sizeof(T)*num);

	mov	eax, DWORD PTR _this$[ebp]
	imul	ecx, DWORD PTR [eax+4], 44
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 219  : 
; 220  :         if(bClear)

	cmp	DWORD PTR _bClear$[ebp], 0
	je	SHORT $LN1@SetSize

; 221  :             zero(&array[oldNum], sizeof(T)*(num-oldNum));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, DWORD PTR _oldNum$[ebp]
	imul	ecx, eax, 44
	push	ecx
	imul	edx, DWORD PTR _oldNum$[ebp], 44
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax]
	push	edx
	call	?zero@@YGXPAXI@Z			; zero
$LN1@SetSize:

; 222  : 
; 223  :         return TRUE;

	mov	eax, 1
$LN5@SetSize:

; 224  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetSize@?$List@UShaderParam@@@@QAEHI@Z ENDP		; List<ShaderParam>::SetSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Add@?$List@UD3D10_INPUT_ELEMENT_DESC@@@@QAEIABUD3D10_INPUT_ELEMENT_DESC@@@Z
_TEXT	SEGMENT
tv73 = -8						; size = 4
_this$ = -4						; size = 4
_val$ = 8						; size = 4
?Add@?$List@UD3D10_INPUT_ELEMENT_DESC@@@@QAEIABUD3D10_INPUT_ELEMENT_DESC@@@Z PROC ; List<D3D10_INPUT_ELEMENT_DESC>::Add, COMDAT
; _this$ = ecx

; 45   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 46   :         array = (T*)ReAllocate(array, sizeof(T)*++num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	DWORD PTR tv73[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR [edx+4], eax
	imul	ecx, DWORD PTR tv73[ebp], 28
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 47   :         mcpy(&array[(num-1)], (void*)&val, sizeof(T));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	imul	ecx, eax, 28
	mov	edx, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR [edx]
	add	edi, ecx
	mov	ecx, 7
	mov	esi, DWORD PTR _val$[ebp]
	rep movsd

; 48   :         return num-1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, 1

; 49   :     }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?Add@?$List@UD3D10_INPUT_ELEMENT_DESC@@@@QAEIABUD3D10_INPUT_ELEMENT_DESC@@@Z ENDP ; List<D3D10_INPUT_ELEMENT_DESC>::Add
_TEXT	ENDS
END

; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

	TITLE	F:\songmm_moon_stone_obs\OBS\Source\Encoder_AAC.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_1DC@BMDOOPIA@?$AAa?$AAa?$AAc?$AA?5?$AAc?$AAo?$AAn?$AAf?$AAi?$AAg?$AAu?$AAr?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?$AA@ ; `string'
PUBLIC	??_C@_1FG@KNBPKHHL@?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9@ ; `string'
PUBLIC	??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@		; `string'
PUBLIC	??_C@_1CC@JAIPNHFF@?$AAa?$AAa?$AAc?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AA?5?$AAe?$AAr?$AAr?$AAo?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_17DCEPMMPP@?$AAA?$AAA?$AAC?$AA?$AA@	; `string'
PUBLIC	??_C@_1CI@JHOJOCIM@?$AAA?$AAu?$AAd?$AAi?$AAo?$AA?5?$AAE?$AAn?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA?3?$AA?5?$AAA?$AAA?$AAC?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CA@CBPMNIMK@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAb?$AAi?$AAt?$AAr?$AAa?$AAt?$AAe?$AA?3?$AA?5?$AA?$AA@ ; `string'
PUBLIC	??_C@_1FK@OOEEKAAM@?$AAL?$AAi?$AAs?$AAt?$AA?3?$AA?3?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AAR?$AAa?$AAn?$AAg?$AAe?$AA?3?$AA?5?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAr?$AAa?$AAn?$AAg@ ; `string'
PUBLIC	??_R3AudioEncoder@@8				; AudioEncoder::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2AACEncoder@@8				; AACEncoder::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@AudioEncoder@@8			; AudioEncoder::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@AACEncoder@@8			; AACEncoder::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVAACEncoder@@@8				; AACEncoder `RTTI Type Descriptor'
PUBLIC	??_R0?AVAudioEncoder@@@8			; AudioEncoder `RTTI Type Descriptor'
PUBLIC	??_R4AACEncoder@@6B@				; AACEncoder::`RTTI Complete Object Locator'
PUBLIC	??_7AudioEncoder@@6B@				; AudioEncoder::`vftable'
PUBLIC	??_R0E@8					; unsigned char `RTTI Type Descriptor'
PUBLIC	??_R0_K@8					; unsigned __int64 `RTTI Type Descriptor'
PUBLIC	??_R3AACEncoder@@8				; AACEncoder::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2AudioEncoder@@8				; AudioEncoder::`RTTI Base Class Array'
PUBLIC	??_7AACEncoder@@6B@				; AACEncoder::`vftable'
PUBLIC	??_R4AudioEncoder@@6B@				; AudioEncoder::`RTTI Complete Object Locator'
EXTRN	_faacEncOpen@16:PROC
EXTRN	_faacEncSetConfiguration@8:PROC
EXTRN	_faacEncEncode@20:PROC
EXTRN	_faacEncGetCurrentConfiguration@4:PROC
EXTRN	_faacEncGetDecoderSpecificInfo@12:PROC
EXTRN	_free:PROC
EXTRN	_faacEncClose@4:PROC
;	COMDAT ??_R4AudioEncoder@@6B@
rdata$r	SEGMENT
??_R4AudioEncoder@@6B@ DD 00H				; AudioEncoder::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVAudioEncoder@@@8
	DD	FLAT:??_R3AudioEncoder@@8
rdata$r	ENDS
;	COMDAT ??_7AACEncoder@@6B@
CONST	SEGMENT
??_7AACEncoder@@6B@ DD FLAT:??_R4AACEncoder@@6B@	; AACEncoder::`vftable'
	DD	FLAT:?Encode@AACEncoder@@UAE_NPAMIAAUDataPacket@@AA_K@Z
	DD	FLAT:?GetHeaders@AACEncoder@@UAEXAAUDataPacket@@@Z
	DD	FLAT:??_EAACEncoder@@UAEPAXI@Z
	DD	FLAT:?GetFrameSize@AACEncoder@@UBEIXZ
	DD	FLAT:?GetBitRate@AACEncoder@@UBEHXZ
	DD	FLAT:?GetCodec@AACEncoder@@UBEPB_WXZ
	DD	FLAT:?GetInfoString@AACEncoder@@UBE?AVString@@XZ
CONST	ENDS
;	COMDAT ??_R2AudioEncoder@@8
rdata$r	SEGMENT
??_R2AudioEncoder@@8 DD FLAT:??_R1A@?0A@EA@AudioEncoder@@8 ; AudioEncoder::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3AACEncoder@@8
rdata$r	SEGMENT
??_R3AACEncoder@@8 DD 00H				; AACEncoder::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2AACEncoder@@8
rdata$r	ENDS
;	COMDAT ??_R0_K@8
data$r	SEGMENT
??_R0_K@8 DD	FLAT:??_7type_info@@6B@			; unsigned __int64 `RTTI Type Descriptor'
	DD	00H
	DB	'._K', 00H
data$r	ENDS
;	COMDAT ??_R0E@8
data$r	SEGMENT
??_R0E@8 DD	FLAT:??_7type_info@@6B@			; unsigned char `RTTI Type Descriptor'
	DD	00H
	DB	'.E', 00H
data$r	ENDS
;	COMDAT ??_7AudioEncoder@@6B@
CONST	SEGMENT
??_7AudioEncoder@@6B@ DD FLAT:??_R4AudioEncoder@@6B@	; AudioEncoder::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:??_EAudioEncoder@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_R4AACEncoder@@6B@
rdata$r	SEGMENT
??_R4AACEncoder@@6B@ DD 00H				; AACEncoder::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVAACEncoder@@@8
	DD	FLAT:??_R3AACEncoder@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVAudioEncoder@@@8
data$r	SEGMENT
??_R0?AVAudioEncoder@@@8 DD FLAT:??_7type_info@@6B@	; AudioEncoder `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVAudioEncoder@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AVAACEncoder@@@8
data$r	SEGMENT
??_R0?AVAACEncoder@@@8 DD FLAT:??_7type_info@@6B@	; AACEncoder `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVAACEncoder@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@AACEncoder@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@AACEncoder@@8 DD FLAT:??_R0?AVAACEncoder@@@8 ; AACEncoder::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3AACEncoder@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@AudioEncoder@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@AudioEncoder@@8 DD FLAT:??_R0?AVAudioEncoder@@@8 ; AudioEncoder::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3AudioEncoder@@8
rdata$r	ENDS
;	COMDAT ??_R2AACEncoder@@8
rdata$r	SEGMENT
??_R2AACEncoder@@8 DD FLAT:??_R1A@?0A@EA@AACEncoder@@8	; AACEncoder::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@AudioEncoder@@8
rdata$r	ENDS
;	COMDAT ??_R3AudioEncoder@@8
rdata$r	SEGMENT
??_R3AudioEncoder@@8 DD 00H				; AudioEncoder::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2AudioEncoder@@8
rdata$r	ENDS
;	COMDAT ??_C@_1FK@OOEEKAAM@?$AAL?$AAi?$AAs?$AAt?$AA?3?$AA?3?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AAR?$AAa?$AAn?$AAg?$AAe?$AA?3?$AA?5?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAr?$AAa?$AAn?$AAg@
CONST	SEGMENT
??_C@_1FK@OOEEKAAM@?$AAL?$AAi?$AAs?$AAt?$AA?3?$AA?3?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AAR?$AAa?$AAn?$AAg?$AAe?$AA?3?$AA?5?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAr?$AAa?$AAn?$AAg@ DB 'L'
	DB	00H, 'i', 00H, 's', 00H, 't', 00H, ':', 00H, ':', 00H, 'R', 00H
	DB	'e', 00H, 'm', 00H, 'o', 00H, 'v', 00H, 'e', 00H, 'R', 00H, 'a'
	DB	00H, 'n', 00H, 'g', 00H, 'e', 00H, ':', 00H, ' ', 00H, ' ', 00H
	DB	'I', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd'
	DB	00H, ' ', 00H, 'r', 00H, 'a', 00H, 'n', 00H, 'g', 00H, 'e', 00H
	DB	' ', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H, 'i', 00H, 'f'
	DB	00H, 'i', 00H, 'e', 00H, 'd', 00H, '.', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@CBPMNIMK@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAb?$AAi?$AAt?$AAr?$AAa?$AAt?$AAe?$AA?3?$AA?5?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@CBPMNIMK@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAb?$AAi?$AAt?$AAr?$AAa?$AAt?$AAe?$AA?3?$AA?5?$AA?$AA@ DB 0dH
	DB	00H, 0aH, 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'b', 00H
	DB	'i', 00H, 't', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'e', 00H, ':'
	DB	00H, ' ', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@JHOJOCIM@?$AAA?$AAu?$AAd?$AAi?$AAo?$AA?5?$AAE?$AAn?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA?3?$AA?5?$AAA?$AAA?$AAC?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@JHOJOCIM@?$AAA?$AAu?$AAd?$AAi?$AAo?$AA?5?$AAE?$AAn?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA?3?$AA?5?$AAA?$AAA?$AAC?$AA?$AA@ DB 'A'
	DB	00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, ' ', 00H, 'E', 00H
	DB	'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'i', 00H, 'n', 00H, 'g'
	DB	00H, ':', 00H, ' ', 00H, 'A', 00H, 'A', 00H, 'C', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_17DCEPMMPP@?$AAA?$AAA?$AAC?$AA?$AA@
CONST	SEGMENT
??_C@_17DCEPMMPP@?$AAA?$AAA?$AAC?$AA?$AA@ DB 'A', 00H, 'A', 00H, 'C', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@JAIPNHFF@?$AAa?$AAa?$AAc?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AA?5?$AAe?$AAr?$AAr?$AAo?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@JAIPNHFF@?$AAa?$AAa?$AAc?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AA?5?$AAe?$AAr?$AAr?$AAo?$AAr?$AA?$AA@ DB 'a'
	DB	00H, 'a', 00H, 'c', 00H, ' ', 00H, 'e', 00H, 'n', 00H, 'c', 00H
	DB	'o', 00H, 'd', 00H, 'e', 00H, ' ', 00H, 'e', 00H, 'r', 00H, 'r'
	DB	00H, 'o', 00H, 'r', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ DB '%', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FG@KNBPKHHL@?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9@
CONST	SEGMENT
??_C@_1FG@KNBPKHHL@?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9@ DB '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@BMDOOPIA@?$AAa?$AAa?$AAc?$AA?5?$AAc?$AAo?$AAn?$AAf?$AAi?$AAg?$AAu?$AAr?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@BMDOOPIA@?$AAa?$AAa?$AAc?$AA?5?$AAc?$AAo?$AAn?$AAf?$AAi?$AAg?$AAu?$AAr?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?$AA@ DB 'a'
	DB	00H, 'a', 00H, 'c', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'n', 00H
	DB	'f', 00H, 'i', 00H, 'g', 00H, 'u', 00H, 'r', 00H, 'a', 00H, 't'
	DB	00H, 'i', 00H, 'o', 00H, 'n', 00H, ' ', 00H, 'f', 00H, 'a', 00H
	DB	'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H, 00H, 00H ; `string'
PUBLIC	?Clear@?$List@_K@@QAEXXZ			; List<unsigned __int64>::Clear
PUBLIC	?Add@?$List@_K@@QAEIAB_K@Z			; List<unsigned __int64>::Add
PUBLIC	?Remove@?$List@M@@QAEXI@Z			; List<float>::Remove
PUBLIC	??A?$List@_K@@QAEAA_KI@Z			; List<unsigned __int64>::operator[]
PUBLIC	??6?$List@_K@@QAEAAV0@AB_K@Z			; List<unsigned __int64>::operator<<
PUBLIC	?Remove@?$List@_K@@QAEXI@Z			; List<unsigned __int64>::Remove
PUBLIC	??1?$List@_K@@QAE@XZ				; List<unsigned __int64>::~List<unsigned __int64>
PUBLIC	??0?$List@_K@@QAE@XZ				; List<unsigned __int64>::List<unsigned __int64>
PUBLIC	?SetSize@?$List@M@@QAEHI@Z			; List<float>::SetSize
PUBLIC	?AppendArray@?$List@M@@QAEXPBMI@Z		; List<float>::AppendArray
PUBLIC	?RemoveRange@?$List@M@@QAEXII@Z			; List<float>::RemoveRange
PUBLIC	?Array@?$List@M@@QBEPAMXZ			; List<float>::Array
PUBLIC	??A?$List@E@@QAEAAEI@Z				; List<unsigned char>::operator[]
PUBLIC	?CreateAACEncoder@@YAPAVAudioEncoder@@I@Z	; CreateAACEncoder
PUBLIC	??0AudioEncoder@@QAE@XZ				; AudioEncoder::AudioEncoder
PUBLIC	??_GAACEncoder@@UAEPAXI@Z			; AACEncoder::`scalar deleting destructor'
PUBLIC	?GetInfoString@AACEncoder@@UBE?AVString@@XZ	; AACEncoder::GetInfoString
PUBLIC	?GetCodec@AACEncoder@@UBEPB_WXZ			; AACEncoder::GetCodec
PUBLIC	?GetBitRate@AACEncoder@@UBEHXZ			; AACEncoder::GetBitRate
PUBLIC	?GetHeaders@AACEncoder@@UAEXAAUDataPacket@@@Z	; AACEncoder::GetHeaders
PUBLIC	?GetFrameSize@AACEncoder@@UBEIXZ		; AACEncoder::GetFrameSize
PUBLIC	?Encode@AACEncoder@@UAE_NPAMIAAUDataPacket@@AA_K@Z ; AACEncoder::Encode
PUBLIC	??1AACEncoder@@UAE@XZ				; AACEncoder::~AACEncoder
PUBLIC	??0AACEncoder@@QAE@I@Z				; AACEncoder::AACEncoder
PUBLIC	?NumAudioChannels@OBS@@QBEIXZ			; OBS::NumAudioChannels
PUBLIC	??_GAudioEncoder@@UAEPAXI@Z			; AudioEncoder::`scalar deleting destructor'
PUBLIC	??1AudioEncoder@@UAE@XZ				; AudioEncoder::~AudioEncoder
EXTRN	??_EAACEncoder@@UAEPAXI@Z:PROC			; AACEncoder::`vector deleting destructor'
EXTRN	??_EAudioEncoder@@UAEPAXI@Z:PROC		; AudioEncoder::`vector deleting destructor'
	ALIGN	4

__Tuple_alloc DB 01H DUP (?)
	ALIGN	4

_ignore	DB	01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
	ALIGN	4

_piecewise_construct DB 01H DUP (?)
_BSS	ENDS
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
_ignore$initializer$ DD FLAT:??__Eignore@std@@YAXXZ
__Tuple_alloc$initializer$ DD FLAT:??__E_Tuple_alloc@std@@YAXXZ
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 70   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3451 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\tuple
;	COMDAT ??__Eignore@std@@YAXXZ
text$di	SEGMENT
??__Eignore@std@@YAXXZ PROC				; std::`dynamic initializer for 'ignore'', COMDAT

; 59   : const _Ignore ignore;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET _ignore
	call	??0_Ignore@std@@QAE@XZ			; std::_Ignore::_Ignore
	pop	ebp
	ret	0
??__Eignore@std@@YAXXZ ENDP				; std::`dynamic initializer for 'ignore''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\tuple
;	COMDAT ??__E_Tuple_alloc@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__E_Tuple_alloc@std@@YAXXZ PROC			; std::`dynamic initializer for '_Tuple_alloc'', COMDAT

; 66   : const _Tuple_alloc_t _Tuple_alloc = _Tuple_alloc_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__E_Tuple_alloc@std@@YAXXZ ENDP			; std::`dynamic initializer for '_Tuple_alloc''
text$di	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ??1AudioEncoder@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1AudioEncoder@@UAE@XZ PROC				; AudioEncoder::~AudioEncoder, COMDAT
; _this$ = ecx

; 163  :     virtual ~AudioEncoder() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7AudioEncoder@@6B@
	mov	esp, ebp
	pop	ebp
	ret	0
??1AudioEncoder@@UAE@XZ ENDP				; AudioEncoder::~AudioEncoder
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GAudioEncoder@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GAudioEncoder@@UAEPAXI@Z PROC			; AudioEncoder::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1AudioEncoder@@UAE@XZ			; AudioEncoder::~AudioEncoder
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GAudioEncoder@@UAEPAXI@Z ENDP			; AudioEncoder::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ?NumAudioChannels@OBS@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?NumAudioChannels@OBS@@QBEIXZ PROC			; OBS::NumAudioChannels, COMDAT
; _this$ = ecx

; 1199 :     inline UINT NumAudioChannels() const {return audioChannels;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+132]
	mov	esp, ebp
	pop	ebp
	ret	0
?NumAudioChannels@OBS@@QBEIXZ ENDP			; OBS::NumAudioChannels
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_aac.cpp
;	COMDAT ??0AACEncoder@@QAE@I@Z
_TEXT	SEGMENT
$T1 = -28						; size = 8
_len$ = -20						; size = 4
_ret$ = -16						; size = 4
_tempHeader$ = -12					; size = 4
_config$ = -8						; size = 4
_this$ = -4						; size = 4
_bitRate$ = 8						; size = 4
??0AACEncoder@@QAE@I@Z PROC				; AACEncoder::AACEncoder, COMDAT
; _this$ = ecx

; 45   :     AACEncoder(UINT bitRate)

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0AudioEncoder@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7AACEncoder@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??0?$List@M@@QAE@XZ			; List<float>::List<float>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??0?$List@E@@QAE@XZ			; List<unsigned char>::List<unsigned char>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	??0?$List@E@@QAE@XZ			; List<unsigned char>::List<unsigned char>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??0?$List@_K@@QAE@XZ			; List<unsigned __int64>::List<unsigned __int64>

; 46   :     {
; 47   :         curBitRate = bitRate;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _bitRate$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 48   : 
; 49   :         faac = faacEncOpen(App->GetSampleRateHz(), App->NumAudioChannels(), &numReadSamples, &outputSize);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?NumAudioChannels@OBS@@QBEIXZ		; OBS::NumAudioChannels
	push	eax
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?GetSampleRateHz@OBS@@QBEIXZ		; OBS::GetSampleRateHz
	push	eax
	call	_faacEncOpen@16
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], eax

; 50   : 
; 51   :         //Log(TEXT("numReadSamples: %d"), numReadSamples);
; 52   :         aacBuffer.SetSize(outputSize+2);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 2
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	?SetSize@?$List@E@@QAEHI@Z		; List<unsigned char>::SetSize

; 53   :         aacBuffer[0] = 0xaf;

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??A?$List@E@@QAEAAEI@Z			; List<unsigned char>::operator[]
	mov	BYTE PTR [eax], 175			; 000000afH

; 54   :         aacBuffer[1] = 0x1;

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??A?$List@E@@QAEAAEI@Z			; List<unsigned char>::operator[]
	mov	BYTE PTR [eax], 1

; 55   : 
; 56   :         faacEncConfigurationPtr config = faacEncGetCurrentConfiguration(faac);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	_faacEncGetCurrentConfiguration@4
	mov	DWORD PTR _config$[ebp], eax

; 57   :         config->bitRate = (bitRate*1000)/App->NumAudioChannels();

	imul	esi, DWORD PTR _bitRate$[ebp], 1000
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?NumAudioChannels@OBS@@QBEIXZ		; OBS::NumAudioChannels
	mov	ecx, eax
	mov	eax, esi
	xor	edx, edx
	div	ecx
	mov	edx, DWORD PTR _config$[ebp]
	mov	DWORD PTR [edx+32], eax

; 58   :         config->quantqual = 100;

	mov	eax, DWORD PTR _config$[ebp]
	mov	DWORD PTR [eax+40], 100			; 00000064H

; 59   :         config->inputFormat = FAAC_INPUT_FLOAT;

	mov	ecx, DWORD PTR _config$[ebp]
	mov	DWORD PTR [ecx+56], 4

; 60   :         config->mpegVersion = MPEG4;

	mov	edx, DWORD PTR _config$[ebp]
	mov	DWORD PTR [edx+12], 0

; 61   :         config->aacObjectType = LOW;

	mov	eax, DWORD PTR _config$[ebp]
	mov	DWORD PTR [eax+16], 2

; 62   :         config->useLfe = 0;

	mov	ecx, DWORD PTR _config$[ebp]
	mov	DWORD PTR [ecx+24], 0

; 63   :         config->outputFormat = 0;

	mov	edx, DWORD PTR _config$[ebp]
	mov	DWORD PTR [edx+44], 0

; 64   : 
; 65   :         int ret = faacEncSetConfiguration(faac, config);

	mov	eax, DWORD PTR _config$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	_faacEncSetConfiguration@8
	mov	DWORD PTR _ret$[ebp], eax

; 66   :         if(!ret)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN1@AACEncoder

; 67   :             CrashError(TEXT("aac configuration failed"));

	push	OFFSET ??_C@_1DC@BMDOOPIA@?$AAa?$AAa?$AAc?$AA?5?$AAc?$AAo?$AAn?$AAf?$AAi?$AAg?$AAu?$AAr?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?$AA@
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ
$LN1@AACEncoder:

; 68   : 
; 69   :         BYTE *tempHeader;
; 70   :         DWORD len;
; 71   : 
; 72   :         header.SetSize(2);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	?SetSize@?$List@E@@QAEHI@Z		; List<unsigned char>::SetSize

; 73   :         header[0] = 0xaf;

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	??A?$List@E@@QAEAAEI@Z			; List<unsigned char>::operator[]
	mov	BYTE PTR [eax], 175			; 000000afH

; 74   :         header[1] = 0x00;

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	??A?$List@E@@QAEAAEI@Z			; List<unsigned char>::operator[]
	mov	BYTE PTR [eax], 0

; 75   : 
; 76   :         faacEncGetDecoderSpecificInfo(faac, &tempHeader, &len);

	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tempHeader$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	_faacEncGetDecoderSpecificInfo@12

; 77   :         header.AppendArray(tempHeader, len);

	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tempHeader$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	?AppendArray@?$List@E@@QAEXPBEI@Z	; List<unsigned char>::AppendArray

; 78   :         free(tempHeader);

	mov	eax, DWORD PTR _tempHeader$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 79   : 
; 80   :         bFirstPacket = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+8], 1

; 81   :         bFirstFrame  = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+64], 1

; 82   : 
; 83   :         Log(TEXT("------------------------------------------"));

	push	OFFSET ??_C@_1FG@KNBPKHHL@?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9@
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 4

; 84   :         Log(TEXT("%s"), GetInfoString().Array());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetInfoString@AACEncoder@@UBE?AVString@@XZ ; AACEncoder::GetInfoString
	mov	ecx, eax
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 85   :     }

	mov	eax, DWORD PTR _this$[ebp]
$LN3@AACEncoder:
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??0AACEncoder@@QAE@I@Z ENDP				; AACEncoder::AACEncoder
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_aac.cpp
;	COMDAT ??1AACEncoder@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1AACEncoder@@UAE@XZ PROC				; AACEncoder::~AACEncoder, COMDAT
; _this$ = ecx

; 88   :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7AACEncoder@@6B@

; 89   :         faacEncClose(faac);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	_faacEncClose@4

; 90   :     }

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??1?$List@_K@@QAE@XZ			; List<unsigned __int64>::~List<unsigned __int64>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	??1?$List@E@@QAE@XZ			; List<unsigned char>::~List<unsigned char>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??1?$List@E@@QAE@XZ			; List<unsigned char>::~List<unsigned char>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??1?$List@M@@QAE@XZ			; List<float>::~List<float>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1AudioEncoder@@UAE@XZ			; AudioEncoder::~AudioEncoder
	mov	esp, ebp
	pop	ebp
	ret	0
??1AACEncoder@@UAE@XZ ENDP				; AACEncoder::~AACEncoder
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_aac.cpp
;	COMDAT ?Encode@AACEncoder@@UAE_NPAMIAAUDataPacket@@AA_K@Z
_TEXT	SEGMENT
$T1 = -128						; size = 16
$T2 = -112						; size = 16
$T3 = -96						; size = 16
_curTimestamp$ = -72					; size = 8
_lastSampleSize$ = -60					; size = 4
tv343 = -56						; size = 4
tv232 = -52						; size = 4
_alignedFloats$4 = -48					; size = 4
_pos$5 = -44						; size = 4
_inputBufferPos$6 = -40					; size = 4
_pos$7 = -36						; size = 4
_numInputSamples$ = -32					; size = 4
_i$8 = -28						; size = 4
_i$9 = -24						; size = 4
_floatsLeft$10 = -20					; size = 4
_i$11 = -16						; size = 4
_ret$ = -12						; size = 4
_inputTemp$12 = -8					; size = 4
_this$ = -4						; size = 4
_input$ = 8						; size = 4
_numInputFrames$ = 12					; size = 4
_packet$ = 16						; size = 4
_timestamp$ = 20					; size = 4
?Encode@AACEncoder@@UAE_NPAMIAAUDataPacket@@AA_K@Z PROC	; AACEncoder::Encode, COMDAT
; _this$ = ecx

; 93   :     {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 94   :         if(bFirstFrame)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+64]
	test	ecx, ecx
	je	SHORT $LN20@Encode

; 95   :         {
; 96   :             curEncodeTimestamp = timestamp;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _timestamp$[ebx]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+56], ecx
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+60], eax

; 97   :             bFirstFrame = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+64], 0
$LN20@Encode:

; 98   :         }
; 99   : 
; 100  :         //------------------------------------------------
; 101  : 
; 102  :         QWORD curTimestamp = timestamp;

	mov	edx, DWORD PTR _timestamp$[ebx]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _curTimestamp$[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _curTimestamp$[ebp+4], ecx

; 103  : 
; 104  :         UINT lastSampleSize = inputBuffer.Num();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?Num@?$List@M@@QBEIXZ			; List<float>::Num
	mov	DWORD PTR _lastSampleSize$[ebp], eax

; 105  :         UINT numInputSamples = numInputFrames*App->NumAudioChannels();

	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?NumAudioChannels@OBS@@QBEIXZ		; OBS::NumAudioChannels
	imul	eax, DWORD PTR _numInputFrames$[ebx]
	mov	DWORD PTR _numInputSamples$[ebp], eax

; 106  :         if (App->NumAudioChannels() == 2)

	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?NumAudioChannels@OBS@@QBEIXZ		; OBS::NumAudioChannels
	cmp	eax, 2
	jne	SHORT $LN19@Encode

; 107  :                 inputBuffer.AppendArray(input, numInputSamples);

	mov	edx, DWORD PTR _numInputSamples$[ebp]
	push	edx
	mov	eax, DWORD PTR _input$[ebx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?AppendArray@?$List@M@@QAEXPBMI@Z	; List<float>::AppendArray

; 108  :         else

	jmp	$LN15@Encode
$LN19@Encode:

; 109  :         {
; 110  :             UINT inputBufferPos = inputBuffer.Num();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?Num@?$List@M@@QBEIXZ			; List<float>::Num
	mov	DWORD PTR _inputBufferPos$6[ebp], eax

; 111  :             inputBuffer.SetSize(inputBufferPos + numInputSamples);

	mov	ecx, DWORD PTR _inputBufferPos$6[ebp]
	add	ecx, DWORD PTR _numInputSamples$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?SetSize@?$List@M@@QAEHI@Z		; List<float>::SetSize

; 112  : 
; 113  :             for (UINT i = 0; i < numInputSamples; i++)

	mov	DWORD PTR _i$11[ebp], 0
	jmp	SHORT $LN17@Encode
$LN16@Encode:
	mov	edx, DWORD PTR _i$11[ebp]
	add	edx, 1
	mov	DWORD PTR _i$11[ebp], edx
$LN17@Encode:
	mov	eax, DWORD PTR _i$11[ebp]
	cmp	eax, DWORD PTR _numInputSamples$[ebp]
	jae	SHORT $LN15@Encode

; 114  :             {
; 115  :                 UINT pos = i * 2;

	mov	ecx, DWORD PTR _i$11[ebp]
	shl	ecx, 1
	mov	DWORD PTR _pos$7[ebp], ecx

; 116  :                 inputBuffer[inputBufferPos + i] = (input[pos] + input[pos + 1]) * 0.5f;

	mov	edx, DWORD PTR _pos$7[ebp]
	mov	eax, DWORD PTR _input$[ebx]
	mov	ecx, DWORD PTR _pos$7[ebp]
	mov	esi, DWORD PTR _input$[ebx]
	movss	xmm0, DWORD PTR [eax+edx*4]
	addss	xmm0, DWORD PTR [esi+ecx*4+4]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	edx, DWORD PTR _inputBufferPos$6[ebp]
	add	edx, DWORD PTR _i$11[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	movss	DWORD PTR tv343[ebp], xmm0
	call	??A?$List@M@@QAEAAMI@Z			; List<float>::operator[]
	movss	xmm0, DWORD PTR tv343[ebp]
	movss	DWORD PTR [eax], xmm0

; 117  :             }

	jmp	SHORT $LN16@Encode
$LN15@Encode:

; 118  :         }
; 119  : 
; 120  :         int ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 121  : 
; 122  :         if(inputBuffer.Num() >= numReadSamples)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?Num@?$List@M@@QBEIXZ			; List<float>::Num
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [ecx+16]
	jb	$LN14@Encode

; 123  :         {
; 124  :             //now we have to upscale the floats.  fortunately we almost always have SSE
; 125  :             UINT floatsLeft  = numReadSamples;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _floatsLeft$10[ebp], eax

; 126  :             float *inputTemp = inputBuffer.Array();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?Array@?$List@M@@QBEPAMXZ		; List<float>::Array
	mov	DWORD PTR _inputTemp$12[ebp], eax

; 127  :             if((UPARAM(inputTemp) & 0xF) == 0)

	mov	ecx, DWORD PTR _inputTemp$12[ebp]
	and	ecx, 15					; 0000000fH
	jne	SHORT $LN13@Encode

; 128  :             {
; 129  :                 UINT alignedFloats = floatsLeft & 0xFFFFFFFC;

	mov	edx, DWORD PTR _floatsLeft$10[ebp]
	and	edx, -4					; fffffffcH
	mov	DWORD PTR _alignedFloats$4[ebp], edx

; 130  : 
; 131  :                 for(UINT i=0; i<alignedFloats; i += 4)

	mov	DWORD PTR _i$8[ebp], 0
	jmp	SHORT $LN12@Encode
$LN11@Encode:
	mov	eax, DWORD PTR _i$8[ebp]
	add	eax, 4
	mov	DWORD PTR _i$8[ebp], eax
$LN12@Encode:
	mov	ecx, DWORD PTR _i$8[ebp]
	cmp	ecx, DWORD PTR _alignedFloats$4[ebp]
	jae	SHORT $LN10@Encode

; 132  :                 {
; 133  :                     float *pos = inputTemp+i;

	mov	edx, DWORD PTR _i$8[ebp]
	mov	eax, DWORD PTR _inputTemp$12[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _pos$5[ebp], ecx

; 134  :                     _mm_store_ps(pos, _mm_mul_ps(_mm_load_ps(pos), _mm_set_ps1(32767.0f)));

	movaps	xmm0, XMMWORD PTR __xmm@46fffe0046fffe0046fffe0046fffe00
	movaps	XMMWORD PTR $T2[ebp], xmm0
	mov	edx, DWORD PTR _pos$5[ebp]
	movaps	xmm0, XMMWORD PTR [edx]
	movaps	XMMWORD PTR $T3[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T3[ebp]
	mulps	xmm0, XMMWORD PTR $T2[ebp]
	movaps	XMMWORD PTR $T1[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T1[ebp]
	mov	eax, DWORD PTR _pos$5[ebp]
	movaps	XMMWORD PTR [eax], xmm0

; 135  :                 }

	jmp	SHORT $LN11@Encode
$LN10@Encode:

; 136  : 
; 137  :                 floatsLeft &= 0x3;

	mov	ecx, DWORD PTR _floatsLeft$10[ebp]
	and	ecx, 3
	mov	DWORD PTR _floatsLeft$10[ebp], ecx

; 138  :                 inputTemp  += alignedFloats;

	mov	edx, DWORD PTR _alignedFloats$4[ebp]
	mov	eax, DWORD PTR _inputTemp$12[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _inputTemp$12[ebp], ecx
$LN13@Encode:

; 139  :             }
; 140  : 
; 141  :             if(floatsLeft)

	cmp	DWORD PTR _floatsLeft$10[ebp], 0
	je	SHORT $LN6@Encode

; 142  :             {
; 143  :                 for(UINT i=0; i<floatsLeft; i++)

	mov	DWORD PTR _i$9[ebp], 0
	jmp	SHORT $LN8@Encode
$LN7@Encode:
	mov	edx, DWORD PTR _i$9[ebp]
	add	edx, 1
	mov	DWORD PTR _i$9[ebp], edx
$LN8@Encode:
	mov	eax, DWORD PTR _i$9[ebp]
	cmp	eax, DWORD PTR _floatsLeft$10[ebp]
	jae	SHORT $LN6@Encode

; 144  :                     inputTemp[i] *= 32767.0f;

	mov	ecx, DWORD PTR _i$9[ebp]
	mov	edx, DWORD PTR _inputTemp$12[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4]
	mulss	xmm0, DWORD PTR __real@46fffe00
	mov	eax, DWORD PTR _i$9[ebp]
	mov	ecx, DWORD PTR _inputTemp$12[ebp]
	movss	DWORD PTR [ecx+eax*4], xmm0
	jmp	SHORT $LN7@Encode
$LN6@Encode:

; 145  :             }
; 146  : 
; 147  :             ret = faacEncEncode(faac, (int32_t*)inputBuffer.Array(), numReadSamples, aacBuffer.Array()+2, outputSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	?Array@?$List@E@@QBEPAEXZ		; List<unsigned char>::Array
	add	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?Array@?$List@M@@QBEPAMXZ		; List<float>::Array
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_faacEncEncode@20
	mov	DWORD PTR _ret$[ebp], eax

; 148  :             if(ret > 0)

	cmp	DWORD PTR _ret$[ebp], 0
	jle	SHORT $LN5@Encode

; 149  :             {
; 150  :                 if(bFirstPacket)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+8]
	test	eax, eax
	je	SHORT $LN4@Encode

; 151  :                 {
; 152  :                     bFirstPacket = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+8], 0

; 153  :                     ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 154  :                 }
; 155  :                 else

	jmp	SHORT $LN3@Encode
$LN4@Encode:

; 156  :                 {
; 157  :                     packet.lpPacket = aacBuffer.Array();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	?Array@?$List@E@@QBEPAEXZ		; List<unsigned char>::Array
	mov	edx, DWORD PTR _packet$[ebx]
	mov	DWORD PTR [edx], eax

; 158  :                     packet.size     = ret+2;

	mov	eax, DWORD PTR _ret$[ebp]
	add	eax, 2
	mov	ecx, DWORD PTR _packet$[ebx]
	mov	DWORD PTR [ecx+4], eax

; 159  : 
; 160  :                     timestamp = bufferedTimestamps[0];

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??A?$List@_K@@QAEAA_KI@Z		; List<unsigned __int64>::operator[]
	mov	edx, DWORD PTR _timestamp$[ebx]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], eax

; 161  :                     bufferedTimestamps.Remove(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	?Remove@?$List@_K@@QAEXI@Z		; List<unsigned __int64>::Remove
$LN3@Encode:

; 162  :                 }

	jmp	SHORT $LN1@Encode
$LN5@Encode:

; 163  :             }
; 164  :             else if(ret < 0)

	cmp	DWORD PTR _ret$[ebp], 0
	jge	SHORT $LN1@Encode

; 165  :                 AppWarning(TEXT("aac encode error"));

	push	OFFSET ??_C@_1CC@JAIPNHFF@?$AAa?$AAa?$AAc?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AA?5?$AAe?$AAr?$AAr?$AAo?$AAr?$AA?$AA@
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 4
$LN1@Encode:

; 166  : 
; 167  :             inputBuffer.RemoveRange(0, numReadSamples);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?RemoveRange@?$List@M@@QAEXII@Z		; List<float>::RemoveRange

; 168  : 
; 169  :             bufferedTimestamps << curEncodeTimestamp;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 56					; 00000038H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??6?$List@_K@@QAEAAV0@AB_K@Z		; List<unsigned __int64>::operator<<

; 170  :             curEncodeTimestamp = curTimestamp + (((numReadSamples-lastSampleSize)/App->NumAudioChannels())*1000/App->GetSampleRateHz());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [ecx+16]
	sub	esi, DWORD PTR _lastSampleSize$[ebp]
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?NumAudioChannels@OBS@@QBEIXZ		; OBS::NumAudioChannels
	mov	ecx, eax
	mov	eax, esi
	xor	edx, edx
	div	ecx
	imul	esi, eax, 1000
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?GetSampleRateHz@OBS@@QBEIXZ		; OBS::GetSampleRateHz
	mov	ecx, eax
	mov	eax, esi
	xor	edx, edx
	div	ecx
	xor	edx, edx
	add	eax, DWORD PTR _curTimestamp$[ebp]
	adc	edx, DWORD PTR _curTimestamp$[ebp+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], eax
	mov	DWORD PTR [ecx+60], edx
$LN14@Encode:

; 171  :         }
; 172  : 
; 173  :         return ret > 0;

	cmp	DWORD PTR _ret$[ebp], 0
	jle	SHORT $LN23@Encode
	mov	DWORD PTR tv232[ebp], 1
	jmp	SHORT $LN24@Encode
$LN23@Encode:
	mov	DWORD PTR tv232[ebp], 0
$LN24@Encode:
	mov	al, BYTE PTR tv232[ebp]

; 174  :     }

	pop	esi
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	16					; 00000010H
?Encode@AACEncoder@@UAE_NPAMIAAUDataPacket@@AA_K@Z ENDP	; AACEncoder::Encode
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_aac.cpp
;	COMDAT ?GetFrameSize@AACEncoder@@UBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFrameSize@AACEncoder@@UBEIXZ PROC			; AACEncoder::GetFrameSize, COMDAT
; _this$ = ecx

; 177  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 178  :         return 1024;

	mov	eax, 1024				; 00000400H

; 179  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFrameSize@AACEncoder@@UBEIXZ ENDP			; AACEncoder::GetFrameSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_aac.cpp
;	COMDAT ?GetHeaders@AACEncoder@@UAEXAAUDataPacket@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_packet$ = 8						; size = 4
?GetHeaders@AACEncoder@@UAEXAAUDataPacket@@@Z PROC	; AACEncoder::GetHeaders, COMDAT
; _this$ = ecx

; 182  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 183  :         packet.lpPacket = header.Array();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	?Array@?$List@E@@QBEPAEXZ		; List<unsigned char>::Array
	mov	ecx, DWORD PTR _packet$[ebp]
	mov	DWORD PTR [ecx], eax

; 184  :         packet.size = header.Num();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	?Num@?$List@E@@QBEIXZ			; List<unsigned char>::Num
	mov	edx, DWORD PTR _packet$[ebp]
	mov	DWORD PTR [edx+4], eax

; 185  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetHeaders@AACEncoder@@UAEXAAUDataPacket@@@Z ENDP	; AACEncoder::GetHeaders
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_aac.cpp
;	COMDAT ?GetBitRate@AACEncoder@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBitRate@AACEncoder@@UBEHXZ PROC			; AACEncoder::GetBitRate, COMDAT
; _this$ = ecx

; 187  :     int GetBitRate() const {return curBitRate;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBitRate@AACEncoder@@UBEHXZ ENDP			; AACEncoder::GetBitRate
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_aac.cpp
;	COMDAT ?GetCodec@AACEncoder@@UBEPB_WXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCodec@AACEncoder@@UBEPB_WXZ PROC			; AACEncoder::GetCodec, COMDAT
; _this$ = ecx

; 188  :     CTSTR GetCodec() const {return TEXT("AAC");}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ??_C@_17DCEPMMPP@?$AAA?$AAA?$AAC?$AA?$AA@
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCodec@AACEncoder@@UBEPB_WXZ ENDP			; AACEncoder::GetCodec
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_aac.cpp
;	COMDAT ?GetInfoString@AACEncoder@@UBE?AVString@@XZ
_TEXT	SEGMENT
$T1 = -20						; size = 8
_strInfo$ = -12						; size = 8
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetInfoString@AACEncoder@@UBE?AVString@@XZ PROC	; AACEncoder::GetInfoString, COMDAT
; _this$ = ecx

; 191  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 192  :         String strInfo;

	lea	ecx, DWORD PTR _strInfo$[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 193  :         strInfo << TEXT("Audio Encoding: AAC")  <<
; 194  :                    TEXT("\r\n    bitrate: ") << IntString(curBitRate);

	push	10					; 0000000aH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	DWORD PTR __imp_?IntString@@YA?AVString@@HH@Z
	add	esp, 12					; 0000000cH
	push	eax
	push	OFFSET ??_C@_1CA@CBPMNIMK@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAb?$AAi?$AAt?$AAr?$AAa?$AAt?$AAe?$AA?3?$AA?5?$AA?$AA@
	push	OFFSET ??_C@_1CI@JHOJOCIM@?$AAA?$AAu?$AAd?$AAi?$AAo?$AA?5?$AAE?$AAn?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA?3?$AA?5?$AAA?$AAA?$AAC?$AA?$AA@
	lea	ecx, DWORD PTR _strInfo$[ebp]
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 195  : 
; 196  :         return strInfo;

	lea	eax, DWORD PTR _strInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0String@@QAE@ABV0@@Z
	lea	ecx, DWORD PTR _strInfo$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 197  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetInfoString@AACEncoder@@UBE?AVString@@XZ ENDP	; AACEncoder::GetInfoString
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GAACEncoder@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GAACEncoder@@UAEPAXI@Z PROC				; AACEncoder::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1AACEncoder@@UAE@XZ			; AACEncoder::~AACEncoder
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GAACEncoder@@UAEPAXI@Z ENDP				; AACEncoder::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0AudioEncoder@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0AudioEncoder@@QAE@XZ PROC				; AudioEncoder::AudioEncoder, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7AudioEncoder@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0AudioEncoder@@QAE@XZ ENDP				; AudioEncoder::AudioEncoder
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_aac.cpp
;	COMDAT ?CreateAACEncoder@@YAPAVAudioEncoder@@I@Z
_TEXT	SEGMENT
tv73 = -8						; size = 4
$T1 = -4						; size = 4
_bitRate$ = 8						; size = 4
?CreateAACEncoder@@YAPAVAudioEncoder@@I@Z PROC		; CreateAACEncoder, COMDAT

; 202  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 203  :     return new AACEncoder(bitRate);

	push	72					; 00000048H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN3@CreateAACE
	mov	eax, DWORD PTR _bitRate$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T1[ebp]
	call	??0AACEncoder@@QAE@I@Z			; AACEncoder::AACEncoder
	mov	DWORD PTR tv73[ebp], eax
	jmp	SHORT $LN4@CreateAACE
$LN3@CreateAACE:
	mov	DWORD PTR tv73[ebp], 0
$LN4@CreateAACE:
	mov	eax, DWORD PTR tv73[ebp]

; 204  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CreateAACEncoder@@YAPAVAudioEncoder@@I@Z ENDP		; CreateAACEncoder
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??A?$List@E@@QAEAAEI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$List@E@@QAEAAEI@Z PROC				; List<unsigned char>::operator[], COMDAT
; _this$ = ecx

; 379  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  :         assert(index < num);
; 381  :         if(index >= num) {DumpError(TEXT("Out of range!  List<%S>::operator[](%d)"), typeid(T).name(), index); return array[0];}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN1@operator
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	push	OFFSET ?__type_info_root_node@@3U__type_info_node@@A ; __type_info_root_node
	mov	ecx, OFFSET ??_R0E@8
	call	?name@type_info@@QBEPBDPAU__type_info_node@@@Z ; type_info::name
	push	eax
	push	OFFSET ??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp_?DumpError@@YAXPB_WZZ
	mov	eax, 1
	imul	eax, eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN3@operator
$LN1@operator:

; 382  :         return array[index];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, DWORD PTR _index$[ebp]
$LN3@operator:

; 383  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@E@@QAEAAEI@Z ENDP				; List<unsigned char>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Array@?$List@M@@QBEPAMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Array@?$List@M@@QBEPAMXZ PROC				; List<float>::Array, COMDAT
; _this$ = ecx

; 41   :     inline T* Array() const             {return array;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	esp, ebp
	pop	ebp
	ret	0
?Array@?$List@M@@QBEPAMXZ ENDP				; List<float>::Array
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?RemoveRange@?$List@M@@QAEXII@Z
_TEXT	SEGMENT
_cutoffCount$ = -12					; size = 4
_count$ = -8						; size = 4
_this$ = -4						; size = 4
_start$ = 8						; size = 4
_end$ = 12						; size = 4
?RemoveRange@?$List@M@@QAEXII@Z PROC			; List<float>::RemoveRange, COMDAT
; _this$ = ecx

; 112  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 113  :         if(start > num || end > num || end <= start)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _start$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	ja	SHORT $LN5@RemoveRang
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _end$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	ja	SHORT $LN5@RemoveRang
	mov	ecx, DWORD PTR _end$[ebp]
	cmp	ecx, DWORD PTR _start$[ebp]
	ja	SHORT $LN6@RemoveRang
$LN5@RemoveRang:

; 114  :         {
; 115  :             AppWarning(TEXT("List::RemoveRange:  Invalid range specified."));

	push	OFFSET ??_C@_1FK@OOEEKAAM@?$AAL?$AAi?$AAs?$AAt?$AA?3?$AA?3?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AAR?$AAa?$AAn?$AAg?$AAe?$AA?3?$AA?5?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAr?$AAa?$AAn?$AAg@
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 4

; 116  :             return;

	jmp	$LN7@RemoveRang
$LN6@RemoveRang:

; 117  :         }
; 118  : 
; 119  :         UINT count = end-start;

	mov	edx, DWORD PTR _end$[ebp]
	sub	edx, DWORD PTR _start$[ebp]
	mov	DWORD PTR _count$[ebp], edx

; 120  :         if(count == 1)

	cmp	DWORD PTR _count$[ebp], 1
	jne	SHORT $LN4@RemoveRang

; 121  :         {
; 122  :             Remove(start);

	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Remove@?$List@M@@QAEXI@Z		; List<float>::Remove

; 123  :             return;

	jmp	$LN7@RemoveRang
	jmp	SHORT $LN3@RemoveRang
$LN4@RemoveRang:

; 124  :         }
; 125  :         else if(count == num)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _count$[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN3@RemoveRang

; 126  :         {
; 127  :             Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@M@@QAEXXZ			; List<float>::Clear

; 128  :             return;

	jmp	SHORT $LN7@RemoveRang
$LN3@RemoveRang:

; 129  :         }
; 130  : 
; 131  :         num -= count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR _count$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 132  : 
; 133  :         UINT cutoffCount = num-start;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR _start$[ebp]
	mov	DWORD PTR _cutoffCount$[ebp], ecx

; 134  :         if(cutoffCount)

	je	SHORT $LN1@RemoveRang

; 135  :             mcpy(array+start, array+end, cutoffCount*sizeof(T));

	mov	edx, DWORD PTR _cutoffCount$[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _end$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _start$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN1@RemoveRang:

; 136  :         array = (T*)ReAllocate(array, num*sizeof(T));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+8]
	call	edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$LN7@RemoveRang:

; 137  :     }

	mov	esp, ebp
	pop	ebp
	ret	8
?RemoveRange@?$List@M@@QAEXII@Z ENDP			; List<float>::RemoveRange
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?AppendArray@?$List@M@@QAEXPBMI@Z
_TEXT	SEGMENT
_oldnum$ = -8						; size = 4
_this$ = -4						; size = 4
_new_array$ = 8						; size = 4
_n$ = 12						; size = 4
?AppendArray@?$List@M@@QAEXPBMI@Z PROC			; List<float>::AppendArray, COMDAT
; _this$ = ecx

; 183  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 184  :         if(!new_array && n)

	cmp	DWORD PTR _new_array$[ebp], 0
	jne	SHORT $LN3@AppendArra
	cmp	DWORD PTR _n$[ebp], 0
	je	SHORT $LN3@AppendArra

; 185  :         {
; 186  :             AppWarning(TEXT("List::AppendArray:  NULL array with count above zero"));

	push	OFFSET ??_C@_1GK@FGBPJKAO@?$AAL?$AAi?$AAs?$AAt?$AA?3?$AA?3?$AAA?$AAp?$AAp?$AAe?$AAn?$AAd?$AAA?$AAr?$AAr?$AAa?$AAy?$AA?3?$AA?5?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?5?$AAw@
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 4

; 187  :             return;

	jmp	SHORT $LN4@AppendArra
$LN3@AppendArra:

; 188  :         }
; 189  : 
; 190  :         if(!n)

	cmp	DWORD PTR _n$[ebp], 0
	jne	SHORT $LN2@AppendArra

; 191  :             return;

	jmp	SHORT $LN4@AppendArra
$LN2@AppendArra:

; 192  : 
; 193  :         int oldnum = num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _oldnum$[ebp], ecx

; 194  : 
; 195  :         SetSize(n+num);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _n$[ebp]
	add	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSize@?$List@M@@QAEHI@Z		; List<float>::SetSize

; 196  : 
; 197  :         assert(num);
; 198  : 
; 199  :         if(!num) {array=NULL; return;}

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN1@AppendArra
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 0
	jmp	SHORT $LN4@AppendArra
$LN1@AppendArra:

; 200  : 
; 201  :         mcpy(&array[oldnum], (void*)new_array, sizeof(T)*n);

	mov	eax, DWORD PTR _n$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _new_array$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _oldnum$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN4@AppendArra:

; 202  :     }

	mov	esp, ebp
	pop	ebp
	ret	8
?AppendArray@?$List@M@@QAEXPBMI@Z ENDP			; List<float>::AppendArray
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?SetSize@?$List@M@@QAEHI@Z
_TEXT	SEGMENT
_bClear$ = -16						; size = 4
_oldNum$ = -12						; size = 4
tv70 = -8						; size = 4
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?SetSize@?$List@M@@QAEHI@Z PROC				; List<float>::SetSize, COMDAT
; _this$ = ecx

; 205  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 206  :         if(num == n)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _n$[ebp]
	jne	SHORT $LN4@SetSize

; 207  :             return FALSE;

	xor	eax, eax
	jmp	$LN5@SetSize
	jmp	SHORT $LN3@SetSize
$LN4@SetSize:

; 208  :         else if(!n)

	cmp	DWORD PTR _n$[ebp], 0
	jne	SHORT $LN3@SetSize

; 209  :         {
; 210  :             Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@M@@QAEXXZ			; List<float>::Clear

; 211  :             return TRUE;

	mov	eax, 1
	jmp	$LN5@SetSize
$LN3@SetSize:

; 212  :         }
; 213  : 
; 214  :         BOOL bClear=(n>num);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jbe	SHORT $LN7@SetSize
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN8@SetSize
$LN7@SetSize:
	mov	DWORD PTR tv70[ebp], 0
$LN8@SetSize:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _bClear$[ebp], ecx

; 215  :         UINT oldNum=num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _oldNum$[ebp], eax

; 216  : 
; 217  :         num = n;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 218  :         array = (T*)ReAllocate(array, sizeof(T)*num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 219  : 
; 220  :         if(bClear)

	cmp	DWORD PTR _bClear$[ebp], 0
	je	SHORT $LN1@SetSize

; 221  :             zero(&array[oldNum], sizeof(T)*(num-oldNum));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, DWORD PTR _oldNum$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _oldNum$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	?zero@@YGXPAXI@Z			; zero
$LN1@SetSize:

; 222  : 
; 223  :         return TRUE;

	mov	eax, 1
$LN5@SetSize:

; 224  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetSize@?$List@M@@QAEHI@Z ENDP				; List<float>::SetSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??0?$List@_K@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$List@_K@@QAE@XZ PROC				; List<unsigned __int64>::List<unsigned __int64>, COMDAT
; _this$ = ecx

; 35   :     inline List() : array(NULL), num(0) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@_K@@QAE@XZ ENDP				; List<unsigned __int64>::List<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??1?$List@_K@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$List@_K@@QAE@XZ PROC				; List<unsigned __int64>::~List<unsigned __int64>, COMDAT
; _this$ = ecx

; 37   :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 38   :         Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@_K@@QAEXXZ		; List<unsigned __int64>::Clear

; 39   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@_K@@QAE@XZ ENDP				; List<unsigned __int64>::~List<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Remove@?$List@_K@@QAEXI@Z
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?Remove@?$List@_K@@QAEXI@Z PROC				; List<unsigned __int64>::Remove, COMDAT
; _this$ = ecx

; 88   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 89   :         assert(index < num);
; 90   :         if(index >= num) return;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN2@Remove
	jmp	$LN3@Remove
$LN2@Remove:

; 91   : 
; 92   :         if(!--num) {Free(array); array=NULL; return;}

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	mov	DWORD PTR tv68[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv68[ebp]
	mov	DWORD PTR [ecx+4], edx
	cmp	DWORD PTR tv68[ebp], 0
	jne	SHORT $LN1@Remove
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 0
	jmp	SHORT $LN3@Remove
$LN1@Remove:

; 93   : 
; 94   :         mcpy(&array[index], &array[index+1], sizeof(T)*(num-index));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR _index$[ebp]
	shl	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _index$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _index$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 95   : 
; 96   :         array = (T*)ReAllocate(array, sizeof(T)*num);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 3
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$LN3@Remove:

; 97   :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?Remove@?$List@_K@@QAEXI@Z ENDP				; List<unsigned __int64>::Remove
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??6?$List@_K@@QAEAAV0@AB_K@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_val$ = 8						; size = 4
??6?$List@_K@@QAEAAV0@AB_K@Z PROC			; List<unsigned __int64>::operator<<, COMDAT
; _this$ = ecx

; 366  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 367  :         Add(val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Add@?$List@_K@@QAEIAB_K@Z		; List<unsigned __int64>::Add

; 368  :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 369  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??6?$List@_K@@QAEAAV0@AB_K@Z ENDP			; List<unsigned __int64>::operator<<
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??A?$List@_K@@QAEAA_KI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$List@_K@@QAEAA_KI@Z PROC				; List<unsigned __int64>::operator[], COMDAT
; _this$ = ecx

; 379  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  :         assert(index < num);
; 381  :         if(index >= num) {DumpError(TEXT("Out of range!  List<%S>::operator[](%d)"), typeid(T).name(), index); return array[0];}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN1@operator
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	push	OFFSET ?__type_info_root_node@@3U__type_info_node@@A ; __type_info_root_node
	mov	ecx, OFFSET ??_R0_K@8
	call	?name@type_info@@QBEPBDPAU__type_info_node@@@Z ; type_info::name
	push	eax
	push	OFFSET ??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp_?DumpError@@YAXPB_WZZ
	mov	eax, 8
	imul	eax, eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN3@operator
$LN1@operator:

; 382  :         return array[index];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _index$[ebp]
	lea	eax, DWORD PTR [eax+ecx*8]
$LN3@operator:

; 383  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@_K@@QAEAA_KI@Z ENDP				; List<unsigned __int64>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Remove@?$List@M@@QAEXI@Z
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?Remove@?$List@M@@QAEXI@Z PROC				; List<float>::Remove, COMDAT
; _this$ = ecx

; 88   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 89   :         assert(index < num);
; 90   :         if(index >= num) return;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN2@Remove
	jmp	$LN3@Remove
$LN2@Remove:

; 91   : 
; 92   :         if(!--num) {Free(array); array=NULL; return;}

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	mov	DWORD PTR tv68[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv68[ebp]
	mov	DWORD PTR [ecx+4], edx
	cmp	DWORD PTR tv68[ebp], 0
	jne	SHORT $LN1@Remove
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 0
	jmp	SHORT $LN3@Remove
$LN1@Remove:

; 93   : 
; 94   :         mcpy(&array[index], &array[index+1], sizeof(T)*(num-index));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR _index$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _index$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _index$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 95   : 
; 96   :         array = (T*)ReAllocate(array, sizeof(T)*num);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$LN3@Remove:

; 97   :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?Remove@?$List@M@@QAEXI@Z ENDP				; List<float>::Remove
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Add@?$List@_K@@QAEIAB_K@Z
_TEXT	SEGMENT
tv73 = -8						; size = 4
_this$ = -4						; size = 4
_val$ = 8						; size = 4
?Add@?$List@_K@@QAEIAB_K@Z PROC				; List<unsigned __int64>::Add, COMDAT
; _this$ = ecx

; 45   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 46   :         array = (T*)ReAllocate(array, sizeof(T)*++num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	DWORD PTR tv73[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR tv73[ebp]
	shl	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 47   :         mcpy(&array[(num-1)], (void*)&val, sizeof(T));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _val$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [edx+eax*8-8], esi
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+eax*8-4], ecx

; 48   :         return num-1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1

; 49   :     }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?Add@?$List@_K@@QAEIAB_K@Z ENDP				; List<unsigned __int64>::Add
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Clear@?$List@_K@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@?$List@_K@@QAEXXZ PROC				; List<unsigned __int64>::Clear, COMDAT
; _this$ = ecx

; 334  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 335  :         if(array)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Clear

; 336  :         {
; 337  :             /*if(IsBadWritePtr(array, sizeof(T)*num))
; 338  :                 CrashError(TEXT("what the.."));*/
; 339  :             Free(array);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4

; 340  :             array = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 341  :             num = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$LN2@Clear:

; 342  :         }
; 343  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$List@_K@@QAEXXZ ENDP				; List<unsigned __int64>::Clear
_TEXT	ENDS
END

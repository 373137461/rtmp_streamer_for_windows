; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

	TITLE	F:\songmm_moon_stone_obs\OBS\Source\libnsgif.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

EXTRN	_realloc:PROC
EXTRN	_calloc:PROC
EXTRN	_strncmp:PROC
EXTRN	_malloc:PROC
$SG4294825188 DB 'GIF', 00H
$SG4294825187 DB 'NETSCAPE2.0', 00H
_maskTbl DD	00H
	DD	01H
	DD	03H
	DD	07H
	DD	0fH
	DD	01fH
	DD	03fH
	DD	07fH
	DD	0ffH
	DD	01ffH
	DD	03ffH
	DD	07ffH
	DD	0fffH
	DD	01fffH
	DD	03fffH
	DD	07fffH
PUBLIC	_gif_finalise
PUBLIC	_gif_create
PUBLIC	_gif_initialise
PUBLIC	_gif_decode_frame
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\libnsgif.c
;	COMDAT _gif_decode_frame
_TEXT	SEGMENT
_save_buffer_position$ = -104				; size = 4
tv344 = -100						; size = 4
_interlace$ = -96					; size = 4
tv272 = -92						; size = 4
tv347 = -88						; size = 4
_decode_y$ = -84					; size = 4
_offset_x$ = -80					; size = 4
_colour_table_size$ = -76				; size = 4
_flags$ = -72						; size = 4
_colour_table$ = -68					; size = 4
_width$ = -64						; size = 4
_offset_y$ = -60					; size = 4
_height$ = -56						; size = 4
_gif_end$ = -52						; size = 4
_entry$1 = -48						; size = 4
_x$ = -44						; size = 4
_index$ = -40						; size = 4
_frame_scanline$ = -36					; size = 4
_last_undisposed_frame$ = -32				; size = 4
_burst_bytes$ = -28					; size = 4
_frame_data$ = -24					; size = 4
_gif_bytes$ = -20					; size = 4
_y$ = -16						; size = 4
_return_value$ = -12					; size = 4
_gif_data$ = -8						; size = 4
_colour$ = -1						; size = 1
_gif$ = 8						; size = 4
_frame$ = 12						; size = 4
_gif_decode_frame PROC					; COMDAT

; 736  : gif_result gif_decode_frame(gif_animation *gif, unsigned int frame) {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	esi

; 737  :     unsigned int index = 0;

	mov	DWORD PTR _index$[ebp], 0

; 738  :     unsigned char *gif_data, *gif_end;
; 739  :     int gif_bytes;
; 740  :     unsigned int width, height, offset_x, offset_y;
; 741  :     unsigned int flags, colour_table_size, interlace;
; 742  :     unsigned int *colour_table;
; 743  :     unsigned int *frame_data = 0;    // Set to 0 for no warnings

	mov	DWORD PTR _frame_data$[ebp], 0

; 744  :     unsigned int *frame_scanline;
; 745  :     unsigned int save_buffer_position;
; 746  :     gif_result return_value = GIF_OK;

	mov	DWORD PTR _return_value$[ebp], 0

; 747  :     unsigned int x, y, decode_y, burst_bytes;
; 748  :     int last_undisposed_frame = (frame - 1);

	mov	eax, DWORD PTR _frame$[ebp]
	sub	eax, 1
	mov	DWORD PTR _last_undisposed_frame$[ebp], eax

; 749  :     register unsigned char colour;
; 750  : 
; 751  :     /*    Ensure we have a frame to decode
; 752  :     */
; 753  :     if (frame >= gif->frame_count_partial)

	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR _frame$[ebp]
	cmp	edx, DWORD PTR [ecx+40]
	jb	SHORT $LN68@gif_decode

; 754  :         return GIF_INSUFFICIENT_DATA;

	mov	eax, -3					; fffffffdH
	jmp	$LN69@gif_decode
$LN68@gif_decode:

; 755  : 
; 756  :     /*    Ensure this frame is supposed to be decoded
; 757  :     */
; 758  :     if (gif->frames[frame].display == FALSE) {

	imul	eax, DWORD PTR _frame$[ebp], 52
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	cmp	DWORD PTR [edx+eax], 0
	jne	SHORT $LN67@gif_decode

; 759  :         gif->current_error = GIF_FRAME_NO_DISPLAY;

	mov	eax, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [eax+60], -6			; fffffffaH

; 760  :         return GIF_OK;

	xor	eax, eax
	jmp	$LN69@gif_decode
$LN67@gif_decode:

; 761  :     }
; 762  : 
; 763  :     if ((!gif->clear_image) && ((int)frame == gif->decoded_frame))

	mov	ecx, DWORD PTR _gif$[ebp]
	cmp	DWORD PTR [ecx+41124], 0
	jne	SHORT $LN66@gif_decode
	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR _frame$[ebp]
	cmp	eax, DWORD PTR [edx+48]
	jne	SHORT $LN66@gif_decode

; 764  :         return GIF_OK;

	xor	eax, eax
	jmp	$LN69@gif_decode
$LN66@gif_decode:

; 765  : 
; 766  :     /*    Get the start of our frame data and the end of the GIF data
; 767  :     */
; 768  :     gif_data = gif->gif_data + gif->frames[frame].frame_pointer;

	imul	ecx, DWORD PTR _frame$[ebp], 52
	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	edx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR [edx+24]
	add	edx, DWORD PTR [eax+ecx+8]
	mov	DWORD PTR _gif_data$[ebp], edx

; 769  :     gif_end = gif->gif_data + gif->buffer_size;

	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _gif$[ebp]
	add	ecx, DWORD PTR [edx+68]
	mov	DWORD PTR _gif_end$[ebp], ecx

; 770  :     gif_bytes = (gif_end - gif_data);

	mov	eax, DWORD PTR _gif_end$[ebp]
	sub	eax, DWORD PTR _gif_data$[ebp]
	mov	DWORD PTR _gif_bytes$[ebp], eax

; 771  : 
; 772  :     /*    Check if we have enough data
; 773  :      *    The shortest block of data is a 10-byte image descriptor + 1-byte gif trailer
; 774  :     */
; 775  :     if (gif_bytes < 12) return GIF_INSUFFICIENT_FRAME_DATA;

	cmp	DWORD PTR _gif_bytes$[ebp], 12		; 0000000cH
	jge	SHORT $LN65@gif_decode
	or	eax, -1
	jmp	$LN69@gif_decode
$LN65@gif_decode:

; 776  : 
; 777  :     /*    Save the buffer position
; 778  :     */
; 779  :     save_buffer_position = gif->buffer_position;

	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR _save_buffer_position$[ebp], edx

; 780  :     gif->buffer_position = gif_data - gif->gif_data;

	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR _gif_data$[ebp]
	sub	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [edx+64], ecx

; 781  : 
; 782  :     /*    Skip any extensions because we all ready processed them
; 783  :     */
; 784  :     if ((return_value = gif_skip_frame_extensions(gif)) != GIF_OK)

	mov	eax, DWORD PTR _gif$[ebp]
	push	eax
	call	_gif_skip_frame_extensions
	add	esp, 4
	mov	DWORD PTR _return_value$[ebp], eax
	cmp	DWORD PTR _return_value$[ebp], 0
	je	SHORT $LN64@gif_decode

; 785  :         goto gif_decode_frame_exit;

	jmp	$gif_decode_frame_exit$71
$LN64@gif_decode:

; 786  :     gif_data = (gif->gif_data + gif->buffer_position);

	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _gif$[ebp]
	add	edx, DWORD PTR [eax+64]
	mov	DWORD PTR _gif_data$[ebp], edx

; 787  :     gif_bytes = (gif_end - gif_data);

	mov	ecx, DWORD PTR _gif_end$[ebp]
	sub	ecx, DWORD PTR _gif_data$[ebp]
	mov	DWORD PTR _gif_bytes$[ebp], ecx

; 788  : 
; 789  :     /*    Ensure we have enough data for the 10-byte image descriptor + 1-byte gif trailer
; 790  :     */
; 791  :     if (gif_bytes < 12) {

	cmp	DWORD PTR _gif_bytes$[ebp], 12		; 0000000cH
	jge	SHORT $LN63@gif_decode

; 792  :         return_value = GIF_INSUFFICIENT_FRAME_DATA;

	mov	DWORD PTR _return_value$[ebp], -1

; 793  :         goto gif_decode_frame_exit;

	jmp	$gif_decode_frame_exit$71
$LN63@gif_decode:

; 794  :     }
; 795  : 
; 796  :     /* 10-byte Image Descriptor is:
; 797  :      *
; 798  :      *    +0    CHAR    Image Separator (0x2c)
; 799  :      *    +1    SHORT    Image Left Position
; 800  :      *    +3    SHORT    Image Top Position
; 801  :      *    +5    SHORT    Width
; 802  :      *    +7    SHORT    Height
; 803  :      *    +9    CHAR    __Packed Fields__
; 804  :      *            1BIT    Local Colour Table Flag
; 805  :      *            1BIT    Interlace Flag
; 806  :      *            1BIT    Sort Flag
; 807  :      *            2BITS    Reserved
; 808  :      *            3BITS    Size of Local Colour Table
; 809  :     */
; 810  :     if (gif_data[0] != GIF_IMAGE_SEPARATOR) {

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _gif_data$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 44					; 0000002cH
	je	SHORT $LN62@gif_decode

; 811  :         return_value = GIF_DATA_ERROR;

	mov	DWORD PTR _return_value$[ebp], -4	; fffffffcH

; 812  :         goto gif_decode_frame_exit;

	jmp	$gif_decode_frame_exit$71
$LN62@gif_decode:

; 813  :     }
; 814  :     offset_x = gif_data[1] | (gif_data[2] << 8);

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _gif_data$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _gif_data$[ebp]
	movzx	eax, BYTE PTR [ecx+eax]
	shl	eax, 8
	or	edx, eax
	mov	DWORD PTR _offset_x$[ebp], edx

; 815  :     offset_y = gif_data[3] | (gif_data[4] << 8);

	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _gif_data$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	mov	edx, 1
	shl	edx, 2
	mov	eax, DWORD PTR _gif_data$[ebp]
	movzx	edx, BYTE PTR [eax+edx]
	shl	edx, 8
	or	ecx, edx
	mov	DWORD PTR _offset_y$[ebp], ecx

; 816  :     width = gif_data[5] | (gif_data[6] << 8);

	mov	eax, 1
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _gif_data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 1
	imul	edx, ecx, 6
	mov	ecx, DWORD PTR _gif_data$[ebp]
	movzx	edx, BYTE PTR [ecx+edx]
	shl	edx, 8
	or	eax, edx
	mov	DWORD PTR _width$[ebp], eax

; 817  :     height = gif_data[7] | (gif_data[8] << 8);

	mov	eax, 1
	imul	ecx, eax, 7
	mov	edx, DWORD PTR _gif_data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 1
	shl	ecx, 3
	mov	edx, DWORD PTR _gif_data$[ebp]
	movzx	ecx, BYTE PTR [edx+ecx]
	shl	ecx, 8
	or	eax, ecx
	mov	DWORD PTR _height$[ebp], eax

; 818  : 
; 819  :     /*    Boundary checking - shouldn't ever happen except unless the data has been
; 820  :         modified since initialisation.
; 821  :     */
; 822  :     if ((offset_x + width > gif->width) || (offset_y + height > gif->height)) {

	mov	edx, DWORD PTR _offset_x$[ebp]
	add	edx, DWORD PTR _width$[ebp]
	mov	eax, DWORD PTR _gif$[ebp]
	cmp	edx, DWORD PTR [eax+28]
	ja	SHORT $LN60@gif_decode
	mov	ecx, DWORD PTR _offset_y$[ebp]
	add	ecx, DWORD PTR _height$[ebp]
	mov	edx, DWORD PTR _gif$[ebp]
	cmp	ecx, DWORD PTR [edx+32]
	jbe	SHORT $LN61@gif_decode
$LN60@gif_decode:

; 823  :         return_value = GIF_DATA_ERROR;

	mov	DWORD PTR _return_value$[ebp], -4	; fffffffcH

; 824  :         goto gif_decode_frame_exit;

	jmp	$gif_decode_frame_exit$71
$LN61@gif_decode:

; 825  :     }
; 826  : 
; 827  :     /*    Decode the flags
; 828  :     */
; 829  :     flags = gif_data[9];

	mov	eax, 1
	imul	ecx, eax, 9
	mov	edx, DWORD PTR _gif_data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _flags$[ebp], eax

; 830  :     colour_table_size = 2 << (flags & GIF_COLOUR_TABLE_SIZE_MASK);

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 7
	mov	edx, 2
	shl	edx, cl
	mov	DWORD PTR _colour_table_size$[ebp], edx

; 831  :     interlace = flags & GIF_INTERLACE_MASK;

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 64					; 00000040H
	mov	DWORD PTR _interlace$[ebp], eax

; 832  : 
; 833  :     /*    Move our pointer to the colour table or image data (if no colour table is given)
; 834  :     */
; 835  :     gif_data += 10;

	mov	ecx, DWORD PTR _gif_data$[ebp]
	add	ecx, 10					; 0000000aH
	mov	DWORD PTR _gif_data$[ebp], ecx

; 836  :     gif_bytes = (gif_end - gif_data);

	mov	edx, DWORD PTR _gif_end$[ebp]
	sub	edx, DWORD PTR _gif_data$[ebp]
	mov	DWORD PTR _gif_bytes$[ebp], edx

; 837  : 
; 838  :     /*    Set up the colour table
; 839  :     */
; 840  :     if (flags & GIF_COLOUR_TABLE_MASK) {

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 128				; 00000080H
	je	$LN59@gif_decode

; 841  :         if (gif_bytes < (int)(3 * colour_table_size)) {

	imul	ecx, DWORD PTR _colour_table_size$[ebp], 3
	cmp	DWORD PTR _gif_bytes$[ebp], ecx
	jge	SHORT $LN58@gif_decode

; 842  :             return_value = GIF_INSUFFICIENT_FRAME_DATA;

	mov	DWORD PTR _return_value$[ebp], -1

; 843  :             goto gif_decode_frame_exit;

	jmp	$gif_decode_frame_exit$71
$LN58@gif_decode:

; 844  :         }
; 845  :         colour_table = gif->local_colour_table;

	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR _colour_table$[ebp], eax

; 846  :         if (!gif->clear_image) {

	mov	ecx, DWORD PTR _gif$[ebp]
	cmp	DWORD PTR [ecx+41124], 0
	jne	$LN57@gif_decode

; 847  :             for (index = 0; index < colour_table_size; index++) {

	mov	DWORD PTR _index$[ebp], 0
	jmp	SHORT $LN56@gif_decode
$LN55@gif_decode:
	mov	edx, DWORD PTR _index$[ebp]
	add	edx, 1
	mov	DWORD PTR _index$[ebp], edx
$LN56@gif_decode:
	mov	eax, DWORD PTR _index$[ebp]
	cmp	eax, DWORD PTR _colour_table_size$[ebp]
	jae	SHORT $LN54@gif_decode

; 848  :                 /* Gif colour map contents are r,g,b.
; 849  :                  *
; 850  :                  * We want to pack them bytewise into the 
; 851  :                  * colour table, such that the red component
; 852  :                  * is in byte 0 and the alpha component is in
; 853  :                  * byte 3.
; 854  :                  */
; 855  :                 unsigned char *entry = 
; 856  :                     (unsigned char *) &colour_table[index];

	mov	ecx, DWORD PTR _index$[ebp]
	mov	edx, DWORD PTR _colour_table$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _entry$1[ebp], eax

; 857  : 
; 858  :                 entry[0] = gif_data[0];    /* r */

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, 1
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _entry$1[ebp]
	mov	esi, DWORD PTR _gif_data$[ebp]
	mov	dl, BYTE PTR [esi+edx]
	mov	BYTE PTR [eax+ecx], dl

; 859  :                 entry[1] = gif_data[1];    /* g */

	mov	eax, 1
	shl	eax, 0
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _entry$1[ebp]
	mov	esi, DWORD PTR _gif_data$[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [edx+ecx], al

; 860  :                 entry[2] = gif_data[2];    /* b */

	mov	ecx, 1
	shl	ecx, 1
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _entry$1[ebp]
	mov	esi, DWORD PTR _gif_data$[ebp]
	mov	cl, BYTE PTR [esi+ecx]
	mov	BYTE PTR [eax+edx], cl

; 861  :                 entry[3] = 0xff;    /* a */

	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _entry$1[ebp]
	mov	BYTE PTR [ecx+eax], 255			; 000000ffH

; 862  : 
; 863  :                 gif_data += 3;

	mov	edx, DWORD PTR _gif_data$[ebp]
	add	edx, 3
	mov	DWORD PTR _gif_data$[ebp], edx

; 864  :             }

	jmp	$LN55@gif_decode
$LN54@gif_decode:

; 865  :         } else {

	jmp	SHORT $LN53@gif_decode
$LN57@gif_decode:

; 866  :             gif_data += 3 * colour_table_size;

	imul	eax, DWORD PTR _colour_table_size$[ebp], 3
	add	eax, DWORD PTR _gif_data$[ebp]
	mov	DWORD PTR _gif_data$[ebp], eax
$LN53@gif_decode:

; 867  :         }
; 868  :         gif_bytes = (gif_end - gif_data);

	mov	ecx, DWORD PTR _gif_end$[ebp]
	sub	ecx, DWORD PTR _gif_data$[ebp]
	mov	DWORD PTR _gif_bytes$[ebp], ecx

; 869  :     } else {

	jmp	SHORT $LN52@gif_decode
$LN59@gif_decode:

; 870  :         colour_table = gif->global_colour_table;

	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+92]
	mov	DWORD PTR _colour_table$[ebp], eax
$LN52@gif_decode:

; 871  :     }
; 872  : 
; 873  :     /*    Check if we've finished
; 874  :     */
; 875  :     if (gif_bytes < 1) {

	cmp	DWORD PTR _gif_bytes$[ebp], 1
	jge	SHORT $LN51@gif_decode

; 876  :         return_value = GIF_INSUFFICIENT_FRAME_DATA;

	mov	DWORD PTR _return_value$[ebp], -1

; 877  :         goto gif_decode_frame_exit;

	jmp	$gif_decode_frame_exit$71
	jmp	SHORT $LN50@gif_decode
$LN51@gif_decode:

; 878  :     } else if (gif_data[0] == GIF_TRAILER) {

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _gif_data$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 59					; 0000003bH
	jne	SHORT $LN50@gif_decode

; 879  :         return_value = GIF_OK;

	mov	DWORD PTR _return_value$[ebp], 0

; 880  :         goto gif_decode_frame_exit;

	jmp	$gif_decode_frame_exit$71
$LN50@gif_decode:

; 881  :     }
; 882  : 
; 883  :     /*    Get the frame data
; 884  :     */
; 885  :     assert(gif->bitmap_callbacks.bitmap_get_buffer);
; 886  :     frame_data = (void *)gif->bitmap_callbacks.bitmap_get_buffer(gif->frame_image);

	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	eax
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	call	edx
	add	esp, 4
	mov	DWORD PTR _frame_data$[ebp], eax

; 887  :     if (!frame_data)

	cmp	DWORD PTR _frame_data$[ebp], 0
	jne	SHORT $LN48@gif_decode

; 888  :         return GIF_INSUFFICIENT_MEMORY;

	mov	eax, -5					; fffffffbH
	jmp	$LN69@gif_decode
$LN48@gif_decode:

; 889  : 
; 890  :     /*    If we are clearing the image we just clear, if not decode
; 891  :     */
; 892  :     if (!gif->clear_image) {

	mov	eax, DWORD PTR _gif$[ebp]
	cmp	DWORD PTR [eax+41124], 0
	jne	$LN47@gif_decode

; 893  :         /*    Ensure we have enough data for a 1-byte LZW code size + 1-byte gif trailer
; 894  :         */
; 895  :         if (gif_bytes < 2) {

	cmp	DWORD PTR _gif_bytes$[ebp], 2
	jge	SHORT $LN46@gif_decode

; 896  :             return_value = GIF_INSUFFICIENT_FRAME_DATA;

	mov	DWORD PTR _return_value$[ebp], -1

; 897  :             goto gif_decode_frame_exit;

	jmp	$gif_decode_frame_exit$71
	jmp	SHORT $LN45@gif_decode
$LN46@gif_decode:

; 898  :         /*    If we only have a 1-byte LZW code size + 1-byte gif trailer, we're finished
; 899  :         */
; 900  :         } else if ((gif_bytes == 2) && (gif_data[1] == GIF_TRAILER)) {

	cmp	DWORD PTR _gif_bytes$[ebp], 2
	jne	SHORT $LN45@gif_decode
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _gif_data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 59					; 0000003bH
	jne	SHORT $LN45@gif_decode

; 901  :             return_value = GIF_OK;

	mov	DWORD PTR _return_value$[ebp], 0

; 902  :             goto gif_decode_frame_exit;

	jmp	$gif_decode_frame_exit$71
$LN45@gif_decode:

; 903  :         }
; 904  : 
; 905  :         /*    If the previous frame's disposal method requires we restore the background
; 906  :          *    colour or this is the first frame, clear the frame data
; 907  :         */
; 908  :         if ((frame == 0) || (gif->decoded_frame == GIF_INVALID_FRAME)) {

	cmp	DWORD PTR _frame$[ebp], 0
	je	SHORT $LN42@gif_decode
	mov	ecx, DWORD PTR _gif$[ebp]
	cmp	DWORD PTR [ecx+48], -1
	jne	SHORT $LN43@gif_decode
$LN42@gif_decode:

; 909  :             memset((char*)frame_data, GIF_TRANSPARENT_COLOUR, gif->width * gif->height * sizeof(int));

	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [edx+28]
	imul	ecx, DWORD PTR [eax+32]
	shl	ecx, 2
	push	ecx
	push	0
	mov	edx, DWORD PTR _frame_data$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 910  :             gif->decoded_frame = frame;

	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR _frame$[ebp]
	mov	DWORD PTR [eax+48], ecx
	jmp	$LN41@gif_decode
$LN43@gif_decode:

; 911  :             /* The line below would fill the image with its background color, but because GIFs support
; 912  :              * transparency we likely wouldn't want to do that. */
; 913  :             /* memset((char*)frame_data, colour_table[gif->background_index], gif->width * gif->height * sizeof(int)); */
; 914  :         } else if ((frame != 0) && (gif->frames[frame - 1].disposal_method == GIF_FRAME_CLEAR)) {

	cmp	DWORD PTR _frame$[ebp], 0
	je	SHORT $LN40@gif_decode
	mov	edx, DWORD PTR _frame$[ebp]
	sub	edx, 1
	imul	eax, edx, 52
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	movzx	eax, BYTE PTR [edx+eax+24]
	cmp	eax, 2
	jne	SHORT $LN40@gif_decode

; 915  :             gif->clear_image = TRUE;

	mov	ecx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [ecx+41124], 1

; 916  :             if ((return_value = gif_decode_frame(gif, (frame - 1))) != GIF_OK)

	mov	edx, DWORD PTR _frame$[ebp]
	sub	edx, 1
	push	edx
	mov	eax, DWORD PTR _gif$[ebp]
	push	eax
	call	_gif_decode_frame
	add	esp, 8
	mov	DWORD PTR _return_value$[ebp], eax
	cmp	DWORD PTR _return_value$[ebp], 0
	je	SHORT $LN39@gif_decode

; 917  :                 goto gif_decode_frame_exit;

	jmp	$gif_decode_frame_exit$71
$LN39@gif_decode:

; 918  :             gif->clear_image = FALSE;

	mov	ecx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [ecx+41124], 0
	jmp	$LN41@gif_decode
$LN40@gif_decode:

; 919  :         /*    If the previous frame's disposal method requires we restore the previous
; 920  :          *    image, find the last image set to "do not dispose" and get that frame data
; 921  :         */
; 922  :         } else if ((frame != 0) && (gif->frames[frame - 1].disposal_method == GIF_FRAME_RESTORE)) {

	cmp	DWORD PTR _frame$[ebp], 0
	je	$LN41@gif_decode
	mov	edx, DWORD PTR _frame$[ebp]
	sub	edx, 1
	imul	eax, edx, 52
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	movzx	eax, BYTE PTR [edx+eax+24]
	cmp	eax, 3
	jne	$LN41@gif_decode
$LN36@gif_decode:

; 923  :             while ((last_undisposed_frame != -1) && (gif->frames[last_undisposed_frame--].disposal_method == GIF_FRAME_RESTORE));

	cmp	DWORD PTR _last_undisposed_frame$[ebp], -1
	je	SHORT $LN35@gif_decode
	imul	ecx, DWORD PTR _last_undisposed_frame$[ebp], 52
	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+44]
	movzx	ecx, BYTE PTR [eax+ecx+24]
	mov	DWORD PTR tv272[ebp], ecx
	mov	edx, DWORD PTR _last_undisposed_frame$[ebp]
	sub	edx, 1
	mov	DWORD PTR _last_undisposed_frame$[ebp], edx
	cmp	DWORD PTR tv272[ebp], 3
	jne	SHORT $LN35@gif_decode
	jmp	SHORT $LN36@gif_decode
$LN35@gif_decode:

; 924  :                 /*    If we don't find one, clear the frame data
; 925  :                 */
; 926  :                 if (last_undisposed_frame == -1) {

	cmp	DWORD PTR _last_undisposed_frame$[ebp], -1
	jne	SHORT $LN34@gif_decode

; 927  :                     /* see notes above on transparency vs. background color */
; 928  :                     memset((char*)frame_data, GIF_TRANSPARENT_COLOUR, gif->width * gif->height * sizeof(int));

	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR [eax+28]
	imul	edx, DWORD PTR [ecx+32]
	shl	edx, 2
	push	edx
	push	0
	mov	eax, DWORD PTR _frame_data$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 929  :                 } else {

	jmp	SHORT $LN41@gif_decode
$LN34@gif_decode:

; 930  :                     if ((return_value = gif_decode_frame(gif, last_undisposed_frame)) != GIF_OK)

	mov	ecx, DWORD PTR _last_undisposed_frame$[ebp]
	push	ecx
	mov	edx, DWORD PTR _gif$[ebp]
	push	edx
	call	_gif_decode_frame
	add	esp, 8
	mov	DWORD PTR _return_value$[ebp], eax
	cmp	DWORD PTR _return_value$[ebp], 0
	je	SHORT $LN32@gif_decode

; 931  :                         goto gif_decode_frame_exit;

	jmp	$gif_decode_frame_exit$71
$LN32@gif_decode:

; 932  :                     /*    Get this frame's data
; 933  :                     */
; 934  :                     assert(gif->bitmap_callbacks.bitmap_get_buffer);
; 935  :                     frame_data = (void *)gif->bitmap_callbacks.bitmap_get_buffer(gif->frame_image);

	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	add	esp, 4
	mov	DWORD PTR _frame_data$[ebp], eax

; 936  :                     if (!frame_data)

	cmp	DWORD PTR _frame_data$[ebp], 0
	jne	SHORT $LN41@gif_decode

; 937  :                         return GIF_INSUFFICIENT_MEMORY;

	mov	eax, -5					; fffffffbH
	jmp	$LN69@gif_decode
$LN41@gif_decode:

; 938  :                 }
; 939  :         }
; 940  :         gif->decoded_frame = frame;

	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR _frame$[ebp]
	mov	DWORD PTR [ecx+48], edx

; 941  : 
; 942  :         /*    Initialise the LZW decoding
; 943  :         */
; 944  :         gif->set_code_size = gif_data[0];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _gif_data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [ecx+41076], eax

; 945  :         gif->buffer_position = (gif_data - gif->gif_data) + 1;

	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR _gif_data$[ebp]
	sub	eax, DWORD PTR [edx+24]
	add	eax, 1
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [ecx+64], eax

; 946  : 
; 947  :         /*    Set our code variables
; 948  :         */
; 949  :         gif->code_size = gif->set_code_size + 1;

	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+41076]
	add	eax, 1
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [ecx+41072], eax

; 950  :         gif->clear_code = (1 << gif->set_code_size);

	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, 1
	mov	ecx, DWORD PTR [edx+41076]
	shl	eax, cl
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [ecx+41088], eax

; 951  :         gif->end_code = gif->clear_code + 1;

	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+41088]
	add	eax, 1
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [ecx+41092], eax

; 952  :         gif->max_code_size = gif->clear_code << 1;

	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+41088]
	shl	eax, 1
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [ecx+41084], eax

; 953  :         gif->max_code = gif->clear_code + 2;

	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+41088]
	add	eax, 2
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [ecx+41080], eax

; 954  :         gif->curbit = gif->lastbit = 0;

	mov	edx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [edx+41100], 0
	mov	eax, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [eax+41096], 0

; 955  :         gif->last_byte = 2;

	mov	ecx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [ecx+41104], 2

; 956  :         gif->get_done = FALSE;

	mov	edx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [edx+41120], 0

; 957  :         gif->direct = gif->buf;

	mov	eax, DWORD PTR _gif$[ebp]
	add	eax, 100				; 00000064H
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [ecx+104], eax

; 958  :         gif_init_LZW(gif);

	mov	edx, DWORD PTR _gif$[ebp]
	push	edx
	call	_gif_init_LZW
	add	esp, 4

; 959  : 
; 960  :         /*    Decompress the data
; 961  :         */
; 962  :         for (y = 0; y < height; y++) {

	mov	DWORD PTR _y$[ebp], 0
	jmp	SHORT $LN30@gif_decode
$LN29@gif_decode:
	mov	eax, DWORD PTR _y$[ebp]
	add	eax, 1
	mov	DWORD PTR _y$[ebp], eax
$LN30@gif_decode:
	mov	ecx, DWORD PTR _y$[ebp]
	cmp	ecx, DWORD PTR _height$[ebp]
	jae	$LN28@gif_decode

; 963  :             if (interlace)

	cmp	DWORD PTR _interlace$[ebp], 0
	je	SHORT $LN27@gif_decode

; 964  :                 decode_y = gif_interlaced_line(height, y) + offset_y;

	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _height$[ebp]
	push	eax
	call	_gif_interlaced_line
	add	esp, 8
	add	eax, DWORD PTR _offset_y$[ebp]
	mov	DWORD PTR _decode_y$[ebp], eax

; 965  :             else

	jmp	SHORT $LN26@gif_decode
$LN27@gif_decode:

; 966  :                 decode_y = y + offset_y;

	mov	ecx, DWORD PTR _y$[ebp]
	add	ecx, DWORD PTR _offset_y$[ebp]
	mov	DWORD PTR _decode_y$[ebp], ecx
$LN26@gif_decode:

; 967  :             frame_scanline = frame_data + offset_x + (decode_y * gif->width);

	mov	edx, DWORD PTR _offset_x$[ebp]
	mov	eax, DWORD PTR _frame_data$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR _decode_y$[ebp]
	imul	eax, DWORD PTR [edx+28]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _frame_scanline$[ebp], ecx

; 968  : 
; 969  :             /*    Rather than decoding pixel by pixel, we try to burst out streams
; 970  :                 of data to remove the need for end-of data checks every pixel.
; 971  :             */
; 972  :             x = width;

	mov	edx, DWORD PTR _width$[ebp]
	mov	DWORD PTR _x$[ebp], edx
$LN25@gif_decode:

; 973  :             while (x > 0) {

	cmp	DWORD PTR _x$[ebp], 0
	jbe	$LN24@gif_decode

; 974  :                 burst_bytes = (gif->stack_pointer - gif->stack);

	mov	eax, DWORD PTR _gif$[ebp]
	add	eax, 32876				; 0000806cH
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR [ecx+41068]
	sub	edx, eax
	mov	DWORD PTR _burst_bytes$[ebp], edx

; 975  :                 if (burst_bytes > 0) {

	je	$LN23@gif_decode

; 976  :                     if (burst_bytes > x)

	mov	eax, DWORD PTR _burst_bytes$[ebp]
	cmp	eax, DWORD PTR _x$[ebp]
	jbe	SHORT $LN22@gif_decode

; 977  :                         burst_bytes = x;

	mov	ecx, DWORD PTR _x$[ebp]
	mov	DWORD PTR _burst_bytes$[ebp], ecx
$LN22@gif_decode:

; 978  :                     x -= burst_bytes;

	mov	edx, DWORD PTR _x$[ebp]
	sub	edx, DWORD PTR _burst_bytes$[ebp]
	mov	DWORD PTR _x$[ebp], edx
$LN21@gif_decode:

; 979  :                     while (burst_bytes-- > 0) {

	mov	eax, DWORD PTR _burst_bytes$[ebp]
	mov	DWORD PTR tv344[ebp], eax
	mov	ecx, DWORD PTR _burst_bytes$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _burst_bytes$[ebp], ecx
	cmp	DWORD PTR tv344[ebp], 0
	jbe	SHORT $LN20@gif_decode

; 980  :                         colour = *--gif->stack_pointer;

	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+41068]
	sub	eax, 1
	mov	DWORD PTR tv347[ebp], eax
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR tv347[ebp]
	mov	DWORD PTR [ecx+41068], edx
	mov	eax, DWORD PTR tv347[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _colour$[ebp], cl

; 981  :                         if (((gif->frames[frame].transparency) &&
; 982  :                             (colour != gif->frames[frame].transparency_index)) ||
; 983  :                             (!gif->frames[frame].transparency))

	imul	edx, DWORD PTR _frame$[ebp], 52
	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	cmp	DWORD PTR [ecx+edx+28], 0
	je	SHORT $LN17@gif_decode
	movzx	edx, BYTE PTR _colour$[ebp]
	imul	eax, DWORD PTR _frame$[ebp], 52
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [ecx+44]
	movzx	eax, BYTE PTR [ecx+eax+32]
	cmp	edx, eax
	jne	SHORT $LN18@gif_decode
$LN17@gif_decode:
	imul	ecx, DWORD PTR _frame$[ebp], 52
	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+44]
	cmp	DWORD PTR [eax+ecx+28], 0
	jne	SHORT $LN19@gif_decode
$LN18@gif_decode:

; 984  :                                 *frame_scanline = colour_table[colour];

	movzx	ecx, BYTE PTR _colour$[ebp]
	mov	edx, DWORD PTR _frame_scanline$[ebp]
	mov	eax, DWORD PTR _colour_table$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edx], ecx
$LN19@gif_decode:

; 985  :                         frame_scanline++;

	mov	edx, DWORD PTR _frame_scanline$[ebp]
	add	edx, 4
	mov	DWORD PTR _frame_scanline$[ebp], edx

; 986  :                     }

	jmp	$LN21@gif_decode
$LN20@gif_decode:

; 987  :                 } else {

	jmp	SHORT $LN16@gif_decode
$LN23@gif_decode:

; 988  :                     if (!gif_next_LZW(gif)) {

	mov	eax, DWORD PTR _gif$[ebp]
	push	eax
	call	_gif_next_LZW
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN16@gif_decode

; 989  :                         /*    Unexpected end of frame, try to recover
; 990  :                         */
; 991  :                         if (gif->current_error == GIF_END_OF_FRAME)

	mov	ecx, DWORD PTR _gif$[ebp]
	cmp	DWORD PTR [ecx+60], -7			; fffffff9H
	jne	SHORT $LN14@gif_decode

; 992  :                             return_value = GIF_OK;

	mov	DWORD PTR _return_value$[ebp], 0

; 993  :                         else

	jmp	SHORT $LN13@gif_decode
$LN14@gif_decode:

; 994  :                             return_value = gif->current_error;

	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	DWORD PTR _return_value$[ebp], eax
$LN13@gif_decode:

; 995  :                         goto gif_decode_frame_exit;

	jmp	$gif_decode_frame_exit$71
$LN16@gif_decode:

; 996  :                     }
; 997  :                 }
; 998  :             }

	jmp	$LN25@gif_decode
$LN24@gif_decode:

; 999  :         }

	jmp	$LN29@gif_decode
$LN28@gif_decode:

; 1000 :     } else {

	jmp	$gif_decode_frame_exit$71
$LN47@gif_decode:

; 1001 :         /*    Clear our frame
; 1002 :         */
; 1003 :         if (gif->frames[frame].disposal_method == GIF_FRAME_CLEAR) {

	imul	ecx, DWORD PTR _frame$[ebp], 52
	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+44]
	movzx	ecx, BYTE PTR [eax+ecx+24]
	cmp	ecx, 2
	jne	$gif_decode_frame_exit$71

; 1004 :             for (y = 0; y < height; y++) {

	mov	DWORD PTR _y$[ebp], 0
	jmp	SHORT $LN10@gif_decode
$LN9@gif_decode:
	mov	edx, DWORD PTR _y$[ebp]
	add	edx, 1
	mov	DWORD PTR _y$[ebp], edx
$LN10@gif_decode:
	mov	eax, DWORD PTR _y$[ebp]
	cmp	eax, DWORD PTR _height$[ebp]
	jae	SHORT $gif_decode_frame_exit$71

; 1005 :                 frame_scanline = frame_data + offset_x + ((offset_y + y) * gif->width);

	mov	ecx, DWORD PTR _offset_x$[ebp]
	mov	edx, DWORD PTR _frame_data$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _offset_y$[ebp]
	add	ecx, DWORD PTR _y$[ebp]
	mov	edx, DWORD PTR _gif$[ebp]
	imul	ecx, DWORD PTR [edx+28]
	lea	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _frame_scanline$[ebp], eax

; 1006 :                 if (gif->frames[frame].transparency)

	imul	ecx, DWORD PTR _frame$[ebp], 52
	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+44]
	cmp	DWORD PTR [eax+ecx+28], 0
	je	SHORT $LN7@gif_decode

; 1007 :                     memset(frame_scanline, GIF_TRANSPARENT_COLOUR, width * 4);

	mov	ecx, DWORD PTR _width$[ebp]
	shl	ecx, 2
	push	ecx
	push	0
	mov	edx, DWORD PTR _frame_scanline$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 1008 :                 else

	jmp	SHORT $LN6@gif_decode
$LN7@gif_decode:

; 1009 :                     memset(frame_scanline, colour_table[gif->background_index], width * 4);

	mov	eax, DWORD PTR _width$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	eax, DWORD PTR _colour_table$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	edx, DWORD PTR _frame_scanline$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH
$LN6@gif_decode:

; 1010 :             }

	jmp	SHORT $LN9@gif_decode
$gif_decode_frame_exit$71:

; 1011 :         }
; 1012 :     }
; 1013 : gif_decode_frame_exit:
; 1014 : 
; 1015 :     /*    Check if we should test for optimisation
; 1016 :     */
; 1017 :     if (gif->frames[frame].virgin) {

	imul	eax, DWORD PTR _frame$[ebp], 52
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	cmp	DWORD PTR [edx+eax+12], 0
	je	SHORT $LN5@gif_decode

; 1018 :         if (gif->bitmap_callbacks.bitmap_test_opaque)

	mov	eax, DWORD PTR _gif$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN4@gif_decode

; 1019 :             gif->frames[frame].opaque = gif->bitmap_callbacks.bitmap_test_opaque(gif->frame_image);

	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	call	ecx
	add	esp, 4
	imul	edx, DWORD PTR _frame$[ebp], 52
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [ecx+44]
	mov	DWORD PTR [ecx+edx+16], eax

; 1020 :         else

	jmp	SHORT $LN3@gif_decode
$LN4@gif_decode:

; 1021 :             gif->frames[frame].opaque = FALSE;

	imul	edx, DWORD PTR _frame$[ebp], 52
	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR [ecx+edx+16], 0
$LN3@gif_decode:

; 1022 :         gif->frames[frame].virgin = FALSE;

	imul	edx, DWORD PTR _frame$[ebp], 52
	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR [ecx+edx+12], 0
$LN5@gif_decode:

; 1023 :     }
; 1024 :     if (gif->bitmap_callbacks.bitmap_set_opaque)

	mov	edx, DWORD PTR _gif$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@gif_decode

; 1025 :         gif->bitmap_callbacks.bitmap_set_opaque(gif->frame_image, gif->frames[frame].opaque);

	imul	eax, DWORD PTR _frame$[ebp], 52
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx+eax+16]
	push	eax
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	ecx
	add	esp, 8
$LN2@gif_decode:

; 1026 :     if (gif->bitmap_callbacks.bitmap_modified)

	mov	edx, DWORD PTR _gif$[ebp]
	cmp	DWORD PTR [edx+20], 0
	je	SHORT $LN1@gif_decode

; 1027 :         gif->bitmap_callbacks.bitmap_modified(gif->frame_image);

	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+20]
	call	eax
	add	esp, 4
$LN1@gif_decode:

; 1028 : 
; 1029 :     /*    Restore the buffer position
; 1030 :     */
; 1031 :     gif->buffer_position = save_buffer_position;

	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR _save_buffer_position$[ebp]
	mov	DWORD PTR [ecx+64], edx

; 1032 : 
; 1033 :     /*    Success!
; 1034 :     */
; 1035 :     return return_value;

	mov	eax, DWORD PTR _return_value$[ebp]
$LN69@gif_decode:

; 1036 : 
; 1037 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_gif_decode_frame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\libnsgif.c
;	COMDAT _gif_initialise
_TEXT	SEGMENT
tv222 = -28						; size = 4
tv215 = -24						; size = 4
_entry$1 = -20						; size = 4
_entry$2 = -16						; size = 4
_index$ = -12						; size = 4
_return_value$ = -8					; size = 4
_gif_data$ = -4						; size = 4
_gif$ = 8						; size = 4
_size$ = 12						; size = 4
_data$ = 16						; size = 4
_gif_initialise PROC					; COMDAT

; 156  : gif_result gif_initialise(gif_animation *gif, size_t size, unsigned char *data) {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi

; 157  :     unsigned char *gif_data;
; 158  :     unsigned int index;
; 159  :     gif_result return_value;
; 160  : 
; 161  :     /*     The GIF format is thoroughly documented; a full description
; 162  :      *    can be found at http://www.w3.org/Graphics/GIF/spec-gif89a.txt
; 163  :     */
; 164  : 
; 165  :     /*    Initialize values
; 166  :     */
; 167  :     gif->buffer_size = size;

	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [eax+68], ecx

; 168  :     gif->gif_data = data;

	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR [edx+24], eax

; 169  :     
; 170  :     /*    Check for sufficient data to be a GIF (6-byte header + 7-byte logical screen descriptor)
; 171  :     */
; 172  :     if (gif->buffer_size < 13) return GIF_INSUFFICIENT_DATA;

	mov	ecx, DWORD PTR _gif$[ebp]
	cmp	DWORD PTR [ecx+68], 13			; 0000000dH
	jae	SHORT $LN31@gif_initia
	mov	eax, -3					; fffffffdH
	jmp	$LN32@gif_initia
$LN31@gif_initia:

; 173  : 
; 174  :     /*    Get our current processing position
; 175  :     */
; 176  :     gif_data = gif->gif_data + gif->buffer_position;

	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _gif$[ebp]
	add	eax, DWORD PTR [ecx+64]
	mov	DWORD PTR _gif_data$[ebp], eax

; 177  : 
; 178  :     /*    See if we should initialise the GIF
; 179  :     */
; 180  :     if (gif->buffer_position == 0) {

	mov	edx, DWORD PTR _gif$[ebp]
	cmp	DWORD PTR [edx+64], 0
	jne	$LN30@gif_initia

; 181  : 
; 182  :         /*    We want everything to be NULL before we start so we've no chance
; 183  :             of freeing bad pointers (paranoia)
; 184  :         */
; 185  :         gif->frame_image = NULL;

	mov	eax, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [eax+52], 0

; 186  :         gif->frames = NULL;

	mov	ecx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [ecx+44], 0

; 187  :         gif->local_colour_table = NULL;

	mov	edx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [edx+96], 0

; 188  :         gif->global_colour_table = NULL;

	mov	eax, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [eax+92], 0

; 189  : 
; 190  :         /*    The caller may have been lazy and not reset any values
; 191  :         */
; 192  :         gif->frame_count = 0;

	mov	ecx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [ecx+36], 0

; 193  :         gif->frame_count_partial = 0;

	mov	edx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [edx+40], 0

; 194  :         gif->decoded_frame = GIF_INVALID_FRAME;

	mov	eax, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [eax+48], -1

; 195  : 
; 196  :         /* 6-byte GIF file header is:
; 197  :          *
; 198  :          *    +0    3CHARS    Signature ('GIF')
; 199  :          *    +3    3CHARS    Version ('87a' or '89a')
; 200  :          */
; 201  :         if (strncmp((const char *) gif_data, "GIF", 3) != 0)

	push	3
	push	OFFSET $SG4294825188
	mov	ecx, DWORD PTR _gif_data$[ebp]
	push	ecx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN29@gif_initia

; 202  :             return GIF_DATA_ERROR;

	mov	eax, -4					; fffffffcH
	jmp	$LN32@gif_initia
$LN29@gif_initia:

; 203  :         gif_data += 3;

	mov	edx, DWORD PTR _gif_data$[ebp]
	add	edx, 3
	mov	DWORD PTR _gif_data$[ebp], edx

; 204  : 
; 205  :         /*    Ensure GIF reports version 87a or 89a
; 206  :         */
; 207  : /*        if ((strncmp(gif_data, "87a", 3) != 0) &&
; 208  :                 (strncmp(gif_data, "89a", 3) != 0))
; 209  :             LOG(("Unknown GIF format - proceeding anyway"));
; 210  : */        gif_data += 3;

	mov	eax, DWORD PTR _gif_data$[ebp]
	add	eax, 3
	mov	DWORD PTR _gif_data$[ebp], eax

; 211  : 
; 212  :         /* 7-byte Logical Screen Descriptor is:
; 213  :          *
; 214  :          *    +0    SHORT    Logical Screen Width
; 215  :          *    +2    SHORT    Logical Screen Height
; 216  :          *    +4    CHAR    __Packed Fields__
; 217  :          *             1BIT    Global Colour Table Flag
; 218  :          *             3BITS    Colour Resolution
; 219  :          *             1BIT    Sort Flag
; 220  :          *             3BITS    Size of Global Colour Table
; 221  :          *    +5    CHAR    Background Colour Index
; 222  :          *    +6    CHAR    Pixel Aspect Ratio
; 223  :          */
; 224  :         gif->width = gif_data[0] | (gif_data[1] << 8);

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _gif_data$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _gif_data$[ebp]
	movzx	edx, BYTE PTR [eax+edx]
	shl	edx, 8
	or	ecx, edx
	mov	eax, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 225  :         gif->height = gif_data[2] | (gif_data[3] << 8);

	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _gif_data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _gif_data$[ebp]
	movzx	edx, BYTE PTR [ecx+edx]
	shl	edx, 8
	or	eax, edx
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 226  :         gif->global_colours = (gif_data[4] & GIF_COLOUR_TABLE_MASK);

	mov	edx, 1
	shl	edx, 2
	mov	eax, DWORD PTR _gif_data$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	and	ecx, 128				; 00000080H
	mov	edx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [edx+88], ecx

; 227  :         gif->colour_table_size = (2 << (gif_data[4] & GIF_COLOUR_TABLE_SIZE_MASK));

	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR _gif_data$[ebp]
	movzx	ecx, BYTE PTR [ecx+eax]
	and	ecx, 7
	mov	edx, 2
	shl	edx, cl
	mov	eax, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [eax+84], edx

; 228  :         gif->background_index = gif_data[5];

	mov	ecx, 1
	imul	edx, ecx, 5
	mov	eax, DWORD PTR _gif_data$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	mov	edx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [edx+76], ecx

; 229  :         gif->aspect_ratio = gif_data[6];

	mov	eax, 1
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _gif_data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [ecx+80], eax

; 230  :         gif->loop_count = 1;

	mov	edx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [edx+56], 1

; 231  :         gif_data += 7;

	mov	eax, DWORD PTR _gif_data$[ebp]
	add	eax, 7
	mov	DWORD PTR _gif_data$[ebp], eax

; 232  : 
; 233  :         /*    Some broken GIFs report the size as the screen size they were created in. As
; 234  :             such, we detect for the common cases and set the sizes as 0 if they are found
; 235  :             which results in the GIF being the maximum size of the frames.
; 236  :         */
; 237  :         if (((gif->width == 640) && (gif->height == 480)) ||
; 238  :                 ((gif->width == 640) && (gif->height == 512)) ||
; 239  :                 ((gif->width == 800) && (gif->height == 600)) ||
; 240  :                 ((gif->width == 1024) && (gif->height == 768)) ||
; 241  :                 ((gif->width == 1280) && (gif->height == 1024)) ||
; 242  :                 ((gif->width == 1600) && (gif->height == 1200)) ||
; 243  :                 ((gif->width == 0) || (gif->height == 0)) ||
; 244  :                 ((gif->width > 2048) || (gif->height > 2048))) {

	mov	ecx, DWORD PTR _gif$[ebp]
	cmp	DWORD PTR [ecx+28], 640			; 00000280H
	jne	SHORT $LN26@gif_initia
	mov	edx, DWORD PTR _gif$[ebp]
	cmp	DWORD PTR [edx+32], 480			; 000001e0H
	je	$LN27@gif_initia
$LN26@gif_initia:
	mov	eax, DWORD PTR _gif$[ebp]
	cmp	DWORD PTR [eax+28], 640			; 00000280H
	jne	SHORT $LN25@gif_initia
	mov	ecx, DWORD PTR _gif$[ebp]
	cmp	DWORD PTR [ecx+32], 512			; 00000200H
	je	$LN27@gif_initia
$LN25@gif_initia:
	mov	edx, DWORD PTR _gif$[ebp]
	cmp	DWORD PTR [edx+28], 800			; 00000320H
	jne	SHORT $LN24@gif_initia
	mov	eax, DWORD PTR _gif$[ebp]
	cmp	DWORD PTR [eax+32], 600			; 00000258H
	je	SHORT $LN27@gif_initia
$LN24@gif_initia:
	mov	ecx, DWORD PTR _gif$[ebp]
	cmp	DWORD PTR [ecx+28], 1024		; 00000400H
	jne	SHORT $LN23@gif_initia
	mov	edx, DWORD PTR _gif$[ebp]
	cmp	DWORD PTR [edx+32], 768			; 00000300H
	je	SHORT $LN27@gif_initia
$LN23@gif_initia:
	mov	eax, DWORD PTR _gif$[ebp]
	cmp	DWORD PTR [eax+28], 1280		; 00000500H
	jne	SHORT $LN22@gif_initia
	mov	ecx, DWORD PTR _gif$[ebp]
	cmp	DWORD PTR [ecx+32], 1024		; 00000400H
	je	SHORT $LN27@gif_initia
$LN22@gif_initia:
	mov	edx, DWORD PTR _gif$[ebp]
	cmp	DWORD PTR [edx+28], 1600		; 00000640H
	jne	SHORT $LN21@gif_initia
	mov	eax, DWORD PTR _gif$[ebp]
	cmp	DWORD PTR [eax+32], 1200		; 000004b0H
	je	SHORT $LN27@gif_initia
$LN21@gif_initia:
	mov	ecx, DWORD PTR _gif$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	je	SHORT $LN27@gif_initia
	mov	edx, DWORD PTR _gif$[ebp]
	cmp	DWORD PTR [edx+32], 0
	je	SHORT $LN27@gif_initia
	mov	eax, DWORD PTR _gif$[ebp]
	cmp	DWORD PTR [eax+28], 2048		; 00000800H
	ja	SHORT $LN27@gif_initia
	mov	ecx, DWORD PTR _gif$[ebp]
	cmp	DWORD PTR [ecx+32], 2048		; 00000800H
	jbe	SHORT $LN28@gif_initia
$LN27@gif_initia:

; 245  :             gif->width = 1;

	mov	edx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [edx+28], 1

; 246  :             gif->height = 1;

	mov	eax, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [eax+32], 1
$LN28@gif_initia:

; 247  :         }
; 248  : 
; 249  :         /*    Allocate some data irrespective of whether we've got any colour tables. We
; 250  :             always get the maximum size in case a GIF is lying to us. It's far better
; 251  :             to give the wrong colours than to trample over some memory somewhere.
; 252  :         */
; 253  :         gif->global_colour_table = (unsigned int *)calloc(GIF_MAX_COLOURS, sizeof(int));

	push	4
	push	256					; 00000100H
	call	_calloc
	add	esp, 8
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [ecx+92], eax

; 254  :         gif->local_colour_table = (unsigned int *)calloc(GIF_MAX_COLOURS, sizeof(int));

	push	4
	push	256					; 00000100H
	call	_calloc
	add	esp, 8
	mov	edx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [edx+96], eax

; 255  :         if ((gif->global_colour_table == NULL) || (gif->local_colour_table == NULL)) {

	mov	eax, DWORD PTR _gif$[ebp]
	cmp	DWORD PTR [eax+92], 0
	je	SHORT $LN18@gif_initia
	mov	ecx, DWORD PTR _gif$[ebp]
	cmp	DWORD PTR [ecx+96], 0
	jne	SHORT $LN19@gif_initia
$LN18@gif_initia:

; 256  :             gif_finalise(gif);

	mov	edx, DWORD PTR _gif$[ebp]
	push	edx
	call	_gif_finalise
	add	esp, 4

; 257  :             return GIF_INSUFFICIENT_MEMORY;

	mov	eax, -5					; fffffffbH
	jmp	$LN32@gif_initia
$LN19@gif_initia:

; 258  :         }
; 259  : 
; 260  :         /*    Set the first colour to a value that will never occur in reality so we
; 261  :             know if we've processed it
; 262  :         */
; 263  :         gif->global_colour_table[0] = GIF_PROCESS_COLOURS;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+92]
	mov	DWORD PTR [ecx+eax], -1442840576	; aa000000H

; 264  :         
; 265  :         /*    Check if the GIF has no frame data (13-byte header + 1-byte termination block)
; 266  :          *    Although generally useless, the GIF specification does not expressly prohibit this
; 267  :          */
; 268  :         if (gif->buffer_size == 14) {

	mov	ecx, DWORD PTR _gif$[ebp]
	cmp	DWORD PTR [ecx+68], 14			; 0000000eH
	jne	SHORT $LN17@gif_initia

; 269  :             if (gif_data[0] == GIF_TRAILER)

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _gif_data$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 59					; 0000003bH
	jne	SHORT $LN16@gif_initia

; 270  :                 return GIF_OK;

	xor	eax, eax
	jmp	$LN32@gif_initia

; 271  :             else

	jmp	SHORT $LN17@gif_initia
$LN16@gif_initia:

; 272  :                 return GIF_INSUFFICIENT_DATA;

	mov	eax, -3					; fffffffdH
	jmp	$LN32@gif_initia
$LN17@gif_initia:

; 273  :         }
; 274  : 
; 275  :         /*    Initialise enough workspace for 4 frames initially
; 276  :         */
; 277  :         if ((gif->frames = (gif_frame *)malloc(sizeof(gif_frame))) == NULL) {

	push	52					; 00000034H
	call	_malloc
	add	esp, 4
	mov	DWORD PTR tv215[ebp], eax
	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR tv215[ebp]
	mov	DWORD PTR [eax+44], ecx
	cmp	DWORD PTR tv215[ebp], 0
	jne	SHORT $LN14@gif_initia

; 278  :             gif_finalise(gif);

	mov	edx, DWORD PTR _gif$[ebp]
	push	edx
	call	_gif_finalise
	add	esp, 4

; 279  :             return GIF_INSUFFICIENT_MEMORY;

	mov	eax, -5					; fffffffbH
	jmp	$LN32@gif_initia
$LN14@gif_initia:

; 280  :         }
; 281  :         gif->frame_holders = 1;

	mov	eax, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [eax+72], 1

; 282  : 
; 283  :         /*    Initialise the sprite header
; 284  :         */
; 285  :         assert(gif->bitmap_callbacks.bitmap_create);
; 286  :         if ((gif->frame_image = gif->bitmap_callbacks.bitmap_create(gif->width, gif->height)) == NULL) {

	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	add	esp, 8
	mov	DWORD PTR tv222[ebp], eax
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR tv222[ebp]
	mov	DWORD PTR [ecx+52], edx
	cmp	DWORD PTR tv222[ebp], 0
	jne	SHORT $LN13@gif_initia

; 287  :             gif_finalise(gif);

	mov	eax, DWORD PTR _gif$[ebp]
	push	eax
	call	_gif_finalise
	add	esp, 4

; 288  :             return GIF_INSUFFICIENT_MEMORY;

	mov	eax, -5					; fffffffbH
	jmp	$LN32@gif_initia
$LN13@gif_initia:

; 289  :         }
; 290  : 
; 291  :         /*    Remember we've done this now
; 292  :         */
; 293  :         gif->buffer_position = gif_data - gif->gif_data;

	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR _gif_data$[ebp]
	sub	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [eax+64], edx
$LN30@gif_initia:

; 294  :     }
; 295  : 
; 296  :     /*    Do the colour map if we haven't already. As the top byte is always 0xff or 0x00
; 297  :         depending on the transparency we know if it's been filled in.
; 298  :     */
; 299  :     if (gif->global_colour_table[0] == GIF_PROCESS_COLOURS) {

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	cmp	DWORD PTR [edx+ecx], -1442840576	; aa000000H
	jne	$LN5@gif_initia

; 300  :         /*    Check for a global colour map signified by bit 7
; 301  :         */
; 302  :         if (gif->global_colours) {

	mov	edx, DWORD PTR _gif$[ebp]
	cmp	DWORD PTR [edx+88], 0
	je	$LN11@gif_initia

; 303  :             if (gif->buffer_size < (gif->colour_table_size * 3 + 12)) {

	mov	eax, DWORD PTR _gif$[ebp]
	imul	ecx, DWORD PTR [eax+84], 3
	add	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _gif$[ebp]
	cmp	DWORD PTR [edx+68], ecx
	jae	SHORT $LN10@gif_initia

; 304  :                 return GIF_INSUFFICIENT_DATA;

	mov	eax, -3					; fffffffdH
	jmp	$LN32@gif_initia
$LN10@gif_initia:

; 305  :             }
; 306  :             for (index = 0; index < gif->colour_table_size; index++) {

	mov	DWORD PTR _index$[ebp], 0
	jmp	SHORT $LN9@gif_initia
$LN8@gif_initia:
	mov	eax, DWORD PTR _index$[ebp]
	add	eax, 1
	mov	DWORD PTR _index$[ebp], eax
$LN9@gif_initia:
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR _index$[ebp]
	cmp	edx, DWORD PTR [ecx+84]
	jae	SHORT $LN7@gif_initia

; 307  :                 /* Gif colour map contents are r,g,b.
; 308  :                  *
; 309  :                  * We want to pack them bytewise into the 
; 310  :                  * colour table, such that the red component
; 311  :                  * is in byte 0 and the alpha component is in
; 312  :                  * byte 3.
; 313  :                  */
; 314  :                 unsigned char *entry = (unsigned char *) &gif->
; 315  :                         global_colour_table[index];

	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	edx, DWORD PTR _index$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _entry$2[ebp], eax

; 316  : 
; 317  :                 entry[0] = gif_data[0];    /* r */

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, 1
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _entry$2[ebp]
	mov	esi, DWORD PTR _gif_data$[ebp]
	mov	dl, BYTE PTR [esi+edx]
	mov	BYTE PTR [eax+ecx], dl

; 318  :                 entry[1] = gif_data[1];    /* g */

	mov	eax, 1
	shl	eax, 0
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _entry$2[ebp]
	mov	esi, DWORD PTR _gif_data$[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [edx+ecx], al

; 319  :                 entry[2] = gif_data[2];    /* b */

	mov	ecx, 1
	shl	ecx, 1
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _entry$2[ebp]
	mov	esi, DWORD PTR _gif_data$[ebp]
	mov	cl, BYTE PTR [esi+ecx]
	mov	BYTE PTR [eax+edx], cl

; 320  :                 entry[3] = 0xff;    /* a */

	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _entry$2[ebp]
	mov	BYTE PTR [ecx+eax], 255			; 000000ffH

; 321  : 
; 322  :                 gif_data += 3;

	mov	edx, DWORD PTR _gif_data$[ebp]
	add	edx, 3
	mov	DWORD PTR _gif_data$[ebp], edx

; 323  :             }

	jmp	$LN8@gif_initia
$LN7@gif_initia:

; 324  :             gif->buffer_position = (gif_data - gif->gif_data);

	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR _gif_data$[ebp]
	sub	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [edx+64], ecx

; 325  :         } else {

	jmp	SHORT $LN5@gif_initia
$LN11@gif_initia:

; 326  :             /*    Create a default colour table with the first two colours as black and white
; 327  :             */
; 328  :             unsigned int *entry = gif->global_colour_table;

	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	DWORD PTR _entry$1[ebp], ecx

; 329  : 
; 330  :             entry[0] = 0x00000000;

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _entry$1[ebp]
	mov	DWORD PTR [ecx+eax], 0

; 331  :             /* Force Alpha channel to opaque */
; 332  :             ((unsigned char *) entry)[3] = 0xff;

	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _entry$1[ebp]
	mov	BYTE PTR [ecx+eax], 255			; 000000ffH

; 333  : 
; 334  :             entry[1] = 0xffffffff;

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _entry$1[ebp]
	mov	DWORD PTR [eax+edx], -1
$LN5@gif_initia:

; 335  :         }
; 336  :     }
; 337  : 
; 338  :     /*    Repeatedly try to initialise frames
; 339  :     */
; 340  :     while ((return_value = gif_initialise_frame(gif)) == GIF_WORKING);

	mov	ecx, DWORD PTR _gif$[ebp]
	push	ecx
	call	_gif_initialise_frame
	add	esp, 4
	mov	DWORD PTR _return_value$[ebp], eax
	cmp	DWORD PTR _return_value$[ebp], 1
	jne	SHORT $LN4@gif_initia
	jmp	SHORT $LN5@gif_initia
$LN4@gif_initia:

; 341  : 
; 342  :     /*    If there was a memory error tell the caller
; 343  :     */
; 344  :     if ((return_value == GIF_INSUFFICIENT_MEMORY) ||
; 345  :             (return_value == GIF_DATA_ERROR))

	cmp	DWORD PTR _return_value$[ebp], -5	; fffffffbH
	je	SHORT $LN2@gif_initia
	cmp	DWORD PTR _return_value$[ebp], -4	; fffffffcH
	jne	SHORT $LN3@gif_initia
$LN2@gif_initia:

; 346  :         return return_value;

	mov	eax, DWORD PTR _return_value$[ebp]
	jmp	SHORT $LN32@gif_initia
$LN3@gif_initia:

; 347  : 
; 348  :     /*    If we didn't have some frames then a GIF_INSUFFICIENT_DATA becomes a
; 349  :         GIF_INSUFFICIENT_FRAME_DATA
; 350  :     */
; 351  :     if ((return_value == GIF_INSUFFICIENT_DATA) && (gif->frame_count_partial > 0))

	cmp	DWORD PTR _return_value$[ebp], -3	; fffffffdH
	jne	SHORT $LN1@gif_initia
	mov	edx, DWORD PTR _gif$[ebp]
	cmp	DWORD PTR [edx+40], 0
	jbe	SHORT $LN1@gif_initia

; 352  :         return GIF_INSUFFICIENT_FRAME_DATA;

	or	eax, -1
	jmp	SHORT $LN32@gif_initia
$LN1@gif_initia:

; 353  : 
; 354  :     /*    Return how many we got
; 355  :     */
; 356  :     return return_value;

	mov	eax, DWORD PTR _return_value$[ebp]
$LN32@gif_initia:

; 357  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_gif_initialise ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\libnsgif.c
;	COMDAT _gif_create
_TEXT	SEGMENT
_gif$ = 8						; size = 4
_bitmap_callbacks$ = 12					; size = 4
_gif_create PROC					; COMDAT

; 136  : void gif_create(gif_animation *gif, gif_bitmap_callback_vt *bitmap_callbacks) {

	push	ebp
	mov	ebp, esp

; 137  :     memset(gif, 0, sizeof(gif_animation));

	push	41128					; 0000a0a8H
	push	0
	mov	eax, DWORD PTR _gif$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 138  :     gif->bitmap_callbacks = *bitmap_callbacks;

	mov	ecx, DWORD PTR _bitmap_callbacks$[ebp]
	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx+20], ecx

; 139  :     gif->decoded_frame = GIF_INVALID_FRAME;

	mov	edx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [edx+48], -1

; 140  : }

	pop	ebp
	ret	0
_gif_create ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\libnsgif.c
;	COMDAT _gif_finalise
_TEXT	SEGMENT
_gif$ = 8						; size = 4
_gif_finalise PROC					; COMDAT

; 1110 : void gif_finalise(gif_animation *gif) {

	push	ebp
	mov	ebp, esp

; 1111 :     /*    Release all our memory blocks
; 1112 :     */
; 1113 :     if (gif->frame_image) {

	mov	eax, DWORD PTR _gif$[ebp]
	cmp	DWORD PTR [eax+52], 0
	je	SHORT $LN1@gif_finali

; 1114 :         assert(gif->bitmap_callbacks.bitmap_destroy);
; 1115 :         gif->bitmap_callbacks.bitmap_destroy(gif->frame_image);

	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	ecx
	add	esp, 4
$LN1@gif_finali:

; 1116 :     }
; 1117 :     gif->frame_image = NULL;

	mov	edx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [edx+52], 0

; 1118 :     free(gif->frames);

	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_free
	add	esp, 4

; 1119 :     gif->frames = NULL;

	mov	edx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [edx+44], 0

; 1120 :     free(gif->local_colour_table);

	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	push	ecx
	call	_free
	add	esp, 4

; 1121 :     gif->local_colour_table = NULL;

	mov	edx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [edx+96], 0

; 1122 :     free(gif->global_colour_table);

	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	push	ecx
	call	_free
	add	esp, 4

; 1123 :     gif->global_colour_table = NULL;

	mov	edx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [edx+92], 0

; 1124 : }

	pop	ebp
	ret	0
_gif_finalise ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\libnsgif.c
;	COMDAT _gif_initialise_sprite
_TEXT	SEGMENT
_max_height$ = -20					; size = 4
_max_width$ = -16					; size = 4
_buffer$ = -12						; size = 4
tv75 = -8						; size = 4
tv71 = -4						; size = 4
_gif$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_gif_initialise_sprite PROC				; COMDAT

; 365  : static gif_result gif_initialise_sprite(gif_animation *gif, unsigned int width, unsigned int height) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 366  :     unsigned int max_width;
; 367  :     unsigned int max_height;
; 368  :     struct bitmap *buffer;
; 369  : 
; 370  :     /*    Check if we've changed
; 371  :     */
; 372  :     if ((width <= gif->width) && (height <= gif->height))

	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR _width$[ebp]
	cmp	ecx, DWORD PTR [eax+28]
	ja	SHORT $LN2@gif_initia
	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR _height$[ebp]
	cmp	eax, DWORD PTR [edx+32]
	ja	SHORT $LN2@gif_initia

; 373  :         return GIF_OK;

	xor	eax, eax
	jmp	$LN3@gif_initia
$LN2@gif_initia:

; 374  : 
; 375  :     /*    Get our maximum values
; 376  :     */
; 377  :     max_width = (width > gif->width) ? width : gif->width;

	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR _width$[ebp]
	cmp	edx, DWORD PTR [ecx+28]
	jbe	SHORT $LN5@gif_initia
	mov	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR tv71[ebp], eax
	jmp	SHORT $LN6@gif_initia
$LN5@gif_initia:
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR tv71[ebp], edx
$LN6@gif_initia:
	mov	eax, DWORD PTR tv71[ebp]
	mov	DWORD PTR _max_width$[ebp], eax

; 378  :     max_height = (height > gif->height) ? height : gif->height;

	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR _height$[ebp]
	cmp	edx, DWORD PTR [ecx+32]
	jbe	SHORT $LN7@gif_initia
	mov	eax, DWORD PTR _height$[ebp]
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN8@gif_initia
$LN7@gif_initia:
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR tv75[ebp], edx
$LN8@gif_initia:
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR _max_height$[ebp], eax

; 379  : 
; 380  :     /*    Allocate some more memory
; 381  :     */
; 382  :     assert(gif->bitmap_callbacks.bitmap_create);
; 383  :     if ((buffer = gif->bitmap_callbacks.bitmap_create(max_width, max_height)) == NULL)

	mov	ecx, DWORD PTR _max_height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _max_width$[ebp]
	push	edx
	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 8
	mov	DWORD PTR _buffer$[ebp], eax
	cmp	DWORD PTR _buffer$[ebp], 0
	jne	SHORT $LN1@gif_initia

; 384  :         return GIF_INSUFFICIENT_MEMORY;

	mov	eax, -5					; fffffffbH
	jmp	SHORT $LN3@gif_initia
$LN1@gif_initia:

; 385  :     assert(gif->bitmap_callbacks.bitmap_destroy);
; 386  :     gif->bitmap_callbacks.bitmap_destroy(gif->frame_image);

	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	eax
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	call	edx
	add	esp, 4

; 387  :     gif->frame_image = buffer;

	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR [eax+52], ecx

; 388  :     gif->width = max_width;

	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR _max_width$[ebp]
	mov	DWORD PTR [edx+28], eax

; 389  :     gif->height = max_height;

	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR _max_height$[ebp]
	mov	DWORD PTR [ecx+32], edx

; 390  : 
; 391  :     /*    Invalidate our currently decoded image
; 392  :     */
; 393  :     gif->decoded_frame = GIF_INVALID_FRAME;

	mov	eax, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [eax+48], -1

; 394  :     return GIF_OK;

	xor	eax, eax
$LN3@gif_initia:

; 395  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_gif_initialise_sprite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\libnsgif.c
;	COMDAT _gif_initialise_frame
_TEXT	SEGMENT
_colour_table_size$ = -60				; size = 4
tv334 = -56						; size = 4
_first_image$ = -52					; size = 4
_return_value$ = -48					; size = 4
_temp_buf$ = -44					; size = 4
_flags$ = -40						; size = 4
_width$ = -36						; size = 4
_height$ = -32						; size = 4
_block_size$ = -28					; size = 4
_gif_end$ = -24						; size = 4
_offset_x$ = -20					; size = 4
_offset_y$ = -16					; size = 4
_gif_bytes$ = -12					; size = 4
_gif_data$ = -8						; size = 4
_frame$ = -4						; size = 4
_gif$ = 8						; size = 4
_gif_initialise_frame PROC				; COMDAT

; 408  : static gif_result gif_initialise_frame(gif_animation *gif) {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	push	esi
	push	edi

; 409  :     int frame;
; 410  :     gif_frame *temp_buf;
; 411  : 
; 412  :     unsigned char *gif_data, *gif_end;
; 413  :     int gif_bytes;
; 414  :     unsigned int flags = 0;

	mov	DWORD PTR _flags$[ebp], 0

; 415  :     unsigned int width, height, offset_x, offset_y;
; 416  :     unsigned int block_size, colour_table_size;
; 417  :     BOOL first_image = TRUE;

	mov	DWORD PTR _first_image$[ebp], 1

; 418  :     gif_result return_value;
; 419  : 
; 420  :     /*    Get the frame to decode and our data position
; 421  :     */
; 422  :     frame = gif->frame_count;

	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR _frame$[ebp], ecx

; 423  : 
; 424  :     /*    Get our buffer position etc.
; 425  :     */
; 426  :     gif_data = (unsigned char *)(gif->gif_data + gif->buffer_position);

	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _gif$[ebp]
	add	eax, DWORD PTR [ecx+64]
	mov	DWORD PTR _gif_data$[ebp], eax

; 427  :     gif_end = (unsigned char *)(gif->gif_data + gif->buffer_size);

	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _gif$[ebp]
	add	eax, DWORD PTR [ecx+68]
	mov	DWORD PTR _gif_end$[ebp], eax

; 428  :     gif_bytes = (gif_end - gif_data);

	mov	edx, DWORD PTR _gif_end$[ebp]
	sub	edx, DWORD PTR _gif_data$[ebp]
	mov	DWORD PTR _gif_bytes$[ebp], edx

; 429  : 
; 430  :     /*    Check if we've finished
; 431  :     */
; 432  :     if ((gif_bytes > 0) && (gif_data[0] == GIF_TRAILER)) return GIF_OK;

	cmp	DWORD PTR _gif_bytes$[ebp], 0
	jle	SHORT $LN31@gif_initia
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _gif_data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 59					; 0000003bH
	jne	SHORT $LN31@gif_initia
	xor	eax, eax
	jmp	$LN32@gif_initia
$LN31@gif_initia:

; 433  :     
; 434  :     /*    Check if we have enough data
; 435  :      *    The shortest block of data is a 4-byte comment extension + 1-byte block terminator + 1-byte gif trailer
; 436  :     */
; 437  :     if (gif_bytes < 6) return GIF_INSUFFICIENT_DATA;

	cmp	DWORD PTR _gif_bytes$[ebp], 6
	jge	SHORT $LN30@gif_initia
	mov	eax, -3					; fffffffdH
	jmp	$LN32@gif_initia
$LN30@gif_initia:

; 438  : 
; 439  :     /*    We could theoretically get some junk data that gives us millions of frames, so
; 440  :         we ensure that we don't have a silly number
; 441  :     */
; 442  :     if (frame > 4096) return GIF_FRAME_DATA_ERROR;

	cmp	DWORD PTR _frame$[ebp], 4096		; 00001000H
	jle	SHORT $LN29@gif_initia
	mov	eax, -2					; fffffffeH
	jmp	$LN32@gif_initia
$LN29@gif_initia:

; 443  : 
; 444  :     /*    Get some memory to store our pointers in etc.
; 445  :     */
; 446  :     if ((int)gif->frame_holders <= frame) {

	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	cmp	edx, DWORD PTR _frame$[ebp]
	jg	SHORT $LN28@gif_initia

; 447  :         /*    Allocate more memory
; 448  :         */
; 449  :         if ((temp_buf = (gif_frame *)realloc(gif->frames,
; 450  :                     (frame + 1) * sizeof(gif_frame))) == NULL)

	mov	eax, DWORD PTR _frame$[ebp]
	add	eax, 1
	imul	ecx, eax, 52
	push	ecx
	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_realloc
	add	esp, 8
	mov	DWORD PTR _temp_buf$[ebp], eax
	cmp	DWORD PTR _temp_buf$[ebp], 0
	jne	SHORT $LN27@gif_initia

; 451  :             return GIF_INSUFFICIENT_MEMORY;

	mov	eax, -5					; fffffffbH
	jmp	$LN32@gif_initia
$LN27@gif_initia:

; 452  :         gif->frames = temp_buf;

	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR _temp_buf$[ebp]
	mov	DWORD PTR [ecx+44], edx

; 453  :         gif->frame_holders = frame + 1;

	mov	eax, DWORD PTR _frame$[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [ecx+72], eax
$LN28@gif_initia:

; 454  :     }
; 455  : 
; 456  :     /*    Store our frame pointer. We would do it when allocating except we
; 457  :         start off with one frame allocated so we can always use realloc.
; 458  :     */
; 459  :     gif->frames[frame].frame_pointer = gif->buffer_position;

	imul	edx, DWORD PTR _frame$[ebp], 52
	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	eax, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [eax+64]
	mov	DWORD PTR [ecx+edx+8], eax

; 460  :     gif->frames[frame].display = FALSE;

	imul	ecx, DWORD PTR _frame$[ebp], 52
	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR [eax+ecx], 0

; 461  :     gif->frames[frame].virgin = TRUE;

	imul	ecx, DWORD PTR _frame$[ebp], 52
	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR [eax+ecx+12], 1

; 462  :     gif->frames[frame].disposal_method = 0;

	imul	ecx, DWORD PTR _frame$[ebp], 52
	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	BYTE PTR [eax+ecx+24], 0

; 463  :     gif->frames[frame].transparency = FALSE;

	imul	ecx, DWORD PTR _frame$[ebp], 52
	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR [eax+ecx+28], 0

; 464  :     gif->frames[frame].frame_delay = 100;

	imul	ecx, DWORD PTR _frame$[ebp], 52
	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR [eax+ecx+4], 100		; 00000064H

; 465  :     gif->frames[frame].redraw_required = FALSE;

	imul	ecx, DWORD PTR _frame$[ebp], 52
	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR [eax+ecx+20], 0

; 466  : 
; 467  :     /*    Invalidate any previous decoding we have of this frame
; 468  :     */
; 469  :     if (gif->decoded_frame == frame)

	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	cmp	edx, DWORD PTR _frame$[ebp]
	jne	SHORT $LN26@gif_initia

; 470  :         gif->decoded_frame = GIF_INVALID_FRAME;

	mov	eax, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [eax+48], -1
$LN26@gif_initia:

; 471  : 
; 472  :     /*    We pretend to initialise the frames, but really we just skip over all
; 473  :         the data contained within. This is all basically a cut down version of
; 474  :         gif_decode_frame that doesn't have any of the LZW bits in it.
; 475  :     */
; 476  : 
; 477  :     /*    Initialise any extensions
; 478  :     */
; 479  :     gif->buffer_position = gif_data - gif->gif_data;

	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR _gif_data$[ebp]
	sub	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [eax+64], edx

; 480  :     if ((return_value = gif_initialise_frame_extensions(gif, frame)) != GIF_OK)

	mov	ecx, DWORD PTR _frame$[ebp]
	push	ecx
	mov	edx, DWORD PTR _gif$[ebp]
	push	edx
	call	_gif_initialise_frame_extensions
	add	esp, 8
	mov	DWORD PTR _return_value$[ebp], eax
	cmp	DWORD PTR _return_value$[ebp], 0
	je	SHORT $LN25@gif_initia

; 481  :         return return_value;

	mov	eax, DWORD PTR _return_value$[ebp]
	jmp	$LN32@gif_initia
$LN25@gif_initia:

; 482  :     gif_data = (gif->gif_data + gif->buffer_position);

	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _gif$[ebp]
	add	ecx, DWORD PTR [edx+64]
	mov	DWORD PTR _gif_data$[ebp], ecx

; 483  :     gif_bytes = (gif_end - gif_data);

	mov	eax, DWORD PTR _gif_end$[ebp]
	sub	eax, DWORD PTR _gif_data$[ebp]
	mov	DWORD PTR _gif_bytes$[ebp], eax

; 484  : 
; 485  :     /*    Check if we've finished
; 486  :     */
; 487  :     if ((gif_bytes = (gif_end - gif_data)) < 1)

	mov	ecx, DWORD PTR _gif_end$[ebp]
	sub	ecx, DWORD PTR _gif_data$[ebp]
	mov	DWORD PTR _gif_bytes$[ebp], ecx
	cmp	DWORD PTR _gif_bytes$[ebp], 1
	jge	SHORT $LN24@gif_initia

; 488  :         return GIF_INSUFFICIENT_FRAME_DATA;

	or	eax, -1
	jmp	$LN32@gif_initia
	jmp	SHORT $LN23@gif_initia
$LN24@gif_initia:

; 489  :     else if (gif_data[0] == GIF_TRAILER) {

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _gif_data$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 59					; 0000003bH
	jne	SHORT $LN23@gif_initia

; 490  :         gif->buffer_position = (gif_data - gif->gif_data);

	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR _gif_data$[ebp]
	sub	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [edx+64], ecx

; 491  :         gif->frame_count = frame + 1;

	mov	eax, DWORD PTR _frame$[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 492  :         return GIF_OK;

	xor	eax, eax
	jmp	$LN32@gif_initia
$LN23@gif_initia:

; 493  :     }
; 494  : 
; 495  :     /*    If we're not done, there should be an image descriptor
; 496  :     */
; 497  :     if (gif_data[0] != GIF_IMAGE_SEPARATOR) return GIF_FRAME_DATA_ERROR;

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _gif_data$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 44					; 0000002cH
	je	SHORT $LN21@gif_initia
	mov	eax, -2					; fffffffeH
	jmp	$LN32@gif_initia
$LN21@gif_initia:

; 498  : 
; 499  :     /*    Do some simple boundary checking
; 500  :     */
; 501  :     offset_x = gif_data[1] | (gif_data[2] << 8);

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _gif_data$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _gif_data$[ebp]
	movzx	eax, BYTE PTR [ecx+eax]
	shl	eax, 8
	or	edx, eax
	mov	DWORD PTR _offset_x$[ebp], edx

; 502  :     offset_y = gif_data[3] | (gif_data[4] << 8);

	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _gif_data$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	mov	edx, 1
	shl	edx, 2
	mov	eax, DWORD PTR _gif_data$[ebp]
	movzx	edx, BYTE PTR [eax+edx]
	shl	edx, 8
	or	ecx, edx
	mov	DWORD PTR _offset_y$[ebp], ecx

; 503  :     width = gif_data[5] | (gif_data[6] << 8);

	mov	eax, 1
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _gif_data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 1
	imul	edx, ecx, 6
	mov	ecx, DWORD PTR _gif_data$[ebp]
	movzx	edx, BYTE PTR [ecx+edx]
	shl	edx, 8
	or	eax, edx
	mov	DWORD PTR _width$[ebp], eax

; 504  :     height = gif_data[7] | (gif_data[8] << 8);

	mov	eax, 1
	imul	ecx, eax, 7
	mov	edx, DWORD PTR _gif_data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 1
	shl	ecx, 3
	mov	edx, DWORD PTR _gif_data$[ebp]
	movzx	ecx, BYTE PTR [edx+ecx]
	shl	ecx, 8
	or	eax, ecx
	mov	DWORD PTR _height$[ebp], eax

; 505  : 
; 506  :     /*    Set up the redraw characteristics. We have to check for extending the area
; 507  :         due to multi-image frames.
; 508  :     */
; 509  :     if (!first_image) {

	cmp	DWORD PTR _first_image$[ebp], 0
	jne	$LN20@gif_initia

; 510  :         if (gif->frames[frame].redraw_x > offset_x) {

	imul	edx, DWORD PTR _frame$[ebp], 52
	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [ecx+edx+36]
	cmp	edx, DWORD PTR _offset_x$[ebp]
	jbe	SHORT $LN19@gif_initia

; 511  :             gif->frames[frame].redraw_width += (gif->frames[frame].redraw_x - offset_x);

	imul	eax, DWORD PTR _frame$[ebp], 52
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	imul	ecx, DWORD PTR _frame$[ebp], 52
	mov	esi, DWORD PTR _gif$[ebp]
	mov	esi, DWORD PTR [esi+44]
	mov	ecx, DWORD PTR [esi+ecx+36]
	sub	ecx, DWORD PTR _offset_x$[ebp]
	add	ecx, DWORD PTR [edx+eax+44]
	imul	edx, DWORD PTR _frame$[ebp], 52
	mov	eax, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [eax+44]
	mov	DWORD PTR [eax+edx+44], ecx

; 512  :             gif->frames[frame].redraw_x = offset_x;

	imul	ecx, DWORD PTR _frame$[ebp], 52
	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	edx, DWORD PTR _offset_x$[ebp]
	mov	DWORD PTR [eax+ecx+36], edx
$LN19@gif_initia:

; 513  :         }
; 514  :         if (gif->frames[frame].redraw_y > offset_y) {

	imul	eax, DWORD PTR _frame$[ebp], 52
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx+eax+40]
	cmp	eax, DWORD PTR _offset_y$[ebp]
	jbe	SHORT $LN18@gif_initia

; 515  :             gif->frames[frame].redraw_height += (gif->frames[frame].redraw_y - offset_y);

	imul	ecx, DWORD PTR _frame$[ebp], 52
	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+44]
	imul	edx, DWORD PTR _frame$[ebp], 52
	mov	esi, DWORD PTR _gif$[ebp]
	mov	esi, DWORD PTR [esi+44]
	mov	edx, DWORD PTR [esi+edx+40]
	sub	edx, DWORD PTR _offset_y$[ebp]
	add	edx, DWORD PTR [eax+ecx+48]
	imul	eax, DWORD PTR _frame$[ebp], 52
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [ecx+44]
	mov	DWORD PTR [ecx+eax+48], edx

; 516  :             gif->frames[frame].redraw_y = offset_y;

	imul	edx, DWORD PTR _frame$[ebp], 52
	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	eax, DWORD PTR _offset_y$[ebp]
	mov	DWORD PTR [ecx+edx+40], eax
$LN18@gif_initia:

; 517  :         }
; 518  :         if ((offset_x + width) > (gif->frames[frame].redraw_x + gif->frames[frame].redraw_width))

	mov	ecx, DWORD PTR _offset_x$[ebp]
	add	ecx, DWORD PTR _width$[ebp]
	imul	edx, DWORD PTR _frame$[ebp], 52
	mov	eax, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [eax+44]
	imul	esi, DWORD PTR _frame$[ebp], 52
	mov	edi, DWORD PTR _gif$[ebp]
	mov	edi, DWORD PTR [edi+44]
	mov	edx, DWORD PTR [eax+edx+36]
	add	edx, DWORD PTR [edi+esi+44]
	cmp	ecx, edx
	jbe	SHORT $LN17@gif_initia

; 519  :             gif->frames[frame].redraw_width = (offset_x + width) - gif->frames[frame].redraw_x;

	mov	eax, DWORD PTR _offset_x$[ebp]
	add	eax, DWORD PTR _width$[ebp]
	imul	ecx, DWORD PTR _frame$[ebp], 52
	mov	edx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR [edx+44]
	sub	eax, DWORD PTR [edx+ecx+36]
	imul	ecx, DWORD PTR _frame$[ebp], 52
	mov	edx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR [edx+44]
	mov	DWORD PTR [edx+ecx+44], eax
$LN17@gif_initia:

; 520  :         if ((offset_y + height) > (gif->frames[frame].redraw_y + gif->frames[frame].redraw_height))

	mov	eax, DWORD PTR _offset_y$[ebp]
	add	eax, DWORD PTR _height$[ebp]
	imul	ecx, DWORD PTR _frame$[ebp], 52
	mov	edx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR [edx+44]
	imul	esi, DWORD PTR _frame$[ebp], 52
	mov	edi, DWORD PTR _gif$[ebp]
	mov	edi, DWORD PTR [edi+44]
	mov	ecx, DWORD PTR [edx+ecx+40]
	add	ecx, DWORD PTR [edi+esi+48]
	cmp	eax, ecx
	jbe	SHORT $LN16@gif_initia

; 521  :             gif->frames[frame].redraw_height = (offset_y + height) - gif->frames[frame].redraw_y;

	mov	edx, DWORD PTR _offset_y$[ebp]
	add	edx, DWORD PTR _height$[ebp]
	imul	eax, DWORD PTR _frame$[ebp], 52
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [ecx+44]
	sub	edx, DWORD PTR [ecx+eax+40]
	imul	eax, DWORD PTR _frame$[ebp], 52
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [ecx+44]
	mov	DWORD PTR [ecx+eax+48], edx
$LN16@gif_initia:

; 522  :     } else {

	jmp	SHORT $LN15@gif_initia
$LN20@gif_initia:

; 523  :         first_image = FALSE;

	mov	DWORD PTR _first_image$[ebp], 0

; 524  :         gif->frames[frame].redraw_x = offset_x;

	imul	edx, DWORD PTR _frame$[ebp], 52
	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	eax, DWORD PTR _offset_x$[ebp]
	mov	DWORD PTR [ecx+edx+36], eax

; 525  :         gif->frames[frame].redraw_y = offset_y;

	imul	ecx, DWORD PTR _frame$[ebp], 52
	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	edx, DWORD PTR _offset_y$[ebp]
	mov	DWORD PTR [eax+ecx+40], edx

; 526  :         gif->frames[frame].redraw_width = width;

	imul	eax, DWORD PTR _frame$[ebp], 52
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR _width$[ebp]
	mov	DWORD PTR [edx+eax+44], ecx

; 527  :         gif->frames[frame].redraw_height = height;

	imul	edx, DWORD PTR _frame$[ebp], 52
	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	eax, DWORD PTR _height$[ebp]
	mov	DWORD PTR [ecx+edx+48], eax
$LN15@gif_initia:

; 528  :     }
; 529  : 
; 530  :     /*    if we are clearing the background then we need to redraw enough to cover the previous
; 531  :         frame too
; 532  :     */
; 533  :     gif->frames[frame].redraw_required = ((gif->frames[frame].disposal_method == GIF_FRAME_CLEAR) ||
; 534  :                         (gif->frames[frame].disposal_method == GIF_FRAME_RESTORE));

	imul	ecx, DWORD PTR _frame$[ebp], 52
	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+44]
	movzx	ecx, BYTE PTR [eax+ecx+24]
	cmp	ecx, 2
	je	SHORT $LN34@gif_initia
	imul	edx, DWORD PTR _frame$[ebp], 52
	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	movzx	edx, BYTE PTR [ecx+edx+24]
	cmp	edx, 3
	je	SHORT $LN34@gif_initia
	mov	DWORD PTR tv334[ebp], 0
	jmp	SHORT $LN35@gif_initia
$LN34@gif_initia:
	mov	DWORD PTR tv334[ebp], 1
$LN35@gif_initia:
	imul	eax, DWORD PTR _frame$[ebp], 52
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR tv334[ebp]
	mov	DWORD PTR [edx+eax+20], ecx

; 535  : 
; 536  :     /*    Boundary checking - shouldn't ever happen except with junk data
; 537  :     */
; 538  :     if (gif_initialise_sprite(gif, (offset_x + width), (offset_y + height)))

	mov	edx, DWORD PTR _offset_y$[ebp]
	add	edx, DWORD PTR _height$[ebp]
	push	edx
	mov	eax, DWORD PTR _offset_x$[ebp]
	add	eax, DWORD PTR _width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _gif$[ebp]
	push	ecx
	call	_gif_initialise_sprite
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN14@gif_initia

; 539  :         return GIF_INSUFFICIENT_MEMORY;

	mov	eax, -5					; fffffffbH
	jmp	$LN32@gif_initia
$LN14@gif_initia:

; 540  : 
; 541  :     /*    Decode the flags
; 542  :     */
; 543  :     flags = gif_data[9];

	mov	edx, 1
	imul	eax, edx, 9
	mov	ecx, DWORD PTR _gif_data$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR _flags$[ebp], edx

; 544  :     colour_table_size = 2 << (flags & GIF_COLOUR_TABLE_SIZE_MASK);

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 7
	mov	eax, 2
	shl	eax, cl
	mov	DWORD PTR _colour_table_size$[ebp], eax

; 545  : 
; 546  :     /*    Move our data onwards and remember we've got a bit of this frame
; 547  :     */
; 548  :     gif_data += 10;

	mov	ecx, DWORD PTR _gif_data$[ebp]
	add	ecx, 10					; 0000000aH
	mov	DWORD PTR _gif_data$[ebp], ecx

; 549  :     gif_bytes = (gif_end - gif_data);

	mov	edx, DWORD PTR _gif_end$[ebp]
	sub	edx, DWORD PTR _gif_data$[ebp]
	mov	DWORD PTR _gif_bytes$[ebp], edx

; 550  :     gif->frame_count_partial = frame + 1;

	mov	eax, DWORD PTR _frame$[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [ecx+40], eax

; 551  : 
; 552  :     /*    Skip the local colour table
; 553  :     */
; 554  :     if (flags & GIF_COLOUR_TABLE_MASK) {

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 128				; 00000080H
	je	SHORT $LN13@gif_initia

; 555  :         gif_data += 3 * colour_table_size;

	imul	eax, DWORD PTR _colour_table_size$[ebp], 3
	add	eax, DWORD PTR _gif_data$[ebp]
	mov	DWORD PTR _gif_data$[ebp], eax

; 556  :         if ((gif_bytes = (gif_end - gif_data)) < 0)

	mov	ecx, DWORD PTR _gif_end$[ebp]
	sub	ecx, DWORD PTR _gif_data$[ebp]
	mov	DWORD PTR _gif_bytes$[ebp], ecx
	jns	SHORT $LN13@gif_initia

; 557  :             return GIF_INSUFFICIENT_FRAME_DATA;

	or	eax, -1
	jmp	$LN32@gif_initia
$LN13@gif_initia:

; 558  :     }
; 559  : 
; 560  :     /*    Ensure we have a correct code size
; 561  :     */
; 562  :     if (gif_data[0] > GIF_MAX_LZW)

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _gif_data$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 12					; 0000000cH
	jle	SHORT $LN11@gif_initia

; 563  :         return GIF_DATA_ERROR;

	mov	eax, -4					; fffffffcH
	jmp	$LN32@gif_initia
$LN11@gif_initia:

; 564  : 
; 565  :     /*    Move our pointer to the actual image data
; 566  :     */
; 567  :     gif_data++;

	mov	eax, DWORD PTR _gif_data$[ebp]
	add	eax, 1
	mov	DWORD PTR _gif_data$[ebp], eax

; 568  :     if (--gif_bytes < 0)

	mov	ecx, DWORD PTR _gif_bytes$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _gif_bytes$[ebp], ecx
	jns	SHORT $LN10@gif_initia

; 569  :         return GIF_INSUFFICIENT_FRAME_DATA;

	or	eax, -1
	jmp	$LN32@gif_initia
$LN10@gif_initia:

; 570  : 
; 571  :     /*    Repeatedly skip blocks until we get a zero block or run out of data
; 572  :      *    These blocks of image data are processed later by gif_decode_frame()
; 573  :     */
; 574  :     block_size = 0;

	mov	DWORD PTR _block_size$[ebp], 0
$LN9@gif_initia:

; 575  :     while (block_size != 1) {

	cmp	DWORD PTR _block_size$[ebp], 1
	je	SHORT $LN8@gif_initia

; 576  :         block_size = gif_data[0] + 1;

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _gif_data$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	add	edx, 1
	mov	DWORD PTR _block_size$[ebp], edx

; 577  :         /*    Check if the frame data runs off the end of the file
; 578  :         */
; 579  :         if ((int)(gif_bytes - block_size) < 0) {

	mov	eax, DWORD PTR _gif_bytes$[ebp]
	sub	eax, DWORD PTR _block_size$[ebp]
	jns	SHORT $LN7@gif_initia

; 580  :             /*    Try to recover by signaling the end of the gif.
; 581  :              *    Once we get garbage data, there is no logical
; 582  :              *    way to determine where the next frame is.
; 583  :              *    It's probably better to partially load the gif
; 584  :              *    than not at all.
; 585  :             */
; 586  :             if (gif_bytes >= 2) {

	cmp	DWORD PTR _gif_bytes$[ebp], 2
	jl	SHORT $LN6@gif_initia

; 587  :                 gif_data[0] = 0;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _gif_data$[ebp]
	mov	BYTE PTR [eax+edx], 0

; 588  :                 gif_data[1] = GIF_TRAILER;

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _gif_data$[ebp]
	mov	BYTE PTR [edx+ecx], 59			; 0000003bH

; 589  :                 gif_bytes = 1;

	mov	DWORD PTR _gif_bytes$[ebp], 1

; 590  :                 ++gif_data;

	mov	eax, DWORD PTR _gif_data$[ebp]
	add	eax, 1
	mov	DWORD PTR _gif_data$[ebp], eax

; 591  :                 break;

	jmp	SHORT $LN8@gif_initia

; 592  :             } else

	jmp	SHORT $LN5@gif_initia
$LN6@gif_initia:

; 593  :                 return GIF_INSUFFICIENT_FRAME_DATA;

	or	eax, -1
	jmp	SHORT $LN32@gif_initia
$LN5@gif_initia:

; 594  :         } else {

	jmp	SHORT $LN4@gif_initia
$LN7@gif_initia:

; 595  :             gif_bytes -= block_size;

	mov	ecx, DWORD PTR _gif_bytes$[ebp]
	sub	ecx, DWORD PTR _block_size$[ebp]
	mov	DWORD PTR _gif_bytes$[ebp], ecx

; 596  :             gif_data += block_size;

	mov	edx, DWORD PTR _gif_data$[ebp]
	add	edx, DWORD PTR _block_size$[ebp]
	mov	DWORD PTR _gif_data$[ebp], edx
$LN4@gif_initia:

; 597  :         }
; 598  :     }

	jmp	SHORT $LN9@gif_initia
$LN8@gif_initia:

; 599  : 
; 600  :     /*    Add the frame and set the display flag
; 601  :     */
; 602  :     gif->buffer_position = gif_data - gif->gif_data;

	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR _gif_data$[ebp]
	sub	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [edx+64], ecx

; 603  :     gif->frame_count = frame + 1;

	mov	eax, DWORD PTR _frame$[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 604  :     gif->frames[frame].display = TRUE;

	imul	edx, DWORD PTR _frame$[ebp], 52
	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR [ecx+edx], 1

; 605  : 
; 606  :     /*    Check if we've finished
; 607  :     */
; 608  :     if (gif_bytes < 1)

	cmp	DWORD PTR _gif_bytes$[ebp], 1
	jge	SHORT $LN3@gif_initia

; 609  :         return GIF_INSUFFICIENT_FRAME_DATA;

	or	eax, -1
	jmp	SHORT $LN32@gif_initia

; 610  :     else

	jmp	SHORT $LN2@gif_initia
$LN3@gif_initia:

; 611  :         if (gif_data[0] == GIF_TRAILER) return GIF_OK;

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _gif_data$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 59					; 0000003bH
	jne	SHORT $LN2@gif_initia
	xor	eax, eax
	jmp	SHORT $LN32@gif_initia
$LN2@gif_initia:

; 612  :     return GIF_WORKING;

	mov	eax, 1
$LN32@gif_initia:

; 613  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_gif_initialise_frame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\libnsgif.c
;	COMDAT _gif_initialise_frame_extensions
_TEXT	SEGMENT
_gif_end$ = -20						; size = 4
_block_size$ = -16					; size = 4
tv79 = -12						; size = 4
_gif_bytes$ = -8					; size = 4
_gif_data$ = -4						; size = 4
_gif$ = 8						; size = 4
_frame$ = 12						; size = 4
_gif_initialise_frame_extensions PROC			; COMDAT

; 620  : static gif_result gif_initialise_frame_extensions(gif_animation *gif, const int frame) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi

; 621  :     unsigned char *gif_data, *gif_end;
; 622  :     int gif_bytes;
; 623  :     unsigned int block_size;
; 624  : 
; 625  :     /*    Get our buffer position etc.
; 626  :     */
; 627  :     gif_data = (unsigned char *)(gif->gif_data + gif->buffer_position);

	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _gif$[ebp]
	add	ecx, DWORD PTR [edx+64]
	mov	DWORD PTR _gif_data$[ebp], ecx

; 628  :     gif_end = (unsigned char *)(gif->gif_data + gif->buffer_size);

	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _gif$[ebp]
	add	ecx, DWORD PTR [edx+68]
	mov	DWORD PTR _gif_end$[ebp], ecx
$LN16@gif_initia:

; 629  :     
; 630  :     /*    Initialise the extensions
; 631  :     */
; 632  :     while (gif_data[0] == GIF_EXTENSION_INTRODUCER) {

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _gif_data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 33					; 00000021H
	jne	$LN15@gif_initia

; 633  :         ++gif_data;

	mov	ecx, DWORD PTR _gif_data$[ebp]
	add	ecx, 1
	mov	DWORD PTR _gif_data$[ebp], ecx

; 634  :         gif_bytes = (gif_end - gif_data);

	mov	edx, DWORD PTR _gif_end$[ebp]
	sub	edx, DWORD PTR _gif_data$[ebp]
	mov	DWORD PTR _gif_bytes$[ebp], edx

; 635  : 
; 636  :         /*    Switch on extension label
; 637  :         */
; 638  :         switch(gif_data[0]) {

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _gif_data$[ebp]
	mov	al, BYTE PTR [edx+ecx]
	mov	BYTE PTR tv79[ebp], al
	cmp	BYTE PTR tv79[ebp], 249			; 000000f9H
	je	SHORT $LN12@gif_initia
	cmp	BYTE PTR tv79[ebp], 254			; 000000feH
	je	$LN5@gif_initia
	cmp	BYTE PTR tv79[ebp], 255			; 000000ffH
	je	$LN8@gif_initia
	jmp	$LN4@gif_initia
$LN12@gif_initia:

; 639  :             /* 6-byte Graphic Control Extension is:
; 640  :              *
; 641  :              *    +0    CHAR    Graphic Control Label
; 642  :              *    +1    CHAR    Block Size
; 643  :              *    +2    CHAR    __Packed Fields__
; 644  :              *            3BITS    Reserved
; 645  :              *            3BITS    Disposal Method
; 646  :              *            1BIT    User Input Flag
; 647  :              *            1BIT    Transparent Color Flag
; 648  :              *    +3    SHORT    Delay Time
; 649  :              *    +5    CHAR    Transparent Color Index
; 650  :             */
; 651  :             case GIF_EXTENSION_GRAPHIC_CONTROL:
; 652  :                 if (gif_bytes < 6) return GIF_INSUFFICIENT_FRAME_DATA;

	cmp	DWORD PTR _gif_bytes$[ebp], 6
	jge	SHORT $LN11@gif_initia
	or	eax, -1
	jmp	$LN17@gif_initia
$LN11@gif_initia:

; 653  :                 gif->frames[frame].frame_delay = gif_data[3] | (gif_data[4] << 8);

	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _gif_data$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	mov	edx, 1
	shl	edx, 2
	mov	eax, DWORD PTR _gif_data$[ebp]
	movzx	edx, BYTE PTR [eax+edx]
	shl	edx, 8
	or	ecx, edx
	imul	eax, DWORD PTR _frame$[ebp], 52
	mov	edx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR [edx+44]
	mov	DWORD PTR [edx+eax+4], ecx

; 654  :                 if (gif_data[2] & GIF_TRANSPARENCY_MASK) {

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _gif_data$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	and	edx, 1
	je	SHORT $LN10@gif_initia

; 655  :                     gif->frames[frame].transparency = TRUE;

	imul	eax, DWORD PTR _frame$[ebp], 52
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR [edx+eax+28], 1

; 656  :                     gif->frames[frame].transparency_index = gif_data[5];

	mov	eax, 1
	imul	ecx, eax, 5
	imul	edx, DWORD PTR _frame$[ebp], 52
	mov	eax, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [eax+44]
	mov	esi, DWORD PTR _gif_data$[ebp]
	mov	cl, BYTE PTR [esi+ecx]
	mov	BYTE PTR [eax+edx+32], cl
$LN10@gif_initia:

; 657  :                 }
; 658  :                 gif->frames[frame].disposal_method = ((gif_data[2] & GIF_DISPOSAL_MASK) >> 2);

	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _gif_data$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	and	ecx, 28					; 0000001cH
	sar	ecx, 2
	imul	edx, DWORD PTR _frame$[ebp], 52
	mov	eax, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [eax+44]
	mov	BYTE PTR [eax+edx+24], cl

; 659  :                 /*    I have encountered documentation and GIFs in the wild that use
; 660  :                  *    0x04 to restore the previous frame, rather than the officially
; 661  :                  *    documented 0x03.  I believe some (older?) software may even actually
; 662  :                  *    export this way.  We handle this as a type of "quirks" mode.
; 663  :                 */
; 664  :                 if (gif->frames[frame].disposal_method == GIF_FRAME_QUIRKS_RESTORE)

	imul	ecx, DWORD PTR _frame$[ebp], 52
	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+44]
	movzx	ecx, BYTE PTR [eax+ecx+24]
	cmp	ecx, 4
	jne	SHORT $LN9@gif_initia

; 665  :                     gif->frames[frame].disposal_method = GIF_FRAME_RESTORE;

	imul	edx, DWORD PTR _frame$[ebp], 52
	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	BYTE PTR [ecx+edx+24], 3
$LN9@gif_initia:

; 666  :                 gif_data += (2 + gif_data[1]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _gif_data$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	mov	edx, DWORD PTR _gif_data$[ebp]
	lea	eax, DWORD PTR [edx+ecx+2]
	mov	DWORD PTR _gif_data$[ebp], eax

; 667  :                 break;

	jmp	$LN13@gif_initia
$LN8@gif_initia:

; 668  : 
; 669  :             /* 14-byte+ Application Extension is:
; 670  :              *
; 671  :              *    +0    CHAR    Application Extension Label
; 672  :              *    +1    CHAR    Block Size
; 673  :              *    +2    8CHARS    Application Identifier
; 674  :              *    +10    3CHARS    Appl. Authentication Code
; 675  :              *    +13    1-256    Application Data (Data sub-blocks)
; 676  :             */
; 677  :             case GIF_EXTENSION_APPLICATION:
; 678  :                 if (gif_bytes < 17) return GIF_INSUFFICIENT_FRAME_DATA;

	cmp	DWORD PTR _gif_bytes$[ebp], 17		; 00000011H
	jge	SHORT $LN7@gif_initia
	or	eax, -1
	jmp	$LN17@gif_initia
$LN7@gif_initia:

; 679  :                 if ((gif_data[1] == 0x0b) &&
; 680  :                     (strncmp((const char *) gif_data + 2,
; 681  :                         "NETSCAPE2.0", 11) == 0) &&
; 682  :                     (gif_data[13] == 0x03) &&
; 683  :                     (gif_data[14] == 0x01)) {

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _gif_data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 11					; 0000000bH
	jne	SHORT $LN6@gif_initia
	push	11					; 0000000bH
	push	OFFSET $SG4294825187
	mov	ecx, DWORD PTR _gif_data$[ebp]
	add	ecx, 2
	push	ecx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@gif_initia
	mov	edx, 1
	imul	eax, edx, 13
	mov	ecx, DWORD PTR _gif_data$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 3
	jne	SHORT $LN6@gif_initia
	mov	eax, 1
	imul	ecx, eax, 14
	mov	edx, DWORD PTR _gif_data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 1
	jne	SHORT $LN6@gif_initia

; 684  :                         gif->loop_count = gif_data[15] | (gif_data[16] << 8);

	mov	ecx, 1
	imul	edx, ecx, 15
	mov	eax, DWORD PTR _gif_data$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	mov	edx, 1
	shl	edx, 4
	mov	eax, DWORD PTR _gif_data$[ebp]
	movzx	edx, BYTE PTR [eax+edx]
	shl	edx, 8
	or	ecx, edx
	mov	eax, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [eax+56], ecx
$LN6@gif_initia:

; 685  :                 }
; 686  :                 gif_data += (2 + gif_data[1]);

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _gif_data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, DWORD PTR _gif_data$[ebp]
	lea	edx, DWORD PTR [ecx+eax+2]
	mov	DWORD PTR _gif_data$[ebp], edx

; 687  :                 break;

	jmp	SHORT $LN13@gif_initia
$LN5@gif_initia:

; 688  : 
; 689  :             /*    Move the pointer to the first data sub-block
; 690  :              *    Skip 1 byte for the extension label
; 691  :             */
; 692  :             case GIF_EXTENSION_COMMENT:
; 693  :                 ++gif_data;

	mov	eax, DWORD PTR _gif_data$[ebp]
	add	eax, 1
	mov	DWORD PTR _gif_data$[ebp], eax

; 694  :                 break;

	jmp	SHORT $LN13@gif_initia
$LN4@gif_initia:

; 695  : 
; 696  :             /*    Move the pointer to the first data sub-block
; 697  :              *    Skip 2 bytes for the extension label and size fields
; 698  :              *    Skip the extension size itself
; 699  :             */
; 700  :             default:
; 701  :                 gif_data += (2 + gif_data[1]);

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _gif_data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, DWORD PTR _gif_data$[ebp]
	lea	edx, DWORD PTR [ecx+eax+2]
	mov	DWORD PTR _gif_data$[ebp], edx
$LN13@gif_initia:

; 702  :         }
; 703  : 
; 704  :         /*    Repeatedly skip blocks until we get a zero block or run out of data
; 705  :          *    This data is ignored by this gif decoder
; 706  :         */
; 707  :         gif_bytes = (gif_end - gif_data);

	mov	eax, DWORD PTR _gif_end$[ebp]
	sub	eax, DWORD PTR _gif_data$[ebp]
	mov	DWORD PTR _gif_bytes$[ebp], eax

; 708  :         block_size = 0;

	mov	DWORD PTR _block_size$[ebp], 0
$LN3@gif_initia:

; 709  :         while (gif_data[0] != GIF_BLOCK_TERMINATOR) {

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _gif_data$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	je	SHORT $LN2@gif_initia

; 710  :             block_size = gif_data[0] + 1;

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _gif_data$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	add	edx, 1
	mov	DWORD PTR _block_size$[ebp], edx

; 711  :             if ((gif_bytes -= block_size) < 0)

	mov	eax, DWORD PTR _gif_bytes$[ebp]
	sub	eax, DWORD PTR _block_size$[ebp]
	mov	DWORD PTR _gif_bytes$[ebp], eax
	jns	SHORT $LN1@gif_initia

; 712  :                 return GIF_INSUFFICIENT_FRAME_DATA;

	or	eax, -1
	jmp	SHORT $LN17@gif_initia
$LN1@gif_initia:

; 713  :             gif_data += block_size;

	mov	ecx, DWORD PTR _gif_data$[ebp]
	add	ecx, DWORD PTR _block_size$[ebp]
	mov	DWORD PTR _gif_data$[ebp], ecx

; 714  :         }

	jmp	SHORT $LN3@gif_initia
$LN2@gif_initia:

; 715  :         ++gif_data;

	mov	edx, DWORD PTR _gif_data$[ebp]
	add	edx, 1
	mov	DWORD PTR _gif_data$[ebp], edx

; 716  :     }

	jmp	$LN16@gif_initia
$LN15@gif_initia:

; 717  : 
; 718  :     /*    Set buffer position and return
; 719  :     */
; 720  :     gif->buffer_position = (gif_data - gif->gif_data);

	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR _gif_data$[ebp]
	sub	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [edx+64], ecx

; 721  :     return GIF_OK;

	xor	eax, eax
$LN17@gif_initia:

; 722  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_gif_initialise_frame_extensions ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\libnsgif.c
;	COMDAT _gif_skip_frame_extensions
_TEXT	SEGMENT
tv79 = -20						; size = 4
_gif_end$ = -16						; size = 4
_block_size$ = -12					; size = 4
_gif_bytes$ = -8					; size = 4
_gif_data$ = -4						; size = 4
_gif$ = 8						; size = 4
_gif_skip_frame_extensions PROC				; COMDAT

; 1044 : static gif_result gif_skip_frame_extensions(gif_animation *gif) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 1045 :     unsigned char *gif_data, *gif_end;
; 1046 :     int gif_bytes;
; 1047 :     unsigned int block_size;
; 1048 : 
; 1049 :     /*    Get our buffer position etc.
; 1050 :     */
; 1051 :     gif_data = (unsigned char *)(gif->gif_data + gif->buffer_position);

	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _gif$[ebp]
	add	ecx, DWORD PTR [edx+64]
	mov	DWORD PTR _gif_data$[ebp], ecx

; 1052 :     gif_end = (unsigned char *)(gif->gif_data + gif->buffer_size);

	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _gif$[ebp]
	add	ecx, DWORD PTR [edx+68]
	mov	DWORD PTR _gif_end$[ebp], ecx

; 1053 :     gif_bytes = (gif_end - gif_data);

	mov	eax, DWORD PTR _gif_end$[ebp]
	sub	eax, DWORD PTR _gif_data$[ebp]
	mov	DWORD PTR _gif_bytes$[ebp], eax
$LN9@gif_skip_f:

; 1054 : 
; 1055 :     /*    Skip the extensions
; 1056 :     */
; 1057 :     while (gif_data[0] == GIF_EXTENSION_INTRODUCER) {

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _gif_data$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 33					; 00000021H
	jne	$LN8@gif_skip_f

; 1058 :         ++gif_data;

	mov	edx, DWORD PTR _gif_data$[ebp]
	add	edx, 1
	mov	DWORD PTR _gif_data$[ebp], edx

; 1059 : 
; 1060 :         /*    Switch on extension label
; 1061 :         */
; 1062 :         switch(gif_data[0]) {

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _gif_data$[ebp]
	mov	al, BYTE PTR [edx+ecx]
	mov	BYTE PTR tv79[ebp], al
	cmp	BYTE PTR tv79[ebp], 254			; 000000feH
	je	SHORT $LN5@gif_skip_f
	jmp	SHORT $LN4@gif_skip_f
$LN5@gif_skip_f:

; 1063 :             /*    Move the pointer to the first data sub-block
; 1064 :              *    1 byte for the extension label
; 1065 :             */
; 1066 :             case GIF_EXTENSION_COMMENT:
; 1067 :                 ++gif_data;

	mov	ecx, DWORD PTR _gif_data$[ebp]
	add	ecx, 1
	mov	DWORD PTR _gif_data$[ebp], ecx

; 1068 :                 break;

	jmp	SHORT $LN6@gif_skip_f
$LN4@gif_skip_f:

; 1069 : 
; 1070 :             /*    Move the pointer to the first data sub-block
; 1071 :              *    2 bytes for the extension label and size fields
; 1072 :              *    Skip the extension size itself
; 1073 :             */
; 1074 :             default:
; 1075 :                 gif_data += (2 + gif_data[1]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _gif_data$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	mov	edx, DWORD PTR _gif_data$[ebp]
	lea	eax, DWORD PTR [edx+ecx+2]
	mov	DWORD PTR _gif_data$[ebp], eax
$LN6@gif_skip_f:

; 1076 :         }
; 1077 : 
; 1078 :         /*    Repeatedly skip blocks until we get a zero block or run out of data
; 1079 :          *    This data is ignored by this gif decoder
; 1080 :         */
; 1081 :         gif_bytes = (gif_end - gif_data);

	mov	ecx, DWORD PTR _gif_end$[ebp]
	sub	ecx, DWORD PTR _gif_data$[ebp]
	mov	DWORD PTR _gif_bytes$[ebp], ecx

; 1082 :         block_size = 0;

	mov	DWORD PTR _block_size$[ebp], 0
$LN3@gif_skip_f:

; 1083 :         while (gif_data[0] != GIF_BLOCK_TERMINATOR) {

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _gif_data$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	SHORT $LN2@gif_skip_f

; 1084 :             block_size = gif_data[0] + 1;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _gif_data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	add	eax, 1
	mov	DWORD PTR _block_size$[ebp], eax

; 1085 :             if ((gif_bytes -= block_size) < 0)

	mov	ecx, DWORD PTR _gif_bytes$[ebp]
	sub	ecx, DWORD PTR _block_size$[ebp]
	mov	DWORD PTR _gif_bytes$[ebp], ecx
	jns	SHORT $LN1@gif_skip_f

; 1086 :                 return GIF_INSUFFICIENT_FRAME_DATA;

	or	eax, -1
	jmp	SHORT $LN10@gif_skip_f
$LN1@gif_skip_f:

; 1087 :             gif_data += block_size;

	mov	edx, DWORD PTR _gif_data$[ebp]
	add	edx, DWORD PTR _block_size$[ebp]
	mov	DWORD PTR _gif_data$[ebp], edx

; 1088 :         }

	jmp	SHORT $LN3@gif_skip_f
$LN2@gif_skip_f:

; 1089 :         ++gif_data;

	mov	eax, DWORD PTR _gif_data$[ebp]
	add	eax, 1
	mov	DWORD PTR _gif_data$[ebp], eax

; 1090 :     }

	jmp	$LN9@gif_skip_f
$LN8@gif_skip_f:

; 1091 : 
; 1092 :     /*    Set buffer position and return
; 1093 :     */
; 1094 :     gif->buffer_position = (gif_data - gif->gif_data);

	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR _gif_data$[ebp]
	sub	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [eax+64], edx

; 1095 :     return GIF_OK;

	xor	eax, eax
$LN10@gif_skip_f:

; 1096 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_gif_skip_frame_extensions ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\libnsgif.c
;	COMDAT _gif_interlaced_line
_TEXT	SEGMENT
_height$ = 8						; size = 4
_y$ = 12						; size = 4
_gif_interlaced_line PROC				; COMDAT

; 1098 : static unsigned int gif_interlaced_line(int height, int y) {

	push	ebp
	mov	ebp, esp

; 1099 :     if ((y << 3) < height) return (y << 3);

	mov	eax, DWORD PTR _y$[ebp]
	shl	eax, 3
	cmp	eax, DWORD PTR _height$[ebp]
	jge	SHORT $LN3@gif_interl
	mov	eax, DWORD PTR _y$[ebp]
	shl	eax, 3
	jmp	SHORT $LN4@gif_interl
$LN3@gif_interl:

; 1100 :     y -= ((height + 7) >> 3);

	mov	ecx, DWORD PTR _height$[ebp]
	add	ecx, 7
	sar	ecx, 3
	mov	edx, DWORD PTR _y$[ebp]
	sub	edx, ecx
	mov	DWORD PTR _y$[ebp], edx

; 1101 :     if ((y << 3) < (height - 4)) return (y << 3) + 4;

	mov	eax, DWORD PTR _y$[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR _height$[ebp]
	sub	ecx, 4
	cmp	eax, ecx
	jge	SHORT $LN2@gif_interl
	mov	edx, DWORD PTR _y$[ebp]
	lea	eax, DWORD PTR [edx*8+4]
	jmp	SHORT $LN4@gif_interl
$LN2@gif_interl:

; 1102 :     y -= ((height + 3) >> 3);

	mov	eax, DWORD PTR _height$[ebp]
	add	eax, 3
	sar	eax, 3
	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _y$[ebp], ecx

; 1103 :     if ((y << 2) < (height - 2)) return (y << 2) + 2;

	mov	edx, DWORD PTR _y$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR _height$[ebp]
	sub	eax, 2
	cmp	edx, eax
	jge	SHORT $LN1@gif_interl
	mov	ecx, DWORD PTR _y$[ebp]
	lea	eax, DWORD PTR [ecx*4+2]
	jmp	SHORT $LN4@gif_interl
$LN1@gif_interl:

; 1104 :     y -= ((height + 1) >> 2);

	mov	edx, DWORD PTR _height$[ebp]
	add	edx, 1
	sar	edx, 2
	mov	eax, DWORD PTR _y$[ebp]
	sub	eax, edx
	mov	DWORD PTR _y$[ebp], eax

; 1105 :     return (y << 1) + 1;

	mov	ecx, DWORD PTR _y$[ebp]
	lea	eax, DWORD PTR [ecx+ecx+1]
$LN4@gif_interl:

; 1106 : }

	pop	ebp
	ret	0
_gif_interlaced_line ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\libnsgif.c
;	COMDAT _gif_init_LZW
_TEXT	SEGMENT
tv95 = -8						; size = 4
_i$ = -4						; size = 4
_gif$ = 8						; size = 4
_gif_init_LZW PROC					; COMDAT

; 1129 : void gif_init_LZW(gif_animation *gif) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1130 :     int i;
; 1131 : 
; 1132 :     gif->current_error = 0;

	mov	eax, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [eax+60], 0

; 1133 :     if (gif->clear_code >= (1 << GIF_MAX_LZW)) {

	mov	ecx, DWORD PTR _gif$[ebp]
	cmp	DWORD PTR [ecx+41088], 4096		; 00001000H
	jl	SHORT $LN7@gif_init_L

; 1134 :         gif->stack_pointer = gif->stack;

	mov	edx, DWORD PTR _gif$[ebp]
	add	edx, 32876				; 0000806cH
	mov	eax, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [eax+41068], edx

; 1135 :         gif->current_error = GIF_FRAME_DATA_ERROR;

	mov	ecx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [ecx+60], -2			; fffffffeH

; 1136 :         return;

	jmp	$LN8@gif_init_L
$LN7@gif_init_L:

; 1137 :     }
; 1138 : 
; 1139 :     /* initialise our table */
; 1140 :     memset(gif->table, 0x00, (1 << GIF_MAX_LZW) * 8);

	push	32768					; 00008000H
	push	0
	mov	edx, DWORD PTR _gif$[ebp]
	add	edx, 108				; 0000006cH
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 1141 :     for (i = 0; i < gif->clear_code; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@gif_init_L
$LN5@gif_init_L:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@gif_init_L:
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+41088]
	jge	SHORT $LN4@gif_init_L

; 1142 :         gif->table[1][i] = i;

	mov	eax, 16384				; 00004000H
	shl	eax, 0
	mov	ecx, DWORD PTR _gif$[ebp]
	lea	edx, DWORD PTR [ecx+eax+108]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx
	jmp	SHORT $LN5@gif_init_L
$LN4@gif_init_L:

; 1143 : 
; 1144 :     /* update our LZW parameters */
; 1145 :     gif->code_size = gif->set_code_size + 1;

	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+41076]
	add	eax, 1
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [ecx+41072], eax

; 1146 :     gif->max_code_size = gif->clear_code << 1;

	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+41088]
	shl	eax, 1
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [ecx+41084], eax

; 1147 :     gif->max_code = gif->clear_code + 2;

	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+41088]
	add	eax, 2
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [ecx+41080], eax

; 1148 :     gif->stack_pointer = gif->stack;

	mov	edx, DWORD PTR _gif$[ebp]
	add	edx, 32876				; 0000806cH
	mov	eax, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [eax+41068], edx
$LN3@gif_init_L:

; 1149 :     do {
; 1150 :         gif->firstcode = gif->oldcode = gif_next_code(gif, gif->code_size);

	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR [ecx+41072]
	push	edx
	mov	eax, DWORD PTR _gif$[ebp]
	push	eax
	call	_gif_next_code
	add	esp, 8
	mov	DWORD PTR tv95[ebp], eax
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR tv95[ebp]
	mov	DWORD PTR [ecx+41112], edx
	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR tv95[ebp]
	mov	DWORD PTR [eax+41108], ecx

; 1151 :     } while (gif->firstcode == gif->clear_code);

	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [edx+41108]
	cmp	ecx, DWORD PTR [eax+41088]
	je	SHORT $LN3@gif_init_L

; 1152 :     *gif->stack_pointer++ =gif->firstcode;

	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+41068]
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	dl, BYTE PTR [ecx+41108]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [eax+41068]
	add	ecx, 1
	mov	edx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [edx+41068], ecx
$LN8@gif_init_L:

; 1153 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_gif_init_LZW ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\libnsgif.c
;	COMDAT _gif_next_LZW
_TEXT	SEGMENT
_incode$ = -16						; size = 4
_block_size$ = -12					; size = 4
_new_code$ = -8						; size = 4
_code$ = -4						; size = 4
_gif$ = 8						; size = 4
_gif_next_LZW PROC					; COMDAT

; 1156 : static BOOL gif_next_LZW(gif_animation *gif) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1157 :     int code, incode;
; 1158 :     int block_size;
; 1159 :     int new_code;
; 1160 : 
; 1161 :     code = gif_next_code(gif, gif->code_size);

	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [eax+41072]
	push	ecx
	mov	edx, DWORD PTR _gif$[ebp]
	push	edx
	call	_gif_next_code
	add	esp, 8
	mov	DWORD PTR _code$[ebp], eax

; 1162 :     if (code < 0) {

	cmp	DWORD PTR _code$[ebp], 0
	jge	SHORT $LN15@gif_next_L

; 1163 :           gif->current_error = code;

	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR _code$[ebp]
	mov	DWORD PTR [eax+60], ecx

; 1164 :         return FALSE;

	xor	eax, eax
	jmp	$LN16@gif_next_L
	jmp	$LN14@gif_next_L
$LN15@gif_next_L:

; 1165 :     } else if (code == gif->clear_code) {

	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR _code$[ebp]
	cmp	eax, DWORD PTR [edx+41088]
	jne	SHORT $LN13@gif_next_L

; 1166 :         gif_init_LZW(gif);

	mov	ecx, DWORD PTR _gif$[ebp]
	push	ecx
	call	_gif_init_LZW
	add	esp, 4

; 1167 :         return TRUE;

	mov	eax, 1
	jmp	$LN16@gif_next_L
	jmp	SHORT $LN14@gif_next_L
$LN13@gif_next_L:

; 1168 :     } else if (code == gif->end_code) {

	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR _code$[ebp]
	cmp	eax, DWORD PTR [edx+41092]
	jne	SHORT $LN14@gif_next_L

; 1169 :         /* skip to the end of our data so multi-image GIFs work */
; 1170 :         if (gif->zero_data_block) {

	mov	ecx, DWORD PTR _gif$[ebp]
	cmp	DWORD PTR [ecx+41116], 0
	je	SHORT $LN10@gif_next_L

; 1171 :             gif->current_error = GIF_FRAME_DATA_ERROR;

	mov	edx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [edx+60], -2			; fffffffeH

; 1172 :             return FALSE;

	xor	eax, eax
	jmp	$LN16@gif_next_L
$LN10@gif_next_L:

; 1173 :         }
; 1174 :         block_size = 0;

	mov	DWORD PTR _block_size$[ebp], 0
$LN9@gif_next_L:

; 1175 :         while (block_size != 1) {

	cmp	DWORD PTR _block_size$[ebp], 1
	je	SHORT $LN8@gif_next_L

; 1176 :             block_size = gif->gif_data[gif->buffer_position] + 1;

	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+24]
	movzx	ecx, BYTE PTR [eax+ecx]
	add	ecx, 1
	mov	DWORD PTR _block_size$[ebp], ecx

; 1177 :             gif->buffer_position += block_size;

	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+64]
	add	eax, DWORD PTR _block_size$[ebp]
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [ecx+64], eax

; 1178 :         }

	jmp	SHORT $LN9@gif_next_L
$LN8@gif_next_L:

; 1179 :         gif->current_error = GIF_FRAME_DATA_ERROR;

	mov	edx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [edx+60], -2			; fffffffeH

; 1180 :         return FALSE;

	xor	eax, eax
	jmp	$LN16@gif_next_L
$LN14@gif_next_L:

; 1181 :     }
; 1182 : 
; 1183 :     incode = code;

	mov	eax, DWORD PTR _code$[ebp]
	mov	DWORD PTR _incode$[ebp], eax

; 1184 :     if (code >= gif->max_code) {

	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR _code$[ebp]
	cmp	edx, DWORD PTR [ecx+41080]
	jl	SHORT $LN6@gif_next_L

; 1185 :         *gif->stack_pointer++ = gif->firstcode;

	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [eax+41068]
	mov	edx, DWORD PTR _gif$[ebp]
	mov	al, BYTE PTR [edx+41108]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR [ecx+41068]
	add	edx, 1
	mov	eax, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [eax+41068], edx

; 1186 :         code = gif->oldcode;

	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR [ecx+41112]
	mov	DWORD PTR _code$[ebp], edx
$LN6@gif_next_L:

; 1187 :     }
; 1188 : 
; 1189 :     /* The following loop is the most important in the GIF decoding cycle as every
; 1190 :      * single pixel passes through it.
; 1191 :      *
; 1192 :      * Note: our gif->stack is always big enough to hold a complete decompressed chunk. */
; 1193 :     while (code >= gif->clear_code) {

	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR _code$[ebp]
	cmp	ecx, DWORD PTR [eax+41088]
	jl	$LN5@gif_next_L

; 1194 :         *gif->stack_pointer++ = gif->table[1][code];

	mov	edx, 16384				; 00004000H
	shl	edx, 0
	mov	eax, DWORD PTR _gif$[ebp]
	lea	ecx, DWORD PTR [eax+edx+108]
	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+41068]
	mov	edx, DWORD PTR _code$[ebp]
	mov	cl, BYTE PTR [ecx+edx*4]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+41068]
	add	eax, 1
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [ecx+41068], eax

; 1195 :         new_code = gif->table[0][code];

	mov	edx, 16384				; 00004000H
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _gif$[ebp]
	lea	edx, DWORD PTR [ecx+eax+108]
	mov	eax, DWORD PTR _code$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _new_code$[ebp], ecx

; 1196 :         if (new_code < gif->clear_code) {

	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR _new_code$[ebp]
	cmp	eax, DWORD PTR [edx+41088]
	jge	SHORT $LN4@gif_next_L

; 1197 :             code = new_code;

	mov	ecx, DWORD PTR _new_code$[ebp]
	mov	DWORD PTR _code$[ebp], ecx

; 1198 :             break;

	jmp	SHORT $LN5@gif_next_L
$LN4@gif_next_L:

; 1199 :         }
; 1200 :         *gif->stack_pointer++ = gif->table[1][new_code];

	mov	edx, 16384				; 00004000H
	shl	edx, 0
	mov	eax, DWORD PTR _gif$[ebp]
	lea	ecx, DWORD PTR [eax+edx+108]
	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+41068]
	mov	edx, DWORD PTR _new_code$[ebp]
	mov	cl, BYTE PTR [ecx+edx*4]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+41068]
	add	eax, 1
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [ecx+41068], eax

; 1201 :         code = gif->table[0][new_code];

	mov	edx, 16384				; 00004000H
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _gif$[ebp]
	lea	edx, DWORD PTR [ecx+eax+108]
	mov	eax, DWORD PTR _new_code$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _code$[ebp], ecx

; 1202 :         if (code == new_code) {

	mov	edx, DWORD PTR _code$[ebp]
	cmp	edx, DWORD PTR _new_code$[ebp]
	jne	SHORT $LN3@gif_next_L

; 1203 :               gif->current_error = GIF_FRAME_DATA_ERROR;

	mov	eax, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [eax+60], -2			; fffffffeH

; 1204 :             return FALSE;

	xor	eax, eax
	jmp	$LN16@gif_next_L
$LN3@gif_next_L:

; 1205 :         }
; 1206 :     }

	jmp	$LN6@gif_next_L
$LN5@gif_next_L:

; 1207 : 
; 1208 :     *gif->stack_pointer++ = gif->firstcode = gif->table[1][code];

	mov	ecx, 16384				; 00004000H
	shl	ecx, 0
	mov	edx, DWORD PTR _gif$[ebp]
	lea	eax, DWORD PTR [edx+ecx+108]
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR _code$[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx+41108], eax
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR [ecx+41068]
	mov	eax, DWORD PTR _gif$[ebp]
	mov	cl, BYTE PTR [eax+41108]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+41068]
	add	eax, 1
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [ecx+41068], eax

; 1209 : 
; 1210 :     if ((code = gif->max_code) < (1 << GIF_MAX_LZW)) {

	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+41080]
	mov	DWORD PTR _code$[ebp], eax
	cmp	DWORD PTR _code$[ebp], 4096		; 00001000H
	jge	$LN2@gif_next_L

; 1211 :         gif->table[0][code] = gif->oldcode;

	mov	ecx, 16384				; 00004000H
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _gif$[ebp]
	lea	ecx, DWORD PTR [eax+edx+108]
	mov	edx, DWORD PTR _code$[ebp]
	mov	eax, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [eax+41112]
	mov	DWORD PTR [ecx+edx*4], eax

; 1212 :         gif->table[1][code] = gif->firstcode;

	mov	ecx, 16384				; 00004000H
	shl	ecx, 0
	mov	edx, DWORD PTR _gif$[ebp]
	lea	eax, DWORD PTR [edx+ecx+108]
	mov	ecx, DWORD PTR _code$[ebp]
	mov	edx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR [edx+41108]
	mov	DWORD PTR [eax+ecx*4], edx

; 1213 :         ++gif->max_code;

	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [eax+41080]
	add	ecx, 1
	mov	edx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [edx+41080], ecx

; 1214 :         if ((gif->max_code >= gif->max_code_size) && (gif->max_code_size < (1 << GIF_MAX_LZW))) {

	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR [eax+41080]
	cmp	edx, DWORD PTR [ecx+41084]
	jl	SHORT $LN2@gif_next_L
	mov	eax, DWORD PTR _gif$[ebp]
	cmp	DWORD PTR [eax+41084], 4096		; 00001000H
	jge	SHORT $LN2@gif_next_L

; 1215 :             gif->max_code_size = gif->max_code_size << 1;

	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR [ecx+41084]
	shl	edx, 1
	mov	eax, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [eax+41084], edx

; 1216 :             ++gif->code_size;

	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR [ecx+41072]
	add	edx, 1
	mov	eax, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [eax+41072], edx
$LN2@gif_next_L:

; 1217 :         }
; 1218 :     }
; 1219 :     gif->oldcode = incode;

	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR _incode$[ebp]
	mov	DWORD PTR [ecx+41112], edx

; 1220 :     return TRUE;

	mov	eax, 1
$LN16@gif_next_L:

; 1221 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_gif_next_LZW ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\libnsgif.c
;	COMDAT _gif_next_code
_TEXT	SEGMENT
_j$ = -28						; size = 4
tv129 = -24						; size = 4
_end$ = -20						; size = 4
_b$ = -16						; size = 4
_i$ = -12						; size = 4
_count$ = -8						; size = 4
_ret$ = -4						; size = 4
_gif$ = 8						; size = 4
_code_size$ = 12					; size = 4
_gif_next_code PROC					; COMDAT

; 1223 : static int gif_next_code(gif_animation *gif, int code_size) {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi

; 1224 :     int i, j, end, count, ret;
; 1225 :     unsigned char *b;
; 1226 : 
; 1227 :     end = gif->curbit + gif->code_size;

	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [eax+41096]
	mov	edx, DWORD PTR _gif$[ebp]
	add	ecx, DWORD PTR [edx+41072]
	mov	DWORD PTR _end$[ebp], ecx

; 1228 :     if (end >= gif->lastbit) {

	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR _end$[ebp]
	cmp	ecx, DWORD PTR [eax+41100]
	jl	$LN9@gif_next_c

; 1229 :         if (gif->get_done)

	mov	edx, DWORD PTR _gif$[ebp]
	cmp	DWORD PTR [edx+41120], 0
	je	SHORT $LN8@gif_next_c

; 1230 :             return GIF_END_OF_FRAME;

	mov	eax, -7					; fffffff9H
	jmp	$LN10@gif_next_c
$LN8@gif_next_c:

; 1231 :         gif->buf[0] = gif->direct[gif->last_byte - 2];

	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [eax+41104]
	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	edx, 1
	imul	edx, edx, 0
	mov	esi, DWORD PTR _gif$[ebp]
	mov	al, BYTE PTR [eax+ecx-2]
	mov	BYTE PTR [esi+edx+100], al

; 1232 :         gif->buf[1] = gif->direct[gif->last_byte - 1];

	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR [ecx+41104]
	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	eax, 1
	shl	eax, 0
	mov	esi, DWORD PTR _gif$[ebp]
	mov	cl, BYTE PTR [ecx+edx-1]
	mov	BYTE PTR [esi+eax+100], cl

; 1233 : 
; 1234 :         /* get the next block */
; 1235 :         gif->direct = gif->gif_data + gif->buffer_position;

	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _gif$[ebp]
	add	eax, DWORD PTR [ecx+64]
	mov	edx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [edx+104], eax

; 1236 :         gif->zero_data_block = ((count = gif->direct[0]) == 0);

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+104]
	movzx	ecx, BYTE PTR [eax+ecx]
	mov	DWORD PTR _count$[ebp], ecx
	cmp	DWORD PTR _count$[ebp], 0
	jne	SHORT $LN12@gif_next_c
	mov	DWORD PTR tv129[ebp], 1
	jmp	SHORT $LN13@gif_next_c
$LN12@gif_next_c:
	mov	DWORD PTR tv129[ebp], 0
$LN13@gif_next_c:
	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR tv129[ebp]
	mov	DWORD PTR [edx+41116], eax

; 1237 :         if ((gif->buffer_position + count) >= gif->buffer_size)

	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	add	edx, DWORD PTR _count$[ebp]
	mov	eax, DWORD PTR _gif$[ebp]
	cmp	edx, DWORD PTR [eax+68]
	jb	SHORT $LN7@gif_next_c

; 1238 :             return GIF_INSUFFICIENT_FRAME_DATA;

	or	eax, -1
	jmp	$LN10@gif_next_c
$LN7@gif_next_c:

; 1239 :         if (count == 0)

	cmp	DWORD PTR _count$[ebp], 0
	jne	SHORT $LN6@gif_next_c

; 1240 :             gif->get_done = TRUE;

	mov	ecx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [ecx+41120], 1

; 1241 :         else {

	jmp	SHORT $LN5@gif_next_c
$LN6@gif_next_c:

; 1242 :             gif->direct -= 1;

	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+104]
	sub	eax, 1
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [ecx+104], eax

; 1243 :             gif->buf[2] = gif->direct[2];

	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	eax, 1
	shl	eax, 1
	mov	esi, DWORD PTR _gif$[ebp]
	mov	cl, BYTE PTR [edx+ecx]
	mov	BYTE PTR [esi+eax+100], cl

; 1244 :             gif->buf[3] = gif->direct[3];

	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	ecx, 1
	imul	ecx, ecx, 3
	mov	esi, DWORD PTR _gif$[ebp]
	mov	dl, BYTE PTR [eax+edx]
	mov	BYTE PTR [esi+ecx+100], dl
$LN5@gif_next_c:

; 1245 :         }
; 1246 :         gif->buffer_position += count + 1;

	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR _count$[ebp]
	lea	eax, DWORD PTR [edx+ecx+1]
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [ecx+64], eax

; 1247 : 
; 1248 :         /* update our variables */
; 1249 :         gif->last_byte = 2 + count;

	mov	edx, DWORD PTR _count$[ebp]
	add	edx, 2
	mov	eax, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [eax+41104], edx

; 1250 :         gif->curbit = (gif->curbit - gif->lastbit) + 16;

	mov	ecx, DWORD PTR _gif$[ebp]
	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [ecx+41096]
	sub	eax, DWORD PTR [edx+41100]
	add	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [ecx+41096], eax

; 1251 :         gif->lastbit = (2 + count) << 3;

	mov	edx, DWORD PTR _count$[ebp]
	lea	eax, DWORD PTR [edx*8+16]
	mov	ecx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [ecx+41100], eax

; 1252 :         end = gif->curbit + gif->code_size;

	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+41096]
	mov	ecx, DWORD PTR _gif$[ebp]
	add	eax, DWORD PTR [ecx+41072]
	mov	DWORD PTR _end$[ebp], eax
$LN9@gif_next_c:

; 1253 :     }
; 1254 : 
; 1255 :     i = gif->curbit >> 3;

	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+41096]
	sar	eax, 3
	mov	DWORD PTR _i$[ebp], eax

; 1256 :     if (i < 2)

	cmp	DWORD PTR _i$[ebp], 2
	jge	SHORT $LN4@gif_next_c

; 1257 :         b = gif->buf;

	mov	ecx, DWORD PTR _gif$[ebp]
	add	ecx, 100				; 00000064H
	mov	DWORD PTR _b$[ebp], ecx

; 1258 :     else

	jmp	SHORT $LN3@gif_next_c
$LN4@gif_next_c:

; 1259 :         b = gif->direct;

	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	DWORD PTR _b$[ebp], eax
$LN3@gif_next_c:

; 1260 : 
; 1261 :     ret = b[i];

	mov	ecx, DWORD PTR _b$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _ret$[ebp], edx

; 1262 :     j = (end >> 3) - 1;

	mov	eax, DWORD PTR _end$[ebp]
	sar	eax, 3
	sub	eax, 1
	mov	DWORD PTR _j$[ebp], eax

; 1263 :     if (i <= j) {

	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _j$[ebp]
	jg	SHORT $LN2@gif_next_c

; 1264 :         ret |= (b[i + 1] << 8);

	mov	edx, DWORD PTR _b$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR [edx+1]
	shl	eax, 8
	or	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR _ret$[ebp], eax

; 1265 :         if (i < j)

	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _j$[ebp]
	jge	SHORT $LN2@gif_next_c

; 1266 :             ret |= (b[i + 2] << 16);

	mov	edx, DWORD PTR _b$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR [edx+2]
	shl	eax, 16					; 00000010H
	or	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR _ret$[ebp], eax
$LN2@gif_next_c:

; 1267 :     }
; 1268 :     ret = (ret >> (gif->curbit % 8)) & maskTbl[gif->code_size];

	mov	ecx, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [ecx+41096]
	and	ecx, -2147483641			; 80000007H
	jns	SHORT $LN14@gif_next_c
	dec	ecx
	or	ecx, -8					; fffffff8H
	inc	ecx
$LN14@gif_next_c:
	mov	edx, DWORD PTR _ret$[ebp]
	sar	edx, cl
	mov	eax, DWORD PTR _gif$[ebp]
	mov	ecx, DWORD PTR [eax+41072]
	and	edx, DWORD PTR _maskTbl[ecx*4]
	mov	DWORD PTR _ret$[ebp], edx

; 1269 :     gif->curbit += gif->code_size;

	mov	edx, DWORD PTR _gif$[ebp]
	mov	eax, DWORD PTR [edx+41096]
	mov	ecx, DWORD PTR _gif$[ebp]
	add	eax, DWORD PTR [ecx+41072]
	mov	edx, DWORD PTR _gif$[ebp]
	mov	DWORD PTR [edx+41096], eax

; 1270 :     return ret;

	mov	eax, DWORD PTR _ret$[ebp]
$LN10@gif_next_c:

; 1271 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_gif_next_code ENDP
_TEXT	ENDS
END

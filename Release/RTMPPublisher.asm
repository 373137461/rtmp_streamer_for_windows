; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

	TITLE	F:\songmm_moon_stone_obs\OBS\Source\RTMPPublisher.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_R4RTMPPublisher@@6B@				; RTMPPublisher::`RTTI Complete Object Locator'
PUBLIC	??_7RTMPPublisher@@6B@				; RTMPPublisher::`vftable'
PUBLIC	??_R0?AUTimedPacket@@@8				; TimedPacket `RTTI Type Descriptor'
EXTRN	__imp__ioctlsocket@12:PROC
EXTRN	__imp__WSAIoctl@36:PROC
EXTRN	__vscprintf:PROC
EXTRN	__imp_?Left@String@@QAE?AV1@I@Z:PROC
EXTRN	__imp_?ParseString@XConfig@@QAE_NABVString@@@Z:PROC
EXTRN	__imp__CreateSemaphoreW@16:PROC
EXTRN	__imp__ResetEvent@4:PROC
EXTRN	__imp__WSAGetLastError@0:PROC
EXTRN	__imp__WSAEnumNetworkEvents@12:PROC
EXTRN	__imp__WSAEventSelect@12:PROC
EXTRN	__imp__ReleaseSemaphore@12:PROC
EXTRN	__imp__SetThreadPriority@8:PROC
EXTRN	__imp__MultiByteToWideChar@24:PROC
EXTRN	__imp__shutdown@8:PROC
EXTRN	__imp_?GetDataItem@XElement@@QBEPAVXDataItem@@PB_W@Z:PROC
EXTRN	__imp_?GetDataItemByID@XElement@@QBEPAVXDataItem@@K@Z:PROC
EXTRN	_strncpy:PROC
EXTRN	_vsprintf_s:PROC
EXTRN	__imp__setsockopt@20:PROC
EXTRN	_vsnprintf:PROC
EXTRN	__imp__recv@16:PROC
EXTRN	__imp__closesocket@4:PROC
EXTRN	__imp__GetIfEntry@4:PROC
EXTRN	__imp__GetBestRoute@12:PROC
EXTRN	__imp__gethostbyname@4:PROC
EXTRN	__imp__send@16:PROC
EXTRN	__imp__getsockopt@20:PROC
EXTRN	__imp__WSAStringToAddressW@20:PROC
;	COMDAT ?bRunOnce@?M@??SendLoop@RTMPPublisher@@IAEXXZ@4_NA
_BSS	SEGMENT
?bRunOnce@?M@??SendLoop@RTMPPublisher@@IAEXXZ@4_NA DB 01H DUP (?) ; `RTMPPublisher::SendLoop'::`12'::bRunOnce
_BSS	ENDS
;	COMDAT ??_R0?AUTimedPacket@@@8
data$r	SEGMENT
??_R0?AUTimedPacket@@@8 DD FLAT:??_7type_info@@6B@	; TimedPacket `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUTimedPacket@@', 00H
data$r	ENDS
;	COMDAT ??_7RTMPPublisher@@6B@
CONST	SEGMENT
??_7RTMPPublisher@@6B@ DD FLAT:??_R4RTMPPublisher@@6B@	; RTMPPublisher::`vftable'
	DD	FLAT:??_ERTMPPublisher@@UAEPAXI@Z
	DD	FLAT:?SendPacket@RTMPPublisher@@UAEXPAEIKW4PacketType@@@Z
	DD	FLAT:?BeginPublishing@RTMPPublisher@@UAEXXZ
	DD	FLAT:?GetPacketStrain@RTMPPublisher@@UBENXZ
	DD	FLAT:?GetCurrentSentBytes@RTMPPublisher@@UAE_KXZ
	DD	FLAT:?NumDroppedFrames@RTMPPublisher@@UBEKXZ
	DD	FLAT:?NumTotalVideoFrames@RTMPPublisher@@UBEKXZ
	DD	FLAT:?ProcessPackets@RTMPPublisher@@MAEXXZ
	DD	FLAT:?FlushBufferedPackets@RTMPPublisher@@MAEXXZ
	DD	FLAT:?RequestKeyframe@RTMPPublisher@@MAEXH@Z
CONST	ENDS
;	COMDAT ??_R4RTMPPublisher@@6B@
rdata$r	SEGMENT
??_R4RTMPPublisher@@6B@ DD 00H				; RTMPPublisher::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVRTMPPublisher@@@8
	DD	FLAT:??_R3RTMPPublisher@@8
$SG4294777025 DB 'app', 00H
	ORG $+2
$SG4294777024 DB 'connect', 00H
$SG4294777023 DB 'flashVer', 00H
	ORG $+2
$SG4294777021 DB 'pageUrl', 00H
$SG4294777017 DB 'audioCodecs', 00H
$SG4294777016 DB 'videoCodecs', 00H
	ORG $+2
$SG4294777022 DB 'swfUrl', 00H
	ORG $+1
$SG4294777013 DB '_result', 00H
$SG4294777012 DB 'FCSubscribe', 00H
$SG4294777020 DB 'tcUrl', 00H
	ORG $+2
$SG4294777019 DB 'fpad', 00H
	ORG $+3
$SG4294777018 DB 'capabilities', 00H
	ORG $+3
$SG4294777015 DB 'videoFunction', 00H
	ORG $+2
$SG4294777014 DB 'objectEncoding', 00H
	ORG $+1
$SG4294777009 DB 'deleteStream', 00H
	ORG $+3
$SG4294777008 DB 'getStreamLength', 00H
$SG4294777011 DB 'onFCSubscribe', 00H
	ORG $+2
$SG4294777010 DB 'createStream', 00H
	ORG $+3
$SG4294777005 DB 'mode', 00H
	ORG $+3
$SG4294777004 DB 'level', 00H
	ORG $+2
$SG4294777007 DB 'play', 00H
	ORG $+3
$SG4294777006 DB 'fmsVer', 00H
	ORG $+1
$SG4294777001 DB 'secureToken', 00H
$SG4294777000 DB 'send', 00H
	ORG $+3
$SG4294777003 DB 'code', 00H
	ORG $+3
$SG4294777002 DB 'description', 00H
$SG4294776997 DB 'width', 00H
	ORG $+2
$SG4294776996 DB 'height', 00H
	ORG $+1
$SG4294776999 DB 'onMetaData', 00H
	ORG $+1
$SG4294776998 DB 'duration', 00H
	ORG $+3
$SG4294776993 DB 'framerate', 00H
	ORG $+2
$SG4294776992 DB 'audiocodecid', 00H
	ORG $+3
$SG4294776995 DB 'videocodecid', 00H
	ORG $+3
$SG4294776994 DB 'videodatarate', 00H
	ORG $+2
$SG4294776989 DB 'audiosamplesize', 00H
$SG4294776988 DB 'audiochannels', 00H
	ORG $+2
$SG4294776991 DB 'audiodatarate', 00H
	ORG $+2
$SG4294776990 DB 'audiosamplerate', 00H
$SG4294776985 DB 'fileSize', 00H
	ORG $+3
$SG4294776984 DB 'onStatus', 00H
	ORG $+3
$SG4294776987 DB 'stereo', 00H
	ORG $+1
$SG4294776986 DB 'encoder', 00H
$SG4294776981 DB 'Started playing', 00H
$SG4294776980 DB 'NetStream.Play.Stop', 00H
$SG4294776983 DB 'status', 00H
	ORG $+1
$SG4294776982 DB 'NetStream.Play.Start', 00H
	ORG $+3
$SG4294776977 DB 'clientid', 00H
	ORG $+3
$SG4294776976 DB 'NetStream.Authenticate.UsherToken', 00H
	ORG $+2
$SG4294776979 DB 'Stopped playing', 00H
$SG4294776978 DB 'details', 00H
$SG4294776973 DB '\"', 00H
	ORG $+1
$SG4294776972 DB 'Open Broadcaster Software v0.657b', 00H
	ORG $+2
$SG4294776975 DB '@setDataFrame', 00H
	ORG $+2
$SG4294776974 DB '"', 00H
	ORG $+2
$SG4294776969 DB 'mp3 ', 00H
	ORG $+3
$SG4294776968 DB '%', 00H, 'S', 00H, 0dH, 00H, 0aH, 00H, 00H, 00H
	ORG $+2
$SG4294776971 DB 'avc1', 00H
	ORG $+3
$SG4294776970 DB 'mp4a', 00H
	ORG $+3
$SG4294776965 DB 'R', 00H, 'T', 00H, 'M', 00H, 'P', 00H, 'P', 00H, 'u', 00H
	DB	'b', 00H, 'l', 00H, 'i', 00H, 's', 00H, 'h', 00H, 'e', 00H, 'r'
	DB	00H, ':', 00H, ' ', 00H, 'C', 00H, 'o', 00H, 'u', 00H, 'l', 00H
	DB	'd', 00H, ' ', 00H, 'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'c'
	DB	00H, 'r', 00H, 'e', 00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H
	DB	's', 00H, 'e', 00H, 'm', 00H, 'a', 00H, 'p', 00H, 'h', 00H, 'o'
	DB	00H, 'r', 00H, 'e', 00H, 00H, 00H
$SG4294776967 DB 'l', 00H, 'i', 00H, 'b', 00H, 'r', 00H, 't', 00H, 'm', 00H
	DB	'p', 00H, ' ', 00H, 'e', 00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r'
	DB	00H, ':', 00H, ' ', 00H, '%', 00H, 's', 00H, 00H, 00H
$SG4294776964 DB 'R', 00H, 'T', 00H, 'M', 00H, 'P', 00H, 'P', 00H, 'u', 00H
	DB	'b', 00H, 'l', 00H, 'i', 00H, 's', 00H, 'h', 00H, 'e', 00H, 'r'
	DB	00H, ':', 00H, ' ', 00H, 'C', 00H, 'o', 00H, 'u', 00H, 'l', 00H
	DB	'd', 00H, ' ', 00H, 'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'c'
	DB	00H, 'r', 00H, 'e', 00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H
	DB	'm', 00H, 'u', 00H, 't', 00H, 'e', 00H, 'x', 00H, 00H, 00H
$SG4294776966 DB 0aH, 00H, 00H, 00H
$SG4294776961 DB 'F', 00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H, 'D', 00H
	DB	'r', 00H, 'o', 00H, 'p', 00H, 'T', 00H, 'h', 00H, 'r', 00H, 'e'
	DB	00H, 's', 00H, 'h', 00H, 'o', 00H, 'l', 00H, 'd', 00H, 00H, 00H
	ORG $+2
$SG4294776960 DB 'P', 00H, 'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 's', 00H
	DB	'h', 00H, 00H, 00H
$SG4294776963 DB 'B', 00H, 'F', 00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H
	DB	'D', 00H, 'r', 00H, 'o', 00H, 'p', 00H, 'T', 00H, 'h', 00H, 'r'
	DB	00H, 'e', 00H, 's', 00H, 'h', 00H, 'o', 00H, 'l', 00H, 'd', 00H
	DB	00H, 00H
$SG4294776962 DB 'P', 00H, 'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 's', 00H
	DB	'h', 00H, 00H, 00H
$SG4294776957 DB 'L', 00H, 'o', 00H, 'w', 00H, 'L', 00H, 'a', 00H, 't', 00H
	DB	'e', 00H, 'n', 00H, 'c', 00H, 'y', 00H, 'M', 00H, 'e', 00H, 't'
	DB	00H, 'h', 00H, 'o', 00H, 'd', 00H, 00H, 00H
	ORG $+2
$SG4294776956 DB 'P', 00H, 'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 's', 00H
	DB	'h', 00H, 00H, 00H
$SG4294776959 DB 'L', 00H, 'o', 00H, 'w', 00H, 'L', 00H, 'a', 00H, 't', 00H
	DB	'e', 00H, 'n', 00H, 'c', 00H, 'y', 00H, 'M', 00H, 'o', 00H, 'd'
	DB	00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG4294776958 DB 'P', 00H, 'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 's', 00H
	DB	'h', 00H, 00H, 00H
$SG4294776955 DB 'L', 00H, 'a', 00H, 't', 00H, 'e', 00H, 'n', 00H, 'c', 00H
	DB	'y', 00H, 'F', 00H, 'a', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, 00H, 00H
$SG4294776953 DB 'U', 00H, 's', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H
	DB	'f', 00H, 'i', 00H, 'x', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'l'
	DB	00H, 'o', 00H, 'w', 00H, ' ', 00H, 'l', 00H, 'a', 00H, 't', 00H
	DB	'e', 00H, 'n', 00H, 'c', 00H, 'y', 00H, ' ', 00H, 'm', 00H, 'o'
	DB	00H, 'd', 00H, 'e', 00H, ',', 00H, ' ', 00H, 'f', 00H, 'a', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '%', 00H, 'd'
	DB	00H, 00H, 00H
$SG4294776952 DB 'U', 00H, 's', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H
	DB	'a', 00H, 'u', 00H, 't', 00H, 'o', 00H, 'm', 00H, 'a', 00H, 't'
	DB	00H, 'i', 00H, 'c', 00H, ' ', 00H, 'l', 00H, 'o', 00H, 'w', 00H
	DB	' ', 00H, 'l', 00H, 'a', 00H, 't', 00H, 'e', 00H, 'n', 00H, 'c'
	DB	00H, 'y', 00H, ' ', 00H, 'm', 00H, 'o', 00H, 'd', 00H, 'e', 00H
	DB	00H, 00H
	ORG $+2
$SG4294776954 DB 'P', 00H, 'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 's', 00H
	DB	'h', 00H, 00H, 00H
$SG4294776949 DB 'S', 00H, 'O', 00H, '_', 00H, 'S', 00H, 'N', 00H, 'D', 00H
	DB	'B', 00H, 'U', 00H, 'F', 00H, ' ', 00H, 'w', 00H, 'a', 00H, 's'
	DB	00H, ' ', 00H, 'a', 00H, 't', 00H, ' ', 00H, '%', 00H, 'u', 00H
	DB	00H, 00H
$SG4294776931 DB 'S', 00H, 'e', 00H, 't', 00H, ' ', 00H, 'a', 00H, 'u', 00H
	DB	'd', 00H, 'i', 00H, 'o', 00H, ' ', 00H, 'o', 00H, 'f', 00H, 'f'
	DB	00H, 's', 00H, 'e', 00H, 't', 00H, ':', 00H, ' ', 00H, '%', 00H
	DB	'd', 00H, 0aH, 00H, 00H, 00H
$SG4294776948 DB 'C', 00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, ' ', 00H
	DB	'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'r', 00H, 'a', 00H, 'i'
	DB	00H, 's', 00H, 'e', 00H, ' ', 00H, 'S', 00H, 'O', 00H, '_', 00H
	DB	'S', 00H, 'N', 00H, 'D', 00H, 'B', 00H, 'U', 00H, 'F', 00H, ' '
	DB	00H, 't', 00H, 'o', 00H, ' ', 00H, '%', 00H, 'u', 00H, ',', 00H
	DB	' ', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'u', 00H, 'e', 00H, ' '
	DB	00H, 'i', 00H, 's', 00H, ' ', 00H, 'n', 00H, 'o', 00H, 'w', 00H
	DB	' ', 00H, '%', 00H, 'd', 00H, 00H, 00H
	ORG $+2
$SG4294776951 DB 'F', 00H, 'a', 00H, 's', 00H, 't', 00H, 'I', 00H, 'n', 00H
	DB	'i', 00H, 't', 00H, 'i', 00H, 'a', 00H, 'l', 00H, 'K', 00H, 'e'
	DB	00H, 'y', 00H, 'f', 00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H
	DB	00H, 00H
$SG4294776950 DB 'P', 00H, 'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 's', 00H
	DB	'h', 00H, 00H, 00H
$SG4294776924 DB ' ', 00H, ' ', 00H, 'I', 00H, 'n', 00H, 't', 00H, 'e', 00H
	DB	'r', 00H, 'f', 00H, 'a', 00H, 'c', 00H, 'e', 00H, ':', 00H, ' '
	DB	00H, '%', 00H, 'S', 00H, ' ', 00H, '(', 00H, '%', 00H, 's', 00H
	DB	',', 00H, ' ', 00H, '%', 00H, 'd', 00H, ' ', 00H, 'm', 00H, 'b'
	DB	00H, 'p', 00H, 's', 00H, ')', 00H, 00H, 00H
$SG4294776945 DB 's', 00H, 'e', 00H, 't', 00H, 's', 00H, 'o', 00H, 'c', 00H
	DB	'k', 00H, 'o', 00H, 'p', 00H, 't', 00H, ':', 00H, ' ', 00H, 'F'
	DB	00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H, ' ', 00H
	DB	't', 00H, 'o', 00H, ' ', 00H, 'r', 00H, 'a', 00H, 'i', 00H, 's'
	DB	00H, 'e', 00H, ' ', 00H, 'S', 00H, 'O', 00H, '_', 00H, 'S', 00H
	DB	'N', 00H, 'D', 00H, 'B', 00H, 'U', 00H, 'F', 00H, ' ', 00H, 't'
	DB	00H, 'o', 00H, ' ', 00H, '%', 00H, 'u', 00H, ',', 00H, ' ', 00H
	DB	'e', 00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '%'
	DB	00H, 'd', 00H, 00H, 00H
$SG4294776927 DB 'e', 00H, 't', 00H, 'h', 00H, 'e', 00H, 'r', 00H, 'n', 00H
	DB	'e', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG4294776944 DB 'g', 00H, 'e', 00H, 't', 00H, 's', 00H, 'o', 00H, 'c', 00H
	DB	'k', 00H, 'o', 00H, 'p', 00H, 't', 00H, ':', 00H, ' ', 00H, 'F'
	DB	00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H, ' ', 00H
	DB	't', 00H, 'o', 00H, ' ', 00H, 'q', 00H, 'u', 00H, 'e', 00H, 'r'
	DB	00H, 'y', 00H, ' ', 00H, 'S', 00H, 'O', 00H, '_', 00H, 'S', 00H
	DB	'N', 00H, 'D', 00H, 'B', 00H, 'U', 00H, 'F', 00H, ',', 00H, ' '
	DB	00H, 'e', 00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'%', 00H, 'd', 00H, 00H, 00H
$SG4294776947 DB 'S', 00H, 'O', 00H, '_', 00H, 'S', 00H, 'N', 00H, 'D', 00H
	DB	'B', 00H, 'U', 00H, 'F', 00H, ' ', 00H, 'i', 00H, 's', 00H, ' '
	DB	00H, 'n', 00H, 'o', 00H, 'w', 00H, ' ', 00H, '%', 00H, 'd', 00H
	DB	00H, 00H
$SG4294776946 DB 'g', 00H, 'e', 00H, 't', 00H, 's', 00H, 'o', 00H, 'c', 00H
	DB	'k', 00H, 'o', 00H, 'p', 00H, 't', 00H, ':', 00H, ' ', 00H, 'F'
	DB	00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H, ' ', 00H
	DB	't', 00H, 'o', 00H, ' ', 00H, 'q', 00H, 'u', 00H, 'e', 00H, 'r'
	DB	00H, 'y', 00H, ' ', 00H, 'S', 00H, 'O', 00H, '_', 00H, 'S', 00H
	DB	'N', 00H, 'D', 00H, 'B', 00H, 'U', 00H, 'F', 00H, ',', 00H, ' '
	DB	00H, 'e', 00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'%', 00H, 'd', 00H, 00H, 00H
$SG4294776941 DB '~', 00H, 'R', 00H, 'T', 00H, 'M', 00H, 'P', 00H, 'P', 00H
	DB	'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 's', 00H, 'h', 00H, 'e'
	DB	00H, 'r', 00H, ':', 00H, ' ', 00H, 'P', 00H, 'a', 00H, 'c', 00H
	DB	'k', 00H, 'e', 00H, 't', 00H, ' ', 00H, 'f', 00H, 'l', 00H, 'u'
	DB	00H, 's', 00H, 'h', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'm', 00H
	DB	'p', 00H, 'l', 00H, 'e', 00H, 't', 00H, 'e', 00H, 'd', 00H, ' '
	DB	00H, 'i', 00H, 'n', 00H, ' ', 00H, '%', 00H, 'd', 00H, ' ', 00H
	DB	'm', 00H, 's', 00H, 00H, 00H
$SG4294776940 DB '~', 00H, 'R', 00H, 'T', 00H, 'M', 00H, 'P', 00H, 'P', 00H
	DB	'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 's', 00H, 'h', 00H, 'e'
	DB	00H, 'r', 00H, ':', 00H, ' ', 00H, 'N', 00H, 'e', 00H, 't', 00H
	DB	'w', 00H, 'o', 00H, 'r', 00H, 'k', 00H, ' ', 00H, 'a', 00H, 'p'
	DB	00H, 'p', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 's', 00H, ' ', 00H
	DB	's', 00H, 't', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'e', 00H, 'd'
	DB	00H, ' ', 00H, 'w', 00H, 'i', 00H, 't', 00H, 'h', 00H, ' ', 00H
	DB	'%', 00H, 'd', 00H, ' ', 00H, '/', 00H, ' ', 00H, '%', 00H, 'd'
	DB	00H, ' ', 00H, 'b', 00H, 'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H
	DB	'r', 00H, 'e', 00H, 'd', 00H, ',', 00H, ' ', 00H, 'd', 00H, 'r'
	DB	00H, 'o', 00H, 'p', 00H, 'p', 00H, 'i', 00H, 'n', 00H, 'g', 00H
	DB	' ', 00H, 'c', 00H, 'o', 00H, 'n', 00H, 'n', 00H, 'e', 00H, 'c'
	DB	00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, '!', 00H, 00H, 00H
$SG4294776943 DB 'R', 00H, 'T', 00H, 'M', 00H, 'P', 00H, 'P', 00H, 'u', 00H
	DB	'b', 00H, 'l', 00H, 'i', 00H, 's', 00H, 'h', 00H, 'e', 00H, 'r'
	DB	00H, ':', 00H, ' ', 00H, 'C', 00H, 'o', 00H, 'u', 00H, 'l', 00H
	DB	'd', 00H, ' ', 00H, 'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'c'
	DB	00H, 'r', 00H, 'e', 00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H
	DB	's', 00H, 'e', 00H, 'n', 00H, 'd', 00H, ' ', 00H, 't', 00H, 'h'
	DB	00H, 'r', 00H, 'e', 00H, 'a', 00H, 'd', 00H, 00H, 00H
$SG4294776942 DB 'R', 00H, 'T', 00H, 'M', 00H, 'P', 00H, 'P', 00H, 'u', 00H
	DB	'b', 00H, 'l', 00H, 'i', 00H, 's', 00H, 'h', 00H, 'e', 00H, 'r'
	DB	00H, ':', 00H, ' ', 00H, 'C', 00H, 'o', 00H, 'u', 00H, 'l', 00H
	DB	'd', 00H, ' ', 00H, 'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'c'
	DB	00H, 'r', 00H, 'e', 00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H
	DB	's', 00H, 'e', 00H, 'n', 00H, 'd', 00H, ' ', 00H, 't', 00H, 'h'
	DB	00H, 'r', 00H, 'e', 00H, 'a', 00H, 'd', 00H, 00H, 00H
$SG4294776937 DB '~', 00H, 'R', 00H, 'T', 00H, 'M', 00H, 'P', 00H, 'u', 00H
	DB	'b', 00H, 'l', 00H, 'i', 00H, 's', 00H, 'h', 00H, 'e', 00H, 'r'
	DB	00H, ':', 00H, ' ', 00H, 'R', 00H, 'e', 00H, 'c', 00H, 'e', 00H
	DB	'i', 00H, 'v', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'e', 00H, 'r'
	DB	00H, 'r', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '%', 00H, 'd', 00H
	DB	' ', 00H, 'w', 00H, 'h', 00H, 'i', 00H, 'l', 00H, 'e', 00H, ' '
	DB	00H, 'w', 00H, 'a', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'n', 00H
	DB	'g', 00H, ' ', 00H, 'f', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'g'
	DB	00H, 'r', 00H, 'a', 00H, 'c', 00H, 'e', 00H, 'f', 00H, 'u', 00H
	DB	'l', 00H, ' ', 00H, 's', 00H, 'h', 00H, 'u', 00H, 't', 00H, 'd'
	DB	00H, 'o', 00H, 'w', 00H, 'n', 00H, '.', 00H, 00H, 00H
$SG4294776921 DB 'P', 00H, 'l', 00H, 'a', 00H, 'y', 00H, 'P', 00H, 'a', 00H
	DB	't', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG4294776936 DB '~', 00H, 'R', 00H, 'T', 00H, 'M', 00H, 'P', 00H, 'P', 00H
	DB	'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 's', 00H, 'h', 00H, 'e'
	DB	00H, 'r', 00H, ':', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'n', 00H
	DB	'a', 00H, 'l', 00H, ' ', 00H, 's', 00H, 'o', 00H, 'c', 00H, 'k'
	DB	00H, 'e', 00H, 't', 00H, ' ', 00H, 's', 00H, 'h', 00H, 'u', 00H
	DB	't', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, ' ', 00H, 'c'
	DB	00H, 'o', 00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, 't', 00H
	DB	'e', 00H, 'd', 00H, ' ', 00H, 'i', 00H, 'n', 00H, ' ', 00H, '%'
	DB	00H, 'd', 00H, ' ', 00H, 'm', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG4294776925 DB 't', 00H, 'y', 00H, 'p', 00H, 'e', 00H, ' ', 00H, '%', 00H
	DB	'd', 00H, 00H, 00H
$SG4294776911 DB 'd', 00H, 'a', 00H, 't', 00H, 'a', 00H, 00H, 00H
	ORG $+2
$SG4294776939 DB '~', 00H, 'R', 00H, 'T', 00H, 'M', 00H, 'P', 00H, 'P', 00H
	DB	'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 's', 00H, 'h', 00H, 'e'
	DB	00H, 'r', 00H, ':', 00H, ' ', 00H, 'S', 00H, 'e', 00H, 'n', 00H
	DB	'd', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'r', 00H, 'e', 00H, 'a'
	DB	00H, 'd', 00H, ' ', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'm', 00H
	DB	'i', 00H, 'n', 00H, 'a', 00H, 't', 00H, 'e', 00H, 'd', 00H, ' '
	DB	00H, 'i', 00H, 'n', 00H, ' ', 00H, '%', 00H, 'd', 00H, ' ', 00H
	DB	'm', 00H, 's', 00H, 00H, 00H
$SG4294776938 DB '~', 00H, 'R', 00H, 'T', 00H, 'M', 00H, 'P', 00H, 'P', 00H
	DB	'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 's', 00H, 'h', 00H, 'e'
	DB	00H, 'r', 00H, ':', 00H, ' ', 00H, 'S', 00H, 'o', 00H, 'c', 00H
	DB	'k', 00H, 'e', 00H, 't', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'r'
	DB	00H, 'e', 00H, 'a', 00H, 'd', 00H, ' ', 00H, 't', 00H, 'e', 00H
	DB	'r', 00H, 'm', 00H, 'i', 00H, 'n', 00H, 'a', 00H, 't', 00H, 'e'
	DB	00H, 'd', 00H, ' ', 00H, 'i', 00H, 'n', 00H, ' ', 00H, '%', 00H
	DB	'd', 00H, ' ', 00H, 'm', 00H, 's', 00H, 00H, 00H
$SG4294776905 DB 'W', 00H, 'e', 00H, 'b', 00H, ' ', 00H, 'A', 00H, 'P', 00H
	DB	'I', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 't', 00H, 'u', 00H, 'r'
	DB	00H, 'n', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'U', 00H, 'R', 00H
	DB	'L', 00H, ':', 00H, ' ', 00H, '%', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG4294776933 DB 'N', 00H, 'u', 00H, 'm', 00H, 'b', 00H, 'e', 00H, 'r', 00H
	DB	' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 'b', 00H, '-', 00H, 'f'
	DB	00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H, 's', 00H, ' ', 00H
	DB	'd', 00H, 'r', 00H, 'o', 00H, 'p', 00H, 'p', 00H, 'e', 00H, 'd'
	DB	00H, ':', 00H, ' ', 00H, '%', 00H, 'u', 00H, ' ', 00H, '(', 00H
	DB	'%', 00H, '0', 00H, '.', 00H, '2', 00H, 'g', 00H, '%', 00H, '%'
	DB	00H, ')', 00H, ',', 00H, ' ', 00H, 'N', 00H, 'u', 00H, 'm', 00H
	DB	'b', 00H, 'e', 00H, 'r', 00H, ' ', 00H, 'o', 00H, 'f', 00H, ' '
	DB	00H, 'p', 00H, '-', 00H, 'f', 00H, 'r', 00H, 'a', 00H, 'm', 00H
	DB	'e', 00H, 's', 00H, ' ', 00H, 'd', 00H, 'r', 00H, 'o', 00H, 'p'
	DB	00H, 'p', 00H, 'e', 00H, 'd', 00H, ':', 00H, ' ', 00H, '%', 00H
	DB	'u', 00H, ' ', 00H, '(', 00H, '%', 00H, '0', 00H, '.', 00H, '2'
	DB	00H, 'g', 00H, '%', 00H, '%', 00H, ')', 00H, ',', 00H, ' ', 00H
	DB	'T', 00H, 'o', 00H, 't', 00H, 'a', 00H, 'l', 00H, ' ', 00H, '%'
	DB	00H, 'u', 00H, ' ', 00H, '(', 00H, '%', 00H, '0', 00H, '.', 00H
	DB	'2', 00H, 'g', 00H, '%', 00H, '%', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG4294776932 DB 'N', 00H, 'u', 00H, 'm', 00H, 'b', 00H, 'e', 00H, 'r', 00H
	DB	' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 'b', 00H, 'y', 00H, 't'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, 's', 00H, 'e', 00H, 'n', 00H
	DB	't', 00H, ':', 00H, ' ', 00H, '%', 00H, 'l', 00H, 'l', 00H, 'u'
	DB	00H, 00H, 00H
	ORG $+2
$SG4294776935 DB 'A', 00H, 'v', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 'g', 00H
	DB	'e', 00H, ' ', 00H, 's', 00H, 'e', 00H, 'n', 00H, 'd', 00H, ' '
	DB	00H, 'p', 00H, 'a', 00H, 'y', 00H, 'l', 00H, 'o', 00H, 'a', 00H
	DB	'd', 00H, ':', 00H, ' ', 00H, '%', 00H, 'd', 00H, ' ', 00H, 'b'
	DB	00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H, ',', 00H, ' ', 00H
	DB	'a', 00H, 'v', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 'g', 00H, 'e'
	DB	00H, ' ', 00H, 's', 00H, 'e', 00H, 'n', 00H, 'd', 00H, ' ', 00H
	DB	'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'v', 00H, 'a'
	DB	00H, 'l', 00H, ':', 00H, ' ', 00H, '%', 00H, 'd', 00H, ' ', 00H
	DB	'm', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG4294776920 DB 'P', 00H, 'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 's', 00H
	DB	'h', 00H, 00H, 00H
$SG4294776901 DB 'U', 00H, 's', 00H, 'e', 00H, 'r', 00H, 'n', 00H, 'a', 00H
	DB	'm', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG4294776934 DB 'N', 00H, 'u', 00H, 'm', 00H, 'b', 00H, 'e', 00H, 'r', 00H
	DB	' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 't', 00H, 'i', 00H, 'm'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, 'w', 00H, 'a', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 't', 00H, 'o', 00H, ' '
	DB	00H, 's', 00H, 'e', 00H, 'n', 00H, 'd', 00H, ':', 00H, ' ', 00H
	DB	'%', 00H, 'd', 00H, ',', 00H, ' ', 00H, 'W', 00H, 'a', 00H, 'i'
	DB	00H, 't', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'f', 00H, 'o', 00H
	DB	'r', 00H, ' ', 00H, 'a', 00H, ' ', 00H, 't', 00H, 'o', 00H, 't'
	DB	00H, 'a', 00H, 'l', 00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H
	DB	'%', 00H, 'd', 00H, ' ', 00H, 'b', 00H, 'y', 00H, 't', 00H, 'e'
	DB	00H, 's', 00H, 00H, 00H
	ORG $+2
$SG4294776929 DB 'd', 00H, 'r', 00H, 'o', 00H, 'p', 00H, 'p', 00H, 'e', 00H
	DB	'd', 00H, ' ', 00H, 'b', 00H, '-', 00H, 'f', 00H, 'r', 00H, 'a'
	DB	00H, 'm', 00H, 'e', 00H, 's', 00H, ' ', 00H, 'a', 00H, 't', 00H
	DB	' ', 00H, '%', 00H, 'u', 00H, ',', 00H, ' ', 00H, 't', 00H, 'h'
	DB	00H, 'r', 00H, 'e', 00H, 's', 00H, 'h', 00H, 'o', 00H, 'l', 00H
	DB	'd', 00H, ' ', 00H, 'i', 00H, 's', 00H, ' ', 00H, '%', 00H, 'u'
	DB	00H, ',', 00H, ' ', 00H, 't', 00H, 'o', 00H, 't', 00H, 'a', 00H
	DB	'l', 00H, ' ', 00H, 'd', 00H, 'u', 00H, 'r', 00H, 'a', 00H, 't'
	DB	00H, 'i', 00H, 'o', 00H, 'n', 00H, ' ', 00H, 'i', 00H, 's', 00H
	DB	' ', 00H, '%', 00H, 'u', 00H, 0dH, 00H, 0aH, 00H, 00H, 00H
$SG4294776928 DB 'g', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'k', 00H, 'e', 00H
	DB	'y', 00H, 'f', 00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H, ':'
	DB	00H, ' ', 00H, '%', 00H, 'u', 00H, 0dH, 00H, 0aH, 00H, 00H, 00H
	ORG $+2
$SG4294776930 DB 'd', 00H, 'r', 00H, 'o', 00H, 'p', 00H, 'p', 00H, 'e', 00H
	DB	'd', 00H, ' ', 00H, 'a', 00H, 'l', 00H, 'l', 00H, ' ', 00H, 'a'
	DB	00H, 't', 00H, ' ', 00H, '%', 00H, 'u', 00H, ',', 00H, ' ', 00H
	DB	't', 00H, 'h', 00H, 'r', 00H, 'e', 00H, 's', 00H, 'h', 00H, 'o'
	DB	00H, 'l', 00H, 'd', 00H, ' ', 00H, 'i', 00H, 's', 00H, ' ', 00H
	DB	'%', 00H, 'u', 00H, ',', 00H, ' ', 00H, 't', 00H, 'o', 00H, 't'
	DB	00H, 'a', 00H, 'l', 00H, ' ', 00H, 'd', 00H, 'u', 00H, 'r', 00H
	DB	'a', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, ' ', 00H, 'i'
	DB	00H, 's', 00H, ' ', 00H, '%', 00H, 'u', 00H, ',', 00H, ' ', 00H
	DB	'%', 00H, 'd', 00H, ' ', 00H, 'i', 00H, 'n', 00H, ' ', 00H, 'q'
	DB	00H, 'u', 00H, 'e', 00H, 'u', 00H, 'e', 00H, 0dH, 00H, 0aH, 00H
	DB	00H, 00H
$SG4294776926 DB '8', 00H, '0', 00H, '2', 00H, '.', 00H, '1', 00H, '1', 00H
	DB	00H, 00H
	ORG $+2
$SG4294776923 DB 'U', 00H, 'R', 00H, 'L', 00H, 00H, 00H
$SG4294776922 DB 'P', 00H, 'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 's', 00H
	DB	'h', 00H, 00H, 00H
$SG4294776917 DB 's', 00H, 'e', 00H, 'r', 00H, 'v', 00H, 'e', 00H, 'r', 00H
	DB	's', 00H, 00H, 00H
$SG4294776916 DB 'C', 00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, ' ', 00H
	DB	'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'n'
	DB	00H, 'd', 00H, ' ', 00H, 'a', 00H, 'n', 00H, 'y', 00H, ' ', 00H
	DB	's', 00H, 'e', 00H, 'r', 00H, 'v', 00H, 'e', 00H, 'r', 00H, 's'
	DB	00H, ' ', 00H, 'f', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 't', 00H
	DB	'h', 00H, 'e', 00H, ' ', 00H, 's', 00H, 'e', 00H, 'r', 00H, 'v'
	DB	00H, 'i', 00H, 'c', 00H, 'e', 00H, ' ', 00H, 's', 00H, 'p', 00H
	DB	'e', 00H, 'c', 00H, 'i', 00H, 'f', 00H, 'i', 00H, 'e', 00H, 'd'
	DB	00H, ' ', 00H, 'i', 00H, 'n', 00H, ' ', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '.'
	DB	00H, 'x', 00H, 'c', 00H, 'o', 00H, 'n', 00H, 'f', 00H, 'i', 00H
	DB	'g', 00H, 00H, 00H
	ORG $+2
$SG4294776907 DB 's', 00H, 't', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 'm', 00H
	DB	'_', 00H, 'n', 00H, 'a', 00H, 'm', 00H, 'e', 00H, 00H, 00H
$SG4294776896 DB 'T', 00H, 'C', 00H, 'P', 00H, 'B', 00H, 'u', 00H, 'f', 00H
	DB	'f', 00H, 'e', 00H, 'r', 00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e'
	DB	00H, 00H, 00H
$SG4294776919 DB 'N', 00H, 'o', 00H, ' ', 00H, 's', 00H, 'e', 00H, 'r', 00H
	DB	'v', 00H, 'e', 00H, 'r', 00H, ' ', 00H, 's', 00H, 'p', 00H, 'e'
	DB	00H, 'c', 00H, 'i', 00H, 'f', 00H, 'i', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'n'
	DB	00H, 'n', 00H, 'e', 00H, 'c', 00H, 't', 00H, ' ', 00H, 't', 00H
	DB	'o', 00H, 00H, 00H
$SG4294776899 DB 'P', 00H, 'a', 00H, 's', 00H, 's', 00H, 'w', 00H, 'o', 00H
	DB	'r', 00H, 'd', 00H, 00H, 00H
	ORG $+2
$SG4294776918 DB 'C', 00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, ' ', 00H
	DB	'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'n'
	DB	00H, 'd', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'e', 00H, ' ', 00H
	DB	's', 00H, 'e', 00H, 'r', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e'
	DB	00H, ' ', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H, 'i', 00H
	DB	'f', 00H, 'i', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'i', 00H, 'n'
	DB	00H, ' ', 00H, 's', 00H, 'e', 00H, 'r', 00H, 'v', 00H, 'i', 00H
	DB	'c', 00H, 'e', 00H, 's', 00H, '.', 00H, 'x', 00H, 'c', 00H, 'o'
	DB	00H, 'n', 00H, 'f', 00H, 'i', 00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG4294776900 DB 'P', 00H, 'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 's', 00H
	DB	'h', 00H, 00H, 00H
$SG4294776893 DB 'B', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'T', 00H, 'o', 00H
	DB	'I', 00H, 'P', 00H, 00H, 00H
	ORG $+2
$SG4294776913 DB 'W', 00H, 'e', 00H, 'b', 00H, 's', 00H, 'e', 00H, 'r', 00H
	DB	'v', 00H, 'e', 00H, 'r', 00H, ' ', 00H, 'f', 00H, 'a', 00H, 'i'
	DB	00H, 'l', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 't', 00H, 'o', 00H
	DB	' ', 00H, 'r', 00H, 'e', 00H, 's', 00H, 'p', 00H, 'o', 00H, 'n'
	DB	00H, 'd', 00H, ' ', 00H, 'w', 00H, 'i', 00H, 't', 00H, 'h', 00H
	DB	' ', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 'm', 00H
	DB	' ', 00H, 'd', 00H, 'e', 00H, 't', 00H, 'a', 00H, 'i', 00H, 'l'
	DB	00H, 's', 00H, '.', 00H, 00H, 00H
	ORG $+2
$SG4294776912 DB 'C', 00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, ' ', 00H
	DB	'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'u', 00H, 'n', 00H, 'd'
	DB	00H, 'e', 00H, 'r', 00H, 's', 00H, 't', 00H, 'a', 00H, 'n', 00H
	DB	'd', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 's', 00H, 'p', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, 'e', 00H, ' ', 00H, 'f', 00H, 'r', 00H
	DB	'o', 00H, 'm', 00H, ' ', 00H, 'w', 00H, 'e', 00H, 'b', 00H, 's'
	DB	00H, 'e', 00H, 'r', 00H, 'v', 00H, 'e', 00H, 'r', 00H, '.', 00H
	DB	00H, 00H
$SG4294776915 DB 'https', 00H
	ORG $+2
$SG4294776914 DB 'http', 00H
	ORG $+3
$SG4294776909 DB 's', 00H, 't', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 'm', 00H
	DB	'_', 00H, 'u', 00H, 'r', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG4294776902 DB 'C', 00H, 'o', 00H, 'n', 00H, 'n', 00H, 'e', 00H, 'c', 00H
	DB	't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, '.', 00H, 'C', 00H, 'o'
	DB	00H, 'u', 00H, 'l', 00H, 'd', 00H, 'N', 00H, 'o', 00H, 't', 00H
	DB	'P', 00H, 'a', 00H, 'r', 00H, 's', 00H, 'e', 00H, 'U', 00H, 'R'
	DB	00H, 'L', 00H, 00H, 00H
$SG4294776885 DB 'C', 00H, 'o', 00H, 'n', 00H, 'n', 00H, 'e', 00H, 'c', 00H
	DB	't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, '.', 00H, 'I', 00H, 'n'
	DB	00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H, 'S', 00H
	DB	't', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 'm', 00H, 00H, 00H
	ORG $+2
$SG4294776908 DB 'N', 00H, 'o', 00H, ' ', 00H, 'v', 00H, 'a', 00H, 'l', 00H
	DB	'i', 00H, 'd', 00H, ' ', 00H, 'b', 00H, 'r', 00H, 'o', 00H, 'a'
	DB	00H, 'd', 00H, 'c', 00H, 'a', 00H, 's', 00H, 't', 00H, ' ', 00H
	DB	's', 00H, 't', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 'm', 00H, ' '
	DB	00H, 'U', 00H, 'R', 00H, 'L', 00H, ' ', 00H, 'r', 00H, 'e', 00H
	DB	't', 00H, 'u', 00H, 'r', 00H, 'n', 00H, 'e', 00H, 'd', 00H, ' '
	DB	00H, 'f', 00H, 'r', 00H, 'o', 00H, 'm', 00H, ' ', 00H, 'w', 00H
	DB	'e', 00H, 'b', 00H, ' ', 00H, 's', 00H, 'e', 00H, 'r', 00H, 'v'
	DB	00H, 'e', 00H, 'r', 00H, '.', 00H, 00H, 00H
$SG4294776910 DB 'N', 00H, 'o', 00H, ' ', 00H, 'v', 00H, 'a', 00H, 'l', 00H
	DB	'i', 00H, 'd', 00H, ' ', 00H, 'd', 00H, 'a', 00H, 't', 00H, 'a'
	DB	00H, ' ', 00H, 'r', 00H, 'e', 00H, 't', 00H, 'u', 00H, 'r', 00H
	DB	'n', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'f', 00H, 'r', 00H, 'o'
	DB	00H, 'm', 00H, ' ', 00H, 'w', 00H, 'e', 00H, 'b', 00H, ' ', 00H
	DB	's', 00H, 'e', 00H, 'r', 00H, 'v', 00H, 'e', 00H, 'r', 00H, '.'
	DB	00H, 00H, 00H
$SG4294776904 DB 'U', 00H, 's', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H
	DB	'R', 00H, 'T', 00H, 'M', 00H, 'P', 00H, ' ', 00H, 's', 00H, 'e'
	DB	00H, 'r', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, ':', 00H
	DB	' ', 00H, '%', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG4294776906 DB 'N', 00H, 'o', 00H, ' ', 00H, 'v', 00H, 'a', 00H, 'l', 00H
	DB	'i', 00H, 'd', 00H, ' ', 00H, 's', 00H, 't', 00H, 'r', 00H, 'e'
	DB	00H, 'a', 00H, 'm', 00H, ' ', 00H, 'n', 00H, 'a', 00H, 'm', 00H
	DB	'e', 00H, '/', 00H, 'p', 00H, 'a', 00H, 't', 00H, 'h', 00H, ' '
	DB	00H, 'r', 00H, 'e', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'n', 00H
	DB	'e', 00H, 'd', 00H, ' ', 00H, 'f', 00H, 'r', 00H, 'o', 00H, 'm'
	DB	00H, ' ', 00H, 'w', 00H, 'e', 00H, 'b', 00H, ' ', 00H, 's', 00H
	DB	'e', 00H, 'r', 00H, 'v', 00H, 'e', 00H, 'r', 00H, '.', 00H, 00H
	DB	00H
$SG4294776903 DB ' ', 00H, ' ', 00H, 'S', 00H, 'e', 00H, 'r', 00H, 'v', 00H
	DB	'e', 00H, 'r', 00H, ' ', 00H, 's', 00H, 'e', 00H, 'l', 00H, 'e'
	DB	00H, 'c', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, ':', 00H
	DB	' ', 00H, '%', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG4294776897 DB 'FMLE/3.0 (compatible; FMSc/1.0)', 00H
$SG4294776898 DB 'P', 00H, 'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 's', 00H
	DB	'h', 00H, 00H, 00H
$SG4294776892 DB 'P', 00H, 'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 's', 00H
	DB	'h', 00H, 00H, 00H
$SG4294776895 DB 'P', 00H, 'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 's', 00H
	DB	'h', 00H, 00H, 00H
$SG4294776894 DB 'D', 00H, 'e', 00H, 'f', 00H, 'a', 00H, 'u', 00H, 'l', 00H
	DB	't', 00H, 00H, 00H
$SG4294776889 DB 'W', 00H, 'S', 00H, 'A', 00H, 'S', 00H, 't', 00H, 'r', 00H
	DB	'i', 00H, 'n', 00H, 'g', 00H, 'T', 00H, 'o', 00H, 'A', 00H, 'd'
	DB	00H, 'd', 00H, 'r', 00H, 'e', 00H, 's', 00H, 's', 00H, ':', 00H
	DB	' ', 00H, 'C', 00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, ' '
	DB	00H, 'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'p', 00H, 'a', 00H
	DB	'r', 00H, 's', 00H, 'e', 00H, ' ', 00H, 'a', 00H, 'd', 00H, 'd'
	DB	00H, 'r', 00H, 'e', 00H, 's', 00H, 's', 00H, 00H, 00H
$SG4294776888 DB 'C', 00H, 'o', 00H, 'n', 00H, 'n', 00H, 'e', 00H, 'c', 00H
	DB	't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, '.', 00H, 'C', 00H, 'o'
	DB	00H, 'u', 00H, 'l', 00H, 'd', 00H, 'N', 00H, 'o', 00H, 't', 00H
	DB	'C', 00H, 'o', 00H, 'n', 00H, 'n', 00H, 'e', 00H, 'c', 00H, 't'
	DB	00H, 00H, 00H
	ORG $+2
$SG4294776891 DB 'D', 00H, 'e', 00H, 'f', 00H, 'a', 00H, 'u', 00H, 'l', 00H
	DB	't', 00H, 00H, 00H
$SG4294776890 DB ' ', 00H, ' ', 00H, 'B', 00H, 'i', 00H, 'n', 00H, 'd', 00H
	DB	'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 't', 00H, 'o', 00H, ' '
	DB	00H, 'n', 00H, 'o', 00H, 'n', 00H, '-', 00H, 'd', 00H, 'e', 00H
	DB	'f', 00H, 'a', 00H, 'u', 00H, 'l', 00H, 't', 00H, ' ', 00H, 'I'
	DB	00H, 'P', 00H, ' ', 00H, '%', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG4294776884 DB 0dH, 00H, 0aH, 00H, 0dH, 00H, 0aH, 00H, 00H, 00H
	ORG $+2
$SG4294776887 DB 0dH, 00H, 0aH, 00H, 0dH, 00H, 0aH, 00H, 00H, 00H
	ORG $+2
$SG4294776886 DB 'C', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H
	DB	't', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'h', 00H, 'a', 00H, 'n'
	DB	00H, 'd', 00H, 's', 00H, 'h', 00H, 'a', 00H, 'k', 00H, 'e', 00H
	DB	' ', 00H, 'w', 00H, 'i', 00H, 't', 00H, 'h', 00H, ' ', 00H, '%'
	DB	00H, 's', 00H, ' ', 00H, 'i', 00H, 'n', 00H, ' ', 00H, '%', 00H
	DB	'u', 00H, ' ', 00H, 'm', 00H, 's', 00H, '.', 00H, 00H, 00H
$SG4294776881 DB 'E', 00H, 'x', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 'i', 00H
	DB	'm', 00H, 'e', 00H, 'n', 00H, 't', 00H, 'a', 00H, 'l', 00H, 'R'
	DB	00H, 'e', 00H, 'c', 00H, 'o', 00H, 'n', 00H, 'n', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'M', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 00H
	DB	00H
$SG4294776880 DB 'P', 00H, 'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 's', 00H
	DB	'h', 00H, 00H, 00H
$SG4294776883 DB 'C', 00H, 'o', 00H, 'n', 00H, 'n', 00H, 'e', 00H, 'c', 00H
	DB	't', 00H, 'e', 00H, 'd', 00H, ':', 00H, ' ', 00H, '%', 00H, 'u'
	DB	00H, 0dH, 00H, 0aH, 00H, 00H, 00H
$SG4294776882 DB 'C', 00H, 'o', 00H, 'n', 00H, 'n', 00H, 'e', 00H, 'c', 00H
	DB	't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, ' ', 00H, 't', 00H, 'o'
	DB	00H, ' ', 00H, '%', 00H, 's', 00H, ' ', 00H, 'f', 00H, 'a', 00H
	DB	'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H, ':', 00H, ' ', 00H, '%'
	DB	00H, 's', 00H, 00H, 00H
$SG4294776877 DB 'D', 00H, 'i', 00H, 's', 00H, 'a', 00H, 'b', 00H, 'l', 00H
	DB	'e', 00H, 'S', 00H, 'e', 00H, 'n', 00H, 'd', 00H, 'W', 00H, 'i'
	DB	00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'O', 00H, 'p', 00H
	DB	't', 00H, 'i', 00H, 'm', 00H, 'i', 00H, 'z', 00H, 'a', 00H, 't'
	DB	00H, 'i', 00H, 'o', 00H, 'n', 00H, 00H, 00H
$SG4294776876 DB 'P', 00H, 'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 's', 00H
	DB	'h', 00H, 00H, 00H
$SG4294776879 DB 'D', 00H, 'e', 00H, 'l', 00H, 'a', 00H, 'y', 00H, 00H, 00H
$SG4294776878 DB 'P', 00H, 'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 's', 00H
	DB	'h', 00H, 00H, 00H
$SG4294776873 DB 'R', 00H, 'T', 00H, 'M', 00H, 'P', 00H, 'P', 00H, 'u', 00H
	DB	'b', 00H, 'l', 00H, 'i', 00H, 's', 00H, 'h', 00H, 'e', 00H, 'r'
	DB	00H, ':', 00H, ':', 00H, 'S', 00H, 'o', 00H, 'c', 00H, 'k', 00H
	DB	'e', 00H, 't', 00H, 'L', 00H, 'o', 00H, 'o', 00H, 'p', 00H, ':'
	DB	00H, ' ', 00H, 'A', 00H, 'b', 00H, 'o', 00H, 'r', 00H, 't', 00H
	DB	'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'd', 00H, 'u', 00H, 'e'
	DB	00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'W', 00H, 'S', 00H
	DB	'A', 00H, 'E', 00H, 'n', 00H, 'u', 00H, 'm', 00H, 'N', 00H, 'e'
	DB	00H, 't', 00H, 'w', 00H, 'o', 00H, 'r', 00H, 'k', 00H, 'E', 00H
	DB	'v', 00H, 'e', 00H, 'n', 00H, 't', 00H, 's', 00H, ' ', 00H, 'f'
	DB	00H, 'a', 00H, 'i', 00H, 'l', 00H, 'u', 00H, 'r', 00H, 'e', 00H
	DB	',', 00H, ' ', 00H, '%', 00H, 'd', 00H, 00H, 00H
$SG4294776872 DB 'R', 00H, 'T', 00H, 'M', 00H, 'P', 00H, 'P', 00H, 'u', 00H
	DB	'b', 00H, 'l', 00H, 'i', 00H, 's', 00H, 'h', 00H, 'e', 00H, 'r'
	DB	00H, ':', 00H, ':', 00H, 'S', 00H, 'o', 00H, 'c', 00H, 'k', 00H
	DB	'e', 00H, 't', 00H, 'L', 00H, 'o', 00H, 'o', 00H, 'p', 00H, ':'
	DB	00H, ' ', 00H, 'R', 00H, 'e', 00H, 'c', 00H, 'e', 00H, 'i', 00H
	DB	'v', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'F', 00H, 'D', 00H, '_'
	DB	00H, 'C', 00H, 'L', 00H, 'O', 00H, 'S', 00H, 'E', 00H, ',', 00H
	DB	' ', 00H, '%', 00H, 'u', 00H, ' ', 00H, 'm', 00H, 's', 00H, ' '
	DB	00H, 's', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'e', 00H, ' ', 00H
	DB	'l', 00H, 'a', 00H, 's', 00H, 't', 00H, ' ', 00H, 's', 00H, 'e'
	DB	00H, 'n', 00H, 'd', 00H, ' ', 00H, '(', 00H, 'b', 00H, 'u', 00H
	DB	'f', 00H, 'f', 00H, 'e', 00H, 'r', 00H, ':', 00H, ' ', 00H, '%'
	DB	00H, 'd', 00H, ' ', 00H, '/', 00H, ' ', 00H, '%', 00H, 'd', 00H
	DB	')', 00H, 00H, 00H
$SG4294776875 DB 'R', 00H, 'T', 00H, 'M', 00H, 'P', 00H, 'P', 00H, 'u', 00H
	DB	'b', 00H, 'l', 00H, 'i', 00H, 's', 00H, 'h', 00H, 'e', 00H, 'r'
	DB	00H, ':', 00H, ':', 00H, 'S', 00H, 'o', 00H, 'c', 00H, 'k', 00H
	DB	'e', 00H, 't', 00H, 'L', 00H, 'o', 00H, 'o', 00H, 'p', 00H, ':'
	DB	00H, ' ', 00H, 'S', 00H, 'e', 00H, 'n', 00H, 'd', 00H, ' ', 00H
	DB	'w', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, ' '
	DB	00H, 'o', 00H, 'p', 00H, 't', 00H, 'i', 00H, 'm', 00H, 'i', 00H
	DB	'z', 00H, 'a', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, ' '
	DB	00H, 'd', 00H, 'i', 00H, 's', 00H, 'a', 00H, 'b', 00H, 'l', 00H
	DB	'e', 00H, 'd', 00H, ' ', 00H, 'b', 00H, 'y', 00H, ' ', 00H, 'u'
	DB	00H, 's', 00H, 'e', 00H, 'r', 00H, '.', 00H, 00H, 00H
	ORG $+3
$SG4294776874 DB 'R', 00H, 'T', 00H, 'M', 00H, 'P', 00H, 'P', 00H, 'u', 00H
	DB	'b', 00H, 'l', 00H, 'i', 00H, 's', 00H, 'h', 00H, 'e', 00H, 'r'
	DB	00H, ':', 00H, ':', 00H, 'S', 00H, 'o', 00H, 'c', 00H, 'k', 00H
	DB	'e', 00H, 't', 00H, 'L', 00H, 'o', 00H, 'o', 00H, 'p', 00H, ':'
	DB	00H, ' ', 00H, 'A', 00H, 'b', 00H, 'o', 00H, 'r', 00H, 't', 00H
	DB	'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'd', 00H, 'u', 00H, 'e'
	DB	00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'W', 00H, 'a', 00H
	DB	'i', 00H, 't', 00H, 'F', 00H, 'o', 00H, 'r', 00H, 'M', 00H, 'u'
	DB	00H, 'l', 00H, 't', 00H, 'i', 00H, 'p', 00H, 'l', 00H, 'e', 00H
	DB	'O', 00H, 'b', 00H, 'j', 00H, 'e', 00H, 'c', 00H, 't', 00H, 's'
	DB	00H, ' ', 00H, 'f', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'u', 00H
	DB	'r', 00H, 'e', 00H, 00H, 00H
$SG4294776869 DB 'R', 00H, 'T', 00H, 'M', 00H, 'P', 00H, 'P', 00H, 'u', 00H
	DB	'b', 00H, 'l', 00H, 'i', 00H, 's', 00H, 'h', 00H, 'e', 00H, 'r'
	DB	00H, ':', 00H, ':', 00H, 'S', 00H, 'o', 00H, 'c', 00H, 'k', 00H
	DB	'e', 00H, 't', 00H, 'L', 00H, 'o', 00H, 'o', 00H, 'p', 00H, ':'
	DB	00H, ' ', 00H, 'S', 00H, 'o', 00H, 'c', 00H, 'k', 00H, 'e', 00H
	DB	't', 00H, ' ', 00H, 'e', 00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r'
	DB	00H, ',', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 'c', 00H, 'v', 00H
	DB	'(', 00H, ')', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 't', 00H, 'u'
	DB	00H, 'r', 00H, 'n', 00H, 'e', 00H, 'd', 00H, ' ', 00H, '%', 00H
	DB	'd', 00H, ',', 00H, ' ', 00H, 'G', 00H, 'e', 00H, 't', 00H, 'L'
	DB	00H, 'a', 00H, 's', 00H, 't', 00H, 'E', 00H, 'r', 00H, 'r', 00H
	DB	'o', 00H, 'r', 00H, '(', 00H, ')', 00H, ' ', 00H, '%', 00H, 'd'
	DB	00H, 00H, 00H
	ORG $+2
$SG4294776868 DB 'R', 00H, 'T', 00H, 'M', 00H, 'P', 00H, 'P', 00H, 'u', 00H
	DB	'b', 00H, 'l', 00H, 'i', 00H, 's', 00H, 'h', 00H, 'e', 00H, 'r'
	DB	00H, ':', 00H, ':', 00H, 'S', 00H, 'o', 00H, 'c', 00H, 'k', 00H
	DB	'e', 00H, 't', 00H, 'L', 00H, 'o', 00H, 'o', 00H, 'p', 00H, ':'
	DB	00H, ' ', 00H, 'I', 00H, 'n', 00H, 'c', 00H, 'r', 00H, 'e', 00H
	DB	'a', 00H, 's', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 's'
	DB	00H, 'e', 00H, 'n', 00H, 'd', 00H, ' ', 00H, 'b', 00H, 'u', 00H
	DB	'f', 00H, 'f', 00H, 'e', 00H, 'r', 00H, ' ', 00H, 't', 00H, 'o'
	DB	00H, ' ', 00H, 'I', 00H, 'S', 00H, 'B', 00H, ' ', 00H, '%', 00H
	DB	'd', 00H, ' ', 00H, '(', 00H, 'b', 00H, 'u', 00H, 'f', 00H, 'f'
	DB	00H, 'e', 00H, 'r', 00H, ':', 00H, ' ', 00H, '%', 00H, 'd', 00H
	DB	' ', 00H, '/', 00H, ' ', 00H, '%', 00H, 'd', 00H, ')', 00H, 00H
	DB	00H
$SG4294776871 DB 'R', 00H, 'T', 00H, 'M', 00H, 'P', 00H, 'P', 00H, 'u', 00H
	DB	'b', 00H, 'l', 00H, 'i', 00H, 's', 00H, 'h', 00H, 'e', 00H, 'r'
	DB	00H, ':', 00H, ':', 00H, 'S', 00H, 'o', 00H, 'c', 00H, 'k', 00H
	DB	'e', 00H, 't', 00H, 'L', 00H, 'o', 00H, 'o', 00H, 'p', 00H, ':'
	DB	00H, ' ', 00H, 'A', 00H, 'b', 00H, 'o', 00H, 'r', 00H, 't', 00H
	DB	'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'd', 00H, 'u', 00H, 'e'
	DB	00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'F', 00H, 'D', 00H
	DB	'_', 00H, 'C', 00H, 'L', 00H, 'O', 00H, 'S', 00H, 'E', 00H, ' '
	DB	00H, 'd', 00H, 'u', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H
	DB	' ', 00H, 's', 00H, 'h', 00H, 'u', 00H, 't', 00H, 'd', 00H, 'o'
	DB	00H, 'w', 00H, 'n', 00H, ',', 00H, ' ', 00H, '%', 00H, 'd', 00H
	DB	' ', 00H, 'b', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H, ' '
	DB	00H, 'l', 00H, 'o', 00H, 's', 00H, 't', 00H, ',', 00H, ' ', 00H
	DB	'e', 00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '%'
	DB	00H, 'd', 00H, 00H, 00H
	ORG $+2
_av_setDataFrame DD FLAT:$SG4294776975
	DD	0dH
$SG4294776870 DB 'R', 00H, 'T', 00H, 'M', 00H, 'P', 00H, 'P', 00H, 'u', 00H
	DB	'b', 00H, 'l', 00H, 'i', 00H, 's', 00H, 'h', 00H, 'e', 00H, 'r'
	DB	00H, ':', 00H, ':', 00H, 'S', 00H, 'o', 00H, 'c', 00H, 'k', 00H
	DB	'e', 00H, 't', 00H, 'L', 00H, 'o', 00H, 'o', 00H, 'p', 00H, ':'
	DB	00H, ' ', 00H, 'A', 00H, 'b', 00H, 'o', 00H, 'r', 00H, 't', 00H
	DB	'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'd', 00H, 'u', 00H, 'e'
	DB	00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'F', 00H, 'D', 00H
	DB	'_', 00H, 'C', 00H, 'L', 00H, 'O', 00H, 'S', 00H, 'E', 00H, ','
	DB	00H, ' ', 00H, 'e', 00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H
	DB	' ', 00H, '%', 00H, 'd', 00H, 00H, 00H
$SG4294776865 DB 'R', 00H, 'T', 00H, 'M', 00H, 'P', 00H, 'P', 00H, 'u', 00H
	DB	'b', 00H, 'l', 00H, 'i', 00H, 's', 00H, 'h', 00H, 'e', 00H, 'r'
	DB	00H, ':', 00H, ':', 00H, 'S', 00H, 'o', 00H, 'c', 00H, 'k', 00H
	DB	'e', 00H, 't', 00H, 'L', 00H, 'o', 00H, 'o', 00H, 'p', 00H, ':'
	DB	00H, ' ', 00H, 'S', 00H, 't', 00H, 'a', 00H, 'l', 00H, 'l', 00H
	DB	'e', 00H, 'd', 00H, ' ', 00H, 'f', 00H, 'o', 00H, 'r', 00H, ' '
	DB	00H, '%', 00H, 'u', 00H, ' ', 00H, 'm', 00H, 's', 00H, ' ', 00H
	DB	't', 00H, 'o', 00H, ' ', 00H, 'w', 00H, 'r', 00H, 'i', 00H, 't'
	DB	00H, 'e', 00H, ' ', 00H, '%', 00H, 'd', 00H, ' ', 00H, 'b', 00H
	DB	'y', 00H, 't', 00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'b'
	DB	00H, 'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H, 'r', 00H, ':', 00H
	DB	' ', 00H, '%', 00H, 'd', 00H, ' ', 00H, '/', 00H, ' ', 00H, '%'
	DB	00H, 'd', 00H, ')', 00H, ',', 00H, ' ', 00H, 'u', 00H, 'n', 00H
	DB	's', 00H, 't', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, ' '
	DB	00H, 'c', 00H, 'o', 00H, 'n', 00H, 'n', 00H, 'e', 00H, 'c', 00H
	DB	't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, '?', 00H, 00H, 00H
	ORG $+2
$SG4294776864 DB 'R', 00H, 'T', 00H, 'M', 00H, 'P', 00H, 'P', 00H, 'u', 00H
	DB	'b', 00H, 'l', 00H, 'i', 00H, 's', 00H, 'h', 00H, 'e', 00H, 'r'
	DB	00H, ':', 00H, ':', 00H, 'S', 00H, 'o', 00H, 'c', 00H, 'k', 00H
	DB	'e', 00H, 't', 00H, 'L', 00H, 'o', 00H, 'o', 00H, 'p', 00H, ':'
	DB	00H, ' ', 00H, 'S', 00H, 'o', 00H, 'c', 00H, 'k', 00H, 'e', 00H
	DB	't', 00H, ' ', 00H, 'e', 00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r'
	DB	00H, ',', 00H, ' ', 00H, 's', 00H, 'e', 00H, 'n', 00H, 'd', 00H
	DB	'(', 00H, ')', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 't', 00H, 'u'
	DB	00H, 'r', 00H, 'n', 00H, 'e', 00H, 'd', 00H, ' ', 00H, '%', 00H
	DB	'd', 00H, ',', 00H, ' ', 00H, 'G', 00H, 'e', 00H, 't', 00H, 'L'
	DB	00H, 'a', 00H, 's', 00H, 't', 00H, 'E', 00H, 'r', 00H, 'r', 00H
	DB	'o', 00H, 'r', 00H, '(', 00H, ')', 00H, ' ', 00H, '%', 00H, 'd'
	DB	00H, 00H, 00H
	ORG $+2
$SG4294776867 DB 'R', 00H, 'T', 00H, 'M', 00H, 'P', 00H, 'P', 00H, 'u', 00H
	DB	'b', 00H, 'l', 00H, 'i', 00H, 's', 00H, 'h', 00H, 'e', 00H, 'r'
	DB	00H, ':', 00H, ':', 00H, 'S', 00H, 'o', 00H, 'c', 00H, 'k', 00H
	DB	'e', 00H, 't', 00H, 'L', 00H, 'o', 00H, 'o', 00H, 'p', 00H, ':'
	DB	00H, ' ', 00H, 'G', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'h', 00H
	DB	'S', 00H, 'e', 00H, 'n', 00H, 'd', 00H, 'B', 00H, 'a', 00H, 'c'
	DB	00H, 'k', 00H, 'l', 00H, 'o', 00H, 'g', 00H, 'E', 00H, 'v', 00H
	DB	'e', 00H, 'n', 00H, 't', 00H, ' ', 00H, 'b', 00H, 'u', 00H, 't'
	DB	00H, ' ', 00H, 'g', 00H, 'e', 00H, 't', 00H, 's', 00H, 'o', 00H
	DB	'c', 00H, 'k', 00H, 'o', 00H, 'p', 00H, 't', 00H, '(', 00H, ')'
	DB	00H, ' ', 00H, 'r', 00H, 'e', 00H, 't', 00H, 'u', 00H, 'r', 00H
	DB	'n', 00H, 'e', 00H, 'd', 00H, ' ', 00H, '%', 00H, 'd', 00H, 00H
	DB	00H
$SG4294776866 DB 'R', 00H, 'T', 00H, 'M', 00H, 'P', 00H, 'P', 00H, 'u', 00H
	DB	'b', 00H, 'l', 00H, 'i', 00H, 's', 00H, 'h', 00H, 'e', 00H, 'r'
	DB	00H, ':', 00H, ':', 00H, 'S', 00H, 'o', 00H, 'c', 00H, 'k', 00H
	DB	'e', 00H, 't', 00H, 'L', 00H, 'o', 00H, 'o', 00H, 'p', 00H, ':'
	DB	00H, ' ', 00H, 'G', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'h', 00H
	DB	'S', 00H, 'e', 00H, 'n', 00H, 'd', 00H, 'B', 00H, 'a', 00H, 'c'
	DB	00H, 'k', 00H, 'l', 00H, 'o', 00H, 'g', 00H, 'E', 00H, 'v', 00H
	DB	'e', 00H, 'n', 00H, 't', 00H, ' ', 00H, 'b', 00H, 'u', 00H, 't'
	DB	00H, ' ', 00H, 'W', 00H, 'S', 00H, 'A', 00H, 'I', 00H, 'o', 00H
	DB	'c', 00H, 't', 00H, 'l', 00H, '(', 00H, ')', 00H, ' ', 00H, 'r'
	DB	00H, 'e', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'n', 00H, 'e', 00H
	DB	'd', 00H, ' ', 00H, '%', 00H, 'd', 00H, 00H, 00H
$SG4294776863 DB 'R', 00H, 'T', 00H, 'M', 00H, 'P', 00H, 'P', 00H, 'u', 00H
	DB	'b', 00H, 'l', 00H, 'i', 00H, 's', 00H, 'h', 00H, 'e', 00H, 'r'
	DB	00H, ':', 00H, ':', 00H, 'S', 00H, 'o', 00H, 'c', 00H, 'k', 00H
	DB	'e', 00H, 't', 00H, 'L', 00H, 'o', 00H, 'o', 00H, 'p', 00H, ':'
	DB	00H, ' ', 00H, 'G', 00H, 'r', 00H, 'a', 00H, 'c', 00H, 'e', 00H
	DB	'f', 00H, 'u', 00H, 'l', 00H, ' ', 00H, 'l', 00H, 'o', 00H, 'o'
	DB	00H, 'p', 00H, ' ', 00H, 'e', 00H, 'x', 00H, 'i', 00H, 't', 00H
	DB	00H, 00H
	ORG $+1
$SG4294776862 DB 'R', 00H, 'T', 00H, 'M', 00H, 'P', 00H, '_', 00H, 'S', 00H
	DB	'e', 00H, 'n', 00H, 'd', 00H, 'P', 00H, 'a', 00H, 'c', 00H, 'k'
	DB	00H, 'e', 00H, 't', 00H, ' ', 00H, 'f', 00H, 'a', 00H, 'i', 00H
	DB	'l', 00H, 'u', 00H, 'r', 00H, 'e', 00H, ',', 00H, ' ', 00H, 's'
	DB	00H, 'h', 00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, ' ', 00H
	DB	'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'h', 00H, 'a', 00H, 'p'
	DB	00H, 'p', 00H, 'e', 00H, 'n', 00H, '!', 00H, 00H, 00H
_av_onMetaData DD FLAT:$SG4294776999
	DD	0aH
PUBLIC	??$_Uninit_move@DDD@std@@YAPADPAD00AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<char,char,char>
PUBLIC	??$_Uninit_move@PADPADU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAPADPAD00AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z ; std::_Uninit_move<char *,char *,std::_Wrap_alloc<std::allocator<char> > >
PUBLIC	??$_Uninitialized_move@PADPADU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAPADPAD00AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z ; std::_Uninitialized_move<char *,char *,std::_Wrap_alloc<std::allocator<char> > >
PUBLIC	??$_Uninit_def_fill_n@DID@std@@YAXPADIAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_def_fill_n<char,unsigned int,char>
PUBLIC	??$_Val_type@PAD@std@@YAPADPAD@Z		; std::_Val_type<char *>
PUBLIC	??$_Umove@PAD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPAD00@Z ; std::vector<char,std::allocator<char> >::_Umove<char *>
PUBLIC	??$_Uninitialized_default_fill_n@PADIU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXPADIAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z ; std::_Uninitialized_default_fill_n<char *,unsigned int,std::_Wrap_alloc<std::allocator<char> > >
PUBLIC	?Add@?$List@UNetworkPacket@@@@QAEIABUNetworkPacket@@@Z ; List<NetworkPacket>::Add
PUBLIC	?Add@?$List@UTimedPacket@@@@QAEIABUTimedPacket@@@Z ; List<TimedPacket>::Add
PUBLIC	?_Reallocate@?$vector@DV?$allocator@D@std@@@std@@IAEXI@Z ; std::vector<char,std::allocator<char> >::_Reallocate
PUBLIC	?_Unused_capacity@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::_Unused_capacity
PUBLIC	??_GXConfig@@QAEPAXI@Z				; XConfig::`scalar deleting destructor'
PUBLIC	?get_deleter@?$_Unique_ptr_base@VXConfig@@U?$default_delete@VXConfig@@@std@@$00@std@@QAEAAU?$default_delete@VXConfig@@@2@XZ ; std::_Unique_ptr_base<XConfig,std::default_delete<XConfig>,1>::get_deleter
PUBLIC	??R?$default_delete@VXConfig@@@std@@QBEXPAVXConfig@@@Z ; std::default_delete<XConfig>::operator()
PUBLIC	?Insert@?$List@UNetworkPacket@@@@QAEXIABUNetworkPacket@@@Z ; List<NetworkPacket>::Insert
PUBLIC	?SetSize@?$List@UTimedPacket@@@@QAEHI@Z		; List<TimedPacket>::SetSize
PUBLIC	?Insert@?$List@UTimedPacket@@@@QAEXIABUTimedPacket@@@Z ; List<TimedPacket>::Insert
PUBLIC	?_Reserve@?$vector@DV?$allocator@D@std@@@std@@IAEXI@Z ; std::vector<char,std::allocator<char> >::_Reserve
PUBLIC	?_Pop_back_n@?$vector@DV?$allocator@D@std@@@std@@QAEXI@Z ; std::vector<char,std::allocator<char> >::_Pop_back_n
PUBLIC	??1NetworkPacket@@QAE@XZ			; NetworkPacket::~NetworkPacket
PUBLIC	??0NetworkPacket@@QAE@XZ			; NetworkPacket::NetworkPacket
PUBLIC	??1?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QAE@XZ ; std::unique_ptr<XConfig,std::default_delete<XConfig> >::~unique_ptr<XConfig,std::default_delete<XConfig> >
PUBLIC	?Last@?$List@UNetworkPacket@@@@QBEAAUNetworkPacket@@XZ ; List<NetworkPacket>::Last
PUBLIC	?InsertNew@?$List@UNetworkPacket@@@@QAEPAUNetworkPacket@@H@Z ; List<NetworkPacket>::InsertNew
PUBLIC	??A?$List@UTimedPacket@@@@QAEAAUTimedPacket@@I@Z ; List<TimedPacket>::operator[]
PUBLIC	?InsertNew@?$List@UTimedPacket@@@@QAEPAUTimedPacket@@H@Z ; List<TimedPacket>::InsertNew
PUBLIC	?CreateNew@?$List@UTimedPacket@@@@QAEPAUTimedPacket@@XZ ; List<TimedPacket>::CreateNew
PUBLIC	?Clear@?$List@UTimedPacket@@@@QAEXXZ		; List<TimedPacket>::Clear
PUBLIC	?MoveItem@?$List@UTimedPacket@@@@QAEXHH@Z	; List<TimedPacket>::MoveItem
PUBLIC	?Remove@?$List@UTimedPacket@@@@QAEXI@Z		; List<TimedPacket>::Remove
PUBLIC	?Num@?$List@UTimedPacket@@@@QBEIXZ		; List<TimedPacket>::Num
PUBLIC	??1?$List@UTimedPacket@@@@QAE@XZ		; List<TimedPacket>::~List<TimedPacket>
PUBLIC	??0?$List@UTimedPacket@@@@QAE@XZ		; List<TimedPacket>::List<TimedPacket>
PUBLIC	?data@?$vector@DV?$allocator@D@std@@@std@@QAEPADXZ ; std::vector<char,std::allocator<char> >::data
PUBLIC	?resize@?$vector@DV?$allocator@D@std@@@std@@QAEXI@Z ; std::vector<char,std::allocator<char> >::resize
PUBLIC	?TransferFrom@?$List@E@@QAEXAAV1@@Z		; List<unsigned char>::TransferFrom
PUBLIC	?BufferedSend@RTMPPublisher@@CAHPAURTMPSockBuf@@PBDHPAV1@@Z ; RTMPPublisher::BufferedSend
PUBLIC	?RequestKeyframe@RTMPPublisher@@MAEXH@Z		; RTMPPublisher::RequestKeyframe
PUBLIC	?DoIFrameDelay@RTMPPublisher@@IAE_N_N@Z		; RTMPPublisher::DoIFrameDelay
PUBLIC	?DropFrame@RTMPPublisher@@IAEXI@Z		; RTMPPublisher::DropFrame
PUBLIC	?SocketThread@RTMPPublisher@@KAKPAV1@@Z		; RTMPPublisher::SocketThread
PUBLIC	?SendThread@RTMPPublisher@@KAKPAV1@@Z		; RTMPPublisher::SendThread
PUBLIC	?SendLoop@RTMPPublisher@@IAEXXZ			; RTMPPublisher::SendLoop
PUBLIC	?SocketLoop@RTMPPublisher@@IAEXXZ		; RTMPPublisher::SocketLoop
PUBLIC	?FatalSocketShutdown@RTMPPublisher@@IAEXXZ	; RTMPPublisher::FatalSocketShutdown
PUBLIC	?SetupSendBacklogEvent@RTMPPublisher@@IAEXXZ	; RTMPPublisher::SetupSendBacklogEvent
PUBLIC	?FlushDataBuffer@RTMPPublisher@@IAEHXZ		; RTMPPublisher::FlushDataBuffer
PUBLIC	??1?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@@std@@QAE@XZ ; std::pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,XElement *>::~pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,XElement *>
PUBLIC	??1ServiceIdentifier@@QAE@XZ			; ServiceIdentifier::~ServiceIdentifier
PUBLIC	?LogInterfaceType@@YAXPAURTMP@@@Z		; LogInterfaceType
PUBLIC	?BeginPublishingInternal@RTMPPublisher@@AAEXXZ	; RTMPPublisher::BeginPublishingInternal
PUBLIC	?SendPacketForReal@RTMPPublisher@@IAEXPAEIKW4PacketType@@@Z ; RTMPPublisher::SendPacketForReal
PUBLIC	??1TimedPacket@@QAE@XZ				; TimedPacket::~TimedPacket
PUBLIC	??0TimedPacket@@QAE@XZ				; TimedPacket::TimedPacket
PUBLIC	?InitializeBuffer@RTMPPublisher@@IAEXXZ		; RTMPPublisher::InitializeBuffer
PUBLIC	?FindClosestBufferIndex@RTMPPublisher@@IAEIK@Z	; RTMPPublisher::FindClosestBufferIndex
PUBLIC	?FindClosestQueueIndex@RTMPPublisher@@IAEIK@Z	; RTMPPublisher::FindClosestQueueIndex
PUBLIC	?Init@RTMPPublisher@@QAE_NI@Z			; RTMPPublisher::Init
PUBLIC	??_GRTMPPublisher@@UAEPAXI@Z			; RTMPPublisher::`scalar deleting destructor'
PUBLIC	?GetRTMPErrors@RTMPPublisher@@CA?AVString@@XZ	; RTMPPublisher::GetRTMPErrors
PUBLIC	?librtmpErrorCallback@RTMPPublisher@@CAXHPBDPAD@Z ; RTMPPublisher::librtmpErrorCallback
PUBLIC	_idealsendbacklognotify
PUBLIC	_idealsendbacklogquery
PUBLIC	?NetworkFailed@OBS@@QAEXXZ			; OBS::NetworkFailed
PUBLIC	?_Fill_n@std@@YAPADPADID@Z			; std::_Fill_n
PUBLIC	?GetData@XDataItem@@QBEPB_WXZ			; XDataItem::GetData
PUBLIC	?CreateRTMPPublisher@@YAPAVNetworkStream@@XZ	; CreateRTMPPublisher
PUBLIC	?NumDroppedFrames@RTMPPublisher@@UBEKXZ		; RTMPPublisher::NumDroppedFrames
PUBLIC	?GetCurrentSentBytes@RTMPPublisher@@UAE_KXZ	; RTMPPublisher::GetCurrentSentBytes
PUBLIC	?GetPacketStrain@RTMPPublisher@@UBENXZ		; RTMPPublisher::GetPacketStrain
PUBLIC	?BeginPublishing@RTMPPublisher@@UAEXXZ		; RTMPPublisher::BeginPublishing
PUBLIC	?SendPacket@RTMPPublisher@@UAEXPAEIKW4PacketType@@@Z ; RTMPPublisher::SendPacket
PUBLIC	??1RTMPPublisher@@UAE@XZ			; RTMPPublisher::~RTMPPublisher
PUBLIC	??0RTMPPublisher@@QAE@XZ			; RTMPPublisher::RTMPPublisher
PUBLIC	?FlushBufferedPackets@RTMPPublisher@@MAEXXZ	; RTMPPublisher::FlushBufferedPackets
PUBLIC	?ProcessPackets@RTMPPublisher@@MAEXXZ		; RTMPPublisher::ProcessPackets
PUBLIC	?InitEncoderData@RTMPPublisher@@IAEXXZ		; RTMPPublisher::InitEncoderData
PUBLIC	?CreateConnectionThread@RTMPPublisher@@CGKPAV1@@Z ; RTMPPublisher::CreateConnectionThread
PUBLIC	?strRTMPErrors@RTMPPublisher@@0VString@@A	; RTMPPublisher::strRTMPErrors
EXTRN	??_ERTMPPublisher@@UAEPAXI@Z:PROC		; RTMPPublisher::`vector deleting destructor'
	ALIGN	4

__Tuple_alloc DB 01H DUP (?)
	ALIGN	4

_ignore	DB	01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
	ALIGN	8

?strRTMPErrors@RTMPPublisher@@0VString@@A DQ 01H DUP (?) ; RTMPPublisher::strRTMPErrors
_piecewise_construct DB 01H DUP (?)
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?resize@?$vector@DV?$allocator@D@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?resize@?$vector@DV?$allocator@D@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?resize@?$vector@DV?$allocator@D@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?resize@?$vector@DV?$allocator@D@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?resize@?$vector@DV?$allocator@D@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?resize@?$vector@DV?$allocator@D@std@@@std@@QAEXI@Z$2
__catchsym$?resize@?$vector@DV?$allocator@D@std@@@std@@QAEXI@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?resize@?$vector@DV?$allocator@D@std@@@std@@QAEXI@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Reallocate@?$vector@DV?$allocator@D@std@@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate@?$vector@DV?$allocator@D@std@@@std@@IAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate@?$vector@DV?$allocator@D@std@@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?_Reallocate@?$vector@DV?$allocator@D@std@@@std@@IAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate@?$vector@DV?$allocator@D@std@@@std@@IAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate@?$vector@DV?$allocator@D@std@@@std@@IAEXI@Z$2
__catchsym$?_Reallocate@?$vector@DV?$allocator@D@std@@@std@@IAEXI@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate@?$vector@DV?$allocator@D@std@@@std@@IAEXI@Z$0
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
_ignore$initializer$ DD FLAT:??__Eignore@std@@YAXXZ
__Tuple_alloc$initializer$ DD FLAT:??__E_Tuple_alloc@std@@YAXXZ
?strRTMPErrors$initializer$@RTMPPublisher@@0P6AXXZA DD FLAT:??__E?strRTMPErrors@RTMPPublisher@@0VString@@A@@YAXXZ ; RTMPPublisher::strRTMPErrors$initializer$
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\rtmppublisher.cpp
;	COMDAT ?CreateConnectionThread@RTMPPublisher@@CGKPAV1@@Z
_TEXT	SEGMENT
$T1 = -788						; size = 8
$T2 = -780						; size = 8
$T3 = -772						; size = 8
$T4 = -764						; size = 8
$T5 = -756						; size = 8
$T6 = -748						; size = 8
$T7 = -740						; size = 8
_sid$ = -732						; size = 12
$T8 = -720						; size = 8
$T9 = -712						; size = 8
tv393 = -704						; size = 4
tv383 = -700						; size = 4
tv744 = -696						; size = 4
tv418 = -692						; size = 4
tv723 = -688						; size = 4
_startTime$ = -684					; size = 4
$T10 = -680						; size = 4
tv708 = -676						; size = 4
_apiData$11 = -672					; size = 12
_p_stream_name_data$12 = -660				; size = 4
_strPlayPath$ = -656					; size = 8
tv594 = -648						; size = 4
$T13 = -644						; size = 4
_p_stream_url_data$14 = -640				; size = 4
_responseCode$15 = -636					; size = 4
tv191 = -632						; size = 4
_strBindIP$ = -628					; size = 8
_web_url$16 = -620					; size = 8
_response$17 = -612					; size = 8
_rtmpPass$ = -604					; size = 4
_rtmpUser$ = -600					; size = 4
_servers$18 = -596					; size = 4
_p_data$19 = -592					; size = 4
_item$20 = -588						; size = 4
_service$21 = -584					; size = 4
_lpAnsiPlaypath$ = -580					; size = 4
_lpAnsiURL$ = -576					; size = 4
_serviceData$22 = -572					; size = 8
tv741 = -564						; size = 4
_tcpBufferSize$ = -560					; size = 4
tv720 = -556						; size = 4
tv705 = -552						; size = 4
_strURL$ = -548						; size = 8
tv711 = -540						; size = 1
$T23 = -539						; size = 1
tv726 = -538						; size = 1
tv747 = -537						; size = 1
_failReason$ = -536					; size = 8
_bSuccess$ = -526					; size = 1
_bCanRetry$ = -525					; size = 1
$T24 = -524						; size = 4
_rtmp$ = -520						; size = 4
_extraHeaders$25 = -516					; size = 512
__$ArrayPad$ = -4					; size = 4
_publisher$ = 8						; size = 4
?CreateConnectionThread@RTMPPublisher@@CGKPAV1@@Z PROC	; RTMPPublisher::CreateConnectionThread, COMDAT

; 840  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 788				; 00000314H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR $T24[ebp], 0

; 841  :     //------------------------------------------------------
; 842  :     // set up URL
; 843  : 
; 844  :     bool bSuccess = false;

	mov	BYTE PTR _bSuccess$[ebp], 0

; 845  :     bool bCanRetry = false;

	mov	BYTE PTR _bCanRetry$[ebp], 0

; 846  : 
; 847  :     RTMP *rtmp = nullptr;

	mov	DWORD PTR _rtmp$[ebp], 0

; 848  : 
; 849  :     String failReason;

	lea	ecx, DWORD PTR _failReason$[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 850  :     String strBindIP;

	lea	ecx, DWORD PTR _strBindIP$[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 851  : 
; 852  :     String strURL       = AppConfig->GetString(TEXT("Publish"), TEXT("URL"));

	push	0
	push	OFFSET $SG4294776923
	push	OFFSET $SG4294776922
	lea	eax, DWORD PTR _strURL$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetString@ConfigFile@@QAE?AVString@@PB_W00@Z

; 853  :     String strPlayPath  = AppConfig->GetString(TEXT("Publish"), TEXT("PlayPath"));

	push	0
	push	OFFSET $SG4294776921
	push	OFFSET $SG4294776920
	lea	ecx, DWORD PTR _strPlayPath$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetString@ConfigFile@@QAE?AVString@@PB_W00@Z

; 854  : 
; 855  :     strURL.KillSpaces();

	lea	ecx, DWORD PTR _strURL$[ebp]
	call	DWORD PTR __imp_?KillSpaces@String@@QAEAAV1@XZ

; 856  :     strPlayPath.KillSpaces();

	lea	ecx, DWORD PTR _strPlayPath$[ebp]
	call	DWORD PTR __imp_?KillSpaces@String@@QAEAAV1@XZ

; 857  : 
; 858  :     LPSTR lpAnsiURL = NULL, lpAnsiPlaypath = NULL;

	mov	DWORD PTR _lpAnsiURL$[ebp], 0
	mov	DWORD PTR _lpAnsiPlaypath$[ebp], 0

; 859  : 
; 860  :     //--------------------------------
; 861  :     // unbelievably disgusting hack for elgato devices (should no longer be necessary)
; 862  : 
; 863  :     /*String strOldDirectory;
; 864  :     UINT dirSize = GetCurrentDirectory(0, 0);
; 865  :     strOldDirectory.SetLength(dirSize);
; 866  :     GetCurrentDirectory(dirSize, strOldDirectory.Array());
; 867  : 
; 868  :     OSSetCurrentDirectory(API->GetAppPath());*/
; 869  : 
; 870  :     //--------------------------------
; 871  : 
; 872  :     ServiceIdentifier sid = GetCurrentService();

	lea	edx, DWORD PTR _sid$[ebp]
	push	edx
	call	?GetCurrentService@@YA?AUServiceIdentifier@@XZ ; GetCurrentService
	add	esp, 4

; 873  : 
; 874  :     //--------------------------------
; 875  : 
; 876  :     if(!strURL.IsValid())

	lea	ecx, DWORD PTR _strURL$[ebp]
	call	DWORD PTR __imp_?IsValid@String@@QBEHXZ
	test	eax, eax
	jne	SHORT $LN44@CreateConn

; 877  :     {
; 878  :         failReason = TEXT("No server specified to connect to");

	push	OFFSET $SG4294776919
	lea	ecx, DWORD PTR _failReason$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z

; 879  :         goto end;

	jmp	$end$60
$LN44@CreateConn:

; 880  :     }
; 881  : 
; 882  :     // A service ID implies the settings have come from the xconfig file.
; 883  :     if(sid.id != 0 || sid.file.IsValid())

	cmp	DWORD PTR _sid$[ebp], 0
	jne	SHORT $LN41@CreateConn
	lea	ecx, DWORD PTR _sid$[ebp+4]
	call	DWORD PTR __imp_?IsValid@String@@QBEHXZ
	test	eax, eax
	je	$LN42@CreateConn
$LN41@CreateConn:

; 884  :     {
; 885  :         auto serviceData = LoadService(&failReason);

	lea	eax, DWORD PTR _failReason$[ebp]
	push	eax
	lea	ecx, DWORD PTR _serviceData$22[ebp]
	push	ecx
	call	?LoadService@@YA?AU?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@@std@@PAVString@@@Z ; LoadService
	add	esp, 8

; 886  :         auto service = serviceData.second;

	mov	edx, DWORD PTR _serviceData$22[ebp+4]
	mov	DWORD PTR _service$21[ebp], edx

; 887  : 
; 888  :         if(!service)

	cmp	DWORD PTR _service$21[ebp], 0
	jne	SHORT $LN40@CreateConn

; 889  :         {
; 890  :             if (failReason.IsEmpty())

	lea	ecx, DWORD PTR _failReason$[ebp]
	call	DWORD PTR __imp_?IsEmpty@String@@QBEHXZ
	test	eax, eax
	je	SHORT __unwind$?CreateConnectionThread@RTMPPublisher@@CGKPAV1@@Z$1

; 891  :                 failReason = TEXT("Could not find the service specified in services.xconfig");

	push	OFFSET $SG4294776918
	lea	ecx, DWORD PTR _failReason$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z
__unwind$?CreateConnectionThread@RTMPPublisher@@CGKPAV1@@Z$1:

; 1099 : 
; 1100 : end:

	lea	ecx, DWORD PTR _serviceData$22[ebp]
	call	??1?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@@std@@QAE@XZ

; 892  :             goto end;

	jmp	$end$60
$LN40@CreateConn:

; 893  :         }
; 894  : 
; 895  :         // Each service can have many ingestion servers. Look up a server for a particular service.
; 896  :         XElement *servers = service->GetElement(TEXT("servers"));

	push	OFFSET $SG4294776917
	mov	ecx, DWORD PTR _service$21[ebp]
	call	DWORD PTR __imp_?GetElement@XElement@@QBEPAV1@PB_W@Z
	mov	DWORD PTR _servers$18[ebp], eax

; 897  :         if(!servers)

	cmp	DWORD PTR _servers$18[ebp], 0
	jne	SHORT $LN37@CreateConn

; 898  :         {
; 899  :             failReason = TEXT("Could not find any servers for the service specified in services.xconfig");

	push	OFFSET $SG4294776916
	lea	ecx, DWORD PTR _failReason$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z

; 1099 : 
; 1100 : end:

	lea	ecx, DWORD PTR _serviceData$22[ebp]
	call	??1?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@@std@@QAE@XZ

; 900  :             goto end;

	jmp	$end$60
$LN37@CreateConn:

; 901  :         }
; 902  : 
; 903  :         // Got the server node now so can look up the ingestion URL.
; 904  :         XDataItem *item = servers->GetDataItem(strURL);

	lea	ecx, DWORD PTR _strURL$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	mov	ecx, DWORD PTR _servers$18[ebp]
	call	DWORD PTR __imp_?GetDataItem@XElement@@QBEPAVXDataItem@@PB_W@Z
	mov	DWORD PTR _item$20[ebp], eax

; 905  :         if(!item)

	cmp	DWORD PTR _item$20[ebp], 0
	jne	SHORT $LN35@CreateConn

; 906  :             item = servers->GetDataItemByID(0);

	push	0
	mov	ecx, DWORD PTR _servers$18[ebp]
	call	DWORD PTR __imp_?GetDataItemByID@XElement@@QBEPAVXDataItem@@K@Z
	mov	DWORD PTR _item$20[ebp], eax
$LN35@CreateConn:

; 907  : 
; 908  :         strURL = item->GetData();

	mov	ecx, DWORD PTR _item$20[ebp]
	call	?GetData@XDataItem@@QBEPB_WXZ		; XDataItem::GetData
	push	eax
	lea	ecx, DWORD PTR _strURL$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z

; 909  : 
; 910  :         // Stream urls start with RTMP. If there's an HTTP(S) then assume this is a web API call
; 911  :         // to get the proper data.
; 912  :         if ((strURL.Left(5).MakeLower() == "https") || (strURL.Left(4).MakeLower() == "http"))

	push	OFFSET $SG4294776915
	lea	ecx, DWORD PTR $T8[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PBD@Z
	or	DWORD PTR $T24[ebp], 1
	or	DWORD PTR $T24[ebp], 2
	lea	eax, DWORD PTR $T8[ebp]
	push	eax
	push	5
	lea	ecx, DWORD PTR $T7[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strURL$[ebp]
	call	DWORD PTR __imp_?Left@String@@QAE?AV1@I@Z
	mov	ecx, eax
	call	DWORD PTR __imp_?MakeLower@String@@QAEAAV1@XZ
	mov	ecx, eax
	call	DWORD PTR __imp_??8String@@QBEHABV0@@Z
	test	eax, eax
	jne	SHORT $LN47@CreateConn
	push	OFFSET $SG4294776914
	lea	ecx, DWORD PTR $T9[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PBD@Z
	or	DWORD PTR $T24[ebp], 4
	or	DWORD PTR $T24[ebp], 8
	lea	edx, DWORD PTR $T9[ebp]
	push	edx
	push	4
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	lea	ecx, DWORD PTR _strURL$[ebp]
	call	DWORD PTR __imp_?Left@String@@QAE?AV1@I@Z
	mov	ecx, eax
	call	DWORD PTR __imp_?MakeLower@String@@QAEAAV1@XZ
	mov	ecx, eax
	call	DWORD PTR __imp_??8String@@QBEHABV0@@Z
	test	eax, eax
	jne	SHORT $LN47@CreateConn
	mov	DWORD PTR tv191[ebp], 0
	jmp	SHORT $LN48@CreateConn
$LN47@CreateConn:
	mov	DWORD PTR tv191[ebp], 1
$LN48@CreateConn:
	mov	cl, BYTE PTR tv191[ebp]
	mov	BYTE PTR $T23[ebp], cl
	mov	edx, DWORD PTR $T24[ebp]
	and	edx, 8
	je	SHORT $LN53@CreateConn
	and	DWORD PTR $T24[ebp], -9			; fffffff7H
	lea	ecx, DWORD PTR $T5[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN53@CreateConn:
	mov	eax, DWORD PTR $T24[ebp]
	and	eax, 4
	je	SHORT $LN54@CreateConn
	and	DWORD PTR $T24[ebp], -5			; fffffffbH
	lea	ecx, DWORD PTR $T9[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN54@CreateConn:
	mov	ecx, DWORD PTR $T24[ebp]
	and	ecx, 2
	je	SHORT $LN55@CreateConn
	and	DWORD PTR $T24[ebp], -3			; fffffffdH
	lea	ecx, DWORD PTR $T7[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN55@CreateConn:
	mov	edx, DWORD PTR $T24[ebp]
	and	edx, 1
	je	SHORT $LN56@CreateConn
	and	DWORD PTR $T24[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T8[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN56@CreateConn:
	movzx	eax, BYTE PTR $T23[ebp]
	test	eax, eax
	je	$LN34@CreateConn

; 913  :         {
; 914  :             // Query the web API for stream details
; 915  :             String web_url = strURL + strPlayPath;

	lea	ecx, DWORD PTR _strPlayPath$[ebp]
	push	ecx
	lea	edx, DWORD PTR _web_url$16[ebp]
	push	edx
	lea	ecx, DWORD PTR _strURL$[ebp]
	call	DWORD PTR __imp_??HString@@QBE?AV0@ABV0@@Z

; 916  : 
; 917  :             int responseCode;
; 918  :             TCHAR extraHeaders[256];
; 919  : 
; 920  :             extraHeaders[0] = 0;

	mov	eax, 2
	imul	ecx, eax, 0
	mov	DWORD PTR $T13[ebp], ecx
	cmp	DWORD PTR $T13[ebp], 512		; 00000200H
	jae	SHORT $LN49@CreateConn
	jmp	SHORT $LN50@CreateConn
$LN49@CreateConn:
	call	___report_rangecheckfailure
$LN50@CreateConn:
	xor	edx, edx
	mov	eax, DWORD PTR $T13[ebp]
	mov	WORD PTR _extraHeaders$25[ebp+eax], dx

; 921  : 
; 922  :             String response = HTTPGetString(web_url, extraHeaders, &responseCode);

	lea	ecx, DWORD PTR _responseCode$15[ebp]
	push	ecx
	lea	edx, DWORD PTR _extraHeaders$25[ebp]
	push	edx
	lea	ecx, DWORD PTR _web_url$16[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	lea	eax, DWORD PTR _response$17[ebp]
	push	eax
	call	?HTTPGetString@@YA?AVString@@PB_W0PAH@Z	; HTTPGetString
	add	esp, 16					; 00000010H

; 923  : 
; 924  :             if (responseCode != 200 && responseCode != 304)

	cmp	DWORD PTR _responseCode$15[ebp], 200	; 000000c8H
	je	SHORT $LN33@CreateConn
	cmp	DWORD PTR _responseCode$15[ebp], 304	; 00000130H
	je	SHORT $LN33@CreateConn

; 925  :             {
; 926  :                 failReason = TEXT("Webserver failed to respond with valid stream details.");

	push	OFFSET $SG4294776913
	lea	ecx, DWORD PTR _failReason$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z

; 1099 : 
; 1100 : end:

	lea	ecx, DWORD PTR _response$17[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _web_url$16[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _serviceData$22[ebp]
	call	??1?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@@std@@QAE@XZ

; 927  :                 goto end;

	jmp	$end$60
$LN33@CreateConn:

; 928  :             }
; 929  : 
; 930  :             XConfig apiData;

	lea	ecx, DWORD PTR _apiData$11[ebp]
	call	DWORD PTR __imp_??0XConfig@@QAE@XZ

; 931  : 
; 932  :             // Expecting a response from the web API to look like this:
; 933  :             // {"data":{"stream_url":"rtmp://some_url", "stream_name": "some-name"}}
; 934  :             // A nice bit of JSON which is basically the same as the structure for XConfig.
; 935  :             if(!apiData.ParseString(response))

	lea	ecx, DWORD PTR _response$17[ebp]
	push	ecx
	lea	ecx, DWORD PTR _apiData$11[ebp]
	call	DWORD PTR __imp_?ParseString@XConfig@@QAE_NABVString@@@Z
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN31@CreateConn

; 936  :             {
; 937  :                 failReason = TEXT("Could not understand response from webserver.");

	push	OFFSET $SG4294776912
	lea	ecx, DWORD PTR _failReason$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z

; 1099 : 
; 1100 : end:

	lea	ecx, DWORD PTR _apiData$11[ebp]
	call	DWORD PTR __imp_??1XConfig@@QAE@XZ
	lea	ecx, DWORD PTR _response$17[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _web_url$16[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _serviceData$22[ebp]
	call	??1?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@@std@@QAE@XZ

; 938  :                 goto end;

	jmp	$end$60
$LN31@CreateConn:

; 939  :             }
; 940  : 
; 941  :             // We could have read an error string back from the server.
; 942  :             // So we need to trap any missing bits of data.
; 943  : 
; 944  :             XElement *p_data = apiData.GetElement(TEXT("data"));

	push	OFFSET $SG4294776911
	lea	ecx, DWORD PTR _apiData$11[ebp]
	call	DWORD PTR __imp_?GetElement@XConfig@@QAEPAVXElement@@PB_W@Z
	mov	DWORD PTR _p_data$19[ebp], eax

; 945  : 
; 946  :             if (p_data == NULL)

	cmp	DWORD PTR _p_data$19[ebp], 0
	jne	SHORT $LN29@CreateConn

; 947  :             {
; 948  :                 failReason = TEXT("No valid data returned from web server.");

	push	OFFSET $SG4294776910
	lea	ecx, DWORD PTR _failReason$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z

; 1099 : 
; 1100 : end:

	lea	ecx, DWORD PTR _apiData$11[ebp]
	call	DWORD PTR __imp_??1XConfig@@QAE@XZ
	lea	ecx, DWORD PTR _response$17[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _web_url$16[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _serviceData$22[ebp]
	call	??1?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@@std@@QAE@XZ

; 949  :                 goto end;

	jmp	$end$60
$LN29@CreateConn:

; 950  :             }
; 951  : 
; 952  :             XDataItem *p_stream_url_data = p_data->GetDataItem(TEXT("stream_url"));

	push	OFFSET $SG4294776909
	mov	ecx, DWORD PTR _p_data$19[ebp]
	call	DWORD PTR __imp_?GetDataItem@XElement@@QBEPAVXDataItem@@PB_W@Z
	mov	DWORD PTR _p_stream_url_data$14[ebp], eax

; 953  : 
; 954  :             if (p_stream_url_data == NULL)

	cmp	DWORD PTR _p_stream_url_data$14[ebp], 0
	jne	SHORT $LN27@CreateConn

; 955  :             {
; 956  :                 failReason = TEXT("No valid broadcast stream URL returned from web server.");

	push	OFFSET $SG4294776908
	lea	ecx, DWORD PTR _failReason$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z

; 1099 : 
; 1100 : end:

	lea	ecx, DWORD PTR _apiData$11[ebp]
	call	DWORD PTR __imp_??1XConfig@@QAE@XZ
	lea	ecx, DWORD PTR _response$17[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _web_url$16[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _serviceData$22[ebp]
	call	??1?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@@std@@QAE@XZ

; 957  :                 goto end;

	jmp	$end$60
$LN27@CreateConn:

; 958  :             }
; 959  : 
; 960  :             strURL = p_stream_url_data->GetData();

	mov	ecx, DWORD PTR _p_stream_url_data$14[ebp]
	call	?GetData@XDataItem@@QBEPB_WXZ		; XDataItem::GetData
	push	eax
	lea	ecx, DWORD PTR _strURL$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z

; 961  : 
; 962  :             XDataItem *p_stream_name_data = p_data->GetDataItem(TEXT("stream_name"));

	push	OFFSET $SG4294776907
	mov	ecx, DWORD PTR _p_data$19[ebp]
	call	DWORD PTR __imp_?GetDataItem@XElement@@QBEPAVXDataItem@@PB_W@Z
	mov	DWORD PTR _p_stream_name_data$12[ebp], eax

; 963  : 
; 964  :             if (p_stream_name_data == NULL)

	cmp	DWORD PTR _p_stream_name_data$12[ebp], 0
	jne	SHORT $LN25@CreateConn

; 965  :             {
; 966  :                 failReason = TEXT("No valid stream name/path returned from web server.");

	push	OFFSET $SG4294776906
	lea	ecx, DWORD PTR _failReason$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z

; 1099 : 
; 1100 : end:

	lea	ecx, DWORD PTR _apiData$11[ebp]
	call	DWORD PTR __imp_??1XConfig@@QAE@XZ
	lea	ecx, DWORD PTR _response$17[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _web_url$16[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _serviceData$22[ebp]
	call	??1?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@@std@@QAE@XZ

; 967  :                 goto end;

	jmp	$end$60
$LN25@CreateConn:

; 968  :             }
; 969  : 
; 970  :             strPlayPath = p_stream_name_data->GetData();

	mov	ecx, DWORD PTR _p_stream_name_data$12[ebp]
	call	?GetData@XDataItem@@QBEPB_WXZ		; XDataItem::GetData
	push	eax
	lea	ecx, DWORD PTR _strPlayPath$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z

; 971  : 
; 972  :             Log(TEXT("Web API returned URL: %s"), strURL.Array());

	lea	ecx, DWORD PTR _strURL$[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET $SG4294776905
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8

; 973  :         }

	lea	ecx, DWORD PTR _apiData$11[ebp]
	call	DWORD PTR __imp_??1XConfig@@QAE@XZ
	lea	ecx, DWORD PTR _response$17[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _web_url$16[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN34@CreateConn:

; 974  : 
; 975  :         Log(TEXT("Using RTMP service: %s"), service->GetName());

	mov	ecx, DWORD PTR _service$21[ebp]
	call	DWORD PTR __imp_?GetName@XBaseItem@@QBEPB_WXZ
	push	eax
	push	OFFSET $SG4294776904
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8

; 976  :         Log(TEXT("  Server selection: %s"), strURL.Array());

	lea	ecx, DWORD PTR _strURL$[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET $SG4294776903
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8

; 977  :     }

	lea	ecx, DWORD PTR _serviceData$22[ebp]
	call	??1?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@@std@@QAE@XZ
$LN42@CreateConn:

; 978  : 
; 979  :     //------------------------------------------------------
; 980  :     // now back to the elgato directory if it needs the directory changed still to function *sigh*
; 981  : 
; 982  :     //OSSetCurrentDirectory(strOldDirectory);
; 983  : 
; 984  :     //------------------------------------------------------
; 985  : 
; 986  :     OSEnterMutex(publisher->hRTMPMutex);

	mov	eax, DWORD PTR _publisher$[ebp]
	mov	ecx, DWORD PTR [eax+136]
	push	ecx
	call	DWORD PTR __imp_?OSEnterMutex@@YGXPAX@Z

; 987  :     publisher->rtmp = RTMP_Alloc();

	call	_RTMP_Alloc
	mov	edx, DWORD PTR _publisher$[ebp]
	mov	DWORD PTR [edx+100], eax

; 988  : 
; 989  :     rtmp = publisher->rtmp;

	mov	eax, DWORD PTR _publisher$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR _rtmp$[ebp], ecx

; 990  :     RTMP_Init(rtmp);

	mov	ecx, DWORD PTR _rtmp$[ebp]
	call	_RTMP_Init

; 991  : 
; 992  :     RTMP_LogSetCallback(librtmpErrorCallback);

	mov	ecx, OFFSET ?librtmpErrorCallback@RTMPPublisher@@CAXHPBDPAD@Z ; RTMPPublisher::librtmpErrorCallback
	call	_RTMP_LogSetCallback

; 993  : 
; 994  :     OSLeaveMutex(publisher->hRTMPMutex);

	mov	edx, DWORD PTR _publisher$[ebp]
	mov	eax, DWORD PTR [edx+136]
	push	eax
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z

; 995  : 
; 996  :     //RTMP_LogSetLevel(RTMP_LOGERROR);
; 997  : 
; 998  :     lpAnsiURL = strURL.CreateUTF8String();

	lea	ecx, DWORD PTR _strURL$[ebp]
	call	DWORD PTR __imp_?CreateUTF8String@String@@QAEPADXZ
	mov	DWORD PTR _lpAnsiURL$[ebp], eax

; 999  :     lpAnsiPlaypath = strPlayPath.CreateUTF8String();

	lea	ecx, DWORD PTR _strPlayPath$[ebp]
	call	DWORD PTR __imp_?CreateUTF8String@String@@QAEPADXZ
	mov	DWORD PTR _lpAnsiPlaypath$[ebp], eax

; 1000 : 
; 1001 :     if(!RTMP_SetupURL2(rtmp, lpAnsiURL, lpAnsiPlaypath))

	mov	ecx, DWORD PTR _lpAnsiPlaypath$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpAnsiURL$[ebp]
	mov	ecx, DWORD PTR _rtmp$[ebp]
	call	_RTMP_SetupURL2
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN23@CreateConn

; 1002 :     {
; 1003 :         failReason = Str("Connection.CouldNotParseURL");

	push	OFFSET $SG4294776902
	mov	edx, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [edx]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	lea	ecx, DWORD PTR _failReason$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z

; 1004 :         goto end;

	jmp	$end$60
$LN23@CreateConn:

; 1005 :     }
; 1006 : 
; 1007 :     // A user name and password can be kept in the .ini file
; 1008 :     // If there's some credentials there then they'll be used in the RTMP channel
; 1009 :     char *rtmpUser = AppConfig->GetString(TEXT("Publish"), TEXT("Username")).CreateUTF8String();

	push	0
	push	OFFSET $SG4294776901
	push	OFFSET $SG4294776900
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetString@ConfigFile@@QAE?AVString@@PB_W00@Z
	mov	ecx, eax
	call	DWORD PTR __imp_?CreateUTF8String@String@@QAEPADXZ
	mov	DWORD PTR _rtmpUser$[ebp], eax
	lea	ecx, DWORD PTR $T3[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 1010 :     char *rtmpPass = AppConfig->GetString(TEXT("Publish"), TEXT("Password")).CreateUTF8String();

	push	0
	push	OFFSET $SG4294776899
	push	OFFSET $SG4294776898
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetString@ConfigFile@@QAE?AVString@@PB_W00@Z
	mov	ecx, eax
	call	DWORD PTR __imp_?CreateUTF8String@String@@QAEPADXZ
	mov	DWORD PTR _rtmpPass$[ebp], eax
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 1011 : 
; 1012 :     if (rtmpUser)

	cmp	DWORD PTR _rtmpUser$[ebp], 0
	je	SHORT $LN21@CreateConn

; 1013 :     {
; 1014 :         rtmp->Link.pubUser.av_val = rtmpUser;

	mov	edx, DWORD PTR _rtmp$[ebp]
	mov	eax, DWORD PTR _rtmpUser$[ebp]
	mov	DWORD PTR [edx+16892], eax

; 1015 :         rtmp->Link.pubUser.av_len = (int)strlen(rtmpUser);

	mov	ecx, DWORD PTR _rtmpUser$[ebp]
	mov	DWORD PTR tv705[ebp], ecx
	mov	edx, DWORD PTR tv705[ebp]
	add	edx, 1
	mov	DWORD PTR tv708[ebp], edx
$LL57@CreateConn:
	mov	eax, DWORD PTR tv705[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv711[ebp], cl
	add	DWORD PTR tv705[ebp], 1
	cmp	BYTE PTR tv711[ebp], 0
	jne	SHORT $LL57@CreateConn
	mov	edx, DWORD PTR tv705[ebp]
	sub	edx, DWORD PTR tv708[ebp]
	mov	DWORD PTR tv383[ebp], edx
	mov	eax, DWORD PTR _rtmp$[ebp]
	mov	ecx, DWORD PTR tv383[ebp]
	mov	DWORD PTR [eax+16896], ecx
$LN21@CreateConn:

; 1016 :     }
; 1017 : 
; 1018 :     if (rtmpPass)

	cmp	DWORD PTR _rtmpPass$[ebp], 0
	je	SHORT $LN20@CreateConn

; 1019 :     {
; 1020 :         rtmp->Link.pubPasswd.av_val = rtmpPass;

	mov	edx, DWORD PTR _rtmp$[ebp]
	mov	eax, DWORD PTR _rtmpPass$[ebp]
	mov	DWORD PTR [edx+16900], eax

; 1021 :         rtmp->Link.pubPasswd.av_len = (int)strlen(rtmpPass);

	mov	ecx, DWORD PTR _rtmpPass$[ebp]
	mov	DWORD PTR tv720[ebp], ecx
	mov	edx, DWORD PTR tv720[ebp]
	add	edx, 1
	mov	DWORD PTR tv723[ebp], edx
$LL58@CreateConn:
	mov	eax, DWORD PTR tv720[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv726[ebp], cl
	add	DWORD PTR tv720[ebp], 1
	cmp	BYTE PTR tv726[ebp], 0
	jne	SHORT $LL58@CreateConn
	mov	edx, DWORD PTR tv720[ebp]
	sub	edx, DWORD PTR tv723[ebp]
	mov	DWORD PTR tv393[ebp], edx
	mov	eax, DWORD PTR _rtmp$[ebp]
	mov	ecx, DWORD PTR tv393[ebp]
	mov	DWORD PTR [eax+16904], ecx
$LN20@CreateConn:

; 1022 :     }
; 1023 : 
; 1024 :     RTMP_EnableWrite(rtmp); //set it to publish

	mov	ecx, DWORD PTR _rtmp$[ebp]
	call	_RTMP_EnableWrite

; 1025 : 
; 1026 :     rtmp->Link.swfUrl.av_len = rtmp->Link.tcUrl.av_len;

	mov	edx, DWORD PTR _rtmp$[ebp]
	mov	eax, DWORD PTR _rtmp$[ebp]
	mov	ecx, DWORD PTR [eax+16824]
	mov	DWORD PTR [edx+16832], ecx

; 1027 :     rtmp->Link.swfUrl.av_val = rtmp->Link.tcUrl.av_val;

	mov	edx, DWORD PTR _rtmp$[ebp]
	mov	eax, DWORD PTR _rtmp$[ebp]
	mov	ecx, DWORD PTR [eax+16820]
	mov	DWORD PTR [edx+16828], ecx

; 1028 :     /*rtmp->Link.pageUrl.av_len = rtmp->Link.tcUrl.av_len;
; 1029 :     rtmp->Link.pageUrl.av_val = rtmp->Link.tcUrl.av_val;*/
; 1030 :     rtmp->Link.flashVer.av_val = "FMLE/3.0 (compatible; FMSc/1.0)";

	mov	edx, DWORD PTR _rtmp$[ebp]
	mov	DWORD PTR [edx+16860], OFFSET $SG4294776897

; 1031 :     rtmp->Link.flashVer.av_len = (int)strlen(rtmp->Link.flashVer.av_val);

	mov	eax, DWORD PTR _rtmp$[ebp]
	mov	ecx, DWORD PTR [eax+16860]
	mov	DWORD PTR tv741[ebp], ecx
	mov	edx, DWORD PTR tv741[ebp]
	add	edx, 1
	mov	DWORD PTR tv744[ebp], edx
$LL59@CreateConn:
	mov	eax, DWORD PTR tv741[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv747[ebp], cl
	add	DWORD PTR tv741[ebp], 1
	cmp	BYTE PTR tv747[ebp], 0
	jne	SHORT $LL59@CreateConn
	mov	edx, DWORD PTR tv741[ebp]
	sub	edx, DWORD PTR tv744[ebp]
	mov	DWORD PTR tv418[ebp], edx
	mov	eax, DWORD PTR _rtmp$[ebp]
	mov	ecx, DWORD PTR tv418[ebp]
	mov	DWORD PTR [eax+16864], ecx

; 1032 : 
; 1033 :     //-----------------------------------------
; 1034 : 
; 1035 :     UINT tcpBufferSize = AppConfig->GetInt(TEXT("Publish"), TEXT("TCPBufferSize"), 64*1024);

	push	65536					; 00010000H
	push	OFFSET $SG4294776896
	push	OFFSET $SG4294776895
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _tcpBufferSize$[ebp], eax

; 1036 : 
; 1037 :     if(tcpBufferSize < 8192)

	cmp	DWORD PTR _tcpBufferSize$[ebp], 8192	; 00002000H
	jae	SHORT $LN19@CreateConn

; 1038 :         tcpBufferSize = 8192;

	mov	DWORD PTR _tcpBufferSize$[ebp], 8192	; 00002000H
	jmp	SHORT $LN18@CreateConn
$LN19@CreateConn:

; 1039 :     else if(tcpBufferSize > 1024*1024)

	cmp	DWORD PTR _tcpBufferSize$[ebp], 1048576	; 00100000H
	jbe	SHORT $LN18@CreateConn

; 1040 :         tcpBufferSize = 1024*1024;

	mov	DWORD PTR _tcpBufferSize$[ebp], 1048576	; 00100000H
$LN18@CreateConn:

; 1041 : 
; 1042 :     rtmp->m_outChunkSize = 4096;//RTMP_DEFAULT_CHUNKSIZE;//

	mov	edx, DWORD PTR _rtmp$[ebp]
	mov	DWORD PTR [edx+4], 4096			; 00001000H

; 1043 :     rtmp->m_bSendChunkSizeInfo = TRUE;

	mov	eax, DWORD PTR _rtmp$[ebp]
	mov	BYTE PTR [eax+208], 1

; 1044 : 
; 1045 :     rtmp->m_bUseNagle = TRUE;

	mov	ecx, DWORD PTR _rtmp$[ebp]
	mov	BYTE PTR [ecx+56], 1

; 1046 : 
; 1047 :     strBindIP = AppConfig->GetString(TEXT("Publish"), TEXT("BindToIP"), TEXT("Default"));

	push	OFFSET $SG4294776894
	push	OFFSET $SG4294776893
	push	OFFSET $SG4294776892
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetString@ConfigFile@@QAE?AVString@@PB_W00@Z
	push	eax
	lea	ecx, DWORD PTR _strBindIP$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 1048 :     if (scmp(strBindIP, TEXT("Default")))

	push	OFFSET $SG4294776891
	lea	ecx, DWORD PTR _strBindIP$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?scmp@@YGHPB_W0@Z
	test	eax, eax
	je	$LN16@CreateConn

; 1049 :     {
; 1050 :         Log(TEXT("  Binding to non-default IP %s"), strBindIP.Array());

	lea	ecx, DWORD PTR _strBindIP$[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET $SG4294776890
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8

; 1051 : 
; 1052 :         if (schr(strBindIP.Array(), ':'))

	push	58					; 0000003aH
	lea	ecx, DWORD PTR _strBindIP$[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?schr@@YGPA_WPB_W_W@Z
	test	eax, eax
	je	SHORT $LN15@CreateConn

; 1053 :             rtmp->m_bindIP.addr.ss_family = AF_INET6;

	mov	eax, 23					; 00000017H
	mov	ecx, DWORD PTR _rtmp$[ebp]
	mov	WORD PTR [ecx+72], ax

; 1054 :         else

	jmp	SHORT $LN14@CreateConn
$LN15@CreateConn:

; 1055 :             rtmp->m_bindIP.addr.ss_family = AF_INET;

	mov	edx, 2
	mov	eax, DWORD PTR _rtmp$[ebp]
	mov	WORD PTR [eax+72], dx
$LN14@CreateConn:

; 1056 :         rtmp->m_bindIP.addrLen = sizeof(rtmp->m_bindIP.addr);

	mov	ecx, DWORD PTR _rtmp$[ebp]
	mov	DWORD PTR [ecx+200], 128		; 00000080H

; 1057 : 
; 1058 :         if (WSAStringToAddress(strBindIP.Array(), rtmp->m_bindIP.addr.ss_family, NULL, (LPSOCKADDR)&rtmp->m_bindIP.addr, &rtmp->m_bindIP.addrLen) == SOCKET_ERROR)

	mov	edx, DWORD PTR _rtmp$[ebp]
	add	edx, 200				; 000000c8H
	push	edx
	mov	eax, DWORD PTR _rtmp$[ebp]
	add	eax, 72					; 00000048H
	push	eax
	push	0
	mov	ecx, DWORD PTR _rtmp$[ebp]
	movzx	edx, WORD PTR [ecx+72]
	push	edx
	lea	ecx, DWORD PTR _strBindIP$[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp__WSAStringToAddressW@20
	cmp	eax, -1
	jne	SHORT $LN16@CreateConn

; 1059 :         {
; 1060 :             // no localization since this should rarely/never happen
; 1061 :             failReason = TEXT("WSAStringToAddress: Could not parse address");

	push	OFFSET $SG4294776889
	lea	ecx, DWORD PTR _failReason$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z

; 1062 :             goto end;

	jmp	$end$60
$LN16@CreateConn:

; 1063 :         }
; 1064 :     }
; 1065 : 
; 1066 :     LogInterfaceType(rtmp);

	mov	eax, DWORD PTR _rtmp$[ebp]
	push	eax
	call	?LogInterfaceType@@YAXPAURTMP@@@Z	; LogInterfaceType
	add	esp, 4

; 1067 : 
; 1068 :     //-----------------------------------------
; 1069 : 
; 1070 :     DWORD startTime = OSGetTime();

	call	DWORD PTR __imp_?OSGetTime@@YGKXZ
	mov	DWORD PTR _startTime$[ebp], eax

; 1071 : 
; 1072 :     if(!RTMP_Connect(rtmp, NULL))

	xor	edx, edx
	mov	ecx, DWORD PTR _rtmp$[ebp]
	call	_RTMP_Connect
	test	eax, eax
	jne	SHORT $LN11@CreateConn

; 1073 :     {
; 1074 :         failReason = Str("Connection.CouldNotConnect");

	push	OFFSET $SG4294776888
	mov	ecx, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	lea	ecx, DWORD PTR _failReason$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z

; 1075 :         failReason << TEXT("\r\n\r\n") << RTMPPublisher::GetRTMPErrors();

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	call	?GetRTMPErrors@RTMPPublisher@@CA?AVString@@XZ ; RTMPPublisher::GetRTMPErrors
	add	esp, 4
	push	eax
	push	OFFSET $SG4294776887
	lea	ecx, DWORD PTR _failReason$[ebp]
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T4[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 1076 :         bCanRetry = true;

	mov	BYTE PTR _bCanRetry$[ebp], 1

; 1077 :         goto end;

	jmp	$end$60
$LN11@CreateConn:

; 1078 :     }
; 1079 : 
; 1080 :     Log(TEXT("Completed handshake with %s in %u ms."), strURL.Array(), OSGetTime() - startTime);

	call	DWORD PTR __imp_?OSGetTime@@YGKXZ
	sub	eax, DWORD PTR _startTime$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strURL$[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET $SG4294776886
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 12					; 0000000cH

; 1081 : 
; 1082 :     if(!RTMP_ConnectStream(rtmp, 0))

	xor	edx, edx
	mov	ecx, DWORD PTR _rtmp$[ebp]
	call	_RTMP_ConnectStream
	test	eax, eax
	jne	SHORT $LN9@CreateConn

; 1083 :     {
; 1084 :         failReason = Str("Connection.InvalidStream");

	push	OFFSET $SG4294776885
	mov	eax, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	lea	ecx, DWORD PTR _failReason$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z

; 1085 :         failReason << TEXT("\r\n\r\n") << RTMPPublisher::GetRTMPErrors();

	lea	ecx, DWORD PTR $T6[ebp]
	push	ecx
	call	?GetRTMPErrors@RTMPPublisher@@CA?AVString@@XZ ; RTMPPublisher::GetRTMPErrors
	add	esp, 4
	push	eax
	push	OFFSET $SG4294776884
	lea	ecx, DWORD PTR _failReason$[ebp]
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T6[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 1086 :         bCanRetry = true;

	mov	BYTE PTR _bCanRetry$[ebp], 1

; 1087 :         goto end;

	jmp	SHORT $end$60
$LN9@CreateConn:

; 1088 :     }
; 1089 : 
; 1090 :     //-----------------------------------------
; 1091 : 
; 1092 :     OSDebugOut(TEXT("Connected: %u\r\n"), OSGetTime());

	call	DWORD PTR __imp_?OSGetTime@@YGKXZ
	push	eax
	push	OFFSET $SG4294776883
	call	DWORD PTR __imp_?OSDebugOut@@YAXPB_WZZ
	add	esp, 8

; 1093 : 
; 1094 :     publisher->RequestKeyframe(1000);

	push	1000					; 000003e8H
	mov	edx, DWORD PTR _publisher$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _publisher$[ebp]
	mov	edx, DWORD PTR [eax+36]
	call	edx

; 1095 : 
; 1096 :     //-----------------------------------------
; 1097 : 
; 1098 :     bSuccess = true;

	mov	BYTE PTR _bSuccess$[ebp], 1
$end$60:

; 1101 : 
; 1102 :     if (lpAnsiURL)

	cmp	DWORD PTR _lpAnsiURL$[ebp], 0
	je	SHORT $LN7@CreateConn

; 1103 :         Free(lpAnsiURL);

	mov	eax, DWORD PTR _lpAnsiURL$[ebp]
	push	eax
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4
$LN7@CreateConn:

; 1104 : 
; 1105 :     if (lpAnsiPlaypath)

	cmp	DWORD PTR _lpAnsiPlaypath$[ebp], 0
	je	SHORT $LN6@CreateConn

; 1106 :         Free(lpAnsiPlaypath);

	mov	ecx, DWORD PTR _lpAnsiPlaypath$[ebp]
	push	ecx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4
$LN6@CreateConn:

; 1107 : 
; 1108 :     if(!bSuccess)

	movzx	edx, BYTE PTR _bSuccess$[ebp]
	test	edx, edx
	jne	$LN5@CreateConn

; 1109 :     {
; 1110 :         OSEnterMutex(publisher->hRTMPMutex);

	mov	eax, DWORD PTR _publisher$[ebp]
	mov	ecx, DWORD PTR [eax+136]
	push	ecx
	call	DWORD PTR __imp_?OSEnterMutex@@YGXPAX@Z

; 1111 :         if(rtmp)

	cmp	DWORD PTR _rtmp$[ebp], 0
	je	SHORT $LN4@CreateConn

; 1112 :         {
; 1113 :             RTMP_Close(rtmp);

	mov	ecx, DWORD PTR _rtmp$[ebp]
	call	_RTMP_Close

; 1114 :             RTMP_Free(rtmp);

	mov	ecx, DWORD PTR _rtmp$[ebp]
	call	_RTMP_Free

; 1115 :             publisher->rtmp = NULL;

	mov	edx, DWORD PTR _publisher$[ebp]
	mov	DWORD PTR [edx+100], 0
$LN4@CreateConn:

; 1116 :         }
; 1117 :         OSLeaveMutex(publisher->hRTMPMutex);

	mov	eax, DWORD PTR _publisher$[ebp]
	mov	ecx, DWORD PTR [eax+136]
	push	ecx
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z

; 1118 : 
; 1119 :         if(failReason.IsValid())

	lea	ecx, DWORD PTR _failReason$[ebp]
	call	DWORD PTR __imp_?IsValid@String@@QBEHXZ
	test	eax, eax
	je	SHORT $LN3@CreateConn

; 1120 :             App->SetStreamReport(failReason);

	lea	ecx, DWORD PTR _failReason$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?SetStreamReport@OBS@@QAEXPB_W@Z	; OBS::SetStreamReport
$LN3@CreateConn:

; 1121 : 
; 1122 :         if(!publisher->bStopping)

	mov	edx, DWORD PTR _publisher$[ebp]
	movzx	eax, BYTE PTR [edx+176]
	test	eax, eax
	jne	SHORT $LN2@CreateConn

; 1123 :             PostMessage(hwndMain, OBS_REQUESTSTOP, bCanRetry ? 0 : 1, 0);

	movzx	ecx, BYTE PTR _bCanRetry$[ebp]
	test	ecx, ecx
	je	SHORT $LN51@CreateConn
	mov	DWORD PTR tv594[ebp], 0
	jmp	SHORT $LN52@CreateConn
$LN51@CreateConn:
	mov	DWORD PTR tv594[ebp], 1
$LN52@CreateConn:
	push	0
	mov	edx, DWORD PTR tv594[ebp]
	push	edx
	push	1025					; 00000401H
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	call	DWORD PTR __imp__PostMessageW@16
$LN2@CreateConn:

; 1124 : 
; 1125 :         Log(TEXT("Connection to %s failed: %s"), strURL.Array(), failReason.Array());

	lea	ecx, DWORD PTR _failReason$[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	lea	ecx, DWORD PTR _strURL$[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET $SG4294776882
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 12					; 0000000cH

; 1126 : 
; 1127 :         publisher->bStopping = true;

	mov	ecx, DWORD PTR _publisher$[ebp]
	mov	BYTE PTR [ecx+176], 1

; 1128 :     }
; 1129 :     else

	jmp	SHORT $LN1@CreateConn
$LN5@CreateConn:

; 1130 :     {
; 1131 :         publisher->Init(tcpBufferSize);

	mov	edx, DWORD PTR _tcpBufferSize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _publisher$[ebp]
	call	?Init@RTMPPublisher@@QAE_NI@Z		; RTMPPublisher::Init

; 1132 :         publisher->bConnected = true;

	mov	eax, DWORD PTR _publisher$[ebp]
	mov	BYTE PTR [eax+18], 1

; 1133 :         publisher->bConnecting = false;

	mov	ecx, DWORD PTR _publisher$[ebp]
	mov	BYTE PTR [ecx+17], 0
$LN1@CreateConn:

; 1134 :     }
; 1135 : 
; 1136 :     return 0;

	mov	DWORD PTR $T10[ebp], 0
	lea	ecx, DWORD PTR _sid$[ebp]
	call	??1ServiceIdentifier@@QAE@XZ
	lea	ecx, DWORD PTR _strPlayPath$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strURL$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strBindIP$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _failReason$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T10[ebp]
$LN46@CreateConn:

; 1137 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?CreateConnectionThread@RTMPPublisher@@CGKPAV1@@Z ENDP	; RTMPPublisher::CreateConnectionThread
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\rtmppublisher.cpp
;	COMDAT ?InitEncoderData@RTMPPublisher@@IAEXXZ
_TEXT	SEGMENT
tv72 = -20						; size = 4
tv79 = -16						; size = 4
_pend$ = -12						; size = 4
_enc$ = -8						; size = 4
_this$ = -4						; size = 4
?InitEncoderData@RTMPPublisher@@IAEXXZ PROC		; RTMPPublisher::InitEncoderData, COMDAT
; _this$ = ecx

; 202  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 203  :     if (encoderDataInitialized)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+42]
	test	ecx, ecx
	je	SHORT $LN2@InitEncode

; 204  :         return;

	jmp	$LN3@InitEncode
$LN2@InitEncode:

; 205  : 
; 206  :     encoderDataInitialized = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+42], 1

; 207  : 
; 208  :     dataBufferSize = (App->GetVideoEncoder()->GetBitRate() + App->GetAudioEncoder()->GetBitRate()) / 8 * 1024;

	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?GetVideoEncoder@OBS@@QBEPAVVideoEncoder@@XZ ; OBS::GetVideoEncoder
	mov	DWORD PTR tv72[ebp], eax
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?GetAudioEncoder@OBS@@QBEPAVAudioEncoder@@XZ ; OBS::GetAudioEncoder
	mov	DWORD PTR tv79[ebp], eax
	mov	eax, DWORD PTR tv79[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv79[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	mov	esi, eax
	mov	ecx, DWORD PTR tv72[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv72[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	add	eax, esi
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	shl	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+212], eax

; 209  :     if (dataBufferSize < 131072)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+212], 131072		; 00020000H
	jge	SHORT $LN1@InitEncode

; 210  :         dataBufferSize = 131072;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+212], 131072		; 00020000H
$LN1@InitEncode:

; 211  : 
; 212  :     metaDataPacketBuffer.resize(2048);

	push	2048					; 00000800H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?resize@?$vector@DV?$allocator@D@std@@@std@@QAEXI@Z ; std::vector<char,std::allocator<char> >::resize

; 213  : 
; 214  :     char *enc = metaDataPacketBuffer.data() + RTMP_MAX_HEADER_SIZE;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?data@?$vector@DV?$allocator@D@std@@@std@@QAEPADXZ ; std::vector<char,std::allocator<char> >::data
	add	eax, 18					; 00000012H
	mov	DWORD PTR _enc$[ebp], eax

; 215  :     char *pend = metaDataPacketBuffer.data() + metaDataPacketBuffer.size();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?data@?$vector@DV?$allocator@D@std@@@std@@QAEPADXZ ; std::vector<char,std::allocator<char> >::data
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	add	esi, eax
	mov	DWORD PTR _pend$[ebp], esi

; 216  :     enc = AMF_EncodeString(enc, pend, &av_setDataFrame);

	push	OFFSET _av_setDataFrame
	mov	edx, DWORD PTR _pend$[ebp]
	mov	ecx, DWORD PTR _enc$[ebp]
	call	_AMF_EncodeString
	add	esp, 4
	mov	DWORD PTR _enc$[ebp], eax

; 217  :     enc = AMF_EncodeString(enc, pend, &av_onMetaData);

	push	OFFSET _av_onMetaData
	mov	edx, DWORD PTR _pend$[ebp]
	mov	ecx, DWORD PTR _enc$[ebp]
	call	_AMF_EncodeString
	add	esp, 4
	mov	DWORD PTR _enc$[ebp], eax

; 218  :     enc = App->EncMetaData(enc, pend);

	push	0
	mov	ecx, DWORD PTR _pend$[ebp]
	push	ecx
	mov	edx, DWORD PTR _enc$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?EncMetaData@OBS@@QAEPADPAD0_N@Z	; OBS::EncMetaData
	mov	DWORD PTR _enc$[ebp], eax

; 219  :     metaDataPacketBuffer.resize(enc - metaDataPacketBuffer.data());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?data@?$vector@DV?$allocator@D@std@@@std@@QAEPADXZ ; std::vector<char,std::allocator<char> >::data
	mov	ecx, DWORD PTR _enc$[ebp]
	sub	ecx, eax
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?resize@?$vector@DV?$allocator@D@std@@@std@@QAEXI@Z ; std::vector<char,std::allocator<char> >::resize

; 220  : 
; 221  :     App->GetAudioHeaders(audioHeaders);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 56					; 00000038H
	push	edx
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?GetAudioHeaders@OBS@@QAEXAAUDataPacket@@@Z ; OBS::GetAudioHeaders

; 222  : 
; 223  :     App->GetVideoHeaders(videoHeaders);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 64					; 00000040H
	push	eax
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?GetVideoHeaders@OBS@@QAEXAAUDataPacket@@@Z ; OBS::GetVideoHeaders
$LN3@InitEncode:

; 224  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?InitEncoderData@RTMPPublisher@@IAEXXZ ENDP		; RTMPPublisher::InitEncoderData
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\rtmppublisher.cpp
;	COMDAT ?ProcessPackets@RTMPPublisher@@MAEXXZ
_TEXT	SEGMENT
_curTime$1 = -12					; size = 4
_queueDuration$2 = -8					; size = 4
_this$ = -4						; size = 4
?ProcessPackets@RTMPPublisher@@MAEXXZ PROC		; RTMPPublisher::ProcessPackets, COMDAT
; _this$ = ecx

; 501  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 502  :     if(!bStreamStarted && !bStopping)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+16]
	test	ecx, ecx
	jne	SHORT $LN12@ProcessPac
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+176]
	test	eax, eax
	jne	SHORT $LN12@ProcessPac

; 503  :     {
; 504  :         BeginPublishingInternal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?BeginPublishingInternal@RTMPPublisher@@AAEXXZ ; RTMPPublisher::BeginPublishingInternal

; 505  :         bStreamStarted = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+16], 1
$LN12@ProcessPac:

; 506  :     }
; 507  : 
; 508  :     //never drop frames if we're in the shutdown sequence, just wait it out
; 509  :     if (!bStopping)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+176]
	test	eax, eax
	jne	$LN11@ProcessPac

; 510  :     {
; 511  :         if (queuedPackets.Num() && minFramedropTimestsamp < queuedPackets[0].timestamp)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	?Num@?$List@UNetworkPacket@@@@QBEIXZ	; List<NetworkPacket>::Num
	test	eax, eax
	je	$LN11@ProcessPac
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	??A?$List@UNetworkPacket@@@@QAEAAUNetworkPacket@@I@Z ; List<NetworkPacket>::operator[]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	cmp	edx, DWORD PTR [eax+8]
	jae	$LN11@ProcessPac

; 512  :         {
; 513  :             DWORD queueDuration = (queuedPackets.Last().timestamp - queuedPackets[0].timestamp);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	?Last@?$List@UNetworkPacket@@@@QBEAAUNetworkPacket@@XZ ; List<NetworkPacket>::Last
	mov	esi, eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	??A?$List@UNetworkPacket@@@@QAEAAUNetworkPacket@@I@Z ; List<NetworkPacket>::operator[]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _queueDuration$2[ebp], ecx

; 514  : 
; 515  :             DWORD curTime = OSGetTime();

	call	DWORD PTR __imp_?OSGetTime@@YGKXZ
	mov	DWORD PTR _curTime$1[ebp], eax

; 516  : 
; 517  :             if (queueDuration >= dropThreshold + audioTimeOffset)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+36]
	cmp	DWORD PTR _queueDuration$2[ebp], eax
	jb	SHORT $LN9@ProcessPac

; 518  :             {
; 519  :                 minFramedropTimestsamp = queuedPackets.Last().timestamp;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	?Last@?$List@UNetworkPacket@@@@QBEAAUNetworkPacket@@XZ ; List<NetworkPacket>::Last
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+72], eax

; 520  : 
; 521  :                 OSDebugOut(TEXT("dropped all at %u, threshold is %u, total duration is %u, %d in queue\r\n"), currentBufferSize, dropThreshold + audioTimeOffset, queueDuration, queuedPackets.Num());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	?Num@?$List@UNetworkPacket@@@@QBEIXZ	; List<NetworkPacket>::Num
	push	eax
	mov	ecx, DWORD PTR _queueDuration$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+36]
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+92]
	push	eax
	push	OFFSET $SG4294776930
	call	DWORD PTR __imp_?OSDebugOut@@YAXPB_WZZ
	add	esp, 20					; 00000014H
$LN8@ProcessPac:

; 522  : 
; 523  :                 //what the hell, just flush it all for now as a test and force a keyframe 1 second after
; 524  :                 while (DoIFrameDelay(false));

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoIFrameDelay@RTMPPublisher@@IAE_N_N@Z	; RTMPPublisher::DoIFrameDelay
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN7@ProcessPac
	jmp	SHORT $LN8@ProcessPac
$LN7@ProcessPac:

; 525  : 
; 526  :                 if(packetWaitType > PacketType_VideoLow)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+180], 1
	jle	SHORT $LN6@ProcessPac

; 527  :                     RequestKeyframe(1000);

	push	1000					; 000003e8H
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	call	eax
$LN6@ProcessPac:

; 528  :             }

	jmp	SHORT $LN11@ProcessPac
$LN9@ProcessPac:

; 529  :             else if (queueDuration >= bframeDropThreshold + audioTimeOffset && curTime-lastBFrameDropTime >= dropThreshold + audioTimeOffset)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+36]
	cmp	DWORD PTR _queueDuration$2[ebp], edx
	jb	SHORT $LN11@ProcessPac
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _curTime$1[ebp]
	sub	edx, DWORD PTR [ecx+96]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	eax, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [eax+36]
	cmp	edx, ecx
	jb	SHORT $LN11@ProcessPac

; 530  :             {
; 531  :                 OSDebugOut(TEXT("dropped b-frames at %u, threshold is %u, total duration is %u\r\n"), currentBufferSize, bframeDropThreshold + audioTimeOffset, queueDuration);

	mov	ecx, DWORD PTR _queueDuration$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+36]
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+92]
	push	eax
	push	OFFSET $SG4294776929
	call	DWORD PTR __imp_?OSDebugOut@@YAXPB_WZZ
	add	esp, 16					; 00000010H
$LN3@ProcessPac:

; 532  : 
; 533  :                 while (DoIFrameDelay(true));

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoIFrameDelay@RTMPPublisher@@IAE_N_N@Z	; RTMPPublisher::DoIFrameDelay
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@ProcessPac
	jmp	SHORT $LN3@ProcessPac
$LN2@ProcessPac:

; 534  : 
; 535  :                 lastBFrameDropTime = curTime;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _curTime$1[ebp]
	mov	DWORD PTR [edx+96], eax
$LN11@ProcessPac:

; 536  :             }
; 537  :         }
; 538  :     }
; 539  : 
; 540  :     if(queuedPackets.Num())

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	?Num@?$List@UNetworkPacket@@@@QBEIXZ	; List<NetworkPacket>::Num
	test	eax, eax
	je	SHORT $LN13@ProcessPac

; 541  :         ReleaseSemaphore(hSendSempahore, 1, NULL);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	push	edx
	call	DWORD PTR __imp__ReleaseSemaphore@12
$LN13@ProcessPac:

; 542  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?ProcessPackets@RTMPPublisher@@MAEXXZ ENDP		; RTMPPublisher::ProcessPackets
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\rtmppublisher.cpp
;	COMDAT ?FlushBufferedPackets@RTMPPublisher@@MAEXXZ
_TEXT	SEGMENT
tv172 = -48						; size = 8
tv169 = -40						; size = 8
_startTime$ = -32					; size = 8
_curTime$1 = -24					; size = 8
_baseTimestamp$ = -16					; size = 4
_i$2 = -12						; size = 4
_this$ = -8						; size = 4
_packet$3 = -4						; size = 4
?FlushBufferedPackets@RTMPPublisher@@MAEXXZ PROC	; RTMPPublisher::FlushBufferedPackets, COMDAT
; _this$ = ecx

; 474  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 475  :     if (!bufferedPackets.Num())

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?Num@?$List@UTimedPacket@@@@QBEIXZ	; List<TimedPacket>::Num
	test	eax, eax
	jne	SHORT $LN7@FlushBuffe

; 476  :         return;

	jmp	$LN8@FlushBuffe
$LN7@FlushBuffe:

; 477  : 
; 478  :     QWORD startTime = GetQPCTimeMS();

	call	DWORD PTR __imp_?GetQPCTimeMS@@YA_KXZ
	mov	DWORD PTR _startTime$[ebp], eax
	mov	DWORD PTR _startTime$[ebp+4], edx

; 479  :     DWORD baseTimestamp = bufferedPackets[0].timestamp;

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	??A?$List@UTimedPacket@@@@QAEAAUTimedPacket@@I@Z ; List<TimedPacket>::operator[]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _baseTimestamp$[ebp], eax

; 480  : 
; 481  :     for (unsigned int i = 0; i < bufferedPackets.Num(); i++)

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN6@FlushBuffe
$LN5@FlushBuffe:
	mov	ecx, DWORD PTR _i$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$2[ebp], ecx
$LN6@FlushBuffe:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?Num@?$List@UTimedPacket@@@@QBEIXZ	; List<TimedPacket>::Num
	cmp	DWORD PTR _i$2[ebp], eax
	jae	$LN4@FlushBuffe

; 482  :     {
; 483  :         TimedPacket &packet = bufferedPackets[i];

	mov	edx, DWORD PTR _i$2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	??A?$List@UTimedPacket@@@@QAEAAUTimedPacket@@I@Z ; List<TimedPacket>::operator[]
	mov	DWORD PTR _packet$3[ebp], eax
$LN3@FlushBuffe:

; 484  : 
; 485  :         QWORD curTime;
; 486  :         do
; 487  :         {
; 488  :             curTime = GetQPCTimeMS();

	call	DWORD PTR __imp_?GetQPCTimeMS@@YA_KXZ
	mov	DWORD PTR _curTime$1[ebp], eax
	mov	DWORD PTR _curTime$1[ebp+4], edx

; 489  :             OSSleep (1);

	push	1
	call	DWORD PTR __imp_?OSSleep@@YGXK@Z

; 490  :         } while (curTime - startTime < packet.timestamp - baseTimestamp);

	mov	eax, DWORD PTR _curTime$1[ebp]
	sub	eax, DWORD PTR _startTime$[ebp]
	mov	ecx, DWORD PTR _curTime$1[ebp+4]
	sbb	ecx, DWORD PTR _startTime$[ebp+4]
	mov	edx, DWORD PTR _packet$3[ebp]
	mov	edx, DWORD PTR [edx+8]
	sub	edx, DWORD PTR _baseTimestamp$[ebp]
	xor	esi, esi
	mov	DWORD PTR tv169[ebp], eax
	mov	DWORD PTR tv169[ebp+4], ecx
	mov	DWORD PTR tv172[ebp], edx
	mov	DWORD PTR tv172[ebp+4], esi
	mov	eax, DWORD PTR tv169[ebp+4]
	cmp	eax, DWORD PTR tv172[ebp+4]
	jb	SHORT $LN3@FlushBuffe
	ja	SHORT $LN1@FlushBuffe
	mov	ecx, DWORD PTR tv169[ebp]
	cmp	ecx, DWORD PTR tv172[ebp]
	jb	SHORT $LN3@FlushBuffe
$LN1@FlushBuffe:

; 491  : 
; 492  :         SendPacketForReal(packet.data.Array(), packet.data.Num(), packet.timestamp, packet.type);

	mov	edx, DWORD PTR _packet$3[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _packet$3[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _packet$3[ebp]
	call	?Num@?$List@E@@QBEIXZ			; List<unsigned char>::Num
	push	eax
	mov	ecx, DWORD PTR _packet$3[ebp]
	call	?Array@?$List@E@@QBEPAEXZ		; List<unsigned char>::Array
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendPacketForReal@RTMPPublisher@@IAEXPAEIKW4PacketType@@@Z ; RTMPPublisher::SendPacketForReal

; 493  : 
; 494  :         packet.data.Clear();

	mov	ecx, DWORD PTR _packet$3[ebp]
	call	?Clear@?$List@E@@QAEXXZ			; List<unsigned char>::Clear

; 495  :     }

	jmp	$LN5@FlushBuffe
$LN4@FlushBuffe:

; 496  : 
; 497  :     bufferedPackets.Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?Clear@?$List@UTimedPacket@@@@QAEXXZ	; List<TimedPacket>::Clear
$LN8@FlushBuffe:

; 498  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?FlushBufferedPackets@RTMPPublisher@@MAEXXZ ENDP	; RTMPPublisher::FlushBufferedPackets
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\rtmppublisher.cpp
;	COMDAT ??0RTMPPublisher@@QAE@XZ
_TEXT	SEGMENT
tv204 = -8						; size = 4
_this$ = -4						; size = 4
??0RTMPPublisher@@QAE@XZ PROC				; RTMPPublisher::RTMPPublisher, COMDAT
; _this$ = ecx

; 76   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0NetworkStream@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7RTMPPublisher@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	??0?$List@UTimedPacket@@@@QAE@XZ	; List<TimedPacket>::List<TimedPacket>

; 88   : 
; 89   :     hRTMPMutex = OSCreateMutex();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+42], 0

; 76   : {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	??0?$vector@DV?$allocator@D@std@@@std@@QAE@XZ ; std::vector<char,std::allocator<char> >::vector<char,std::allocator<char> >
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	??0?$List@UNetworkPacket@@@@QAE@XZ	; List<NetworkPacket>::List<NetworkPacket>

; 77   :     //bufferedPackets.SetBaseSize(MAX_BUFFERED_PACKETS);
; 78   : 
; 79   :     bFirstKeyframe = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+41], 1

; 80   : 
; 81   :     hSendSempahore = CreateSemaphore(NULL, 0, 0x7FFFFFFFL, NULL);

	push	0
	push	2147483647				; 7fffffffH
	push	0
	push	0
	call	DWORD PTR __imp__CreateSemaphoreW@16
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+104], eax

; 82   :     if(!hSendSempahore)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+104], 0
	jne	SHORT $LN13@RTMPPublis

; 83   :         CrashError(TEXT("RTMPPublisher: Could not create semaphore"));

	push	OFFSET $SG4294776965
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ
$LN13@RTMPPublis:

; 84   : 
; 85   :     hDataMutex = OSCreateMutex();

	call	DWORD PTR __imp_?OSCreateMutex@@YGPAXXZ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+108], eax

; 86   :     if(!hDataMutex)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+108], 0
	jne	SHORT $LN12@RTMPPublis

; 87   :         CrashError(TEXT("RTMPPublisher: Could not create mutex"));

	push	OFFSET $SG4294776964
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ
$LN12@RTMPPublis:

; 88   : 
; 89   :     hRTMPMutex = OSCreateMutex();

	call	DWORD PTR __imp_?OSCreateMutex@@YGPAXXZ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+136], eax

; 90   : 
; 91   :     //------------------------------------------
; 92   : 
; 93   :     bframeDropThreshold = AppConfig->GetInt(TEXT("Publish"), TEXT("BFrameDropThreshold"), 400);

	push	400					; 00000190H
	push	OFFSET $SG4294776963
	push	OFFSET $SG4294776962
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+80], eax

; 94   :     if(bframeDropThreshold < 50)        bframeDropThreshold = 50;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+80], 50			; 00000032H
	jae	SHORT $LN11@RTMPPublis
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+80], 50			; 00000032H
	jmp	SHORT $LN10@RTMPPublis
$LN11@RTMPPublis:

; 95   :     else if(bframeDropThreshold > 1000) bframeDropThreshold = 1000;

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+80], 1000		; 000003e8H
	jbe	SHORT $LN10@RTMPPublis
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+80], 1000		; 000003e8H
$LN10@RTMPPublis:

; 96   : 
; 97   :     dropThreshold = AppConfig->GetInt(TEXT("Publish"), TEXT("FrameDropThreshold"), 600);

	push	600					; 00000258H
	push	OFFSET $SG4294776961
	push	OFFSET $SG4294776960
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+76], eax

; 98   :     if(dropThreshold < 50)        dropThreshold = 50;

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+76], 50			; 00000032H
	jae	SHORT $LN8@RTMPPublis
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+76], 50			; 00000032H
	jmp	SHORT $LN7@RTMPPublis
$LN8@RTMPPublis:

; 99   :     else if(dropThreshold > 1000) dropThreshold = 1000;

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+76], 1000		; 000003e8H
	jbe	SHORT $LN7@RTMPPublis
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+76], 1000		; 000003e8H
$LN7@RTMPPublis:

; 100  : 
; 101  :     if (AppConfig->GetInt(TEXT("Publish"), TEXT("LowLatencyMode"), 0))

	push	0
	push	OFFSET $SG4294776959
	push	OFFSET $SG4294776958
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	test	eax, eax
	je	$LN5@RTMPPublis

; 102  :     {
; 103  :         if (AppConfig->GetInt(TEXT("Publish"), TEXT("LowLatencyMethod"), 0) == 0)

	push	0
	push	OFFSET $SG4294776957
	push	OFFSET $SG4294776956
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	test	eax, eax
	jne	SHORT $LN4@RTMPPublis

; 104  :         {
; 105  :             latencyFactor = AppConfig->GetInt(TEXT("Publish"), TEXT("LatencyFactor"), 20);

	push	20					; 00000014H
	push	OFFSET $SG4294776955
	push	OFFSET $SG4294776954
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+224], eax

; 106  : 
; 107  :             if (latencyFactor < 3)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+224], 3
	jge	SHORT $LN3@RTMPPublis

; 108  :                 latencyFactor = 3;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+224], 3
$LN3@RTMPPublis:

; 109  : 
; 110  :             lowLatencyMode = LL_MODE_FIXED;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+220], 1

; 111  :             Log(TEXT("Using fixed low latency mode, factor %d"), latencyFactor);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+224]
	push	eax
	push	OFFSET $SG4294776953
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8

; 112  :         }
; 113  :         else

	jmp	SHORT $LN2@RTMPPublis
$LN4@RTMPPublis:

; 114  :         {
; 115  :             lowLatencyMode = LL_MODE_AUTO;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+220], 2

; 116  :             Log(TEXT("Using automatic low latency mode"));

	push	OFFSET $SG4294776952
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 4
$LN2@RTMPPublis:

; 117  :         }
; 118  :     }
; 119  :     else

	jmp	SHORT $LN1@RTMPPublis
$LN5@RTMPPublis:

; 120  :         lowLatencyMode = LL_MODE_NONE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+220], 0
$LN1@RTMPPublis:

; 121  :     
; 122  :     bFastInitialKeyframe = AppConfig->GetInt(TEXT("Publish"), TEXT("FastInitialKeyframe"), 0) == 1;

	push	0
	push	OFFSET $SG4294776951
	push	OFFSET $SG4294776950
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	cmp	eax, 1
	jne	SHORT $LN16@RTMPPublis
	mov	DWORD PTR tv204[ebp], 1
	jmp	SHORT $LN17@RTMPPublis
$LN16@RTMPPublis:
	mov	DWORD PTR tv204[ebp], 0
$LN17@RTMPPublis:
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR tv204[ebp]
	mov	BYTE PTR [eax+256], cl

; 123  : 
; 124  :     strRTMPErrors.Clear();

	mov	ecx, OFFSET ?strRTMPErrors@RTMPPublisher@@0VString@@A ; RTMPPublisher::strRTMPErrors
	call	DWORD PTR __imp_?Clear@String@@QAEAAV1@XZ

; 125  : }

	mov	eax, DWORD PTR _this$[ebp]
$LN15@RTMPPublis:
	mov	esp, ebp
	pop	ebp
	ret	0
??0RTMPPublisher@@QAE@XZ ENDP				; RTMPPublisher::RTMPPublisher
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\rtmppublisher.cpp
;	COMDAT ??1RTMPPublisher@@UAE@XZ
_TEXT	SEGMENT
_dBFrameDropPercentage$ = -1084				; size = 8
_dPFrameDropPercentage$ = -1076				; size = 8
tv330 = -1068						; size = 4
tv512 = -1064						; size = 4
tv525 = -1060						; size = 4
_ret$1 = -1056						; size = 4
tv530 = -1052						; size = 4
tv341 = -1048						; size = 4
tv517 = -1044						; size = 4
_i$2 = -1040						; size = 4
_startTime$ = -1036					; size = 4
_this$ = -1032						; size = 4
_buff$3 = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
??1RTMPPublisher@@UAE@XZ PROC				; RTMPPublisher::~RTMPPublisher, COMDAT
; _this$ = ecx

; 227  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1084				; 0000043cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7RTMPPublisher@@6B@

; 228  :     //OSDebugOut (TEXT("*** ~RTMPPublisher (%d queued, %d buffered, %d data)\n"), queuedPackets.Num(), bufferedPackets.Num(), curDataBufferLen);
; 229  :     bStopping = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+176], 1

; 230  : 
; 231  :     //we're in the middle of connecting! wait for that to happen to avoid all manner of race conditions
; 232  :     if (hConnectionThread)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+140], 0
	je	$LN32@RTMPPublis

; 233  :     {
; 234  :         //the connect thread could be stalled in a blocking call, kill the socket to ensure it wakes up
; 235  :         if (WaitForSingleObject(hConnectionThread, 0) == WAIT_TIMEOUT)

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	push	ecx
	call	DWORD PTR __imp__WaitForSingleObject@8
	cmp	eax, 258				; 00000102H
	jne	SHORT $LN31@RTMPPublis

; 236  :         {
; 237  :             OSEnterMutex(hRTMPMutex);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+136]
	push	eax
	call	DWORD PTR __imp_?OSEnterMutex@@YGXPAX@Z

; 238  :             if (rtmp && rtmp->m_sb.sb_socket != -1)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+100], 0
	je	SHORT $LN30@RTMPPublis
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+100]
	cmp	DWORD PTR [eax+384], -1
	je	SHORT $LN30@RTMPPublis

; 239  :             {
; 240  :                 closesocket(rtmp->m_sb.sb_socket);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	eax, DWORD PTR [edx+384]
	push	eax
	call	DWORD PTR __imp__closesocket@4

; 241  :                 rtmp->m_sb.sb_socket = -1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR [edx+384], -1
$LN30@RTMPPublis:

; 242  :             }
; 243  :             OSLeaveMutex(hRTMPMutex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+136]
	push	ecx
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z
$LN31@RTMPPublis:

; 244  :         }
; 245  : 
; 246  :         WaitForSingleObject(hConnectionThread, INFINITE);

	push	-1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8

; 247  :         OSCloseThread(hConnectionThread);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	push	edx
	call	DWORD PTR __imp_?OSCloseThread@@YGHPAX@Z
$LN32@RTMPPublis:

; 248  :     }
; 249  : 
; 250  :     DWORD startTime = OSGetTime();

	call	DWORD PTR __imp_?OSGetTime@@YGKXZ
	mov	DWORD PTR _startTime$[ebp], eax

; 251  : 
; 252  :     //send all remaining buffered packets, this may block since it respects timestamps
; 253  :     FlushBufferedPackets ();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FlushBufferedPackets@RTMPPublisher@@MAEXXZ ; RTMPPublisher::FlushBufferedPackets

; 254  : 
; 255  :     Log(TEXT("~RTMPPublisher: Packet flush completed in %d ms"), OSGetTime() - startTime);

	call	DWORD PTR __imp_?OSGetTime@@YGKXZ
	sub	eax, DWORD PTR _startTime$[ebp]
	push	eax
	push	OFFSET $SG4294776941
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8

; 256  : 
; 257  :     //OSDebugOut (TEXT("%d queued after flush\n"), queuedPackets.Num());
; 258  : 
; 259  :     if(hSendThread)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+112], 0
	je	$LN29@RTMPPublis

; 260  :     {
; 261  :         startTime = OSGetTime();

	call	DWORD PTR __imp_?OSGetTime@@YGKXZ
	mov	DWORD PTR _startTime$[ebp], eax

; 262  : 
; 263  :         //this marks the thread to exit after current work is done
; 264  :         SetEvent(hSendLoopExit);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+144]
	push	edx
	call	DWORD PTR __imp__SetEvent@4

; 265  : 
; 266  :         //these wake up the thread
; 267  :         ReleaseSemaphore(hSendSempahore, 1, NULL);

	push	0
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	push	ecx
	call	DWORD PTR __imp__ReleaseSemaphore@12

; 268  :         SetEvent(hBufferSpaceAvailableEvent);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+128]
	push	eax
	call	DWORD PTR __imp__SetEvent@4

; 269  : 
; 270  :         //wait 50 sec for all data to finish sending
; 271  :         if (WaitForSingleObject(hSendThread, 50000) == WAIT_TIMEOUT)

	push	50000					; 0000c350H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	push	edx
	call	DWORD PTR __imp__WaitForSingleObject@8
	cmp	eax, 258				; 00000102H
	jne	SHORT $LN28@RTMPPublis

; 272  :         {
; 273  :             Log(TEXT("~RTMPPublisher: Network appears stalled with %d / %d buffered, dropping connection!"), curDataBufferLen, dataBufferSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+212]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+216]
	push	eax
	push	OFFSET $SG4294776940
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 12					; 0000000cH

; 274  :             FatalSocketShutdown();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FatalSocketShutdown@RTMPPublisher@@IAEXXZ ; RTMPPublisher::FatalSocketShutdown

; 275  : 
; 276  :             //this will wake up and flush the sendloop if it's still trying to send out stuff
; 277  :             ReleaseSemaphore(hSendSempahore, 1, NULL);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	push	edx
	call	DWORD PTR __imp__ReleaseSemaphore@12

; 278  :             SetEvent(hBufferSpaceAvailableEvent);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	push	ecx
	call	DWORD PTR __imp__SetEvent@4
$LN28@RTMPPublis:

; 279  :         }
; 280  : 
; 281  :         OSTerminateThread(hSendThread, 10000);

	push	10000					; 00002710H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	push	eax
	call	DWORD PTR __imp_?OSTerminateThread@@YGHPAXK@Z

; 282  : 
; 283  :         Log(TEXT("~RTMPPublisher: Send thread terminated in %d ms"), OSGetTime() - startTime);

	call	DWORD PTR __imp_?OSGetTime@@YGKXZ
	sub	eax, DWORD PTR _startTime$[ebp]
	push	eax
	push	OFFSET $SG4294776939
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8
$LN29@RTMPPublis:

; 284  :     }
; 285  : 
; 286  :     if(hSendSempahore)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+104], 0
	je	SHORT $LN27@RTMPPublis

; 287  :         CloseHandle(hSendSempahore);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	push	eax
	call	DWORD PTR __imp__CloseHandle@4
$LN27@RTMPPublis:

; 288  : 
; 289  :     //OSDebugOut (TEXT("*** ~RTMPPublisher hSendThread terminated (%d queued, %d buffered, %d data)\n"), queuedPackets.Num(), bufferedPackets.Num(), curDataBufferLen);
; 290  : 
; 291  :     if (hSocketThread)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+116], 0
	je	SHORT $LN26@RTMPPublis

; 292  :     {
; 293  :         startTime = OSGetTime();

	call	DWORD PTR __imp_?OSGetTime@@YGKXZ
	mov	DWORD PTR _startTime$[ebp], eax

; 294  : 
; 295  :         //mark the socket loop to shut down after the buffer is empty
; 296  :         SetEvent(hSocketLoopExit);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	push	eax
	call	DWORD PTR __imp__SetEvent@4

; 297  : 
; 298  :         //wake it up in case it already is empty
; 299  :         SetEvent(hBufferEvent);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+124]
	push	edx
	call	DWORD PTR __imp__SetEvent@4

; 300  : 
; 301  :         //wait 60 sec for it to exit
; 302  :         OSTerminateThread(hSocketThread, 60000);

	push	60000					; 0000ea60H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	push	ecx
	call	DWORD PTR __imp_?OSTerminateThread@@YGHPAXK@Z

; 303  : 
; 304  :         Log(TEXT("~RTMPPublisher: Socket thread terminated in %d ms"), OSGetTime() - startTime);

	call	DWORD PTR __imp_?OSGetTime@@YGKXZ
	sub	eax, DWORD PTR _startTime$[ebp]
	push	eax
	push	OFFSET $SG4294776938
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8
$LN26@RTMPPublis:

; 305  :     }
; 306  : 
; 307  :     //OSDebugOut (TEXT("*** ~RTMPPublisher hSocketThread terminated (%d queued, %d buffered, %d data)\n"), queuedPackets.Num(), bufferedPackets.Num(), curDataBufferLen);
; 308  : 
; 309  :     if(rtmp)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+100], 0
	je	$LN25@RTMPPublis

; 310  :     {
; 311  :         if (RTMP_IsConnected(rtmp))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	call	_RTMP_IsConnected
	test	eax, eax
	je	$LN24@RTMPPublis

; 312  :         {
; 313  :             startTime = OSGetTime();

	call	DWORD PTR __imp_?OSGetTime@@YGKXZ
	mov	DWORD PTR _startTime$[ebp], eax

; 314  : 
; 315  :             //at this point nothing should be in the buffer, flush out what remains to the net and make it blocking
; 316  :             FlushDataBuffer();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FlushDataBuffer@RTMPPublisher@@IAEHXZ	; RTMPPublisher::FlushDataBuffer

; 317  : 
; 318  :             //disable the buffered send, so RTMP_* functions write directly to the net (and thus block)
; 319  :             rtmp->m_bCustomSend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	BYTE PTR [edx+57], 0

; 320  : 
; 321  :             //manually shut down the stream and issue a graceful socket shutdown
; 322  :             RTMP_DeleteStream(rtmp);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	call	_RTMP_DeleteStream

; 323  : 
; 324  :             shutdown(rtmp->m_sb.sb_socket, SD_SEND);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	eax, DWORD PTR [edx+384]
	push	eax
	call	DWORD PTR __imp__shutdown@8
$LN23@RTMPPublis:

; 325  : 
; 326  :             //this waits for the socket shutdown to complete gracefully
; 327  :             for (;;)
; 328  :             {
; 329  :                 char buff[1024];
; 330  :                 int ret;
; 331  : 
; 332  :                 ret = recv(rtmp->m_sb.sb_socket, buff, sizeof(buff), 0);

	push	0
	push	1024					; 00000400H
	lea	ecx, DWORD PTR _buff$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	ecx, DWORD PTR [eax+384]
	push	ecx
	call	DWORD PTR __imp__recv@16
	mov	DWORD PTR _ret$1[ebp], eax

; 333  :                 if (!ret)

	cmp	DWORD PTR _ret$1[ebp], 0
	jne	SHORT $LN21@RTMPPublis

; 334  :                     break;

	jmp	SHORT $LN22@RTMPPublis
	jmp	SHORT $LN19@RTMPPublis
$LN21@RTMPPublis:

; 335  :                 else if (ret == -1)

	cmp	DWORD PTR _ret$1[ebp], -1
	jne	SHORT $LN19@RTMPPublis

; 336  :                 {
; 337  :                     Log(TEXT("~RTMPublisher: Received error %d while waiting for graceful shutdown."), WSAGetLastError());

	call	DWORD PTR __imp__WSAGetLastError@0
	push	eax
	push	OFFSET $SG4294776937
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8

; 338  :                     break;

	jmp	SHORT $LN22@RTMPPublis
$LN19@RTMPPublis:

; 339  :                 }
; 340  :             }

	jmp	SHORT $LN23@RTMPPublis
$LN22@RTMPPublis:

; 341  : 
; 342  :             Log(TEXT("~RTMPPublisher: Final socket shutdown completed in %d ms"), OSGetTime() - startTime);

	call	DWORD PTR __imp_?OSGetTime@@YGKXZ
	sub	eax, DWORD PTR _startTime$[ebp]
	push	eax
	push	OFFSET $SG4294776936
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8
$LN24@RTMPPublis:

; 343  : 
; 344  :             //OSDebugOut(TEXT("Graceful shutdown complete.\n"));
; 345  :         }
; 346  : 
; 347  :         //this closes the socket if not already done
; 348  :         RTMP_Close(rtmp);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+100]
	call	_RTMP_Close
$LN25@RTMPPublis:

; 349  :     }
; 350  : 
; 351  :     if(hDataMutex)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+108], 0
	je	SHORT $LN18@RTMPPublis

; 352  :         OSCloseMutex(hDataMutex);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	call	DWORD PTR __imp_?OSCloseMutex@@YGXPAX@Z
$LN18@RTMPPublis:

; 353  : 
; 354  :     while (bufferedPackets.Num())

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?Num@?$List@UTimedPacket@@@@QBEIXZ	; List<TimedPacket>::Num
	test	eax, eax
	je	SHORT $LN16@RTMPPublis

; 355  :     {
; 356  :         //this should not happen any more...
; 357  :         bufferedPackets[0].data.Clear();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	??A?$List@UTimedPacket@@@@QAEAAUTimedPacket@@I@Z ; List<TimedPacket>::operator[]
	mov	ecx, eax
	call	?Clear@?$List@E@@QAEXXZ			; List<unsigned char>::Clear

; 358  :         bufferedPackets.Remove(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?Remove@?$List@UTimedPacket@@@@QAEXI@Z	; List<TimedPacket>::Remove

; 359  :     }

	jmp	SHORT $LN18@RTMPPublis
$LN16@RTMPPublis:

; 360  : 
; 361  :     if (dataBuffer)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+208], 0
	je	SHORT $LN15@RTMPPublis

; 362  :         Free(dataBuffer);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+208]
	push	edx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4
$LN15@RTMPPublis:

; 363  : 
; 364  :     if (hDataBufferMutex)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+132], 0
	je	SHORT $LN14@RTMPPublis

; 365  :         OSCloseMutex(hDataBufferMutex);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+132]
	push	edx
	call	DWORD PTR __imp_?OSCloseMutex@@YGXPAX@Z
$LN14@RTMPPublis:

; 366  : 
; 367  :     if (hBufferEvent)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+124], 0
	je	SHORT $LN13@RTMPPublis

; 368  :         CloseHandle(hBufferEvent);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+124]
	push	edx
	call	DWORD PTR __imp__CloseHandle@4
$LN13@RTMPPublis:

; 369  : 
; 370  :     if (hSendLoopExit)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+144], 0
	je	SHORT $LN12@RTMPPublis

; 371  :         CloseHandle(hSendLoopExit);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+144]
	push	edx
	call	DWORD PTR __imp__CloseHandle@4
$LN12@RTMPPublis:

; 372  : 
; 373  :     if (hSocketLoopExit)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+148], 0
	je	SHORT $LN11@RTMPPublis

; 374  :         CloseHandle(hSocketLoopExit);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+148]
	push	edx
	call	DWORD PTR __imp__CloseHandle@4
$LN11@RTMPPublis:

; 375  : 
; 376  :     if (hSendBacklogEvent)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+152], 0
	je	SHORT $LN10@RTMPPublis

; 377  :         CloseHandle(hSendBacklogEvent);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+152]
	push	edx
	call	DWORD PTR __imp__CloseHandle@4
$LN10@RTMPPublis:

; 378  : 
; 379  :     if (hBufferSpaceAvailableEvent)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+128], 0
	je	SHORT $LN9@RTMPPublis

; 380  :         CloseHandle(hBufferSpaceAvailableEvent);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	push	edx
	call	DWORD PTR __imp__CloseHandle@4
$LN9@RTMPPublis:

; 381  : 
; 382  :     if (hWriteEvent)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+120], 0
	je	SHORT $LN8@RTMPPublis

; 383  :         CloseHandle(hWriteEvent);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+120]
	push	edx
	call	DWORD PTR __imp__CloseHandle@4
$LN8@RTMPPublis:

; 384  : 
; 385  :     if(rtmp)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+100], 0
	je	SHORT $LN7@RTMPPublis

; 386  :     {
; 387  :         if (rtmp->Link.pubUser.av_val)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	cmp	DWORD PTR [edx+16892], 0
	je	SHORT $LN6@RTMPPublis

; 388  :             Free(rtmp->Link.pubUser.av_val);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR [ecx+16892]
	push	edx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4
$LN6@RTMPPublis:

; 389  :         if (rtmp->Link.pubPasswd.av_val)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	cmp	DWORD PTR [ecx+16900], 0
	je	SHORT $LN5@RTMPPublis

; 390  :             Free(rtmp->Link.pubPasswd.av_val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	ecx, DWORD PTR [eax+16900]
	push	ecx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4
$LN5@RTMPPublis:

; 391  :         RTMP_Free(rtmp);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+100]
	call	_RTMP_Free
$LN7@RTMPPublis:

; 392  :     }
; 393  : 
; 394  :     //--------------------------
; 395  : 
; 396  :     for(UINT i=0; i<queuedPackets.Num(); i++)

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN4@RTMPPublis
$LN3@RTMPPublis:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN4@RTMPPublis:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	?Num@?$List@UNetworkPacket@@@@QBEIXZ	; List<NetworkPacket>::Num
	cmp	DWORD PTR _i$2[ebp], eax
	jae	SHORT $LN2@RTMPPublis

; 397  :         queuedPackets[i].data.Clear();

	mov	ecx, DWORD PTR _i$2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	??A?$List@UNetworkPacket@@@@QAEAAUNetworkPacket@@I@Z ; List<NetworkPacket>::operator[]
	mov	ecx, eax
	call	?Clear@?$List@E@@QAEXXZ			; List<unsigned char>::Clear
	jmp	SHORT $LN3@RTMPPublis
$LN2@RTMPPublis:

; 398  :     queuedPackets.Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	?Clear@?$List@UNetworkPacket@@@@QAEXXZ	; List<NetworkPacket>::Clear

; 399  : 
; 400  :     double dBFrameDropPercentage = double(numBFramesDumped)/max(1, NumTotalVideoFrames())*100.0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumTotalVideoFrames@RTMPPublisher@@UBEKXZ ; RTMPPublisher::NumTotalVideoFrames
	cmp	eax, 1
	jae	SHORT $LN35@RTMPPublis
	mov	DWORD PTR tv330[ebp], 1
	jmp	SHORT $LN36@RTMPPublis
$LN35@RTMPPublis:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumTotalVideoFrames@RTMPPublisher@@UBEKXZ ; RTMPPublisher::NumTotalVideoFrames
	mov	DWORD PTR tv330[ebp], eax
$LN36@RTMPPublis:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+204]
	mov	DWORD PTR tv512[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv512[ebp]
	mov	ecx, DWORD PTR tv512[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	mov	edx, DWORD PTR tv330[ebp]
	mov	DWORD PTR tv517[ebp], edx
	cvtsi2sd xmm1, DWORD PTR tv517[ebp]
	mov	eax, DWORD PTR tv517[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	divsd	xmm0, xmm1
	mulsd	xmm0, QWORD PTR __real@4059000000000000
	movsd	QWORD PTR _dBFrameDropPercentage$[ebp], xmm0

; 401  :     double dPFrameDropPercentage = double(numPFramesDumped)/max(1, NumTotalVideoFrames())*100.0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumTotalVideoFrames@RTMPPublisher@@UBEKXZ ; RTMPPublisher::NumTotalVideoFrames
	cmp	eax, 1
	jae	SHORT $LN37@RTMPPublis
	mov	DWORD PTR tv341[ebp], 1
	jmp	SHORT $LN38@RTMPPublis
$LN37@RTMPPublis:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumTotalVideoFrames@RTMPPublisher@@UBEKXZ ; RTMPPublisher::NumTotalVideoFrames
	mov	DWORD PTR tv341[ebp], eax
$LN38@RTMPPublis:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+200]
	mov	DWORD PTR tv525[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv525[ebp]
	mov	eax, DWORD PTR tv525[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mov	ecx, DWORD PTR tv341[ebp]
	mov	DWORD PTR tv530[ebp], ecx
	cvtsi2sd xmm1, DWORD PTR tv530[ebp]
	mov	edx, DWORD PTR tv530[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	divsd	xmm0, xmm1
	mulsd	xmm0, QWORD PTR __real@4059000000000000
	movsd	QWORD PTR _dPFrameDropPercentage$[ebp], xmm0

; 402  : 
; 403  :     if (totalSendCount)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+252], 0
	je	SHORT $LN1@RTMPPublis

; 404  :         Log(TEXT("Average send payload: %d bytes, average send interval: %d ms"), (DWORD)(totalSendBytes / totalSendCount), totalSendPeriod / totalSendCount);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+248]
	xor	edx, edx
	div	DWORD PTR [esi+252]
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+252]
	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	push	eax
	mov	eax, DWORD PTR [edx+244]
	push	eax
	mov	ecx, DWORD PTR [edx+240]
	push	ecx
	call	__aulldiv
	push	eax
	push	OFFSET $SG4294776935
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 12					; 0000000cH
$LN1@RTMPPublis:

; 405  : 
; 406  :     Log(TEXT("Number of times waited to send: %d, Waited for a total of %d bytes"), totalTimesWaited, totalBytesWaited);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+232]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+228]
	push	edx
	push	OFFSET $SG4294776934
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 12					; 0000000cH

; 407  : 
; 408  :     Log(TEXT("Number of b-frames dropped: %u (%0.2g%%), Number of p-frames dropped: %u (%0.2g%%), Total %u (%0.2g%%)"),
; 409  :         numBFramesDumped, dBFrameDropPercentage,
; 410  :         numPFramesDumped, dPFrameDropPercentage,
; 411  :         numBFramesDumped+numPFramesDumped, dBFrameDropPercentage+dPFrameDropPercentage);

	movsd	xmm0, QWORD PTR _dBFrameDropPercentage$[ebp]
	addsd	xmm0, QWORD PTR _dPFrameDropPercentage$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+204]
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+200]
	push	ecx
	sub	esp, 8
	movsd	xmm0, QWORD PTR _dPFrameDropPercentage$[ebp]
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+200]
	push	ecx
	sub	esp, 8
	movsd	xmm0, QWORD PTR _dBFrameDropPercentage$[ebp]
	movsd	QWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+204]
	push	eax
	push	OFFSET $SG4294776933
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 40					; 00000028H

; 412  : 
; 413  :     Log(TEXT("Number of bytes sent: %llu"), totalSendBytes);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+244]
	push	edx
	mov	eax, DWORD PTR [ecx+240]
	push	eax
	push	OFFSET $SG4294776932
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 12					; 0000000cH

; 414  : 
; 415  : 
; 416  :     /*if(totalCalls)
; 417  :         Log(TEXT("average send time: %u"), totalTime/totalCalls);*/
; 418  : 
; 419  :     strRTMPErrors.Clear();

	mov	ecx, OFFSET ?strRTMPErrors@RTMPPublisher@@0VString@@A ; RTMPPublisher::strRTMPErrors
	call	DWORD PTR __imp_?Clear@String@@QAEAAV1@XZ

; 420  : 
; 421  :     //--------------------------
; 422  : }

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	??1?$List@UNetworkPacket@@@@QAE@XZ	; List<NetworkPacket>::~List<NetworkPacket>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ ; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	??1?$List@UTimedPacket@@@@QAE@XZ	; List<TimedPacket>::~List<TimedPacket>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1NetworkStream@@UAE@XZ		; NetworkStream::~NetworkStream
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
??1RTMPPublisher@@UAE@XZ ENDP				; RTMPPublisher::~RTMPPublisher
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\rtmppublisher.cpp
;	COMDAT ?SendPacket@RTMPPublisher@@UAEXPAEIKW4PacketType@@@Z
_TEXT	SEGMENT
_packet$1 = -44						; size = 16
_packet$2 = -28						; size = 16
_newID$3 = -12						; size = 4
_packet$ = -8						; size = 4
_this$ = -4						; size = 4
_data$ = 8						; size = 4
_size$ = 12						; size = 4
_timestamp$ = 16					; size = 4
_type$ = 20						; size = 4
?SendPacket@RTMPPublisher@@UAEXPAEIKW4PacketType@@@Z PROC ; RTMPPublisher::SendPacket, COMDAT
; _this$ = ecx

; 545  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 546  :     InitEncoderData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitEncoderData@RTMPPublisher@@IAEXXZ	; RTMPPublisher::InitEncoderData

; 547  : 
; 548  :     if(!bConnected && !bConnecting && !bStopping)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+18]
	test	ecx, ecx
	jne	SHORT $LN15@SendPacket
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+17]
	test	eax, eax
	jne	SHORT $LN15@SendPacket
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+176]
	test	edx, edx
	jne	SHORT $LN15@SendPacket

; 549  :     {
; 550  :         hConnectionThread = OSCreateThread((XTHREAD)CreateConnectionThread, this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	push	OFFSET ?CreateConnectionThread@RTMPPublisher@@CGKPAV1@@Z ; RTMPPublisher::CreateConnectionThread
	call	DWORD PTR __imp_?OSCreateThread@@YGPAXP6GKPAX@Z0@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+140], eax

; 551  :         bConnecting = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+17], 1
$LN15@SendPacket:

; 552  :     }
; 553  : 
; 554  :     if (bFastInitialKeyframe)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+256]
	test	ecx, ecx
	je	$LN14@SendPacket

; 555  :     {
; 556  :         if (!bConnected)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+18]
	test	eax, eax
	jne	SHORT $LN13@SendPacket

; 557  :         {
; 558  :             //while not connected, keep at most one keyframe buffered
; 559  :             if (type != PacketType_VideoHighest)

	cmp	DWORD PTR _type$[ebp], 3
	je	SHORT $LN12@SendPacket

; 560  :                 return;

	jmp	$LN16@SendPacket
$LN12@SendPacket:

; 561  :         
; 562  :             bufferedPackets.Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?Clear@?$List@UTimedPacket@@@@QAEXXZ	; List<TimedPacket>::Clear
$LN13@SendPacket:

; 563  :         }
; 564  : 
; 565  :         if (bConnected && bFirstKeyframe)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+18]
	test	edx, edx
	je	$LN11@SendPacket
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+41]
	test	ecx, ecx
	je	$LN11@SendPacket

; 566  :         {
; 567  :             bFirstKeyframe = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+41], 0

; 568  :             firstTimestamp = timestamp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _timestamp$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 569  : 
; 570  :             //send out our buffered keyframe immediately, unless this packet happens to also be a keyframe
; 571  :             if (type != PacketType_VideoHighest && bufferedPackets.Num() == 1)

	cmp	DWORD PTR _type$[ebp], 3
	je	SHORT $LN10@SendPacket
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?Num@?$List@UTimedPacket@@@@QBEIXZ	; List<TimedPacket>::Num
	cmp	eax, 1
	jne	SHORT $LN10@SendPacket

; 572  :             {
; 573  :                 TimedPacket packet;

	lea	ecx, DWORD PTR _packet$2[ebp]
	call	??0TimedPacket@@QAE@XZ

; 574  :                 mcpy(&packet, &bufferedPackets[0], sizeof(TimedPacket));

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	??A?$List@UTimedPacket@@@@QAEAAUTimedPacket@@I@Z ; List<TimedPacket>::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _packet$2[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _packet$2[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _packet$2[ebp+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR _packet$2[ebp+12], eax

; 575  :                 bufferedPackets.Remove(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?Remove@?$List@UTimedPacket@@@@QAEXI@Z	; List<TimedPacket>::Remove

; 576  :                 packet.timestamp = 0;

	mov	DWORD PTR _packet$2[ebp+8], 0

; 577  : 
; 578  :                 SendPacketForReal(packet.data.Array(), packet.data.Num(), packet.timestamp, packet.type);

	mov	ecx, DWORD PTR _packet$2[ebp+12]
	push	ecx
	mov	edx, DWORD PTR _packet$2[ebp+8]
	push	edx
	lea	ecx, DWORD PTR _packet$2[ebp]
	call	?Num@?$List@E@@QBEIXZ			; List<unsigned char>::Num
	push	eax
	lea	ecx, DWORD PTR _packet$2[ebp]
	call	?Array@?$List@E@@QBEPAEXZ		; List<unsigned char>::Array
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendPacketForReal@RTMPPublisher@@IAEXPAEIKW4PacketType@@@Z ; RTMPPublisher::SendPacketForReal

; 579  :             }

	lea	ecx, DWORD PTR _packet$2[ebp]
	call	??1TimedPacket@@QAE@XZ

; 580  :             else

	jmp	SHORT $LN11@SendPacket
$LN10@SendPacket:

; 581  :                 bufferedPackets.Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?Clear@?$List@UTimedPacket@@@@QAEXXZ	; List<TimedPacket>::Clear
$LN11@SendPacket:

; 582  :         }
; 583  :     }
; 584  :     else

	jmp	SHORT $LN8@SendPacket
$LN14@SendPacket:

; 585  :     {
; 586  :         if (bFirstKeyframe)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+41]
	test	ecx, ecx
	je	SHORT $LN8@SendPacket

; 587  :         {
; 588  :             if (!bConnected || type != PacketType_VideoHighest)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+18]
	test	eax, eax
	je	SHORT $LN5@SendPacket
	cmp	DWORD PTR _type$[ebp], 3
	je	SHORT $LN6@SendPacket
$LN5@SendPacket:

; 589  :                 return;

	jmp	$LN16@SendPacket
$LN6@SendPacket:

; 590  : 
; 591  :             firstTimestamp = timestamp;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _timestamp$[ebp]
	mov	DWORD PTR [ecx+20], edx

; 592  :             bFirstKeyframe = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+41], 0
$LN8@SendPacket:

; 593  :         }
; 594  :     }
; 595  : 
; 596  :     //OSDebugOut (TEXT("%u: SendPacket (%d bytes - %08x @ %u)\n"), OSGetTime(), size, quickHash(data,size), timestamp);
; 597  : 
; 598  :     if (bufferedPackets.Num() == MAX_BUFFERED_PACKETS)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?Num@?$List@UTimedPacket@@@@QBEIXZ	; List<TimedPacket>::Num
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN4@SendPacket

; 599  :     {
; 600  :         if (!bBufferFull)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+40]
	test	edx, edx
	jne	SHORT $LN3@SendPacket

; 601  :         {
; 602  :             InitializeBuffer();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitializeBuffer@RTMPPublisher@@IAEXXZ	; RTMPPublisher::InitializeBuffer

; 603  :             bBufferFull = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+40], 1
$LN3@SendPacket:

; 604  :         }
; 605  : 
; 606  :         TimedPacket packet;

	lea	ecx, DWORD PTR _packet$1[ebp]
	call	??0TimedPacket@@QAE@XZ

; 607  :         mcpy(&packet, &bufferedPackets[0], sizeof(TimedPacket));

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	??A?$List@UTimedPacket@@@@QAEAAUTimedPacket@@I@Z ; List<TimedPacket>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _packet$1[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _packet$1[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _packet$1[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _packet$1[ebp+12], edx

; 608  :         bufferedPackets.Remove(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?Remove@?$List@UTimedPacket@@@@QAEXI@Z	; List<TimedPacket>::Remove

; 609  : 
; 610  :         SendPacketForReal(packet.data.Array(), packet.data.Num(), packet.timestamp, packet.type);

	mov	eax, DWORD PTR _packet$1[ebp+12]
	push	eax
	mov	ecx, DWORD PTR _packet$1[ebp+8]
	push	ecx
	lea	ecx, DWORD PTR _packet$1[ebp]
	call	?Num@?$List@E@@QBEIXZ			; List<unsigned char>::Num
	push	eax
	lea	ecx, DWORD PTR _packet$1[ebp]
	call	?Array@?$List@E@@QBEPAEXZ		; List<unsigned char>::Array
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendPacketForReal@RTMPPublisher@@IAEXPAEIKW4PacketType@@@Z ; RTMPPublisher::SendPacketForReal

; 611  :     }

	lea	ecx, DWORD PTR _packet$1[ebp]
	call	??1TimedPacket@@QAE@XZ
$LN4@SendPacket:

; 612  : 
; 613  :     timestamp -= firstTimestamp;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _timestamp$[ebp]
	sub	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _timestamp$[ebp], eax

; 614  : 
; 615  :     TimedPacket *packet;
; 616  :     
; 617  :     if (type == PacketType_Audio)

	cmp	DWORD PTR _type$[ebp], 4
	jne	SHORT $LN2@SendPacket

; 618  :     {
; 619  :         UINT newID;
; 620  :         timestamp -= audioTimeOffset;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _timestamp$[ebp]
	sub	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR _timestamp$[ebp], edx

; 621  : 
; 622  :         newID = FindClosestBufferIndex(timestamp);

	mov	eax, DWORD PTR _timestamp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindClosestBufferIndex@RTMPPublisher@@IAEIK@Z ; RTMPPublisher::FindClosestBufferIndex
	mov	DWORD PTR _newID$3[ebp], eax

; 623  :         packet = bufferedPackets.InsertNew(newID);

	mov	ecx, DWORD PTR _newID$3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?InsertNew@?$List@UTimedPacket@@@@QAEPAUTimedPacket@@H@Z ; List<TimedPacket>::InsertNew
	mov	DWORD PTR _packet$[ebp], eax

; 624  :     }
; 625  :     else

	jmp	SHORT $LN1@SendPacket
$LN2@SendPacket:

; 626  :     {
; 627  :         packet = bufferedPackets.CreateNew();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?CreateNew@?$List@UTimedPacket@@@@QAEPAUTimedPacket@@XZ ; List<TimedPacket>::CreateNew
	mov	DWORD PTR _packet$[ebp], eax
$LN1@SendPacket:

; 628  :     }
; 629  : 
; 630  :     packet->data.CopyArray(data, size);

	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _packet$[ebp]
	call	?CopyArray@?$List@E@@QAEXPBEI@Z		; List<unsigned char>::CopyArray

; 631  :     packet->timestamp = timestamp;

	mov	ecx, DWORD PTR _packet$[ebp]
	mov	edx, DWORD PTR _timestamp$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 632  :     packet->type = type;

	mov	eax, DWORD PTR _packet$[ebp]
	mov	ecx, DWORD PTR _type$[ebp]
	mov	DWORD PTR [eax+12], ecx
$LN16@SendPacket:

; 633  : 
; 634  :     /*for (UINT i=0; i<bufferedPackets.Num(); i++)
; 635  :     {
; 636  :         if (bufferedPackets[i].data.Array() == 0)
; 637  :             nop();
; 638  :     }*/
; 639  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?SendPacket@RTMPPublisher@@UAEXPAEIKW4PacketType@@@Z ENDP ; RTMPPublisher::SendPacket
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\rtmppublisher.cpp
;	COMDAT ?BeginPublishing@RTMPPublisher@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?BeginPublishing@RTMPPublisher@@UAEXXZ PROC		; RTMPPublisher::BeginPublishing, COMDAT
; _this$ = ecx

; 784  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 785  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?BeginPublishing@RTMPPublisher@@UAEXXZ ENDP		; RTMPPublisher::BeginPublishing
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\rtmppublisher.cpp
;	COMDAT ?GetPacketStrain@RTMPPublisher@@UBENXZ
_TEXT	SEGMENT
tv74 = -12						; size = 8
_this$ = -4						; size = 4
?GetPacketStrain@RTMPPublisher@@UBENXZ PROC		; RTMPPublisher::GetPacketStrain, COMDAT
; _this$ = ecx

; 1140 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1141 :     return (curDataBufferLen / (double)dataBufferSize) * 100.0;

	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2sd xmm0, DWORD PTR [eax+216]
	mov	ecx, DWORD PTR _this$[ebp]
	cvtsi2sd xmm1, DWORD PTR [ecx+212]
	divsd	xmm0, xmm1
	mulsd	xmm0, QWORD PTR __real@4059000000000000
	movsd	QWORD PTR tv74[ebp], xmm0
	fld	QWORD PTR tv74[ebp]

; 1142 :     /*if(packetWaitType >= PacketType_VideoHigh)
; 1143 :         return min(100.0, dNetworkStrain*100.0);
; 1144 :     else if(bNetworkStrain)
; 1145 :         return dNetworkStrain*66.0;
; 1146 : 
; 1147 :     return dNetworkStrain*33.0;*/
; 1148 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPacketStrain@RTMPPublisher@@UBENXZ ENDP		; RTMPPublisher::GetPacketStrain
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\rtmppublisher.cpp
;	COMDAT ?GetCurrentSentBytes@RTMPPublisher@@UAE_KXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCurrentSentBytes@RTMPPublisher@@UAE_KXZ PROC	; RTMPPublisher::GetCurrentSentBytes, COMDAT
; _this$ = ecx

; 1151 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1152 :     return bytesSent;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+184]
	mov	edx, DWORD PTR [ecx+188]

; 1153 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCurrentSentBytes@RTMPPublisher@@UAE_KXZ ENDP	; RTMPPublisher::GetCurrentSentBytes
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\rtmppublisher.cpp
;	COMDAT ?NumDroppedFrames@RTMPPublisher@@UBEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?NumDroppedFrames@RTMPPublisher@@UBEKXZ PROC		; RTMPPublisher::NumDroppedFrames, COMDAT
; _this$ = ecx

; 1156 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1157 :     return numBFramesDumped+numPFramesDumped;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+204]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+200]

; 1158 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?NumDroppedFrames@RTMPPublisher@@UBEKXZ ENDP		; RTMPPublisher::NumDroppedFrames
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\rtmppublisher.cpp
;	COMDAT ?CreateRTMPPublisher@@YAPAVNetworkStream@@XZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
$T1 = -4						; size = 4
?CreateRTMPPublisher@@YAPAVNetworkStream@@XZ PROC	; CreateRTMPPublisher, COMDAT

; 1745 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1746 :     return new RTMPPublisher;

	push	264					; 00000108H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN3@CreateRTMP
	mov	ecx, DWORD PTR $T1[ebp]
	call	??0RTMPPublisher@@QAE@XZ		; RTMPPublisher::RTMPPublisher
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@CreateRTMP
$LN3@CreateRTMP:
	mov	DWORD PTR tv72[ebp], 0
$LN4@CreateRTMP:
	mov	eax, DWORD PTR tv72[ebp]

; 1747 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CreateRTMPPublisher@@YAPAVNetworkStream@@XZ ENDP	; CreateRTMPPublisher
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\xconfig.h
;	COMDAT ?GetData@XDataItem@@QBEPB_WXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetData@XDataItem@@QBEPB_WXZ PROC			; XDataItem::GetData, COMDAT
; _this$ = ecx

; 68   :     inline CTSTR GetData() const        {return strData;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	esp, ebp
	pop	ebp
	ret	0
?GetData@XDataItem@@QBEPB_WXZ ENDP			; XDataItem::GetData
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 70   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xutility
;	COMDAT ?_Fill_n@std@@YAPADPADID@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 1
?_Fill_n@std@@YAPADPADID@Z PROC				; std::_Fill_n, COMDAT

; 2638 : 	{	// copy char _Val _Count times through [_Dest, ...)

	push	ebp
	mov	ebp, esp

; 2639 : 	_CSTD memset(_Dest, _Val, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	movsx	ecx, BYTE PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 2640 : 	return (_Dest + _Count);

	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, DWORD PTR __Count$[ebp]

; 2641 : 	}

	pop	ebp
	ret	0
?_Fill_n@std@@YAPADPADID@Z ENDP				; std::_Fill_n
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3451 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\tuple
;	COMDAT ??__Eignore@std@@YAXXZ
text$di	SEGMENT
??__Eignore@std@@YAXXZ PROC				; std::`dynamic initializer for 'ignore'', COMDAT

; 59   : const _Ignore ignore;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET _ignore
	call	??0_Ignore@std@@QAE@XZ			; std::_Ignore::_Ignore
	pop	ebp
	ret	0
??__Eignore@std@@YAXXZ ENDP				; std::`dynamic initializer for 'ignore''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\tuple
;	COMDAT ??__E_Tuple_alloc@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__E_Tuple_alloc@std@@YAXXZ PROC			; std::`dynamic initializer for '_Tuple_alloc'', COMDAT

; 66   : const _Tuple_alloc_t _Tuple_alloc = _Tuple_alloc_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__E_Tuple_alloc@std@@YAXXZ ENDP			; std::`dynamic initializer for '_Tuple_alloc''
text$di	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ?NetworkFailed@OBS@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?NetworkFailed@OBS@@QAEXXZ PROC				; OBS::NetworkFailed, COMDAT
; _this$ = ecx

; 1207 :     inline void NetworkFailed() { if (hwndMain) PostMessage(hwndMain, OBS_NETWORK_FAILED, 0, 0); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR ?hwndMain@@3PAUHWND__@@A, 0	; hwndMain
	je	SHORT $LN2@NetworkFai
	push	0
	push	0
	push	1033					; 00000409H
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	call	DWORD PTR __imp__PostMessageW@16
$LN2@NetworkFai:
	mov	esp, ebp
	pop	ebp
	ret	0
?NetworkFailed@OBS@@QAEXXZ ENDP				; OBS::NetworkFailed
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\8.1\include\um\ws2tcpip.h
;	COMDAT _idealsendbacklogquery
_TEXT	SEGMENT
_bytes$ = -4						; size = 4
_s$ = 8							; size = 4
_pISB$ = 12						; size = 4
_idealsendbacklogquery PROC				; COMDAT

; 888  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 889  :     DWORD bytes;
; 890  : 
; 891  :     return WSAIoctl(s, SIO_IDEAL_SEND_BACKLOG_QUERY, 
; 892  :                     NULL, 0, pISB, sizeof(*pISB), &bytes, NULL, NULL);

	push	0
	push	0
	lea	eax, DWORD PTR _bytes$[ebp]
	push	eax
	push	4
	mov	ecx, DWORD PTR _pISB$[ebp]
	push	ecx
	push	0
	push	0
	push	1074033787				; 4004747bH
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	DWORD PTR __imp__WSAIoctl@36

; 893  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_idealsendbacklogquery ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\8.1\include\um\ws2tcpip.h
;	COMDAT _idealsendbacklognotify
_TEXT	SEGMENT
_bytes$ = -4						; size = 4
_s$ = 8							; size = 4
_lpOverlapped$ = 12					; size = 4
_lpCompletionRoutine$ = 16				; size = 4
_idealsendbacklognotify PROC				; COMDAT

; 903  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 904  :     DWORD bytes;
; 905  : 
; 906  :     return WSAIoctl(s, SIO_IDEAL_SEND_BACKLOG_CHANGE, 
; 907  :                     NULL, 0, NULL, 0, &bytes, 
; 908  :                     lpOverlapped, lpCompletionRoutine);

	mov	eax, DWORD PTR _lpCompletionRoutine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpOverlapped$[ebp]
	push	ecx
	lea	edx, DWORD PTR _bytes$[ebp]
	push	edx
	push	0
	push	0
	push	0
	push	0
	push	536900730				; 2000747aH
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	DWORD PTR __imp__WSAIoctl@36

; 909  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_idealsendbacklognotify ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\rtmppublisher.cpp
;	COMDAT ??__E?strRTMPErrors@RTMPPublisher@@0VString@@A@@YAXXZ
text$di	SEGMENT
??__E?strRTMPErrors@RTMPPublisher@@0VString@@A@@YAXXZ PROC ; `dynamic initializer for 'RTMPPublisher::strRTMPErrors'', COMDAT

; 26   : String RTMPPublisher::strRTMPErrors;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?strRTMPErrors@RTMPPublisher@@0VString@@A ; RTMPPublisher::strRTMPErrors
	call	DWORD PTR __imp_??0String@@QAE@XZ
	push	OFFSET ??__F?strRTMPErrors@RTMPPublisher@@0VString@@A@@YAXXZ ; `dynamic atexit destructor for 'RTMPPublisher::strRTMPErrors''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?strRTMPErrors@RTMPPublisher@@0VString@@A@@YAXXZ ENDP ; `dynamic initializer for 'RTMPPublisher::strRTMPErrors''
text$di	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?strRTMPErrors@RTMPPublisher@@0VString@@A@@YAXXZ
text$yd	SEGMENT
??__F?strRTMPErrors@RTMPPublisher@@0VString@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'RTMPPublisher::strRTMPErrors'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?strRTMPErrors@RTMPPublisher@@0VString@@A ; RTMPPublisher::strRTMPErrors
	call	DWORD PTR __imp_??1String@@QAE@XZ
	pop	ebp
	ret	0
??__F?strRTMPErrors@RTMPPublisher@@0VString@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'RTMPPublisher::strRTMPErrors''
text$yd	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\rtmppublisher.cpp
;	COMDAT ?librtmpErrorCallback@RTMPPublisher@@CAXHPBDPAD@Z
_TEXT	SEGMENT
$T1 = -3080						; size = 4
_logStr$ = -3076					; size = 2048
_ansiStr$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_level$ = 8						; size = 4
_format$ = 12						; size = 4
_vl$ = 16						; size = 4
?librtmpErrorCallback@RTMPPublisher@@CAXHPBDPAD@Z PROC	; RTMPPublisher::librtmpErrorCallback, COMDAT

; 53   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 3080				; 00000c08H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 54   :     char ansiStr[1024];
; 55   :     TCHAR logStr[1024];
; 56   : 
; 57   :     if (level > RTMP_LOGERROR)

	cmp	DWORD PTR _level$[ebp], 1
	jle	SHORT $LN1@librtmpErr

; 58   :         return;

	jmp	$LN3@librtmpErr
$LN1@librtmpErr:

; 59   : 
; 60   :     vsnprintf(ansiStr, sizeof(ansiStr)-1, format, vl);

	mov	eax, DWORD PTR _vl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _format$[ebp]
	push	ecx
	push	1023					; 000003ffH
	lea	edx, DWORD PTR _ansiStr$[ebp]
	push	edx
	call	_vsnprintf
	add	esp, 16					; 00000010H

; 61   :     ansiStr[sizeof(ansiStr)-1] = 0;

	mov	eax, 1
	imul	ecx, eax, 1023
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 1024		; 00000400H
	jae	SHORT $LN4@librtmpErr
	jmp	SHORT $LN5@librtmpErr
$LN4@librtmpErr:
	call	___report_rangecheckfailure
$LN5@librtmpErr:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _ansiStr$[ebp+edx], 0

; 62   : 
; 63   :     MultiByteToWideChar(CP_UTF8, 0, ansiStr, -1, logStr, _countof(logStr)-1);

	push	1023					; 000003ffH
	lea	eax, DWORD PTR _logStr$[ebp]
	push	eax
	push	-1
	lea	ecx, DWORD PTR _ansiStr$[ebp]
	push	ecx
	push	0
	push	65001					; 0000fde9H
	call	DWORD PTR __imp__MultiByteToWideChar@24

; 64   : 
; 65   :     Log (TEXT("librtmp error: %s"), logStr);

	lea	edx, DWORD PTR _logStr$[ebp]
	push	edx
	push	OFFSET $SG4294776967
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8

; 66   : 
; 67   :     strRTMPErrors << logStr << TEXT("\n");

	push	OFFSET $SG4294776966
	lea	eax, DWORD PTR _logStr$[ebp]
	push	eax
	mov	ecx, OFFSET ?strRTMPErrors@RTMPPublisher@@0VString@@A ; RTMPPublisher::strRTMPErrors
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
$LN3@librtmpErr:

; 68   : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?librtmpErrorCallback@RTMPPublisher@@CAXHPBDPAD@Z ENDP	; RTMPPublisher::librtmpErrorCallback
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\rtmppublisher.cpp
;	COMDAT ?GetRTMPErrors@RTMPPublisher@@CA?AVString@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetRTMPErrors@RTMPPublisher@@CA?AVString@@XZ PROC	; RTMPPublisher::GetRTMPErrors, COMDAT

; 71   : {

	push	ebp
	mov	ebp, esp

; 72   :     return strRTMPErrors;

	push	OFFSET ?strRTMPErrors@RTMPPublisher@@0VString@@A ; RTMPPublisher::strRTMPErrors
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0String@@QAE@ABV0@@Z
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 73   : }

	pop	ebp
	ret	0
?GetRTMPErrors@RTMPPublisher@@CA?AVString@@XZ ENDP	; RTMPPublisher::GetRTMPErrors
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GRTMPPublisher@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GRTMPPublisher@@UAEPAXI@Z PROC			; RTMPPublisher::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1RTMPPublisher@@UAE@XZ		; RTMPPublisher::~RTMPPublisher
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GRTMPPublisher@@UAEPAXI@Z ENDP			; RTMPPublisher::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\rtmppublisher.cpp
;	COMDAT ?Init@RTMPPublisher@@QAE_NI@Z
_TEXT	SEGMENT
_curTCPBufSizeSize$ = -12				; size = 4
_curTCPBufSize$ = -8					; size = 4
_this$ = -4						; size = 4
_tcpBufferSize$ = 8					; size = 4
?Init@RTMPPublisher@@QAE_NI@Z PROC			; RTMPPublisher::Init, COMDAT
; _this$ = ecx

; 128  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 129  :     //------------------------------------------
; 130  : 
; 131  :     //Log(TEXT("Using Send Buffer Size: %u"), sendBufferSize);
; 132  : 
; 133  :     rtmp->m_customSendFunc = (CUSTOMSEND)RTMPPublisher::BufferedSend;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR [ecx+64], OFFSET ?BufferedSend@RTMPPublisher@@CAHPAURTMPSockBuf@@PBDHPAV1@@Z ; RTMPPublisher::BufferedSend

; 134  :     rtmp->m_customSendParam = this;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+60], ecx

; 135  :     rtmp->m_bCustomSend = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	BYTE PTR [eax+57], 1

; 136  : 
; 137  :     //------------------------------------------
; 138  : 
; 139  :     int curTCPBufSize, curTCPBufSizeSize = sizeof(curTCPBufSize);

	mov	DWORD PTR _curTCPBufSizeSize$[ebp], 4

; 140  :     
; 141  :     if (!getsockopt(rtmp->m_sb.sb_socket, SOL_SOCKET, SO_SNDBUF, (char *)&curTCPBufSize, &curTCPBufSizeSize))

	lea	ecx, DWORD PTR _curTCPBufSizeSize$[ebp]
	push	ecx
	lea	edx, DWORD PTR _curTCPBufSize$[ebp]
	push	edx
	push	4097					; 00001001H
	push	65535					; 0000ffffH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR [ecx+384]
	push	edx
	call	DWORD PTR __imp__getsockopt@20
	test	eax, eax
	jne	$LN10@Init

; 142  :     {
; 143  :         Log(TEXT("SO_SNDBUF was at %u"), curTCPBufSize);

	mov	eax, DWORD PTR _curTCPBufSize$[ebp]
	push	eax
	push	OFFSET $SG4294776949
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8

; 144  : 
; 145  :         if (curTCPBufSize < int(tcpBufferSize))

	mov	ecx, DWORD PTR _curTCPBufSize$[ebp]
	cmp	ecx, DWORD PTR _tcpBufferSize$[ebp]
	jge	$LN9@Init

; 146  :         {
; 147  :             if (!setsockopt(rtmp->m_sb.sb_socket, SOL_SOCKET, SO_SNDBUF, (const char *)&tcpBufferSize, sizeof(tcpBufferSize)))

	push	4
	lea	edx, DWORD PTR _tcpBufferSize$[ebp]
	push	edx
	push	4097					; 00001001H
	push	65535					; 0000ffffH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR [ecx+384]
	push	edx
	call	DWORD PTR __imp__setsockopt@20
	test	eax, eax
	jne	SHORT $LN8@Init

; 148  :             {
; 149  :                 if (!getsockopt(rtmp->m_sb.sb_socket, SOL_SOCKET, SO_SNDBUF, (char *)&curTCPBufSize, &curTCPBufSizeSize))

	lea	eax, DWORD PTR _curTCPBufSizeSize$[ebp]
	push	eax
	lea	ecx, DWORD PTR _curTCPBufSize$[ebp]
	push	ecx
	push	4097					; 00001001H
	push	65535					; 0000ffffH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	ecx, DWORD PTR [eax+384]
	push	ecx
	call	DWORD PTR __imp__getsockopt@20
	test	eax, eax
	jne	SHORT $LN7@Init

; 150  :                 {
; 151  :                     if (curTCPBufSize != tcpBufferSize)

	mov	edx, DWORD PTR _curTCPBufSize$[ebp]
	cmp	edx, DWORD PTR _tcpBufferSize$[ebp]
	je	SHORT $LN6@Init

; 152  :                         Log(TEXT("Could not raise SO_SNDBUF to %u, value is now %d"), tcpBufferSize, curTCPBufSize);

	mov	eax, DWORD PTR _curTCPBufSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tcpBufferSize$[ebp]
	push	ecx
	push	OFFSET $SG4294776948
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 12					; 0000000cH
$LN6@Init:

; 153  : 
; 154  :                     Log(TEXT("SO_SNDBUF is now %d"), curTCPBufSize);

	mov	edx, DWORD PTR _curTCPBufSize$[ebp]
	push	edx
	push	OFFSET $SG4294776947
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8

; 155  :                 }
; 156  :                 else

	jmp	SHORT $LN5@Init
$LN7@Init:

; 157  :                 {
; 158  :                     Log(TEXT("getsockopt: Failed to query SO_SNDBUF, error %d"), WSAGetLastError());

	call	DWORD PTR __imp__WSAGetLastError@0
	push	eax
	push	OFFSET $SG4294776946
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8
$LN5@Init:

; 159  :                 }
; 160  :             }
; 161  :             else

	jmp	SHORT $LN9@Init
$LN8@Init:

; 162  :             {
; 163  :                 Log(TEXT("setsockopt: Failed to raise SO_SNDBUF to %u, error %d"), tcpBufferSize, WSAGetLastError());

	call	DWORD PTR __imp__WSAGetLastError@0
	push	eax
	mov	eax, DWORD PTR _tcpBufferSize$[ebp]
	push	eax
	push	OFFSET $SG4294776945
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 12					; 0000000cH
$LN9@Init:

; 164  :             }
; 165  :         }
; 166  :     }
; 167  :     else

	jmp	SHORT $LN3@Init
$LN10@Init:

; 168  :     {
; 169  :         Log(TEXT("getsockopt: Failed to query SO_SNDBUF, error %d"), WSAGetLastError());

	call	DWORD PTR __imp__WSAGetLastError@0
	push	eax
	push	OFFSET $SG4294776944
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8
$LN3@Init:

; 170  :     }
; 171  : 
; 172  :     //------------------------------------------
; 173  : 
; 174  :     hSendThread = OSCreateThread((XTHREAD)RTMPPublisher::SendThread, this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	push	OFFSET ?SendThread@RTMPPublisher@@KAKPAV1@@Z ; RTMPPublisher::SendThread
	call	DWORD PTR __imp_?OSCreateThread@@YGPAXP6GKPAX@Z0@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+112], eax

; 175  :     if(!hSendThread)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+112], 0
	jne	SHORT $LN2@Init

; 176  :         CrashError(TEXT("RTMPPublisher: Could not create send thread"));

	push	OFFSET $SG4294776943
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ
$LN2@Init:

; 177  : 
; 178  :     hBufferEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

	push	0
	push	0
	push	0
	push	0
	call	DWORD PTR __imp__CreateEventW@16
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+124], eax

; 179  :     hBufferSpaceAvailableEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

	push	0
	push	0
	push	0
	push	0
	call	DWORD PTR __imp__CreateEventW@16
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+128], eax

; 180  :     hWriteEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

	push	0
	push	0
	push	0
	push	0
	call	DWORD PTR __imp__CreateEventW@16
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+120], eax

; 181  : 
; 182  :     hSendLoopExit = CreateEvent(NULL, TRUE, FALSE, NULL);

	push	0
	push	0
	push	1
	push	0
	call	DWORD PTR __imp__CreateEventW@16
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+144], eax

; 183  :     hSocketLoopExit = CreateEvent(NULL, TRUE, FALSE, NULL);

	push	0
	push	0
	push	1
	push	0
	call	DWORD PTR __imp__CreateEventW@16
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+148], eax

; 184  :     hSendBacklogEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

	push	0
	push	0
	push	1
	push	0
	call	DWORD PTR __imp__CreateEventW@16
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+152], eax

; 185  : 
; 186  :     hDataBufferMutex = OSCreateMutex();

	call	DWORD PTR __imp_?OSCreateMutex@@YGPAXXZ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+132], eax

; 187  : 
; 188  :     dataBuffer = (BYTE *)Allocate(dataBufferSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+212]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+208], eax

; 189  : 
; 190  :     hSocketThread = OSCreateThread((XTHREAD)RTMPPublisher::SocketThread, this);

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	push	OFFSET ?SocketThread@RTMPPublisher@@KAKPAV1@@Z ; RTMPPublisher::SocketThread
	call	DWORD PTR __imp_?OSCreateThread@@YGPAXP6GKPAX@Z0@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+116], eax

; 191  :     if(!hSocketThread)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+116], 0
	jne	SHORT $LN1@Init

; 192  :         CrashError(TEXT("RTMPPublisher: Could not create send thread"));

	push	OFFSET $SG4294776942
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ
$LN1@Init:

; 193  : 
; 194  :     //------------------------------------------
; 195  : 
; 196  :     packetWaitType = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+180], 0

; 197  : 
; 198  :     return true;

	mov	al, 1
$LN12@Init:

; 199  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Init@RTMPPublisher@@QAE_NI@Z ENDP			; RTMPPublisher::Init
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\rtmppublisher.cpp
;	COMDAT ?FindClosestQueueIndex@RTMPPublisher@@IAEIK@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_index$ = -4						; size = 4
_timestamp$ = 8						; size = 4
?FindClosestQueueIndex@RTMPPublisher@@IAEIK@Z PROC	; RTMPPublisher::FindClosestQueueIndex, COMDAT
; _this$ = ecx

; 425  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 426  :     UINT index;
; 427  :     for (index=0; index<queuedPackets.Num(); index++) {

	mov	DWORD PTR _index$[ebp], 0
	jmp	SHORT $LN4@FindCloses
$LN3@FindCloses:
	mov	eax, DWORD PTR _index$[ebp]
	add	eax, 1
	mov	DWORD PTR _index$[ebp], eax
$LN4@FindCloses:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	?Num@?$List@UNetworkPacket@@@@QBEIXZ	; List<NetworkPacket>::Num
	cmp	DWORD PTR _index$[ebp], eax
	jae	SHORT $LN2@FindCloses

; 428  :         if (queuedPackets[index].timestamp > timestamp)

	mov	ecx, DWORD PTR _index$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	??A?$List@UNetworkPacket@@@@QAEAAUNetworkPacket@@I@Z ; List<NetworkPacket>::operator[]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR _timestamp$[ebp]
	jbe	SHORT $LN1@FindCloses

; 429  :             break;

	jmp	SHORT $LN2@FindCloses
$LN1@FindCloses:

; 430  :     }

	jmp	SHORT $LN3@FindCloses
$LN2@FindCloses:

; 431  : 
; 432  :     return index;

	mov	eax, DWORD PTR _index$[ebp]

; 433  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?FindClosestQueueIndex@RTMPPublisher@@IAEIK@Z ENDP	; RTMPPublisher::FindClosestQueueIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\rtmppublisher.cpp
;	COMDAT ?FindClosestBufferIndex@RTMPPublisher@@IAEIK@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_index$ = -4						; size = 4
_timestamp$ = 8						; size = 4
?FindClosestBufferIndex@RTMPPublisher@@IAEIK@Z PROC	; RTMPPublisher::FindClosestBufferIndex, COMDAT
; _this$ = ecx

; 436  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 437  :     UINT index;
; 438  :     for (index=0; index<bufferedPackets.Num(); index++) {

	mov	DWORD PTR _index$[ebp], 0
	jmp	SHORT $LN4@FindCloses
$LN3@FindCloses:
	mov	eax, DWORD PTR _index$[ebp]
	add	eax, 1
	mov	DWORD PTR _index$[ebp], eax
$LN4@FindCloses:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?Num@?$List@UTimedPacket@@@@QBEIXZ	; List<TimedPacket>::Num
	cmp	DWORD PTR _index$[ebp], eax
	jae	SHORT $LN2@FindCloses

; 439  :         if (bufferedPackets[index].timestamp > timestamp)

	mov	ecx, DWORD PTR _index$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	??A?$List@UTimedPacket@@@@QAEAAUTimedPacket@@I@Z ; List<TimedPacket>::operator[]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR _timestamp$[ebp]
	jbe	SHORT $LN1@FindCloses

; 440  :             break;

	jmp	SHORT $LN2@FindCloses
$LN1@FindCloses:

; 441  :     }

	jmp	SHORT $LN3@FindCloses
$LN2@FindCloses:

; 442  : 
; 443  :     return index;

	mov	eax, DWORD PTR _index$[ebp]

; 444  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?FindClosestBufferIndex@RTMPPublisher@@IAEIK@Z ENDP	; RTMPPublisher::FindClosestBufferIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\rtmppublisher.cpp
;	COMDAT ?InitializeBuffer@RTMPPublisher@@IAEXXZ
_TEXT	SEGMENT
_newTimestamp$1 = -24					; size = 4
_newIndex$2 = -20					; size = 4
_packet$3 = -16						; size = 4
_i$4 = -12						; size = 4
_this$ = -8						; size = 4
_bFirstAudio$ = -1					; size = 1
?InitializeBuffer@RTMPPublisher@@IAEXXZ PROC		; RTMPPublisher::InitializeBuffer, COMDAT
; _this$ = ecx

; 447  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 448  :     bool bFirstAudio = true;

	mov	BYTE PTR _bFirstAudio$[ebp], 1

; 449  :     for (UINT i=0; i<bufferedPackets.Num(); i++) {

	mov	DWORD PTR _i$4[ebp], 0
	jmp	SHORT $LN7@Initialize
$LN6@Initialize:
	mov	eax, DWORD PTR _i$4[ebp]
	add	eax, 1
	mov	DWORD PTR _i$4[ebp], eax
$LN7@Initialize:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?Num@?$List@UTimedPacket@@@@QBEIXZ	; List<TimedPacket>::Num
	cmp	DWORD PTR _i$4[ebp], eax
	jae	$LN8@Initialize

; 450  :         TimedPacket &packet = bufferedPackets[i];

	mov	ecx, DWORD PTR _i$4[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	??A?$List@UTimedPacket@@@@QAEAAUTimedPacket@@I@Z ; List<TimedPacket>::operator[]
	mov	DWORD PTR _packet$3[ebp], eax

; 451  : 
; 452  :         //first, get the audio time offset from the first audio packet
; 453  :         if (packet.type == PacketType_Audio) {

	mov	edx, DWORD PTR _packet$3[ebp]
	cmp	DWORD PTR [edx+12], 4
	jne	$LN4@Initialize

; 454  :             if (bFirstAudio) {

	movzx	eax, BYTE PTR _bFirstAudio$[ebp]
	test	eax, eax
	je	SHORT $LN3@Initialize

; 455  :                 audioTimeOffset = packet.timestamp;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _packet$3[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+36], eax

; 456  :                 OSDebugOut(TEXT("Set audio offset: %d\n"), audioTimeOffset);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	push	OFFSET $SG4294776931
	call	DWORD PTR __imp_?OSDebugOut@@YAXPB_WZZ
	add	esp, 8

; 457  :                 bFirstAudio = false;

	mov	BYTE PTR _bFirstAudio$[ebp], 0
$LN3@Initialize:

; 458  :             }
; 459  : 
; 460  :             DWORD newTimestamp = packet.timestamp-audioTimeOffset;

	mov	eax, DWORD PTR _packet$3[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR _newTimestamp$1[ebp], edx

; 461  : 
; 462  :             UINT newIndex = FindClosestBufferIndex(newTimestamp);

	mov	eax, DWORD PTR _newTimestamp$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindClosestBufferIndex@RTMPPublisher@@IAEIK@Z ; RTMPPublisher::FindClosestBufferIndex
	mov	DWORD PTR _newIndex$2[ebp], eax

; 463  :             if (newIndex < i) {

	mov	ecx, DWORD PTR _newIndex$2[ebp]
	cmp	ecx, DWORD PTR _i$4[ebp]
	jae	SHORT $LN2@Initialize

; 464  :                 bufferedPackets.MoveItem(i, newIndex);

	mov	edx, DWORD PTR _newIndex$2[ebp]
	push	edx
	mov	eax, DWORD PTR _i$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?MoveItem@?$List@UTimedPacket@@@@QAEXHH@Z ; List<TimedPacket>::MoveItem

; 465  :                 bufferedPackets[newIndex].timestamp = newTimestamp;

	mov	ecx, DWORD PTR _newIndex$2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	??A?$List@UTimedPacket@@@@QAEAAUTimedPacket@@I@Z ; List<TimedPacket>::operator[]
	mov	edx, DWORD PTR _newTimestamp$1[ebp]
	mov	DWORD PTR [eax+8], edx

; 466  :             } else {

	jmp	SHORT $LN4@Initialize
$LN2@Initialize:

; 467  :                 bufferedPackets[i].timestamp = newTimestamp;

	mov	eax, DWORD PTR _i$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	??A?$List@UTimedPacket@@@@QAEAAUTimedPacket@@I@Z ; List<TimedPacket>::operator[]
	mov	ecx, DWORD PTR _newTimestamp$1[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN4@Initialize:

; 468  :             }
; 469  :         }
; 470  :     }

	jmp	$LN6@Initialize
$LN8@Initialize:

; 471  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InitializeBuffer@RTMPPublisher@@IAEXXZ ENDP		; RTMPPublisher::InitializeBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0TimedPacket@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0TimedPacket@@QAE@XZ PROC				; TimedPacket::TimedPacket, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$List@E@@QAE@XZ			; List<unsigned char>::List<unsigned char>
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0TimedPacket@@QAE@XZ ENDP				; TimedPacket::TimedPacket
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1TimedPacket@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1TimedPacket@@QAE@XZ PROC				; TimedPacket::~TimedPacket, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$List@E@@QAE@XZ			; List<unsigned char>::~List<unsigned char>
	mov	esp, ebp
	pop	ebp
	ret	0
??1TimedPacket@@QAE@XZ ENDP				; TimedPacket::~TimedPacket
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\rtmppublisher.cpp
;	COMDAT ?SendPacketForReal@RTMPPublisher@@IAEXPAEIKW4PacketType@@@Z
_TEXT	SEGMENT
_sei$1 = -44						; size = 8
_paddedData$2 = -36					; size = 8
_droppedFrameVal$3 = -28				; size = 4
_id$4 = -24						; size = 4
tv175 = -20						; size = 4
tv152 = -16						; size = 4
_queuedPacket$5 = -12					; size = 4
_this$ = -8						; size = 4
_bAddPacket$6 = -2					; size = 1
_bSend$7 = -1						; size = 1
_data$ = 8						; size = 4
_size$ = 12						; size = 4
_timestamp$ = 16					; size = 4
_type$ = 20						; size = 4
?SendPacketForReal@RTMPPublisher@@IAEXPAEIKW4PacketType@@@Z PROC ; RTMPPublisher::SendPacketForReal, COMDAT
; _this$ = ecx

; 642  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 643  :     //OSDebugOut (TEXT("%u: SendPacketForReal (%d bytes - %08x @ %u, type %d)\n"), OSGetTime(), size, quickHash(data,size), timestamp, type);
; 644  :     //Log(TEXT("packet| timestamp: %u, type: %u, bytes: %u"), timestamp, (UINT)type, size);
; 645  : 
; 646  :     OSEnterMutex(hDataMutex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	push	ecx
	call	DWORD PTR __imp_?OSEnterMutex@@YGXPAX@Z

; 647  : 
; 648  :     if(bConnected)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+18]
	test	eax, eax
	je	$LN13@SendPacket

; 649  :     {
; 650  :         ProcessPackets();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	call	eax

; 651  : 
; 652  :         bool bSend = bSentFirstKeyframe;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+24]
	mov	BYTE PTR _bSend$7[ebp], dl

; 653  : 
; 654  :         if(!bSentFirstKeyframe)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+24]
	test	ecx, ecx
	jne	SHORT $LN12@SendPacket

; 655  :         {
; 656  :             if(type == PacketType_VideoHighest)

	cmp	DWORD PTR _type$[ebp], 3
	jne	SHORT $LN12@SendPacket

; 657  :             {
; 658  :                 bSend = true;

	mov	BYTE PTR _bSend$7[ebp], 1

; 659  : 
; 660  :                 OSDebugOut(TEXT("got keyframe: %u\r\n"), OSGetTime());

	call	DWORD PTR __imp_?OSGetTime@@YGKXZ
	push	eax
	push	OFFSET $SG4294776928
	call	DWORD PTR __imp_?OSDebugOut@@YAXPB_WZZ
	add	esp, 8
$LN12@SendPacket:

; 661  :             }
; 662  :         }
; 663  : 
; 664  :         if(bSend)

	movzx	edx, BYTE PTR _bSend$7[ebp]
	test	edx, edx
	je	$LN13@SendPacket

; 665  :         {
; 666  :             if(!bSentFirstAudio && type == PacketType_Audio)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+25]
	test	ecx, ecx
	jne	SHORT $LN9@SendPacket
	cmp	DWORD PTR _type$[ebp], 4
	jne	SHORT $LN9@SendPacket

; 667  :             {
; 668  :                 timestamp = 0;

	mov	DWORD PTR _timestamp$[ebp], 0

; 669  :                 bSentFirstAudio = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+25], 1
$LN9@SendPacket:

; 670  :             }
; 671  : 
; 672  :             totalFrames++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+192]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+192], ecx

; 673  :             if(type != PacketType_Audio)

	cmp	DWORD PTR _type$[ebp], 4
	je	SHORT $LN8@SendPacket

; 674  :                 totalVideoFrames++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+196], ecx
$LN8@SendPacket:

; 675  : 
; 676  :             bool bAddPacket = false;

	mov	BYTE PTR _bAddPacket$6[ebp], 0

; 677  :             if(type >= packetWaitType)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _type$[ebp]
	cmp	ecx, DWORD PTR [eax+180]
	jl	SHORT $LN7@SendPacket

; 678  :             {
; 679  :                 if(type != PacketType_Audio)

	cmp	DWORD PTR _type$[ebp], 4
	je	SHORT $LN6@SendPacket

; 680  :                     packetWaitType = PacketType_VideoDisposable;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+180], 0
$LN6@SendPacket:

; 681  : 
; 682  :                 bAddPacket = true;

	mov	BYTE PTR _bAddPacket$6[ebp], 1
$LN7@SendPacket:

; 683  :             }
; 684  : 
; 685  :             if(bAddPacket)

	movzx	eax, BYTE PTR _bAddPacket$6[ebp]
	test	eax, eax
	je	$LN5@SendPacket

; 686  :             {
; 687  :                 List<BYTE> paddedData;

	lea	ecx, DWORD PTR _paddedData$2[ebp]
	call	??0?$List@E@@QAE@XZ			; List<unsigned char>::List<unsigned char>

; 688  :                 paddedData.SetSize(size+RTMP_MAX_HEADER_SIZE);

	mov	ecx, DWORD PTR _size$[ebp]
	add	ecx, 18					; 00000012H
	push	ecx
	lea	ecx, DWORD PTR _paddedData$2[ebp]
	call	?SetSize@?$List@E@@QAEHI@Z		; List<unsigned char>::SetSize

; 689  :                 mcpy(paddedData.Array()+RTMP_MAX_HEADER_SIZE, data, size);

	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	lea	ecx, DWORD PTR _paddedData$2[ebp]
	call	?Array@?$List@E@@QBEPAEXZ		; List<unsigned char>::Array
	add	eax, 18					; 00000012H
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 690  : 
; 691  :                 if(!bSentFirstKeyframe)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+24]
	test	edx, edx
	jne	SHORT $LN4@SendPacket

; 692  :                 {
; 693  :                     DataPacket sei;
; 694  :                     App->GetVideoEncoder()->GetSEI(sei);

	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?GetVideoEncoder@OBS@@QBEPAVVideoEncoder@@XZ ; OBS::GetVideoEncoder
	mov	DWORD PTR tv152[ebp], eax
	lea	eax, DWORD PTR _sei$1[ebp]
	push	eax
	mov	ecx, DWORD PTR tv152[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv152[ebp]
	mov	eax, DWORD PTR [edx+28]
	call	eax

; 695  :                     paddedData.InsertArray(RTMP_MAX_HEADER_SIZE+5, sei.lpPacket, sei.size);

	mov	ecx, DWORD PTR _sei$1[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _sei$1[ebp]
	push	edx
	push	23					; 00000017H
	lea	ecx, DWORD PTR _paddedData$2[ebp]
	call	?InsertArray@?$List@E@@QAEXIPBEI@Z	; List<unsigned char>::InsertArray

; 696  : 
; 697  :                     bSentFirstKeyframe = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+24], 1
$LN4@SendPacket:

; 698  :                 }
; 699  : 
; 700  :                 currentBufferSize += paddedData.Num();

	lea	ecx, DWORD PTR _paddedData$2[ebp]
	call	?Num@?$List@E@@QBEIXZ			; List<unsigned char>::Num
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+92]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+92], eax

; 701  : 
; 702  :                 UINT droppedFrameVal = queuedPackets.Num() ? queuedPackets.Last().distanceFromDroppedFrame+1 : 10000;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	?Num@?$List@UNetworkPacket@@@@QBEIXZ	; List<NetworkPacket>::Num
	test	eax, eax
	je	SHORT $LN16@SendPacket
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	?Last@?$List@UNetworkPacket@@@@QBEAAUNetworkPacket@@XZ ; List<NetworkPacket>::Last
	mov	eax, DWORD PTR [eax+16]
	add	eax, 1
	mov	DWORD PTR tv175[ebp], eax
	jmp	SHORT $LN17@SendPacket
$LN16@SendPacket:
	mov	DWORD PTR tv175[ebp], 10000		; 00002710H
$LN17@SendPacket:
	mov	ecx, DWORD PTR tv175[ebp]
	mov	DWORD PTR _droppedFrameVal$3[ebp], ecx

; 703  : 
; 704  :                 UINT id = FindClosestQueueIndex(timestamp);

	mov	edx, DWORD PTR _timestamp$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindClosestQueueIndex@RTMPPublisher@@IAEIK@Z ; RTMPPublisher::FindClosestQueueIndex
	mov	DWORD PTR _id$4[ebp], eax

; 705  : 
; 706  :                 NetworkPacket *queuedPacket = queuedPackets.InsertNew(id);

	mov	eax, DWORD PTR _id$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	?InsertNew@?$List@UNetworkPacket@@@@QAEPAUNetworkPacket@@H@Z ; List<NetworkPacket>::InsertNew
	mov	DWORD PTR _queuedPacket$5[ebp], eax

; 707  :                 queuedPacket->distanceFromDroppedFrame = droppedFrameVal;

	mov	ecx, DWORD PTR _queuedPacket$5[ebp]
	mov	edx, DWORD PTR _droppedFrameVal$3[ebp]
	mov	DWORD PTR [ecx+16], edx

; 708  :                 queuedPacket->data.TransferFrom(paddedData);

	lea	eax, DWORD PTR _paddedData$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _queuedPacket$5[ebp]
	call	?TransferFrom@?$List@E@@QAEXAAV1@@Z	; List<unsigned char>::TransferFrom

; 709  :                 queuedPacket->timestamp = timestamp;

	mov	ecx, DWORD PTR _queuedPacket$5[ebp]
	mov	edx, DWORD PTR _timestamp$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 710  :                 queuedPacket->type = type;

	mov	eax, DWORD PTR _queuedPacket$5[ebp]
	mov	ecx, DWORD PTR _type$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 711  :             }

	lea	ecx, DWORD PTR _paddedData$2[ebp]
	call	??1?$List@E@@QAE@XZ			; List<unsigned char>::~List<unsigned char>

; 712  :             else

	jmp	SHORT $LN13@SendPacket
$LN5@SendPacket:

; 713  :             {
; 714  :                 if(type < PacketType_VideoHigh)

	cmp	DWORD PTR _type$[ebp], 2
	jge	SHORT $LN2@SendPacket

; 715  :                     numBFramesDumped++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+204]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+204], eax

; 716  :                 else

	jmp	SHORT $LN13@SendPacket
$LN2@SendPacket:

; 717  :                     numPFramesDumped++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+200]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+200], eax
$LN13@SendPacket:

; 718  :             }
; 719  :         }
; 720  :     }
; 721  : 
; 722  :     OSLeaveMutex(hDataMutex);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+108]
	push	eax
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z

; 723  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?SendPacketForReal@RTMPPublisher@@IAEXPAEIKW4PacketType@@@Z ENDP ; RTMPPublisher::SendPacketForReal
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\rtmppublisher.cpp
;	COMDAT ?BeginPublishingInternal@RTMPPublisher@@AAEXXZ
_TEXT	SEGMENT
_packet$ = -44						; size = 32
_packetPadding$ = -12					; size = 8
_this$ = -4						; size = 4
?BeginPublishingInternal@RTMPPublisher@@AAEXXZ PROC	; RTMPPublisher::BeginPublishingInternal, COMDAT
; _this$ = ecx

; 726  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 727  :     RTMPPacket packet;
; 728  : 
; 729  :     packet.m_nChannel = 0x03;     // control channel (invoke)

	mov	DWORD PTR _packet$[ebp+4], 3

; 730  :     packet.m_headerType = RTMP_PACKET_SIZE_LARGE;

	mov	BYTE PTR _packet$[ebp], 0

; 731  :     packet.m_packetType = RTMP_PACKET_TYPE_INFO;

	mov	BYTE PTR _packet$[ebp+1], 18		; 00000012H

; 732  :     packet.m_nTimeStamp = 0;

	mov	DWORD PTR _packet$[ebp+8], 0

; 733  :     packet.m_nInfoField2 = rtmp->m_stream_id;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _packet$[ebp+12], edx

; 734  :     packet.m_hasAbsTimestamp = TRUE;

	mov	BYTE PTR _packet$[ebp+2], 1

; 735  :     packet.m_body = metaDataPacketBuffer.data() + RTMP_MAX_HEADER_SIZE;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?data@?$vector@DV?$allocator@D@std@@@std@@QAEPADXZ ; std::vector<char,std::allocator<char> >::data
	add	eax, 18					; 00000012H
	mov	DWORD PTR _packet$[ebp+28], eax

; 736  : 
; 737  :     packet.m_nBodySize = metaDataPacketBuffer.size() - RTMP_MAX_HEADER_SIZE;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	sub	eax, 18					; 00000012H
	mov	DWORD PTR _packet$[ebp+16], eax

; 738  :     if(!RTMP_SendPacket(rtmp, &packet, FALSE))

	push	0
	lea	edx, DWORD PTR _packet$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	call	_RTMP_SendPacket
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN3@BeginPubli

; 739  :     {
; 740  :         App->PostStopMessage();

	push	0
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?PostStopMessage@OBS@@QAEX_N@Z		; OBS::PostStopMessage

; 741  :         return;

	jmp	$LN4@BeginPubli
$LN3@BeginPubli:

; 742  :     }
; 743  : 
; 744  :     //----------------------------------------------
; 745  : 
; 746  :     List<BYTE> packetPadding;

	lea	ecx, DWORD PTR _packetPadding$[ebp]
	call	??0?$List@E@@QAE@XZ			; List<unsigned char>::List<unsigned char>

; 747  : 
; 748  :     //----------------------------------------------
; 749  : 
; 750  :     packet.m_nChannel = 0x05; // source channel

	mov	DWORD PTR _packet$[ebp+4], 5

; 751  :     packet.m_packetType = RTMP_PACKET_TYPE_AUDIO;

	mov	BYTE PTR _packet$[ebp+1], 8

; 752  : 
; 753  :     packetPadding.SetSize(RTMP_MAX_HEADER_SIZE);

	push	18					; 00000012H
	lea	ecx, DWORD PTR _packetPadding$[ebp]
	call	?SetSize@?$List@E@@QAEHI@Z		; List<unsigned char>::SetSize

; 754  :     packetPadding.AppendArray(audioHeaders.lpPacket, audioHeaders.size);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	lea	ecx, DWORD PTR _packetPadding$[ebp]
	call	?AppendArray@?$List@E@@QAEXPBEI@Z	; List<unsigned char>::AppendArray

; 755  : 
; 756  :     packet.m_body = (char*)packetPadding.Array()+RTMP_MAX_HEADER_SIZE;

	lea	ecx, DWORD PTR _packetPadding$[ebp]
	call	?Array@?$List@E@@QBEPAEXZ		; List<unsigned char>::Array
	add	eax, 18					; 00000012H
	mov	DWORD PTR _packet$[ebp+28], eax

; 757  :     packet.m_nBodySize = audioHeaders.size;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	DWORD PTR _packet$[ebp+16], eax

; 758  :     if(!RTMP_SendPacket(rtmp, &packet, FALSE))

	push	0
	lea	edx, DWORD PTR _packet$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+100]
	call	_RTMP_SendPacket
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@BeginPubli

; 759  :     {
; 760  :         App->PostStopMessage();

	push	0
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?PostStopMessage@OBS@@QAEX_N@Z		; OBS::PostStopMessage

; 761  :         return;

	lea	ecx, DWORD PTR _packetPadding$[ebp]
	call	??1?$List@E@@QAE@XZ			; List<unsigned char>::~List<unsigned char>
	jmp	SHORT $LN4@BeginPubli
$LN2@BeginPubli:

; 762  :     }
; 763  : 
; 764  :     //----------------------------------------------
; 765  : 
; 766  :     packet.m_nChannel = 0x04; // source channel

	mov	DWORD PTR _packet$[ebp+4], 4

; 767  :     packet.m_headerType = RTMP_PACKET_SIZE_LARGE;

	mov	BYTE PTR _packet$[ebp], 0

; 768  :     packet.m_packetType = RTMP_PACKET_TYPE_VIDEO;

	mov	BYTE PTR _packet$[ebp+1], 9

; 769  : 
; 770  : 
; 771  :     packetPadding.SetSize(RTMP_MAX_HEADER_SIZE);

	push	18					; 00000012H
	lea	ecx, DWORD PTR _packetPadding$[ebp]
	call	?SetSize@?$List@E@@QAEHI@Z		; List<unsigned char>::SetSize

; 772  :     packetPadding.AppendArray(videoHeaders.lpPacket, videoHeaders.size);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+68]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	lea	ecx, DWORD PTR _packetPadding$[ebp]
	call	?AppendArray@?$List@E@@QAEXPBEI@Z	; List<unsigned char>::AppendArray

; 773  : 
; 774  :     packet.m_body = (char*)packetPadding.Array()+RTMP_MAX_HEADER_SIZE;

	lea	ecx, DWORD PTR _packetPadding$[ebp]
	call	?Array@?$List@E@@QBEPAEXZ		; List<unsigned char>::Array
	add	eax, 18					; 00000012H
	mov	DWORD PTR _packet$[ebp+28], eax

; 775  :     packet.m_nBodySize = videoHeaders.size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	DWORD PTR _packet$[ebp+16], ecx

; 776  :     if(!RTMP_SendPacket(rtmp, &packet, FALSE))

	push	0
	lea	edx, DWORD PTR _packet$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	call	_RTMP_SendPacket
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@BeginPubli

; 777  :     {
; 778  :         App->PostStopMessage();

	push	0
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?PostStopMessage@OBS@@QAEX_N@Z		; OBS::PostStopMessage

; 779  :         return;

	lea	ecx, DWORD PTR _packetPadding$[ebp]
	call	??1?$List@E@@QAE@XZ			; List<unsigned char>::~List<unsigned char>
	jmp	SHORT $LN4@BeginPubli
$LN1@BeginPubli:

; 780  :     }
; 781  : }

	lea	ecx, DWORD PTR _packetPadding$[ebp]
	call	??1?$List@E@@QAE@XZ			; List<unsigned char>::~List<unsigned char>
$LN4@BeginPubli:
	mov	esp, ebp
	pop	ebp
	ret	0
?BeginPublishingInternal@RTMPPublisher@@AAEXXZ ENDP	; RTMPPublisher::BeginPublishingInternal
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\rtmppublisher.cpp
;	COMDAT ?LogInterfaceType@@YAXPAURTMP@@@Z
_TEXT	SEGMENT
$T1 = -1216						; size = 8
_destAddr$ = -1208					; size = 4
_otherType$2 = -1204					; size = 8
_speed$3 = -1196					; size = 4
_h$ = -1192						; size = 4
$T4 = -1188						; size = 4
_sourceAddr$ = -1184					; size = 4
_type$5 = -1180						; size = 4
_row$6 = -1176						; size = 860
_route$ = -316						; size = 56
_hostname$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_rtmp$ = 8						; size = 4
?LogInterfaceType@@YAXPAURTMP@@@Z PROC			; LogInterfaceType, COMDAT

; 788  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1216				; 000004c0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 789  :     MIB_IPFORWARDROW    route;
; 790  :     DWORD               destAddr, sourceAddr;
; 791  :     CHAR                hostname[256];
; 792  : 
; 793  :     if (rtmp->Link.hostname.av_len >= sizeof(hostname)-1)

	mov	eax, DWORD PTR _rtmp$[ebp]
	cmp	DWORD PTR [eax+16792], 255		; 000000ffH
	jb	SHORT $LN12@LogInterfa

; 794  :         return;

	jmp	$LN14@LogInterfa
$LN12@LogInterfa:

; 795  : 
; 796  :     strncpy (hostname, rtmp->Link.hostname.av_val, sizeof(hostname)-1);

	push	255					; 000000ffH
	mov	ecx, DWORD PTR _rtmp$[ebp]
	mov	edx, DWORD PTR [ecx+16788]
	push	edx
	lea	eax, DWORD PTR _hostname$[ebp]
	push	eax
	call	_strncpy
	add	esp, 12					; 0000000cH

; 797  :     hostname[rtmp->Link.hostname.av_len] = 0;

	mov	ecx, DWORD PTR _rtmp$[ebp]
	mov	edx, DWORD PTR [ecx+16792]
	mov	DWORD PTR $T4[ebp], edx
	cmp	DWORD PTR $T4[ebp], 256			; 00000100H
	jae	SHORT $LN15@LogInterfa
	jmp	SHORT $LN16@LogInterfa
$LN15@LogInterfa:
	call	___report_rangecheckfailure
$LN16@LogInterfa:
	mov	eax, DWORD PTR $T4[ebp]
	mov	BYTE PTR _hostname$[ebp+eax], 0

; 798  : 
; 799  :     HOSTENT *h = gethostbyname(hostname);

	lea	ecx, DWORD PTR _hostname$[ebp]
	push	ecx
	call	DWORD PTR __imp__gethostbyname@4
	mov	DWORD PTR _h$[ebp], eax

; 800  :     if (!h)

	cmp	DWORD PTR _h$[ebp], 0
	jne	SHORT $LN11@LogInterfa

; 801  :         return;

	jmp	$LN14@LogInterfa
$LN11@LogInterfa:

; 802  : 
; 803  :     destAddr = *(DWORD *)h->h_addr_list[0];

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _h$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [eax+edx]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _destAddr$[ebp], ecx

; 804  : 
; 805  :     if (rtmp->m_bindIP.addrLen == 0)

	mov	edx, DWORD PTR _rtmp$[ebp]
	cmp	DWORD PTR [edx+200], 0
	jne	SHORT $LN10@LogInterfa

; 806  :         sourceAddr = 0;

	mov	DWORD PTR _sourceAddr$[ebp], 0
	jmp	SHORT $LN9@LogInterfa
$LN10@LogInterfa:

; 807  :     else if (rtmp->m_bindIP.addr.ss_family == AF_INET)

	mov	eax, DWORD PTR _rtmp$[ebp]
	movzx	ecx, WORD PTR [eax+72]
	cmp	ecx, 2
	jne	SHORT $LN8@LogInterfa

; 808  :         sourceAddr = (*(struct sockaddr_in *)&rtmp->m_bindIP).sin_addr.S_un.S_addr;

	mov	edx, DWORD PTR _rtmp$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR _sourceAddr$[ebp], eax

; 809  :     else

	jmp	SHORT $LN9@LogInterfa
$LN8@LogInterfa:

; 810  :         return; // getting route for IPv6 is far more complex, ignore for now

	jmp	$LN14@LogInterfa
$LN9@LogInterfa:

; 811  : 
; 812  :     if (!GetBestRoute (destAddr, sourceAddr, &route))

	lea	ecx, DWORD PTR _route$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sourceAddr$[ebp]
	push	edx
	mov	eax, DWORD PTR _destAddr$[ebp]
	push	eax
	call	DWORD PTR __imp__GetBestRoute@12
	test	eax, eax
	jne	$LN14@LogInterfa

; 813  :     {
; 814  :         MIB_IFROW row;
; 815  :         zero (&row, sizeof(row));

	push	860					; 0000035cH
	lea	ecx, DWORD PTR _row$6[ebp]
	push	ecx
	call	?zero@@YGXPAXI@Z			; zero

; 816  :         row.dwIndex = route.dwForwardIfIndex;

	mov	edx, DWORD PTR _route$[ebp+16]
	mov	DWORD PTR _row$6[ebp+512], edx

; 817  : 
; 818  :         if (!GetIfEntry (&row))

	lea	eax, DWORD PTR _row$6[ebp]
	push	eax
	call	DWORD PTR __imp__GetIfEntry@4
	test	eax, eax
	jne	$LN14@LogInterfa

; 819  :         {
; 820  :             DWORD speed = row.dwSpeed / 1000000;

	mov	eax, DWORD PTR _row$6[ebp+524]
	xor	edx, edx
	mov	ecx, 1000000				; 000f4240H
	div	ecx
	mov	DWORD PTR _speed$3[ebp], eax

; 821  :             TCHAR *type;
; 822  :             String otherType;

	lea	ecx, DWORD PTR _otherType$2[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 823  : 
; 824  :             if (row.dwType == IF_TYPE_ETHERNET_CSMACD)

	cmp	DWORD PTR _row$6[ebp+516], 6
	jne	SHORT $LN4@LogInterfa

; 825  :                 type = TEXT("ethernet");

	mov	DWORD PTR _type$5[ebp], OFFSET $SG4294776927
	jmp	SHORT $LN3@LogInterfa
$LN4@LogInterfa:

; 826  :             else if (row.dwType == IF_TYPE_IEEE80211)

	cmp	DWORD PTR _row$6[ebp+516], 71		; 00000047H
	jne	SHORT $LN2@LogInterfa

; 827  :                 type = TEXT("802.11");

	mov	DWORD PTR _type$5[ebp], OFFSET $SG4294776926

; 828  :             else

	jmp	SHORT $LN3@LogInterfa
$LN2@LogInterfa:

; 829  :             {
; 830  :                 otherType = FormattedString (TEXT("type %d"), row.dwType);

	mov	edx, DWORD PTR _row$6[ebp+516]
	push	edx
	push	OFFSET $SG4294776925
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _otherType$2[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 831  :                 type = otherType.Array();

	lea	ecx, DWORD PTR _otherType$2[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	mov	DWORD PTR _type$5[ebp], eax
$LN3@LogInterfa:

; 832  :             }
; 833  : 
; 834  :             Log (TEXT("  Interface: %S (%s, %d mbps)"), row.bDescr, type, speed);

	mov	ecx, DWORD PTR _speed$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _type$5[ebp]
	push	edx
	lea	eax, DWORD PTR _row$6[ebp+604]
	push	eax
	push	OFFSET $SG4294776924
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 16					; 00000010H

; 835  :         }

	lea	ecx, DWORD PTR _otherType$2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN14@LogInterfa:

; 836  :     }
; 837  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?LogInterfaceType@@YAXPAURTMP@@@Z ENDP			; LogInterfaceType
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1ServiceIdentifier@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1ServiceIdentifier@@QAE@XZ PROC			; ServiceIdentifier::~ServiceIdentifier, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1ServiceIdentifier@@QAE@XZ ENDP			; ServiceIdentifier::~ServiceIdentifier
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@@std@@QAE@XZ PROC ; std::pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,XElement *>::~pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,XElement *>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QAE@XZ ; std::unique_ptr<XConfig,std::default_delete<XConfig> >::~unique_ptr<XConfig,std::default_delete<XConfig> >
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@@std@@QAE@XZ ENDP ; std::pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,XElement *>::~pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,XElement *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\rtmppublisher.cpp
;	COMDAT ?FlushDataBuffer@RTMPPublisher@@IAEHXZ
_TEXT	SEGMENT
_ret$ = -12						; size = 4
_zero$ = -8						; size = 4
_this$ = -4						; size = 4
?FlushDataBuffer@RTMPPublisher@@IAEHXZ PROC		; RTMPPublisher::FlushDataBuffer, COMDAT
; _this$ = ecx

; 1161 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1162 :     unsigned long zero = 0;

	mov	DWORD PTR _zero$[ebp], 0

; 1163 : 
; 1164 :     //OSDebugOut (TEXT("*** ~RTMPPublisher FlushDataBuffer (%d)\n"), curDataBufferLen);
; 1165 :     
; 1166 :     //make it blocking again
; 1167 :     WSAEventSelect(rtmp->m_sb.sb_socket, NULL, 0);

	push	0
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR [ecx+384]
	push	edx
	call	DWORD PTR __imp__WSAEventSelect@12

; 1168 :     ioctlsocket(rtmp->m_sb.sb_socket, FIONBIO, &zero);

	lea	eax, DWORD PTR _zero$[ebp]
	push	eax
	push	-2147195266				; 8004667eH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	eax, DWORD PTR [edx+384]
	push	eax
	call	DWORD PTR __imp__ioctlsocket@12

; 1169 : 
; 1170 :     OSEnterMutex(hDataBufferMutex);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+132]
	push	edx
	call	DWORD PTR __imp_?OSEnterMutex@@YGXPAX@Z

; 1171 :     int ret = send(rtmp->m_sb.sb_socket, (const char *)dataBuffer, curDataBufferLen, 0);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+216]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+208]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	eax, DWORD PTR [edx+384]
	push	eax
	call	DWORD PTR __imp__send@16
	mov	DWORD PTR _ret$[ebp], eax

; 1172 :     curDataBufferLen = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+216], 0

; 1173 :     OSLeaveMutex(hDataBufferMutex);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+132]
	push	eax
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z

; 1174 : 
; 1175 :     return ret;

	mov	eax, DWORD PTR _ret$[ebp]

; 1176 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FlushDataBuffer@RTMPPublisher@@IAEHXZ ENDP		; RTMPPublisher::FlushDataBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\rtmppublisher.cpp
;	COMDAT ?SetupSendBacklogEvent@RTMPPublisher@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetupSendBacklogEvent@RTMPPublisher@@IAEXXZ PROC	; RTMPPublisher::SetupSendBacklogEvent, COMDAT
; _this$ = ecx

; 1179 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1180 :     zero (&sendBacklogOverlapped, sizeof(sendBacklogOverlapped));

	push	20					; 00000014H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 156				; 0000009cH
	push	eax
	call	?zero@@YGXPAXI@Z			; zero

; 1181 : 
; 1182 :     ResetEvent (hSendBacklogEvent);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+152]
	push	edx
	call	DWORD PTR __imp__ResetEvent@4

; 1183 :     sendBacklogOverlapped.hEvent = hSendBacklogEvent;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+152]
	mov	DWORD PTR [eax+172], edx

; 1184 : 
; 1185 :     idealsendbacklognotify (rtmp->m_sb.sb_socket, &sendBacklogOverlapped, NULL);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 156				; 0000009cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	eax, DWORD PTR [edx+384]
	push	eax
	call	_idealsendbacklognotify
	add	esp, 12					; 0000000cH

; 1186 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetupSendBacklogEvent@RTMPPublisher@@IAEXXZ ENDP	; RTMPPublisher::SetupSendBacklogEvent
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\rtmppublisher.cpp
;	COMDAT ?FatalSocketShutdown@RTMPPublisher@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?FatalSocketShutdown@RTMPPublisher@@IAEXXZ PROC		; RTMPPublisher::FatalSocketShutdown, COMDAT
; _this$ = ecx

; 1189 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1190 :     //We close the socket manually to avoid trying to run cleanup code during the shutdown cycle since
; 1191 :     //if we're being called the socket is already in an unusable state.
; 1192 :     closesocket(rtmp->m_sb.sb_socket);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR [ecx+384]
	push	edx
	call	DWORD PTR __imp__closesocket@4

; 1193 :     rtmp->m_sb.sb_socket = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR [ecx+384], -1

; 1194 : 
; 1195 :     //anything buffered is invalid now
; 1196 :     curDataBufferLen = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+216], 0

; 1197 : 
; 1198 :     if (!bStopping)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+176]
	test	ecx, ecx
	jne	SHORT $LN4@FatalSocke

; 1199 :     {
; 1200 :         if (AppConfig->GetInt(TEXT("Publish"), TEXT("ExperimentalReconnectMode")) == 1 && AppConfig->GetInt(TEXT("Publish"), TEXT("Delay")) == 0)

	push	0
	push	OFFSET $SG4294776881
	push	OFFSET $SG4294776880
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	cmp	eax, 1
	jne	SHORT $LN2@FatalSocke
	push	0
	push	OFFSET $SG4294776879
	push	OFFSET $SG4294776878
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	test	eax, eax
	jne	SHORT $LN2@FatalSocke

; 1201 :             App->NetworkFailed();

	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?NetworkFailed@OBS@@QAEXXZ		; OBS::NetworkFailed

; 1202 :         else

	jmp	SHORT $LN4@FatalSocke
$LN2@FatalSocke:

; 1203 :             App->PostStopMessage();

	push	0
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?PostStopMessage@OBS@@QAEX_N@Z		; OBS::PostStopMessage
$LN4@FatalSocke:

; 1204 :     }
; 1205 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FatalSocketShutdown@RTMPPublisher@@IAEXXZ ENDP		; RTMPPublisher::FatalSocketShutdown
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\rtmppublisher.cpp
;	COMDAT ?SocketLoop@RTMPPublisher@@IAEXXZ
_TEXT	SEGMENT
_bufferSize$1 = -16528					; size = 4
_sendLength$2 = -16524					; size = 4
_curTCPBufSize$3 = -16520				; size = 4
_diff$4 = -16516					; size = 4
_curTCPBufSizeSize$5 = -16512				; size = 4
tv279 = -16508						; size = 4
_errorCode$6 = -16504					; size = 4
_ret$7 = -16500						; size = 4
_diff$8 = -16496					; size = 4
_fatalError$9 = -16492					; size = 4
_fatalError$10 = -16488					; size = 4
_errorCode$11 = -16484					; size = 4
_idealSendBacklog$12 = -16480				; size = 4
_latencyPacketSize$ = -16476				; size = 4
_delayTime$ = -16472					; size = 4
_status$13 = -16468					; size = 4
_lastSendTime$ = -16464					; size = 4
_exitLoop$14 = -16457					; size = 1
_ret$15 = -16456					; size = 4
_canWrite$ = -16449					; size = 1
_this$ = -16448						; size = 4
_networkEvents$ = -16444				; size = 44
_hObjects$ = -16400					; size = 12
_discard$16 = -16388					; size = 16384
__$ArrayPad$ = -4					; size = 4
?SocketLoop@RTMPPublisher@@IAEXXZ PROC			; RTMPPublisher::SocketLoop, COMDAT
; _this$ = ecx

; 1208 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 16528				; 00004090H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1209 :     bool canWrite = false;

	mov	BYTE PTR _canWrite$[ebp], 0

; 1210 : 
; 1211 :     int delayTime;
; 1212 :     int latencyPacketSize;
; 1213 :     DWORD lastSendTime = 0;

	mov	DWORD PTR _lastSendTime$[ebp], 0

; 1214 : 
; 1215 :     WSANETWORKEVENTS networkEvents;
; 1216 : 
; 1217 :     SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);

	push	1
	call	DWORD PTR __imp__GetCurrentThread@0
	push	eax
	call	DWORD PTR __imp__SetThreadPriority@8

; 1218 : 
; 1219 :     WSAEventSelect(rtmp->m_sb.sb_socket, hWriteEvent, FD_READ|FD_WRITE|FD_CLOSE);

	push	35					; 00000023H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+120]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	ecx, DWORD PTR [eax+384]
	push	ecx
	call	DWORD PTR __imp__WSAEventSelect@12

; 1220 : 
; 1221 :     //Low latency mode works by delaying delayTime ms between calls to send() and only sending
; 1222 :     //a buffer as large as latencyPacketSize at once. This causes keyframes and other data bursts
; 1223 :     //to be sent over several sends instead of one large one.
; 1224 :     if (lowLatencyMode == LL_MODE_AUTO)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+220], 2
	jne	SHORT $LN53@SocketLoop

; 1225 :     {
; 1226 :         //Auto mode aims for a constant rate of whatever the stream bitrate is and segments into
; 1227 :         //MTU sized packets (test packet captures indicated that despite nagling being enabled,
; 1228 :         //the size of the send() buffer is still important for some reason). Note that delays
; 1229 :         //become very short at this rate, and it can take a while for the buffer to empty after
; 1230 :         //a keyframe.
; 1231 :         delayTime = 1400.0f / (dataBufferSize / 1000.0f);

	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+212]
	divss	xmm0, DWORD PTR __real@447a0000
	movss	xmm1, DWORD PTR __real@44af0000
	divss	xmm1, xmm0
	cvttss2si ecx, xmm1
	mov	DWORD PTR _delayTime$[ebp], ecx

; 1232 :         latencyPacketSize = 1460;

	mov	DWORD PTR _latencyPacketSize$[ebp], 1460 ; 000005b4H
	jmp	SHORT $LN50@SocketLoop
$LN53@SocketLoop:

; 1233 :     }
; 1234 :     else if (lowLatencyMode == LL_MODE_FIXED)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+220], 1
	jne	SHORT $LN51@SocketLoop

; 1235 :     {
; 1236 :         //We use latencyFactor - 2 to guarantee we're always sending at a slightly higher
; 1237 :         //rate than the maximum expected data rate so we don't get backed up
; 1238 :         latencyPacketSize = dataBufferSize / (latencyFactor - 2);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+224]
	sub	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+212]
	cdq
	idiv	ecx
	mov	DWORD PTR _latencyPacketSize$[ebp], eax

; 1239 :         delayTime = 1000 / latencyFactor;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, 1000				; 000003e8H
	cdq
	idiv	DWORD PTR [ecx+224]
	mov	DWORD PTR _delayTime$[ebp], eax

; 1240 :     }
; 1241 :     else

	jmp	SHORT $LN50@SocketLoop
$LN51@SocketLoop:

; 1242 :     {
; 1243 :         latencyPacketSize = dataBufferSize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+212]
	mov	DWORD PTR _latencyPacketSize$[ebp], eax

; 1244 :         delayTime = 0;

	mov	DWORD PTR _delayTime$[ebp], 0
$LN50@SocketLoop:

; 1245 :     }
; 1246 : 
; 1247 :     if (AppConfig->GetInt (TEXT("Publish"), TEXT("DisableSendWindowOptimization"), 0) == 0)

	push	0
	push	OFFSET $SG4294776877
	push	OFFSET $SG4294776876
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	test	eax, eax
	jne	SHORT $LN49@SocketLoop

; 1248 :         SetupSendBacklogEvent ();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetupSendBacklogEvent@RTMPPublisher@@IAEXXZ ; RTMPPublisher::SetupSendBacklogEvent

; 1249 :     else

	jmp	SHORT $LN48@SocketLoop
$LN49@SocketLoop:

; 1250 :         Log (TEXT("RTMPPublisher::SocketLoop: Send window optimization disabled by user."));

	push	OFFSET $SG4294776875
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 4
$LN48@SocketLoop:

; 1251 : 
; 1252 :     HANDLE hObjects[3];
; 1253 : 
; 1254 :     hObjects[0] = hWriteEvent;

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+120]
	mov	DWORD PTR _hObjects$[ebp+edx], ecx

; 1255 :     hObjects[1] = hBufferEvent;

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+124]
	mov	DWORD PTR _hObjects$[ebp+edx], ecx

; 1256 :     hObjects[2] = hSendBacklogEvent;

	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	mov	DWORD PTR _hObjects$[ebp+edx], ecx
$LN58@SocketLoop:

; 1257 : 
; 1258 :     for (;;)
; 1259 :     {
; 1260 :         if (bStopping && WaitForSingleObject(hSocketLoopExit, 0) != WAIT_TIMEOUT)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+176]
	test	eax, eax
	je	SHORT $LN45@SocketLoop
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+148]
	push	edx
	call	DWORD PTR __imp__WaitForSingleObject@8
	cmp	eax, 258				; 00000102H
	je	SHORT $LN45@SocketLoop

; 1261 :         {
; 1262 :             OSEnterMutex(hDataBufferMutex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+132]
	push	ecx
	call	DWORD PTR __imp_?OSEnterMutex@@YGXPAX@Z

; 1263 :             if (curDataBufferLen == 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+216], 0
	jne	SHORT $LN44@SocketLoop

; 1264 :             {
; 1265 :                 //OSDebugOut (TEXT("Exiting on empty buffer.\n"));
; 1266 :                 OSLeaveMutex(hDataBufferMutex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+132]
	push	ecx
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z

; 1267 :                 break;

	jmp	$LN46@SocketLoop
$LN44@SocketLoop:

; 1268 :             }
; 1269 : 
; 1270 :             //OSDebugOut (TEXT("Want to exit, but %d bytes remain.\n"), curDataBufferLen);
; 1271 :             OSLeaveMutex(hDataBufferMutex);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+132]
	push	eax
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z
$LN45@SocketLoop:

; 1272 :         }
; 1273 : 
; 1274 :         int status = WaitForMultipleObjects (3, hObjects, FALSE, INFINITE);

	push	-1
	push	0
	lea	ecx, DWORD PTR _hObjects$[ebp]
	push	ecx
	push	3
	call	DWORD PTR __imp__WaitForMultipleObjects@16
	mov	DWORD PTR _status$13[ebp], eax

; 1275 :         if (status == WAIT_ABANDONED || status == WAIT_FAILED)

	cmp	DWORD PTR _status$13[ebp], 128		; 00000080H
	je	SHORT $LN42@SocketLoop
	cmp	DWORD PTR _status$13[ebp], -1
	jne	SHORT $LN43@SocketLoop
$LN42@SocketLoop:

; 1276 :         {
; 1277 :             Log(TEXT("RTMPPublisher::SocketLoop: Aborting due to WaitForMultipleObjects failure"));

	push	OFFSET $SG4294776874
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 4

; 1278 :             App->PostStopMessage();

	push	0
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?PostStopMessage@OBS@@QAEX_N@Z		; OBS::PostStopMessage

; 1279 :             return;

	jmp	$LN54@SocketLoop
$LN43@SocketLoop:

; 1280 :         }
; 1281 : 
; 1282 :         if (status == WAIT_OBJECT_0)

	cmp	DWORD PTR _status$13[ebp], 0
	jne	$LN41@SocketLoop

; 1283 :         {
; 1284 :             //Socket event
; 1285 :             if (WSAEnumNetworkEvents (rtmp->m_sb.sb_socket, NULL, &networkEvents))

	lea	edx, DWORD PTR _networkEvents$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR [ecx+384]
	push	edx
	call	DWORD PTR __imp__WSAEnumNetworkEvents@12
	test	eax, eax
	je	SHORT $LN40@SocketLoop

; 1286 :             {
; 1287 :                 Log(TEXT("RTMPPublisher::SocketLoop: Aborting due to WSAEnumNetworkEvents failure, %d"), WSAGetLastError());

	call	DWORD PTR __imp__WSAGetLastError@0
	push	eax
	push	OFFSET $SG4294776873
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8

; 1288 :                 App->PostStopMessage();

	push	0
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?PostStopMessage@OBS@@QAEX_N@Z		; OBS::PostStopMessage

; 1289 :                 return;

	jmp	$LN54@SocketLoop
$LN40@SocketLoop:

; 1290 :             }
; 1291 : 
; 1292 :             if (networkEvents.lNetworkEvents & FD_WRITE)

	mov	eax, DWORD PTR _networkEvents$[ebp]
	and	eax, 2
	je	SHORT $LN39@SocketLoop

; 1293 :                 canWrite = true;

	mov	BYTE PTR _canWrite$[ebp], 1
$LN39@SocketLoop:

; 1294 : 
; 1295 :             if (networkEvents.lNetworkEvents & FD_CLOSE)

	mov	ecx, DWORD PTR _networkEvents$[ebp]
	and	ecx, 32					; 00000020H
	je	$LN38@SocketLoop

; 1296 :             {
; 1297 :                 if (lastSendTime)

	cmp	DWORD PTR _lastSendTime$[ebp], 0
	je	SHORT $LN37@SocketLoop

; 1298 :                 {
; 1299 :                     DWORD diff = OSGetTime() - lastSendTime;

	call	DWORD PTR __imp_?OSGetTime@@YGKXZ
	sub	eax, DWORD PTR _lastSendTime$[ebp]
	mov	DWORD PTR _diff$4[ebp], eax

; 1300 :                     Log(TEXT("RTMPPublisher::SocketLoop: Received FD_CLOSE, %u ms since last send (buffer: %d / %d)"), diff, curDataBufferLen, dataBufferSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+212]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+216]
	push	edx
	mov	eax, DWORD PTR _diff$4[ebp]
	push	eax
	push	OFFSET $SG4294776872
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 16					; 00000010H
$LN37@SocketLoop:

; 1301 :                 }
; 1302 : 
; 1303 :                 if (bStopping)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+176]
	test	edx, edx
	je	SHORT $LN36@SocketLoop

; 1304 :                     Log(TEXT("RTMPPublisher::SocketLoop: Aborting due to FD_CLOSE during shutdown, %d bytes lost, error %d"), curDataBufferLen, networkEvents.iErrorCode[FD_CLOSE_BIT]);

	mov	eax, 4
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _networkEvents$[ebp+ecx+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+216]
	push	ecx
	push	OFFSET $SG4294776871
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 12					; 0000000cH

; 1305 :                 else

	jmp	SHORT $LN35@SocketLoop
$LN36@SocketLoop:

; 1306 :                     Log(TEXT("RTMPPublisher::SocketLoop: Aborting due to FD_CLOSE, error %d"), networkEvents.iErrorCode[FD_CLOSE_BIT]);

	mov	edx, 4
	imul	eax, edx, 5
	mov	ecx, DWORD PTR _networkEvents$[ebp+eax+4]
	push	ecx
	push	OFFSET $SG4294776870
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8
$LN35@SocketLoop:

; 1307 :                 FatalSocketShutdown ();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FatalSocketShutdown@RTMPPublisher@@IAEXXZ ; RTMPPublisher::FatalSocketShutdown

; 1308 :                 return;

	jmp	$LN54@SocketLoop
$LN38@SocketLoop:

; 1309 :             }
; 1310 : 
; 1311 :             if (networkEvents.lNetworkEvents & FD_READ)

	mov	edx, DWORD PTR _networkEvents$[ebp]
	and	edx, 1
	je	$LN32@SocketLoop

; 1312 :             {
; 1313 :                 BYTE discard[16384];
; 1314 :                 int ret, errorCode;
; 1315 :                 BOOL fatalError = FALSE;

	mov	DWORD PTR _fatalError$10[ebp], 0
$LN33@SocketLoop:

; 1316 : 
; 1317 :                 for (;;)
; 1318 :                 {
; 1319 :                     ret = recv(rtmp->m_sb.sb_socket, (char *)discard, sizeof(discard), 0);

	push	0
	push	16384					; 00004000H
	lea	eax, DWORD PTR _discard$16[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	eax, DWORD PTR [edx+384]
	push	eax
	call	DWORD PTR __imp__recv@16
	mov	DWORD PTR _ret$7[ebp], eax

; 1320 :                     if (ret == -1)

	cmp	DWORD PTR _ret$7[ebp], -1
	jne	SHORT $LN31@SocketLoop

; 1321 :                     {
; 1322 :                         errorCode = WSAGetLastError();

	call	DWORD PTR __imp__WSAGetLastError@0
	mov	DWORD PTR _errorCode$6[ebp], eax

; 1323 : 
; 1324 :                         if (errorCode == WSAEWOULDBLOCK)

	cmp	DWORD PTR _errorCode$6[ebp], 10035	; 00002733H
	jne	SHORT $LN30@SocketLoop

; 1325 :                             break;

	jmp	SHORT $LN32@SocketLoop
$LN30@SocketLoop:

; 1326 : 
; 1327 :                         fatalError = TRUE;

	mov	DWORD PTR _fatalError$10[ebp], 1
	jmp	SHORT $LN28@SocketLoop
$LN31@SocketLoop:

; 1328 :                     }
; 1329 :                     else if (ret == 0)

	cmp	DWORD PTR _ret$7[ebp], 0
	jne	SHORT $LN28@SocketLoop

; 1330 :                     {
; 1331 :                         errorCode = 0;

	mov	DWORD PTR _errorCode$6[ebp], 0

; 1332 :                         fatalError = TRUE;

	mov	DWORD PTR _fatalError$10[ebp], 1
$LN28@SocketLoop:

; 1333 :                     }
; 1334 : 
; 1335 :                     if (fatalError)

	cmp	DWORD PTR _fatalError$10[ebp], 0
	je	SHORT $LN27@SocketLoop

; 1336 :                     {
; 1337 :                         Log(TEXT("RTMPPublisher::SocketLoop: Socket error, recv() returned %d, GetLastError() %d"), ret, errorCode);

	mov	ecx, DWORD PTR _errorCode$6[ebp]
	push	ecx
	mov	edx, DWORD PTR _ret$7[ebp]
	push	edx
	push	OFFSET $SG4294776869
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 12					; 0000000cH

; 1338 :                         FatalSocketShutdown ();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FatalSocketShutdown@RTMPPublisher@@IAEXXZ ; RTMPPublisher::FatalSocketShutdown

; 1339 :                         return;

	jmp	$LN54@SocketLoop
$LN27@SocketLoop:

; 1340 :                     }
; 1341 :                 }

	jmp	$LN33@SocketLoop
$LN32@SocketLoop:

; 1342 :             }
; 1343 :         }

	jmp	$LN25@SocketLoop
$LN41@SocketLoop:

; 1344 :         else if (status == WAIT_OBJECT_0 + 2)

	cmp	DWORD PTR _status$13[ebp], 2
	jne	$LN25@SocketLoop

; 1345 :         {
; 1346 :             //Ideal send backlog event
; 1347 :             ULONG idealSendBacklog;
; 1348 : 
; 1349 :             if (!idealsendbacklogquery(rtmp->m_sb.sb_socket, &idealSendBacklog))

	lea	eax, DWORD PTR _idealSendBacklog$12[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	eax, DWORD PTR [edx+384]
	push	eax
	call	_idealsendbacklogquery
	add	esp, 8
	test	eax, eax
	jne	$LN24@SocketLoop

; 1350 :             {
; 1351 :                 int curTCPBufSize, curTCPBufSizeSize = sizeof(curTCPBufSize);

	mov	DWORD PTR _curTCPBufSizeSize$5[ebp], 4

; 1352 :                 if (!getsockopt(rtmp->m_sb.sb_socket, SOL_SOCKET, SO_SNDBUF, (char *)&curTCPBufSize, &curTCPBufSizeSize))

	lea	ecx, DWORD PTR _curTCPBufSizeSize$5[ebp]
	push	ecx
	lea	edx, DWORD PTR _curTCPBufSize$3[ebp]
	push	edx
	push	4097					; 00001001H
	push	65535					; 0000ffffH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR [ecx+384]
	push	edx
	call	DWORD PTR __imp__getsockopt@20
	test	eax, eax
	jne	SHORT $LN23@SocketLoop

; 1353 :                 {
; 1354 :                     if (curTCPBufSize < (int)idealSendBacklog)

	mov	eax, DWORD PTR _curTCPBufSize$3[ebp]
	cmp	eax, DWORD PTR _idealSendBacklog$12[ebp]
	jge	SHORT $LN22@SocketLoop

; 1355 :                     {
; 1356 :                         int bufferSize = (int)idealSendBacklog;

	mov	ecx, DWORD PTR _idealSendBacklog$12[ebp]
	mov	DWORD PTR _bufferSize$1[ebp], ecx

; 1357 :                         setsockopt(rtmp->m_sb.sb_socket, SOL_SOCKET, SO_SNDBUF, (const char *)&bufferSize, sizeof(bufferSize));

	push	4
	lea	edx, DWORD PTR _bufferSize$1[ebp]
	push	edx
	push	4097					; 00001001H
	push	65535					; 0000ffffH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR [ecx+384]
	push	edx
	call	DWORD PTR __imp__setsockopt@20

; 1358 :                         Log(TEXT("RTMPPublisher::SocketLoop: Increasing send buffer to ISB %d (buffer: %d / %d)"), idealSendBacklog, curDataBufferLen, dataBufferSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+212]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+216]
	push	eax
	mov	ecx, DWORD PTR _idealSendBacklog$12[ebp]
	push	ecx
	push	OFFSET $SG4294776868
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 16					; 00000010H
$LN22@SocketLoop:

; 1359 :                     }
; 1360 :                 }
; 1361 :                 else

	jmp	SHORT $LN21@SocketLoop
$LN23@SocketLoop:

; 1362 :                     Log(TEXT("RTMPPublisher::SocketLoop: Got hSendBacklogEvent but getsockopt() returned %d"), WSAGetLastError());

	call	DWORD PTR __imp__WSAGetLastError@0
	push	eax
	push	OFFSET $SG4294776867
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8
$LN21@SocketLoop:

; 1363 :             }
; 1364 :             else

	jmp	SHORT $LN20@SocketLoop
$LN24@SocketLoop:

; 1365 :                 Log(TEXT("RTMPPublisher::SocketLoop: Got hSendBacklogEvent but WSAIoctl() returned %d"), WSAGetLastError());

	call	DWORD PTR __imp__WSAGetLastError@0
	push	eax
	push	OFFSET $SG4294776866
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8
$LN20@SocketLoop:

; 1366 : 
; 1367 :             SetupSendBacklogEvent ();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetupSendBacklogEvent@RTMPPublisher@@IAEXXZ ; RTMPPublisher::SetupSendBacklogEvent

; 1368 :             continue;

	jmp	$LN58@SocketLoop
$LN25@SocketLoop:

; 1369 :         }
; 1370 :         
; 1371 :         if (canWrite)

	movzx	edx, BYTE PTR _canWrite$[ebp]
	test	edx, edx
	je	$LN16@SocketLoop

; 1372 :         {
; 1373 :             bool exitLoop = false;

	mov	BYTE PTR _exitLoop$14[ebp], 0
$LN18@SocketLoop:

; 1374 :             do
; 1375 :             {
; 1376 :                 OSEnterMutex(hDataBufferMutex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+132]
	push	ecx
	call	DWORD PTR __imp_?OSEnterMutex@@YGXPAX@Z

; 1377 : 
; 1378 :                 if (!curDataBufferLen)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+216], 0
	jne	SHORT $LN15@SocketLoop

; 1379 :                 {
; 1380 :                     //this is now an expected occasional condition due to use of auto-reset events, we could end up emptying the buffer
; 1381 :                     //as it's filled in a previous loop cycle, especially if using low latency mode.
; 1382 :                     OSLeaveMutex(hDataBufferMutex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+132]
	push	ecx
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z

; 1383 :                     //Log(TEXT("RTMPPublisher::SocketLoop: Trying to send, but no data available?!"));
; 1384 :                     break;

	jmp	$LN16@SocketLoop
$LN15@SocketLoop:

; 1385 :                 }
; 1386 :                 
; 1387 :                 int ret;
; 1388 :                 if (lowLatencyMode != LL_MODE_NONE)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+220], 0
	je	SHORT $LN14@SocketLoop

; 1389 :                 {
; 1390 :                     int sendLength = min (latencyPacketSize, curDataBufferLen);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _latencyPacketSize$[ebp]
	cmp	ecx, DWORD PTR [eax+216]
	jge	SHORT $LN56@SocketLoop
	mov	edx, DWORD PTR _latencyPacketSize$[ebp]
	mov	DWORD PTR tv279[ebp], edx
	jmp	SHORT $LN57@SocketLoop
$LN56@SocketLoop:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+216]
	mov	DWORD PTR tv279[ebp], ecx
$LN57@SocketLoop:
	mov	edx, DWORD PTR tv279[ebp]
	mov	DWORD PTR _sendLength$2[ebp], edx

; 1391 :                     ret = send(rtmp->m_sb.sb_socket, (const char *)dataBuffer, sendLength, 0);

	push	0
	mov	eax, DWORD PTR _sendLength$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+208]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR [ecx+384]
	push	edx
	call	DWORD PTR __imp__send@16
	mov	DWORD PTR _ret$15[ebp], eax

; 1392 :                 }
; 1393 :                 else

	jmp	SHORT $LN13@SocketLoop
$LN14@SocketLoop:

; 1394 :                 {
; 1395 :                     ret = send(rtmp->m_sb.sb_socket, (const char *)dataBuffer, curDataBufferLen, 0);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+216]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+208]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	eax, DWORD PTR [edx+384]
	push	eax
	call	DWORD PTR __imp__send@16
	mov	DWORD PTR _ret$15[ebp], eax
$LN13@SocketLoop:

; 1396 :                 }
; 1397 : 
; 1398 :                 if (ret > 0)

	cmp	DWORD PTR _ret$15[ebp], 0
	jle	$LN12@SocketLoop

; 1399 :                 {
; 1400 :                     if (curDataBufferLen - ret)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+216]
	sub	edx, DWORD PTR _ret$15[ebp]
	je	SHORT $LN11@SocketLoop

; 1401 :                         memmove(dataBuffer, dataBuffer + ret, curDataBufferLen - ret);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+216]
	sub	ecx, DWORD PTR _ret$15[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+208]
	add	eax, DWORD PTR _ret$15[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+208]
	push	edx
	call	_memmove
	add	esp, 12					; 0000000cH
$LN11@SocketLoop:

; 1402 :                     curDataBufferLen -= ret;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+216]
	sub	ecx, DWORD PTR _ret$15[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+216], ecx

; 1403 : 
; 1404 :                     bytesSent += ret;

	mov	eax, DWORD PTR _ret$15[ebp]
	cdq
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+184]
	adc	edx, DWORD PTR [ecx+188]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+184], eax
	mov	DWORD PTR [ecx+188], edx

; 1405 : 
; 1406 :                     if (lastSendTime)

	cmp	DWORD PTR _lastSendTime$[ebp], 0
	je	$LN10@SocketLoop

; 1407 :                     {
; 1408 :                         DWORD diff = OSGetTime() - lastSendTime;

	call	DWORD PTR __imp_?OSGetTime@@YGKXZ
	sub	eax, DWORD PTR _lastSendTime$[ebp]
	mov	DWORD PTR _diff$8[ebp], eax

; 1409 : 
; 1410 :                         if (diff >= 1500)

	cmp	DWORD PTR _diff$8[ebp], 1500		; 000005dcH
	jb	SHORT $LN9@SocketLoop

; 1411 :                             Log(TEXT("RTMPPublisher::SocketLoop: Stalled for %u ms to write %d bytes (buffer: %d / %d), unstable connection?"), diff, ret, curDataBufferLen, dataBufferSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+212]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+216]
	push	edx
	mov	eax, DWORD PTR _ret$15[ebp]
	push	eax
	mov	ecx, DWORD PTR _diff$8[ebp]
	push	ecx
	push	OFFSET $SG4294776865
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 20					; 00000014H
$LN9@SocketLoop:

; 1412 : 
; 1413 :                         totalSendPeriod += diff;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+248]
	add	eax, DWORD PTR _diff$8[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+248], eax

; 1414 :                         totalSendBytes += ret;

	mov	eax, DWORD PTR _ret$15[ebp]
	cdq
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+240]
	adc	edx, DWORD PTR [ecx+244]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+240], eax
	mov	DWORD PTR [ecx+244], edx

; 1415 :                         totalSendCount++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+252]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+252], eax
$LN10@SocketLoop:

; 1416 :                     }
; 1417 : 
; 1418 :                     lastSendTime = OSGetTime();

	call	DWORD PTR __imp_?OSGetTime@@YGKXZ
	mov	DWORD PTR _lastSendTime$[ebp], eax

; 1419 : 
; 1420 :                     SetEvent(hBufferSpaceAvailableEvent);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+128]
	push	eax
	call	DWORD PTR __imp__SetEvent@4

; 1421 :                 }
; 1422 :                 else

	jmp	$LN3@SocketLoop
$LN12@SocketLoop:

; 1423 :                 {
; 1424 :                     int errorCode;
; 1425 :                     BOOL fatalError = FALSE;

	mov	DWORD PTR _fatalError$9[ebp], 0

; 1426 : 
; 1427 :                     if (ret == -1)

	cmp	DWORD PTR _ret$15[ebp], -1
	jne	SHORT $LN7@SocketLoop

; 1428 :                     {
; 1429 :                         errorCode = WSAGetLastError();

	call	DWORD PTR __imp__WSAGetLastError@0
	mov	DWORD PTR _errorCode$11[ebp], eax

; 1430 : 
; 1431 :                         if (errorCode == WSAEWOULDBLOCK)

	cmp	DWORD PTR _errorCode$11[ebp], 10035	; 00002733H
	jne	SHORT $LN6@SocketLoop

; 1432 :                         {
; 1433 :                             canWrite = false;

	mov	BYTE PTR _canWrite$[ebp], 0

; 1434 :                             OSLeaveMutex(hDataBufferMutex);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+132]
	push	edx
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z

; 1435 :                             break;

	jmp	$LN16@SocketLoop
$LN6@SocketLoop:

; 1436 :                         }
; 1437 : 
; 1438 :                         fatalError = TRUE;

	mov	DWORD PTR _fatalError$9[ebp], 1
	jmp	SHORT $LN4@SocketLoop
$LN7@SocketLoop:

; 1439 :                     }
; 1440 :                     else if (ret == 0)

	cmp	DWORD PTR _ret$15[ebp], 0
	jne	SHORT $LN4@SocketLoop

; 1441 :                     {
; 1442 :                         errorCode = 0;

	mov	DWORD PTR _errorCode$11[ebp], 0

; 1443 :                         fatalError = TRUE;

	mov	DWORD PTR _fatalError$9[ebp], 1
$LN4@SocketLoop:

; 1444 :                     }
; 1445 : 
; 1446 :                     if (fatalError)

	cmp	DWORD PTR _fatalError$9[ebp], 0
	je	SHORT $LN3@SocketLoop

; 1447 :                     {
; 1448 :                         //connection closed, or connection was aborted / socket closed / etc, that's a fatal error for us.
; 1449 :                         Log(TEXT("RTMPPublisher::SocketLoop: Socket error, send() returned %d, GetLastError() %d"), ret, errorCode);

	mov	eax, DWORD PTR _errorCode$11[ebp]
	push	eax
	mov	ecx, DWORD PTR _ret$15[ebp]
	push	ecx
	push	OFFSET $SG4294776864
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 12					; 0000000cH

; 1450 :                         OSLeaveMutex(hDataBufferMutex);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+132]
	push	eax
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z

; 1451 :                         FatalSocketShutdown ();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FatalSocketShutdown@RTMPPublisher@@IAEXXZ ; RTMPPublisher::FatalSocketShutdown

; 1452 :                         return;

	jmp	SHORT $LN54@SocketLoop
$LN3@SocketLoop:

; 1453 :                     }
; 1454 :                 }
; 1455 : 
; 1456 :                 //finish writing for now
; 1457 :                 if (curDataBufferLen <= 1000)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+216], 1000		; 000003e8H
	jg	SHORT $LN2@SocketLoop

; 1458 :                     exitLoop = true;

	mov	BYTE PTR _exitLoop$14[ebp], 1
$LN2@SocketLoop:

; 1459 : 
; 1460 :                 OSLeaveMutex(hDataBufferMutex);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+132]
	push	eax
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z

; 1461 : 
; 1462 :                 if (delayTime)

	cmp	DWORD PTR _delayTime$[ebp], 0
	je	SHORT $LN1@SocketLoop

; 1463 :                     Sleep (delayTime);

	mov	ecx, DWORD PTR _delayTime$[ebp]
	push	ecx
	call	DWORD PTR __imp__Sleep@4
$LN1@SocketLoop:

; 1464 :             } while (!exitLoop);

	movzx	edx, BYTE PTR _exitLoop$14[ebp]
	test	edx, edx
	je	$LN18@SocketLoop
$LN16@SocketLoop:

; 1465 :         }
; 1466 :     }

	jmp	$LN58@SocketLoop
$LN46@SocketLoop:

; 1467 : 
; 1468 :     Log(TEXT("RTMPPublisher::SocketLoop: Graceful loop exit"));

	push	OFFSET $SG4294776863
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 4
$LN54@SocketLoop:

; 1469 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?SocketLoop@RTMPPublisher@@IAEXXZ ENDP			; RTMPPublisher::SocketLoop
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\rtmppublisher.cpp
;	COMDAT ?SendLoop@RTMPPublisher@@IAEXXZ
_TEXT	SEGMENT
_packet$1 = -60						; size = 32
_packetData$2 = -28					; size = 8
_timestamp$3 = -20					; size = 4
tv146 = -16						; size = 4
_type$4 = -12						; size = 4
tv144 = -8						; size = 4
_this$ = -4						; size = 4
?SendLoop@RTMPPublisher@@IAEXXZ PROC			; RTMPPublisher::SendLoop, COMDAT
; _this$ = ecx

; 1472 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	DWORD PTR _this$[ebp], ecx

; 1473 :     SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);

	push	1
	call	DWORD PTR __imp__GetCurrentThread@0
	push	eax
	call	DWORD PTR __imp__SetThreadPriority@8
$LN9@SendLoop:

; 1474 :     while(WaitForSingleObject(hSendSempahore, INFINITE) == WAIT_OBJECT_0)

	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	push	ecx
	call	DWORD PTR __imp__WaitForSingleObject@8
	test	eax, eax
	jne	$LN10@SendLoop
$LN7@SendLoop:

; 1475 :     {
; 1476 :         while(true)

	mov	edx, 1
	test	edx, edx
	je	$LN6@SendLoop

; 1477 :         {
; 1478 :             OSEnterMutex(hDataMutex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	push	ecx
	call	DWORD PTR __imp_?OSEnterMutex@@YGXPAX@Z

; 1479 :             if(queuedPackets.Num() == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	?Num@?$List@UNetworkPacket@@@@QBEIXZ	; List<NetworkPacket>::Num
	test	eax, eax
	jne	SHORT $LN5@SendLoop

; 1480 :             {
; 1481 :                 OSLeaveMutex(hDataMutex);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+108]
	push	eax
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z

; 1482 :                 break;

	jmp	$LN6@SendLoop
$LN5@SendLoop:

; 1483 :             }
; 1484 : 
; 1485 :             List<BYTE> packetData;

	lea	ecx, DWORD PTR _packetData$2[ebp]
	call	??0?$List@E@@QAE@XZ			; List<unsigned char>::List<unsigned char>

; 1486 :             PacketType type       = queuedPackets[0].type;

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	??A?$List@UNetworkPacket@@@@QAEAAUNetworkPacket@@I@Z ; List<NetworkPacket>::operator[]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _type$4[ebp], ecx

; 1487 :             DWORD      timestamp  = queuedPackets[0].timestamp;

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	??A?$List@UNetworkPacket@@@@QAEAAUNetworkPacket@@I@Z ; List<NetworkPacket>::operator[]
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _timestamp$3[ebp], edx

; 1488 :             packetData.TransferFrom(queuedPackets[0].data);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	??A?$List@UNetworkPacket@@@@QAEAAUNetworkPacket@@I@Z ; List<NetworkPacket>::operator[]
	push	eax
	lea	ecx, DWORD PTR _packetData$2[ebp]
	call	?TransferFrom@?$List@E@@QAEXAAV1@@Z	; List<unsigned char>::TransferFrom

; 1489 : 
; 1490 :             currentBufferSize -= packetData.Num();

	lea	ecx, DWORD PTR _packetData$2[ebp]
	call	?Num@?$List@E@@QBEIXZ			; List<unsigned char>::Num
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	sub	edx, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+92], edx

; 1491 : 
; 1492 :             queuedPackets.Remove(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	?Remove@?$List@UNetworkPacket@@@@QAEXI@Z ; List<NetworkPacket>::Remove

; 1493 : 
; 1494 :             OSLeaveMutex(hDataMutex);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z

; 1495 : 
; 1496 :             //--------------------------------------------
; 1497 : 
; 1498 :             RTMPPacket packet;
; 1499 :             packet.m_nChannel = (type == PacketType_Audio) ? 0x5 : 0x4;

	cmp	DWORD PTR _type$4[ebp], 4
	jne	SHORT $LN12@SendLoop
	mov	DWORD PTR tv144[ebp], 5
	jmp	SHORT $LN13@SendLoop
$LN12@SendLoop:
	mov	DWORD PTR tv144[ebp], 4
$LN13@SendLoop:
	mov	eax, DWORD PTR tv144[ebp]
	mov	DWORD PTR _packet$1[ebp+4], eax

; 1500 :             packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;

	mov	BYTE PTR _packet$1[ebp], 1

; 1501 :             packet.m_packetType = (type == PacketType_Audio) ? RTMP_PACKET_TYPE_AUDIO : RTMP_PACKET_TYPE_VIDEO;

	cmp	DWORD PTR _type$4[ebp], 4
	jne	SHORT $LN14@SendLoop
	mov	DWORD PTR tv146[ebp], 8
	jmp	SHORT $LN15@SendLoop
$LN14@SendLoop:
	mov	DWORD PTR tv146[ebp], 9
$LN15@SendLoop:
	mov	cl, BYTE PTR tv146[ebp]
	mov	BYTE PTR _packet$1[ebp+1], cl

; 1502 :             packet.m_nTimeStamp = timestamp;

	mov	edx, DWORD PTR _timestamp$3[ebp]
	mov	DWORD PTR _packet$1[ebp+8], edx

; 1503 :             packet.m_nInfoField2 = rtmp->m_stream_id;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _packet$1[ebp+12], edx

; 1504 :             packet.m_hasAbsTimestamp = TRUE;

	mov	BYTE PTR _packet$1[ebp+2], 1

; 1505 : 
; 1506 :             packet.m_nBodySize = packetData.Num()-RTMP_MAX_HEADER_SIZE;

	lea	ecx, DWORD PTR _packetData$2[ebp]
	call	?Num@?$List@E@@QBEIXZ			; List<unsigned char>::Num
	sub	eax, 18					; 00000012H
	mov	DWORD PTR _packet$1[ebp+16], eax

; 1507 :             packet.m_body = (char*)packetData.Array()+RTMP_MAX_HEADER_SIZE;

	lea	ecx, DWORD PTR _packetData$2[ebp]
	call	?Array@?$List@E@@QBEPAEXZ		; List<unsigned char>::Array
	add	eax, 18					; 00000012H
	mov	DWORD PTR _packet$1[ebp+28], eax

; 1508 : 
; 1509 :             //QWORD sendTimeStart = OSGetTimeMicroseconds();
; 1510 :             if(!RTMP_SendPacket(rtmp, &packet, FALSE))

	push	0
	lea	edx, DWORD PTR _packet$1[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	call	_RTMP_SendPacket
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN4@SendLoop

; 1511 :             {
; 1512 :                 //should never reach here with the new shutdown sequence.
; 1513 :                 RUNONCE Log(TEXT("RTMP_SendPacket failure, should not happen!"));

	movzx	ecx, BYTE PTR ?bRunOnce@?M@??SendLoop@RTMPPublisher@@IAEXXZ@4_NA
	test	ecx, ecx
	jne	SHORT $LN3@SendLoop
	mov	BYTE PTR ?bRunOnce@?M@??SendLoop@RTMPPublisher@@IAEXXZ@4_NA, 1
	movzx	edx, BYTE PTR ?bRunOnce@?M@??SendLoop@RTMPPublisher@@IAEXXZ@4_NA
	test	edx, edx
	je	SHORT $LN3@SendLoop
	push	OFFSET $SG4294776862
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 4
$LN3@SendLoop:

; 1514 :                 if(!RTMP_IsConnected(rtmp))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	call	_RTMP_IsConnected
	test	eax, eax
	jne	SHORT $LN4@SendLoop

; 1515 :                 {
; 1516 :                     App->PostStopMessage();

	push	0
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?PostStopMessage@OBS@@QAEX_N@Z		; OBS::PostStopMessage

; 1517 :                     break;

	lea	ecx, DWORD PTR _packetData$2[ebp]
	call	??1?$List@E@@QAE@XZ			; List<unsigned char>::~List<unsigned char>
	jmp	SHORT $LN6@SendLoop
$LN4@SendLoop:

; 1518 :                 }
; 1519 :             }
; 1520 : 
; 1521 :             //----------------------------------------------------------
; 1522 : 
; 1523 :             /*outputRateSize += packetData.Num();
; 1524 :             packetSizeRecord << PacketTimeSize(timestamp, packetData.Num());
; 1525 :             if(packetSizeRecord.Num())
; 1526 :             {
; 1527 :                 UINT packetID=0;
; 1528 :                 for(; packetID<packetSizeRecord.Num(); packetID++)
; 1529 :                 {
; 1530 :                     if(timestamp-packetSizeRecord[packetID].timestamp < outputRateWindowTime)
; 1531 :                         break;
; 1532 :                     else
; 1533 :                         outputRateSize -= packetSizeRecord[packetID].size;
; 1534 :                 }
; 1535 : 
; 1536 :                 if(packetID != 0)
; 1537 :                     packetSizeRecord.RemoveRange(0, packetID);
; 1538 :             }*/
; 1539 : 
; 1540 :             //bytesSent += packetData.Num();
; 1541 :         }

	lea	ecx, DWORD PTR _packetData$2[ebp]
	call	??1?$List@E@@QAE@XZ			; List<unsigned char>::~List<unsigned char>
	jmp	$LN7@SendLoop
$LN6@SendLoop:

; 1542 : 
; 1543 :         if (bStopping && WaitForSingleObject(hSendLoopExit, 0) == WAIT_OBJECT_0)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+176]
	test	edx, edx
	je	SHORT $LN1@SendLoop
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	push	ecx
	call	DWORD PTR __imp__WaitForSingleObject@8
	test	eax, eax
	jne	SHORT $LN1@SendLoop

; 1544 :             return;

	jmp	SHORT $LN10@SendLoop
$LN1@SendLoop:

; 1545 :     }

	jmp	$LN9@SendLoop
$LN10@SendLoop:

; 1546 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SendLoop@RTMPPublisher@@IAEXXZ ENDP			; RTMPPublisher::SendLoop
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\rtmppublisher.cpp
;	COMDAT ?SendThread@RTMPPublisher@@KAKPAV1@@Z
_TEXT	SEGMENT
_publisher$ = 8						; size = 4
?SendThread@RTMPPublisher@@KAKPAV1@@Z PROC		; RTMPPublisher::SendThread, COMDAT

; 1549 : {

	push	ebp
	mov	ebp, esp

; 1550 :     publisher->SendLoop();

	mov	ecx, DWORD PTR _publisher$[ebp]
	call	?SendLoop@RTMPPublisher@@IAEXXZ		; RTMPPublisher::SendLoop

; 1551 :     return 0;

	xor	eax, eax

; 1552 : }

	pop	ebp
	ret	0
?SendThread@RTMPPublisher@@KAKPAV1@@Z ENDP		; RTMPPublisher::SendThread
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\rtmppublisher.cpp
;	COMDAT ?SocketThread@RTMPPublisher@@KAKPAV1@@Z
_TEXT	SEGMENT
_publisher$ = 8						; size = 4
?SocketThread@RTMPPublisher@@KAKPAV1@@Z PROC		; RTMPPublisher::SocketThread, COMDAT

; 1555 : {

	push	ebp
	mov	ebp, esp

; 1556 :     publisher->SocketLoop();

	mov	ecx, DWORD PTR _publisher$[ebp]
	call	?SocketLoop@RTMPPublisher@@IAEXXZ	; RTMPPublisher::SocketLoop

; 1557 :     return 0;

	xor	eax, eax

; 1558 : }

	pop	ebp
	ret	0
?SocketThread@RTMPPublisher@@KAKPAV1@@Z ENDP		; RTMPPublisher::SocketThread
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\rtmppublisher.cpp
;	COMDAT ?DropFrame@RTMPPublisher@@IAEXI@Z
_TEXT	SEGMENT
tv178 = -44						; size = 4
_distance$1 = -40					; size = 4
_distance$2 = -36					; size = 4
_dropPacket$ = -32					; size = 4
_type$ = -28						; size = 4
_packet$3 = -24						; size = 4
_i$4 = -20						; size = 4
_i$5 = -16						; size = 4
_i$6 = -12						; size = 4
_this$ = -8						; size = 4
_bSetPriority$ = -1					; size = 1
_id$ = 8						; size = 4
?DropFrame@RTMPPublisher@@IAEXI@Z PROC			; RTMPPublisher::DropFrame, COMDAT
; _this$ = ecx

; 1561 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1562 :     NetworkPacket &dropPacket = queuedPackets[id];

	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	??A?$List@UNetworkPacket@@@@QAEAAUNetworkPacket@@I@Z ; List<NetworkPacket>::operator[]
	mov	DWORD PTR _dropPacket$[ebp], eax

; 1563 :     currentBufferSize -= dropPacket.data.Num();

	mov	ecx, DWORD PTR _dropPacket$[ebp]
	call	?Num@?$List@E@@QBEIXZ			; List<unsigned char>::Num
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	sub	edx, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+92], edx

; 1564 :     PacketType type = dropPacket.type;

	mov	ecx, DWORD PTR _dropPacket$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _type$[ebp], edx

; 1565 :     dropPacket.data.Clear();

	mov	ecx, DWORD PTR _dropPacket$[ebp]
	call	?Clear@?$List@E@@QAEXXZ			; List<unsigned char>::Clear

; 1566 : 
; 1567 :     if(dropPacket.type < PacketType_VideoHigh)

	mov	eax, DWORD PTR _dropPacket$[ebp]
	cmp	DWORD PTR [eax+12], 2
	jge	SHORT $LN25@DropFrame

; 1568 :         numBFramesDumped++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+204]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+204], edx

; 1569 :     else

	jmp	SHORT $LN24@DropFrame
$LN25@DropFrame:

; 1570 :         numPFramesDumped++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+200]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+200], edx
$LN24@DropFrame:

; 1571 : 
; 1572 :     for(UINT i=id+1; i<queuedPackets.Num(); i++)

	mov	ecx, DWORD PTR _id$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$5[ebp], ecx
	jmp	SHORT $LN23@DropFrame
$LN22@DropFrame:
	mov	edx, DWORD PTR _i$5[ebp]
	add	edx, 1
	mov	DWORD PTR _i$5[ebp], edx
$LN23@DropFrame:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	?Num@?$List@UNetworkPacket@@@@QBEIXZ	; List<NetworkPacket>::Num
	cmp	DWORD PTR _i$5[ebp], eax
	jae	SHORT $LN21@DropFrame

; 1573 :     {
; 1574 :         UINT distance = (i-id);

	mov	eax, DWORD PTR _i$5[ebp]
	sub	eax, DWORD PTR _id$[ebp]
	mov	DWORD PTR _distance$2[ebp], eax

; 1575 :         if(queuedPackets[i].distanceFromDroppedFrame <= distance)

	mov	ecx, DWORD PTR _i$5[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	??A?$List@UNetworkPacket@@@@QAEAAUNetworkPacket@@I@Z ; List<NetworkPacket>::operator[]
	mov	edx, DWORD PTR [eax+16]
	cmp	edx, DWORD PTR _distance$2[ebp]
	ja	SHORT $LN20@DropFrame

; 1576 :             break;

	jmp	SHORT $LN21@DropFrame
$LN20@DropFrame:

; 1577 : 
; 1578 :         queuedPackets[i].distanceFromDroppedFrame = distance;

	mov	eax, DWORD PTR _i$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	??A?$List@UNetworkPacket@@@@QAEAAUNetworkPacket@@I@Z ; List<NetworkPacket>::operator[]
	mov	ecx, DWORD PTR _distance$2[ebp]
	mov	DWORD PTR [eax+16], ecx

; 1579 :     }

	jmp	SHORT $LN22@DropFrame
$LN21@DropFrame:

; 1580 : 
; 1581 :     for(int i=int(id)-1; i>=0; i--)

	mov	edx, DWORD PTR _id$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$4[ebp], edx
	jmp	SHORT $LN19@DropFrame
$LN18@DropFrame:
	mov	eax, DWORD PTR _i$4[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$4[ebp], eax
$LN19@DropFrame:
	cmp	DWORD PTR _i$4[ebp], 0
	jl	SHORT $LN17@DropFrame

; 1582 :     {
; 1583 :         UINT distance = (id-UINT(i));

	mov	ecx, DWORD PTR _id$[ebp]
	sub	ecx, DWORD PTR _i$4[ebp]
	mov	DWORD PTR _distance$1[ebp], ecx

; 1584 :         if(queuedPackets[i].distanceFromDroppedFrame <= distance)

	mov	edx, DWORD PTR _i$4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	??A?$List@UNetworkPacket@@@@QAEAAUNetworkPacket@@I@Z ; List<NetworkPacket>::operator[]
	mov	eax, DWORD PTR [eax+16]
	cmp	eax, DWORD PTR _distance$1[ebp]
	ja	SHORT $LN16@DropFrame

; 1585 :             break;

	jmp	SHORT $LN17@DropFrame
$LN16@DropFrame:

; 1586 : 
; 1587 :         queuedPackets[i].distanceFromDroppedFrame = distance;

	mov	ecx, DWORD PTR _i$4[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	??A?$List@UNetworkPacket@@@@QAEAAUNetworkPacket@@I@Z ; List<NetworkPacket>::operator[]
	mov	edx, DWORD PTR _distance$1[ebp]
	mov	DWORD PTR [eax+16], edx

; 1588 :     }

	jmp	SHORT $LN18@DropFrame
$LN17@DropFrame:

; 1589 : 
; 1590 :     bool bSetPriority = true;

	mov	BYTE PTR _bSetPriority$[ebp], 1

; 1591 :     for(UINT i=id+1; i<queuedPackets.Num(); i++)

	mov	eax, DWORD PTR _id$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$6[ebp], eax
	jmp	SHORT $LN15@DropFrame
$LN14@DropFrame:
	mov	ecx, DWORD PTR _i$6[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$6[ebp], ecx
$LN15@DropFrame:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	?Num@?$List@UNetworkPacket@@@@QBEIXZ	; List<NetworkPacket>::Num
	cmp	DWORD PTR _i$6[ebp], eax
	jae	$LN13@DropFrame

; 1592 :     {
; 1593 :         NetworkPacket &packet = queuedPackets[i];

	mov	edx, DWORD PTR _i$6[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	??A?$List@UNetworkPacket@@@@QAEAAUNetworkPacket@@I@Z ; List<NetworkPacket>::operator[]
	mov	DWORD PTR _packet$3[ebp], eax

; 1594 :         if(packet.type < PacketType_Audio)

	mov	eax, DWORD PTR _packet$3[ebp]
	cmp	DWORD PTR [eax+12], 4
	jge	$LN12@DropFrame

; 1595 :         {
; 1596 :             if(type >= PacketType_VideoHigh)

	cmp	DWORD PTR _type$[ebp], 2
	jl	$LN11@DropFrame

; 1597 :             {
; 1598 :                 if(packet.type < PacketType_VideoHighest)

	mov	ecx, DWORD PTR _packet$3[ebp]
	cmp	DWORD PTR [ecx+12], 3
	jge	SHORT $LN10@DropFrame

; 1599 :                 {
; 1600 :                     currentBufferSize -= packet.data.Num();

	mov	ecx, DWORD PTR _packet$3[ebp]
	call	?Num@?$List@E@@QBEIXZ			; List<unsigned char>::Num
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+92]
	sub	ecx, eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+92], ecx

; 1601 :                     packet.data.Clear();

	mov	ecx, DWORD PTR _packet$3[ebp]
	call	?Clear@?$List@E@@QAEXXZ			; List<unsigned char>::Clear

; 1602 :                     queuedPackets.Remove(i--);

	mov	eax, DWORD PTR _i$6[ebp]
	mov	DWORD PTR tv178[ebp], eax
	mov	ecx, DWORD PTR tv178[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	?Remove@?$List@UNetworkPacket@@@@QAEXI@Z ; List<NetworkPacket>::Remove
	mov	edx, DWORD PTR _i$6[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$6[ebp], edx

; 1603 : 
; 1604 :                     if(packet.type < PacketType_VideoHigh)

	mov	eax, DWORD PTR _packet$3[ebp]
	cmp	DWORD PTR [eax+12], 2
	jge	SHORT $LN9@DropFrame

; 1605 :                         numBFramesDumped++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+204]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+204], edx

; 1606 :                     else

	jmp	SHORT $LN8@DropFrame
$LN9@DropFrame:

; 1607 :                         numPFramesDumped++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+200]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+200], edx
$LN8@DropFrame:

; 1608 :                 }
; 1609 :                 else

	jmp	SHORT $LN7@DropFrame
$LN10@DropFrame:

; 1610 :                 {
; 1611 :                     bSetPriority = false;

	mov	BYTE PTR _bSetPriority$[ebp], 0

; 1612 :                     break;

	jmp	SHORT $LN13@DropFrame
$LN7@DropFrame:

; 1613 :                 }
; 1614 :             }
; 1615 :             else

	jmp	SHORT $LN12@DropFrame
$LN11@DropFrame:

; 1616 :             {
; 1617 :                 if(packet.type >= type)

	mov	ecx, DWORD PTR _packet$3[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cmp	edx, DWORD PTR _type$[ebp]
	jl	SHORT $LN12@DropFrame

; 1618 :                 {
; 1619 :                     bSetPriority = false;

	mov	BYTE PTR _bSetPriority$[ebp], 0

; 1620 :                     break;

	jmp	SHORT $LN13@DropFrame
$LN12@DropFrame:

; 1621 :                 }
; 1622 :             }
; 1623 :         }
; 1624 :     }

	jmp	$LN14@DropFrame
$LN13@DropFrame:

; 1625 : 
; 1626 :     if(bSetPriority)

	movzx	eax, BYTE PTR _bSetPriority$[ebp]
	test	eax, eax
	je	SHORT $LN26@DropFrame

; 1627 :     {
; 1628 :         if(type >= PacketType_VideoHigh)

	cmp	DWORD PTR _type$[ebp], 2
	jl	SHORT $LN3@DropFrame

; 1629 :             packetWaitType = PacketType_VideoHighest;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+180], 3

; 1630 :         else

	jmp	SHORT $LN26@DropFrame
$LN3@DropFrame:

; 1631 :         {
; 1632 :             if(packetWaitType < type)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+180]
	cmp	eax, DWORD PTR _type$[ebp]
	jge	SHORT $LN26@DropFrame

; 1633 :                 packetWaitType = type;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _type$[ebp]
	mov	DWORD PTR [ecx+180], edx
$LN26@DropFrame:

; 1634 :         }
; 1635 :     }
; 1636 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?DropFrame@RTMPPublisher@@IAEXI@Z ENDP			; RTMPPublisher::DropFrame
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\rtmppublisher.cpp
;	COMDAT ?DoIFrameDelay@RTMPPublisher@@IAE_N_N@Z
_TEXT	SEGMENT
_bestPacketDistance$1 = -36				; size = 4
_packet$2 = -32						; size = 4
_packet$3 = -28						; size = 4
_i$4 = -24						; size = 4
_this$ = -20						; size = 4
_i$5 = -16						; size = 4
_curWaitType$ = -12					; size = 4
_bestPacket$6 = -8					; size = 4
_bFoundIFrame$7 = -1					; size = 1
_bBFramesOnly$ = 8					; size = 1
?DoIFrameDelay@RTMPPublisher@@IAE_N_N@Z PROC		; RTMPPublisher::DoIFrameDelay, COMDAT
; _this$ = ecx

; 1640 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 1641 :     int curWaitType = PacketType_VideoDisposable;

	mov	DWORD PTR _curWaitType$[ebp], 0
$LN22@DoIFrameDe:

; 1642 : 
; 1643 :     while(!bBFramesOnly && curWaitType < PacketType_VideoHighest ||
; 1644 :            bBFramesOnly && curWaitType < PacketType_VideoHigh)

	movzx	eax, BYTE PTR _bBFramesOnly$[ebp]
	test	eax, eax
	jne	SHORT $LN19@DoIFrameDe
	cmp	DWORD PTR _curWaitType$[ebp], 3
	jl	SHORT $LN20@DoIFrameDe
$LN19@DoIFrameDe:
	movzx	ecx, BYTE PTR _bBFramesOnly$[ebp]
	test	ecx, ecx
	je	$LN21@DoIFrameDe
	cmp	DWORD PTR _curWaitType$[ebp], 2
	jge	$LN21@DoIFrameDe
$LN20@DoIFrameDe:

; 1645 :     {
; 1646 :         UINT bestPacket = INVALID;

	mov	DWORD PTR _bestPacket$6[ebp], -1

; 1647 :         UINT bestPacketDistance = 0;

	mov	DWORD PTR _bestPacketDistance$1[ebp], 0

; 1648 : 
; 1649 :         if(curWaitType == PacketType_VideoHigh)

	cmp	DWORD PTR _curWaitType$[ebp], 2
	jne	SHORT $LN18@DoIFrameDe

; 1650 :         {
; 1651 :             bool bFoundIFrame = false;

	mov	BYTE PTR _bFoundIFrame$7[ebp], 0

; 1652 : 
; 1653 :             for(int i=int(queuedPackets.Num())-1; i>=0; i--)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	?Num@?$List@UNetworkPacket@@@@QBEIXZ	; List<NetworkPacket>::Num
	sub	eax, 1
	mov	DWORD PTR _i$5[ebp], eax
	jmp	SHORT $LN17@DoIFrameDe
$LN16@DoIFrameDe:
	mov	edx, DWORD PTR _i$5[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$5[ebp], edx
$LN17@DoIFrameDe:
	cmp	DWORD PTR _i$5[ebp], 0
	jl	SHORT $LN15@DoIFrameDe

; 1654 :             {
; 1655 :                 NetworkPacket &packet = queuedPackets[i];

	mov	eax, DWORD PTR _i$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	??A?$List@UNetworkPacket@@@@QAEAAUNetworkPacket@@I@Z ; List<NetworkPacket>::operator[]
	mov	DWORD PTR _packet$3[ebp], eax

; 1656 :                 if(packet.type == PacketType_Audio)

	mov	ecx, DWORD PTR _packet$3[ebp]
	cmp	DWORD PTR [ecx+12], 4
	jne	SHORT $LN14@DoIFrameDe

; 1657 :                     continue;

	jmp	SHORT $LN16@DoIFrameDe
$LN14@DoIFrameDe:

; 1658 : 
; 1659 :                 if(packet.type == curWaitType)

	mov	edx, DWORD PTR _packet$3[ebp]
	mov	eax, DWORD PTR [edx+12]
	cmp	eax, DWORD PTR _curWaitType$[ebp]
	jne	SHORT $LN13@DoIFrameDe

; 1660 :                 {
; 1661 :                     if(bFoundIFrame)

	movzx	ecx, BYTE PTR _bFoundIFrame$7[ebp]
	test	ecx, ecx
	je	SHORT $LN12@DoIFrameDe

; 1662 :                     {
; 1663 :                         bestPacket = UINT(i);

	mov	edx, DWORD PTR _i$5[ebp]
	mov	DWORD PTR _bestPacket$6[ebp], edx

; 1664 :                         break;

	jmp	SHORT $LN15@DoIFrameDe
	jmp	SHORT $LN11@DoIFrameDe
$LN12@DoIFrameDe:

; 1665 :                     }
; 1666 :                     else if(bestPacket == INVALID)

	cmp	DWORD PTR _bestPacket$6[ebp], -1
	jne	SHORT $LN11@DoIFrameDe

; 1667 :                         bestPacket = UINT(i);

	mov	eax, DWORD PTR _i$5[ebp]
	mov	DWORD PTR _bestPacket$6[ebp], eax
$LN11@DoIFrameDe:

; 1668 :                 }

	jmp	SHORT $LN9@DoIFrameDe
$LN13@DoIFrameDe:

; 1669 :                 else if(packet.type == PacketType_VideoHighest)

	mov	ecx, DWORD PTR _packet$3[ebp]
	cmp	DWORD PTR [ecx+12], 3
	jne	SHORT $LN9@DoIFrameDe

; 1670 :                     bFoundIFrame = true;

	mov	BYTE PTR _bFoundIFrame$7[ebp], 1
$LN9@DoIFrameDe:

; 1671 :             }

	jmp	SHORT $LN16@DoIFrameDe
$LN15@DoIFrameDe:

; 1672 :         }
; 1673 :         else

	jmp	SHORT $LN7@DoIFrameDe
$LN18@DoIFrameDe:

; 1674 :         {
; 1675 :             for(UINT i=0; i<queuedPackets.Num(); i++)

	mov	DWORD PTR _i$4[ebp], 0
	jmp	SHORT $LN6@DoIFrameDe
$LN5@DoIFrameDe:
	mov	edx, DWORD PTR _i$4[ebp]
	add	edx, 1
	mov	DWORD PTR _i$4[ebp], edx
$LN6@DoIFrameDe:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	?Num@?$List@UNetworkPacket@@@@QBEIXZ	; List<NetworkPacket>::Num
	cmp	DWORD PTR _i$4[ebp], eax
	jae	SHORT $LN7@DoIFrameDe

; 1676 :             {
; 1677 :                 NetworkPacket &packet = queuedPackets[i];

	mov	eax, DWORD PTR _i$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	??A?$List@UNetworkPacket@@@@QAEAAUNetworkPacket@@I@Z ; List<NetworkPacket>::operator[]
	mov	DWORD PTR _packet$2[ebp], eax

; 1678 :                 if(packet.type <= curWaitType)

	mov	ecx, DWORD PTR _packet$2[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cmp	edx, DWORD PTR _curWaitType$[ebp]
	jg	SHORT $LN3@DoIFrameDe

; 1679 :                 {
; 1680 :                     if(packet.distanceFromDroppedFrame > bestPacketDistance)

	mov	eax, DWORD PTR _packet$2[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR _bestPacketDistance$1[ebp]
	jbe	SHORT $LN3@DoIFrameDe

; 1681 :                     {
; 1682 :                         bestPacket = i;

	mov	edx, DWORD PTR _i$4[ebp]
	mov	DWORD PTR _bestPacket$6[ebp], edx

; 1683 :                         bestPacketDistance = packet.distanceFromDroppedFrame;

	mov	eax, DWORD PTR _packet$2[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _bestPacketDistance$1[ebp], ecx
$LN3@DoIFrameDe:

; 1684 :                     }
; 1685 :                 }
; 1686 :             }

	jmp	SHORT $LN5@DoIFrameDe
$LN7@DoIFrameDe:

; 1687 :         }
; 1688 : 
; 1689 :         if(bestPacket != INVALID)

	cmp	DWORD PTR _bestPacket$6[ebp], -1
	je	SHORT $LN1@DoIFrameDe

; 1690 :         {
; 1691 :             DropFrame(bestPacket);

	mov	edx, DWORD PTR _bestPacket$6[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DropFrame@RTMPPublisher@@IAEXI@Z	; RTMPPublisher::DropFrame

; 1692 :             queuedPackets.Remove(bestPacket);

	mov	eax, DWORD PTR _bestPacket$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	?Remove@?$List@UNetworkPacket@@@@QAEXI@Z ; List<NetworkPacket>::Remove

; 1693 :             return true;

	mov	al, 1
	jmp	SHORT $LN23@DoIFrameDe
$LN1@DoIFrameDe:

; 1694 :         }
; 1695 : 
; 1696 :         curWaitType++;

	mov	ecx, DWORD PTR _curWaitType$[ebp]
	add	ecx, 1
	mov	DWORD PTR _curWaitType$[ebp], ecx

; 1697 :     }

	jmp	$LN22@DoIFrameDe
$LN21@DoIFrameDe:

; 1698 : 
; 1699 :     return false;

	xor	al, al
$LN23@DoIFrameDe:

; 1700 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?DoIFrameDelay@RTMPPublisher@@IAE_N_N@Z ENDP		; RTMPPublisher::DoIFrameDelay
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\rtmppublisher.cpp
;	COMDAT ?RequestKeyframe@RTMPPublisher@@MAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_waitTime$ = 8						; size = 4
?RequestKeyframe@RTMPPublisher@@MAEXH@Z PROC		; RTMPPublisher::RequestKeyframe, COMDAT
; _this$ = ecx

; 1703 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1704 :     App->RequestKeyframe(waitTime);

	mov	eax, DWORD PTR _waitTime$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?RequestKeyframe@OBS@@QAEXH@Z		; OBS::RequestKeyframe

; 1705 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?RequestKeyframe@RTMPPublisher@@MAEXH@Z ENDP		; RTMPPublisher::RequestKeyframe
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\rtmppublisher.cpp
;	COMDAT ?BufferedSend@RTMPPublisher@@CAHPAURTMPSockBuf@@PBDHPAV1@@Z
_TEXT	SEGMENT
_status$1 = -4						; size = 4
_sb$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_network$ = 20						; size = 4
?BufferedSend@RTMPPublisher@@CAHPAURTMPSockBuf@@PBDHPAV1@@Z PROC ; RTMPPublisher::BufferedSend, COMDAT

; 1708 : {

	push	ebp
	mov	ebp, esp
	push	ecx
$retrySend$7:

; 1709 :     //NOTE: This function is called from the SendLoop thread, be careful of race conditions.
; 1710 : 
; 1711 : retrySend:
; 1712 : 
; 1713 :     //We may have been disconnected mid-shutdown or something, just pretend we wrote the data
; 1714 :     //to avoid blocking if the socket loop exited.
; 1715 :     if (!RTMP_IsConnected(network->rtmp))

	mov	eax, DWORD PTR _network$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	call	_RTMP_IsConnected
	test	eax, eax
	jne	SHORT $LN4@BufferedSe

; 1716 :         return len;

	mov	eax, DWORD PTR _len$[ebp]
	jmp	$LN5@BufferedSe
$LN4@BufferedSe:

; 1717 : 
; 1718 :     OSEnterMutex(network->hDataBufferMutex);

	mov	ecx, DWORD PTR _network$[ebp]
	mov	edx, DWORD PTR [ecx+132]
	push	edx
	call	DWORD PTR __imp_?OSEnterMutex@@YGXPAX@Z

; 1719 : 
; 1720 :     if (network->curDataBufferLen + len >= network->dataBufferSize)

	mov	eax, DWORD PTR _network$[ebp]
	mov	ecx, DWORD PTR [eax+216]
	add	ecx, DWORD PTR _len$[ebp]
	mov	edx, DWORD PTR _network$[ebp]
	cmp	ecx, DWORD PTR [edx+212]
	jl	SHORT $LN3@BufferedSe

; 1721 :     {
; 1722 :         //Log(TEXT("RTMPPublisher::BufferedSend: Socket buffer is full (%d / %d bytes), waiting to send %d bytes"), network->curDataBufferLen, network->dataBufferSize, len);
; 1723 :         ++network->totalTimesWaited;

	mov	eax, DWORD PTR _network$[ebp]
	mov	ecx, DWORD PTR [eax+228]
	add	ecx, 1
	mov	edx, DWORD PTR _network$[ebp]
	mov	DWORD PTR [edx+228], ecx

; 1724 :         network->totalBytesWaited += len;

	mov	eax, DWORD PTR _network$[ebp]
	mov	ecx, DWORD PTR [eax+232]
	add	ecx, DWORD PTR _len$[ebp]
	mov	edx, DWORD PTR _network$[ebp]
	mov	DWORD PTR [edx+232], ecx

; 1725 : 
; 1726 :         OSLeaveMutex(network->hDataBufferMutex);

	mov	eax, DWORD PTR _network$[ebp]
	mov	ecx, DWORD PTR [eax+132]
	push	ecx
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z

; 1727 : 
; 1728 :         int status = WaitForSingleObject(network->hBufferSpaceAvailableEvent, INFINITE);

	push	-1
	mov	edx, DWORD PTR _network$[ebp]
	mov	eax, DWORD PTR [edx+128]
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
	mov	DWORD PTR _status$1[ebp], eax

; 1729 :         if (status == WAIT_ABANDONED || status == WAIT_FAILED)

	cmp	DWORD PTR _status$1[ebp], 128		; 00000080H
	je	SHORT $LN1@BufferedSe
	cmp	DWORD PTR _status$1[ebp], -1
	jne	SHORT $LN2@BufferedSe
$LN1@BufferedSe:

; 1730 :             return 0;

	xor	eax, eax
	jmp	SHORT $LN5@BufferedSe
$LN2@BufferedSe:

; 1731 :         goto retrySend;

	jmp	$retrySend$7
$LN3@BufferedSe:

; 1732 :     }
; 1733 : 
; 1734 :     mcpy(network->dataBuffer + network->curDataBufferLen, buf, len);

	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	mov	eax, DWORD PTR _network$[ebp]
	mov	ecx, DWORD PTR [eax+208]
	mov	edx, DWORD PTR _network$[ebp]
	add	ecx, DWORD PTR [edx+216]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1735 :     network->curDataBufferLen += len;

	mov	eax, DWORD PTR _network$[ebp]
	mov	ecx, DWORD PTR [eax+216]
	add	ecx, DWORD PTR _len$[ebp]
	mov	edx, DWORD PTR _network$[ebp]
	mov	DWORD PTR [edx+216], ecx

; 1736 : 
; 1737 :     OSLeaveMutex(network->hDataBufferMutex);

	mov	eax, DWORD PTR _network$[ebp]
	mov	ecx, DWORD PTR [eax+132]
	push	ecx
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z

; 1738 : 
; 1739 :     SetEvent (network->hBufferEvent);

	mov	edx, DWORD PTR _network$[ebp]
	mov	eax, DWORD PTR [edx+124]
	push	eax
	call	DWORD PTR __imp__SetEvent@4

; 1740 : 
; 1741 :     return len;

	mov	eax, DWORD PTR _len$[ebp]
$LN5@BufferedSe:

; 1742 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?BufferedSend@RTMPPublisher@@CAHPAURTMPSockBuf@@PBDHPAV1@@Z ENDP ; RTMPPublisher::BufferedSend
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?TransferFrom@?$List@E@@QAEXAAV1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_list$ = 8						; size = 4
?TransferFrom@?$List@E@@QAEXAAV1@@Z PROC		; List<unsigned char>::TransferFrom, COMDAT
; _this$ = ecx

; 307  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 308  :         if(array) Clear();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@TransferFr
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@E@@QAEXXZ			; List<unsigned char>::Clear
$LN1@TransferFr:

; 309  :         array = list.Array();

	mov	ecx, DWORD PTR _list$[ebp]
	call	?Array@?$List@E@@QBEPAEXZ		; List<unsigned char>::Array
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 310  :         num   = list.Num();

	mov	ecx, DWORD PTR _list$[ebp]
	call	?Num@?$List@E@@QBEIXZ			; List<unsigned char>::Num
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax

; 311  :         zero(&list, sizeof(List<T>));

	push	8
	mov	eax, DWORD PTR _list$[ebp]
	push	eax
	call	?zero@@YGXPAXI@Z			; zero

; 312  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?TransferFrom@?$List@E@@QAEXAAV1@@Z ENDP		; List<unsigned char>::TransferFrom
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ?resize@?$vector@DV?$allocator@D@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Alval$2 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
?resize@?$vector@DV?$allocator@D@std@@@std@@QAEXI@Z PROC ; std::vector<char,std::allocator<char> >::resize, COMDAT
; _this$ = ecx

; 1100 : 		{	// determine new length, padding as needed

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?resize@?$vector@DV?$allocator@D@std@@@std@@QAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1101 : 		if (_Newsize < size())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	cmp	DWORD PTR __Newsize$[ebp], eax
	jae	SHORT $LN4@resize

; 1102 : 			_Pop_back_n(size() - _Newsize);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	sub	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Pop_back_n@?$vector@DV?$allocator@D@std@@@std@@QAEXI@Z ; std::vector<char,std::allocator<char> >::_Pop_back_n
	jmp	$LN6@resize
$LN4@resize:

; 1103 : 		else if (size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	$LN6@resize

; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());

	lea	eax, DWORD PTR __Alval$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char> > >::_Getal

; 1106 : 			_Reserve(_Newsize - size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	mov	ecx, DWORD PTR __Newsize$[ebp]
	sub	ecx, eax
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reserve@?$vector@DV?$allocator@D@std@@@std@@IAEXI@Z ; std::vector<char,std::allocator<char> >::_Reserve

; 1107 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);

	lea	edx, DWORD PTR __Alval$2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	mov	ecx, DWORD PTR __Newsize$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	??$_Uninitialized_default_fill_n@PADIU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXPADIAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z ; std::_Uninitialized_default_fill_n<char *,unsigned int,std::_Wrap_alloc<std::allocator<char> > >
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN7@resize
__catch$?resize@?$vector@DV?$allocator@D@std@@@std@@QAEXI@Z$0:

; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@DV?$allocator@D@std@@@std@@IAEXXZ ; std::vector<char,std::allocator<char> >::_Tidy

; 1112 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1113 : 			_CATCH_END

	mov	eax, $LN10@resize
	ret	0
$LN7@resize:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?resize@?$vector@DV?$allocator@D@std@@@std@@QAEXI@Z$1
$LN10@resize:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?resize@?$vector@DV?$allocator@D@std@@@std@@QAEXI@Z$1:

; 1114 : 			this->_Mylast += _Newsize - size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	mov	ecx, DWORD PTR __Newsize$[ebp]
	sub	ecx, eax
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], ecx
$LN6@resize:

; 1115 : 			}
; 1116 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?resize@?$vector@DV?$allocator@D@std@@@std@@QAEXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?resize@?$vector@DV?$allocator@D@std@@@std@@QAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?resize@?$vector@DV?$allocator@D@std@@@std@@QAEXI@Z ENDP ; std::vector<char,std::allocator<char> >::resize
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ?data@?$vector@DV?$allocator@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?data@?$vector@DV?$allocator@D@std@@@std@@QAEPADXZ PROC	; std::vector<char,std::allocator<char> >::data, COMDAT
; _this$ = ecx

; 1213 : 		{	// return address of first element

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1214 : 		return (this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 1215 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?data@?$vector@DV?$allocator@D@std@@@std@@QAEPADXZ ENDP	; std::vector<char,std::allocator<char> >::data
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??0?$List@UTimedPacket@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$List@UTimedPacket@@@@QAE@XZ PROC			; List<TimedPacket>::List<TimedPacket>, COMDAT
; _this$ = ecx

; 35   :     inline List() : array(NULL), num(0) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@UTimedPacket@@@@QAE@XZ ENDP			; List<TimedPacket>::List<TimedPacket>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??1?$List@UTimedPacket@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$List@UTimedPacket@@@@QAE@XZ PROC			; List<TimedPacket>::~List<TimedPacket>, COMDAT
; _this$ = ecx

; 37   :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 38   :         Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@UTimedPacket@@@@QAEXXZ	; List<TimedPacket>::Clear

; 39   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@UTimedPacket@@@@QAE@XZ ENDP			; List<TimedPacket>::~List<TimedPacket>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Num@?$List@UTimedPacket@@@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Num@?$List@UTimedPacket@@@@QBEIXZ PROC			; List<TimedPacket>::Num, COMDAT
; _this$ = ecx

; 42   :     inline unsigned int Num() const     {return num;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?Num@?$List@UTimedPacket@@@@QBEIXZ ENDP			; List<TimedPacket>::Num
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Remove@?$List@UTimedPacket@@@@QAEXI@Z
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?Remove@?$List@UTimedPacket@@@@QAEXI@Z PROC		; List<TimedPacket>::Remove, COMDAT
; _this$ = ecx

; 88   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 89   :         assert(index < num);
; 90   :         if(index >= num) return;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN2@Remove
	jmp	$LN3@Remove
$LN2@Remove:

; 91   : 
; 92   :         if(!--num) {Free(array); array=NULL; return;}

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	mov	DWORD PTR tv68[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv68[ebp]
	mov	DWORD PTR [ecx+4], edx
	cmp	DWORD PTR tv68[ebp], 0
	jne	SHORT $LN1@Remove
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 0
	jmp	SHORT $LN3@Remove
$LN1@Remove:

; 93   : 
; 94   :         mcpy(&array[index], &array[index+1], sizeof(T)*(num-index));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR _index$[ebp]
	shl	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _index$[ebp]
	add	edx, 1
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _index$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 95   : 
; 96   :         array = (T*)ReAllocate(array, sizeof(T)*num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$LN3@Remove:

; 97   :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?Remove@?$List@UTimedPacket@@@@QAEXI@Z ENDP		; List<TimedPacket>::Remove
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?MoveItem@?$List@UTimedPacket@@@@QAEXHH@Z
_TEXT	SEGMENT
_val$ = -24						; size = 16
_last$ = -8						; size = 4
_this$ = -4						; size = 4
_id$ = 8						; size = 4
_newID$ = 12						; size = 4
?MoveItem@?$List@UTimedPacket@@@@QAEXHH@Z PROC		; List<TimedPacket>::MoveItem, COMDAT
; _this$ = ecx

; 227  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 228  :         register int last = num-1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	mov	DWORD PTR _last$[ebp], ecx

; 229  : 
; 230  :         assert(id <= last);
; 231  :         if(newID == id || id > last || newID > last)

	mov	edx, DWORD PTR _newID$[ebp]
	cmp	edx, DWORD PTR _id$[ebp]
	je	SHORT $LN4@MoveItem
	mov	eax, DWORD PTR _id$[ebp]
	cmp	eax, DWORD PTR _last$[ebp]
	jg	SHORT $LN4@MoveItem
	mov	ecx, DWORD PTR _newID$[ebp]
	cmp	ecx, DWORD PTR _last$[ebp]
	jle	SHORT $LN5@MoveItem
$LN4@MoveItem:

; 232  :             return;

	jmp	$LN6@MoveItem
$LN5@MoveItem:

; 233  : 
; 234  :         T val;

	lea	ecx, DWORD PTR _val$[ebp]
	call	??0TimedPacket@@QAE@XZ

; 235  :         mcpy(&val, array+id, sizeof(T));

	mov	edx, DWORD PTR _id$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _val$[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _val$[ebp+4], eax
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _val$[ebp+8], edx
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR _val$[ebp+12], eax

; 236  :         if(newID < id)

	mov	ecx, DWORD PTR _newID$[ebp]
	cmp	ecx, DWORD PTR _id$[ebp]
	jge	SHORT $LN3@MoveItem

; 237  :             mcpyrev(array+newID+1, array+newID, (id-newID)*sizeof(T));

	mov	edx, DWORD PTR _id$[ebp]
	sub	edx, DWORD PTR _newID$[ebp]
	shl	edx, 4
	push	edx
	mov	eax, DWORD PTR _newID$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR _newID$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx+edx+16]
	push	edx
	call	?mcpyrev@@YGXPAXPBXI@Z			; mcpyrev
	jmp	SHORT $LN2@MoveItem
$LN3@MoveItem:

; 238  :         else if(id < newID)

	mov	eax, DWORD PTR _id$[ebp]
	cmp	eax, DWORD PTR _newID$[ebp]
	jge	SHORT $LN2@MoveItem

; 239  :             mcpy(array+id, array+id+1, (newID-id)*sizeof(T));

	mov	ecx, DWORD PTR _newID$[ebp]
	sub	ecx, DWORD PTR _id$[ebp]
	shl	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _id$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx+edx+16]
	push	edx
	mov	eax, DWORD PTR _id$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN2@MoveItem:

; 240  :         mcpy(array+newID, &val, sizeof(T));

	mov	edx, DWORD PTR _newID$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, edx
	mov	edx, DWORD PTR _val$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _val$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _val$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _val$[ebp+12]
	mov	DWORD PTR [ecx+12], eax

; 241  :         zero(&val, sizeof(T));

	push	16					; 00000010H
	lea	ecx, DWORD PTR _val$[ebp]
	push	ecx
	call	?zero@@YGXPAXI@Z			; zero

; 242  :     }

	lea	ecx, DWORD PTR _val$[ebp]
	call	??1TimedPacket@@QAE@XZ
$LN6@MoveItem:
	mov	esp, ebp
	pop	ebp
	ret	8
?MoveItem@?$List@UTimedPacket@@@@QAEXHH@Z ENDP		; List<TimedPacket>::MoveItem
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Clear@?$List@UTimedPacket@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@?$List@UTimedPacket@@@@QAEXXZ PROC		; List<TimedPacket>::Clear, COMDAT
; _this$ = ecx

; 334  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 335  :         if(array)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Clear

; 336  :         {
; 337  :             /*if(IsBadWritePtr(array, sizeof(T)*num))
; 338  :                 CrashError(TEXT("what the.."));*/
; 339  :             Free(array);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4

; 340  :             array = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 341  :             num = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$LN2@Clear:

; 342  :         }
; 343  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$List@UTimedPacket@@@@QAEXXZ ENDP		; List<TimedPacket>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?CreateNew@?$List@UTimedPacket@@@@QAEPAUTimedPacket@@XZ
_TEXT	SEGMENT
_value$ = -8						; size = 4
_this$ = -4						; size = 4
?CreateNew@?$List@UTimedPacket@@@@QAEPAUTimedPacket@@XZ PROC ; List<TimedPacket>::CreateNew, COMDAT
; _this$ = ecx

; 346  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 347  :         SetSize(num+1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSize@?$List@UTimedPacket@@@@QAEHI@Z	; List<TimedPacket>::SetSize

; 348  : 
; 349  :         T *value = &array[num-1];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR _value$[ebp], eax

; 350  : 
; 351  :         return value;

	mov	eax, DWORD PTR _value$[ebp]

; 352  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?CreateNew@?$List@UTimedPacket@@@@QAEPAUTimedPacket@@XZ ENDP ; List<TimedPacket>::CreateNew
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?InsertNew@?$List@UTimedPacket@@@@QAEPAUTimedPacket@@H@Z
_TEXT	SEGMENT
_ins$ = -24						; size = 16
$T1 = -8						; size = 4
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?InsertNew@?$List@UTimedPacket@@@@QAEPAUTimedPacket@@H@Z PROC ; List<TimedPacket>::InsertNew, COMDAT
; _this$ = ecx

; 355  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 356  :         T ins;

	lea	ecx, DWORD PTR _ins$[ebp]
	call	??0TimedPacket@@QAE@XZ

; 357  : 
; 358  :         zero(&ins, sizeof(T));

	push	16					; 00000010H
	lea	eax, DWORD PTR _ins$[ebp]
	push	eax
	call	?zero@@YGXPAXI@Z			; zero

; 359  : 
; 360  :         Insert(index, ins);

	lea	ecx, DWORD PTR _ins$[ebp]
	push	ecx
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Insert@?$List@UTimedPacket@@@@QAEXIABUTimedPacket@@@Z ; List<TimedPacket>::Insert

; 361  : 
; 362  :         return &array[index];

	mov	eax, DWORD PTR _index$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T1[ebp], eax
	lea	ecx, DWORD PTR _ins$[ebp]
	call	??1TimedPacket@@QAE@XZ
	mov	eax, DWORD PTR $T1[ebp]

; 363  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?InsertNew@?$List@UTimedPacket@@@@QAEPAUTimedPacket@@H@Z ENDP ; List<TimedPacket>::InsertNew
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??A?$List@UTimedPacket@@@@QAEAAUTimedPacket@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$List@UTimedPacket@@@@QAEAAUTimedPacket@@I@Z PROC	; List<TimedPacket>::operator[], COMDAT
; _this$ = ecx

; 379  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  :         assert(index < num);
; 381  :         if(index >= num) {DumpError(TEXT("Out of range!  List<%S>::operator[](%d)"), typeid(T).name(), index); return array[0];}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN1@operator
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	push	OFFSET ?__type_info_root_node@@3U__type_info_node@@A ; __type_info_root_node
	mov	ecx, OFFSET ??_R0?AUTimedPacket@@@8
	call	?name@type_info@@QBEPBDPAU__type_info_node@@@Z ; type_info::name
	push	eax
	push	OFFSET ??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp_?DumpError@@YAXPB_WZZ
	mov	eax, 16					; 00000010H
	imul	eax, eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN3@operator
$LN1@operator:

; 382  :         return array[index];

	mov	eax, DWORD PTR _index$[ebp]
	shl	eax, 4
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx]
$LN3@operator:

; 383  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@UTimedPacket@@@@QAEAAUTimedPacket@@I@Z ENDP	; List<TimedPacket>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?InsertNew@?$List@UNetworkPacket@@@@QAEPAUNetworkPacket@@H@Z
_TEXT	SEGMENT
_ins$ = -28						; size = 20
$T1 = -8						; size = 4
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?InsertNew@?$List@UNetworkPacket@@@@QAEPAUNetworkPacket@@H@Z PROC ; List<NetworkPacket>::InsertNew, COMDAT
; _this$ = ecx

; 355  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 356  :         T ins;

	lea	ecx, DWORD PTR _ins$[ebp]
	call	??0NetworkPacket@@QAE@XZ

; 357  : 
; 358  :         zero(&ins, sizeof(T));

	push	20					; 00000014H
	lea	eax, DWORD PTR _ins$[ebp]
	push	eax
	call	?zero@@YGXPAXI@Z			; zero

; 359  : 
; 360  :         Insert(index, ins);

	lea	ecx, DWORD PTR _ins$[ebp]
	push	ecx
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Insert@?$List@UNetworkPacket@@@@QAEXIABUNetworkPacket@@@Z ; List<NetworkPacket>::Insert

; 361  : 
; 362  :         return &array[index];

	imul	eax, DWORD PTR _index$[ebp], 20
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T1[ebp], eax
	lea	ecx, DWORD PTR _ins$[ebp]
	call	??1NetworkPacket@@QAE@XZ
	mov	eax, DWORD PTR $T1[ebp]

; 363  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?InsertNew@?$List@UNetworkPacket@@@@QAEPAUNetworkPacket@@H@Z ENDP ; List<NetworkPacket>::InsertNew
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Last@?$List@UNetworkPacket@@@@QBEAAUNetworkPacket@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Last@?$List@UNetworkPacket@@@@QBEAAUNetworkPacket@@XZ PROC ; List<NetworkPacket>::Last, COMDAT
; _this$ = ecx

; 446  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 447  :         assert(num > 0);
; 448  : 
; 449  :         return array[num-1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	imul	eax, ecx, 20
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx]

; 450  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?Last@?$List@UNetworkPacket@@@@QBEAAUNetworkPacket@@XZ ENDP ; List<NetworkPacket>::Last
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ??1?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QAE@XZ PROC ; std::unique_ptr<XConfig,std::default_delete<XConfig> >::~unique_ptr<XConfig,std::default_delete<XConfig> >, COMDAT
; _this$ = ecx

; 1446 : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1447 : 		if (this->_Myptr != pointer())

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@unique_ptr

; 1448 : 			this->get_deleter()(this->_Myptr);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?get_deleter@?$_Unique_ptr_base@VXConfig@@U?$default_delete@VXConfig@@@std@@$00@std@@QAEAAU?$default_delete@VXConfig@@@2@XZ ; std::_Unique_ptr_base<XConfig,std::default_delete<XConfig>,1>::get_deleter
	mov	ecx, eax
	call	??R?$default_delete@VXConfig@@@std@@QBEXPAVXConfig@@@Z ; std::default_delete<XConfig>::operator()
$LN2@unique_ptr:

; 1449 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QAE@XZ ENDP ; std::unique_ptr<XConfig,std::default_delete<XConfig> >::~unique_ptr<XConfig,std::default_delete<XConfig> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0NetworkPacket@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0NetworkPacket@@QAE@XZ PROC				; NetworkPacket::NetworkPacket, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$List@E@@QAE@XZ			; List<unsigned char>::List<unsigned char>
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0NetworkPacket@@QAE@XZ ENDP				; NetworkPacket::NetworkPacket
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1NetworkPacket@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1NetworkPacket@@QAE@XZ PROC				; NetworkPacket::~NetworkPacket, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$List@E@@QAE@XZ			; List<unsigned char>::~List<unsigned char>
	mov	esp, ebp
	pop	ebp
	ret	0
??1NetworkPacket@@QAE@XZ ENDP				; NetworkPacket::~NetworkPacket
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ?_Pop_back_n@?$vector@DV?$allocator@D@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Ptr$ = -8						; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Pop_back_n@?$vector@DV?$allocator@D@std@@@std@@QAEXI@Z PROC ; std::vector<char,std::allocator<char> >::_Pop_back_n, COMDAT
; _this$ = ecx

; 1495 : 		{	// erase _Count elements at end

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1496 : 		pointer _Ptr = this->_Mylast - _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx

; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z ; std::vector<char,std::allocator<char> >::_Destroy

; 1503 : 		this->_Mylast = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1504 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Pop_back_n@?$vector@DV?$allocator@D@std@@@std@@QAEXI@Z ENDP ; std::vector<char,std::allocator<char> >::_Pop_back_n
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ?_Reserve@?$vector@DV?$allocator@D@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@DV?$allocator@D@std@@@std@@IAEXI@Z PROC ; std::vector<char,std::allocator<char> >::_Reserve, COMDAT
; _this$ = ecx

; 1612 : 		{	// ensure room for _Count new elements, grow exponentially

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1613 : 		if (_Unused_capacity() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Unused_capacity@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::_Unused_capacity
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN4@Reserve

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN1@Reserve

; 1616 : 				_Xlen();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$vector@DV?$allocator@D@std@@@std@@IBEXXZ ; std::vector<char,std::allocator<char> >::_Xlen
$LN1@Reserve:

; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	add	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow_to@?$vector@DV?$allocator@D@std@@@std@@IBEII@Z ; std::vector<char,std::allocator<char> >::_Grow_to
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reallocate@?$vector@DV?$allocator@D@std@@@std@@IAEXI@Z ; std::vector<char,std::allocator<char> >::_Reallocate
$LN4@Reserve:

; 1618 : 			}
; 1619 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Reserve@?$vector@DV?$allocator@D@std@@@std@@IAEXI@Z ENDP ; std::vector<char,std::allocator<char> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Insert@?$List@UTimedPacket@@@@QAEXIABUTimedPacket@@@Z
_TEXT	SEGMENT
_moveCount$ = -16					; size = 4
tv94 = -12						; size = 4
_temp$ = -8						; size = 4
_this$ = -4						; size = 4
_index$ = 8						; size = 4
_val$ = 12						; size = 4
?Insert@?$List@UTimedPacket@@@@QAEXIABUTimedPacket@@@Z PROC ; List<TimedPacket>::Insert, COMDAT
; _this$ = ecx

; 64   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 65   :         assert(index <= num);
; 66   :         if(index > num) return;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jbe	SHORT $LN3@Insert
	jmp	$LN4@Insert
$LN3@Insert:

; 67   : 
; 68   :         if(!num && !index)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN2@Insert
	cmp	DWORD PTR _index$[ebp], 0
	jne	SHORT $LN2@Insert

; 69   :         {
; 70   :             Add(val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Add@?$List@UTimedPacket@@@@QAEIABUTimedPacket@@@Z ; List<TimedPacket>::Add

; 71   :             return;

	jmp	$LN4@Insert
$LN2@Insert:

; 72   :         }
; 73   : 
; 74   :         //this makes it safe to insert an item already in the list
; 75   :         T *temp = (T*)Allocate(sizeof(T));

	push	16					; 00000010H
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	mov	DWORD PTR _temp$[ebp], eax

; 76   :         mcpy(temp, &val, sizeof(T));

	mov	ecx, DWORD PTR _val$[ebp]
	mov	edx, DWORD PTR _temp$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx

; 77   : 
; 78   :         UINT moveCount = num-index;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, DWORD PTR _index$[ebp]
	mov	DWORD PTR _moveCount$[ebp], eax

; 79   :         array = (T*)ReAllocate(array, sizeof(T)*++num);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	DWORD PTR tv94[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR tv94[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR tv94[ebp]
	shl	edx, 4
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 80   :         if(moveCount)

	cmp	DWORD PTR _moveCount$[ebp], 0
	je	SHORT $LN1@Insert

; 81   :             mcpyrev(array+(index+1), array+index, moveCount*sizeof(T));

	mov	edx, DWORD PTR _moveCount$[ebp]
	shl	edx, 4
	push	edx
	mov	eax, DWORD PTR _index$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR _index$[ebp]
	add	edx, 1
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax]
	push	edx
	call	?mcpyrev@@YGXPAXPBXI@Z			; mcpyrev
$LN1@Insert:

; 82   :         mcpy(&array[index], temp, sizeof(T));

	mov	ecx, DWORD PTR _index$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, ecx
	mov	ecx, DWORD PTR _temp$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ecx

; 83   : 
; 84   :         Free(temp);

	mov	edx, DWORD PTR _temp$[ebp]
	push	edx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4
$LN4@Insert:

; 85   :     }

	mov	esp, ebp
	pop	ebp
	ret	8
?Insert@?$List@UTimedPacket@@@@QAEXIABUTimedPacket@@@Z ENDP ; List<TimedPacket>::Insert
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?SetSize@?$List@UTimedPacket@@@@QAEHI@Z
_TEXT	SEGMENT
_bClear$ = -16						; size = 4
_oldNum$ = -12						; size = 4
tv70 = -8						; size = 4
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?SetSize@?$List@UTimedPacket@@@@QAEHI@Z PROC		; List<TimedPacket>::SetSize, COMDAT
; _this$ = ecx

; 205  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 206  :         if(num == n)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _n$[ebp]
	jne	SHORT $LN4@SetSize

; 207  :             return FALSE;

	xor	eax, eax
	jmp	$LN5@SetSize
	jmp	SHORT $LN3@SetSize
$LN4@SetSize:

; 208  :         else if(!n)

	cmp	DWORD PTR _n$[ebp], 0
	jne	SHORT $LN3@SetSize

; 209  :         {
; 210  :             Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@UTimedPacket@@@@QAEXXZ	; List<TimedPacket>::Clear

; 211  :             return TRUE;

	mov	eax, 1
	jmp	$LN5@SetSize
$LN3@SetSize:

; 212  :         }
; 213  : 
; 214  :         BOOL bClear=(n>num);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jbe	SHORT $LN7@SetSize
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN8@SetSize
$LN7@SetSize:
	mov	DWORD PTR tv70[ebp], 0
$LN8@SetSize:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _bClear$[ebp], ecx

; 215  :         UINT oldNum=num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _oldNum$[ebp], eax

; 216  : 
; 217  :         num = n;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 218  :         array = (T*)ReAllocate(array, sizeof(T)*num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 219  : 
; 220  :         if(bClear)

	cmp	DWORD PTR _bClear$[ebp], 0
	je	SHORT $LN1@SetSize

; 221  :             zero(&array[oldNum], sizeof(T)*(num-oldNum));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, DWORD PTR _oldNum$[ebp]
	shl	eax, 4
	push	eax
	mov	ecx, DWORD PTR _oldNum$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	push	ecx
	call	?zero@@YGXPAXI@Z			; zero
$LN1@SetSize:

; 222  : 
; 223  :         return TRUE;

	mov	eax, 1
$LN5@SetSize:

; 224  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetSize@?$List@UTimedPacket@@@@QAEHI@Z ENDP		; List<TimedPacket>::SetSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Insert@?$List@UNetworkPacket@@@@QAEXIABUNetworkPacket@@@Z
_TEXT	SEGMENT
_moveCount$ = -16					; size = 4
tv94 = -12						; size = 4
_temp$ = -8						; size = 4
_this$ = -4						; size = 4
_index$ = 8						; size = 4
_val$ = 12						; size = 4
?Insert@?$List@UNetworkPacket@@@@QAEXIABUNetworkPacket@@@Z PROC ; List<NetworkPacket>::Insert, COMDAT
; _this$ = ecx

; 64   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 65   :         assert(index <= num);
; 66   :         if(index > num) return;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jbe	SHORT $LN3@Insert
	jmp	$LN4@Insert
$LN3@Insert:

; 67   : 
; 68   :         if(!num && !index)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN2@Insert
	cmp	DWORD PTR _index$[ebp], 0
	jne	SHORT $LN2@Insert

; 69   :         {
; 70   :             Add(val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Add@?$List@UNetworkPacket@@@@QAEIABUNetworkPacket@@@Z ; List<NetworkPacket>::Add

; 71   :             return;

	jmp	$LN4@Insert
$LN2@Insert:

; 72   :         }
; 73   : 
; 74   :         //this makes it safe to insert an item already in the list
; 75   :         T *temp = (T*)Allocate(sizeof(T));

	push	20					; 00000014H
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	mov	DWORD PTR _temp$[ebp], eax

; 76   :         mcpy(temp, &val, sizeof(T));

	mov	ecx, DWORD PTR _val$[ebp]
	mov	edx, DWORD PTR _temp$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], ecx

; 77   : 
; 78   :         UINT moveCount = num-index;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, DWORD PTR _index$[ebp]
	mov	DWORD PTR _moveCount$[ebp], eax

; 79   :         array = (T*)ReAllocate(array, sizeof(T)*++num);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	DWORD PTR tv94[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR tv94[ebp]
	mov	DWORD PTR [eax+4], ecx
	imul	edx, DWORD PTR tv94[ebp], 20
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 80   :         if(moveCount)

	cmp	DWORD PTR _moveCount$[ebp], 0
	je	SHORT $LN1@Insert

; 81   :             mcpyrev(array+(index+1), array+index, moveCount*sizeof(T));

	imul	edx, DWORD PTR _moveCount$[ebp], 20
	push	edx
	imul	eax, DWORD PTR _index$[ebp], 20
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR _index$[ebp]
	add	edx, 1
	imul	eax, edx, 20
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	push	eax
	call	?mcpyrev@@YGXPAXPBXI@Z			; mcpyrev
$LN1@Insert:

; 82   :         mcpy(&array[index], temp, sizeof(T));

	imul	edx, DWORD PTR _index$[ebp], 20
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, edx
	mov	edx, DWORD PTR _temp$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], edx

; 83   : 
; 84   :         Free(temp);

	mov	eax, DWORD PTR _temp$[ebp]
	push	eax
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4
$LN4@Insert:

; 85   :     }

	mov	esp, ebp
	pop	ebp
	ret	8
?Insert@?$List@UNetworkPacket@@@@QAEXIABUNetworkPacket@@@Z ENDP ; List<NetworkPacket>::Insert
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ??R?$default_delete@VXConfig@@@std@@QBEXPAVXConfig@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv68 = -12						; size = 4
$T1 = -8						; size = 4
$T2 = -4						; size = 4
__Ptr$ = 8						; size = 4
??R?$default_delete@VXConfig@@@std@@QBEXPAVXConfig@@@Z PROC ; std::default_delete<XConfig>::operator(), COMDAT
; _this$ = ecx

; 1197 : 		{	// delete a pointer

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1198 : 		static_assert(0 < sizeof (_Ty),
; 1199 : 			"can't delete an incomplete type");
; 1200 : 		delete _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN3@operator
	push	1
	mov	ecx, DWORD PTR $T2[ebp]
	call	??_GXConfig@@QAEPAXI@Z
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $LN1@operator
$LN3@operator:
	mov	DWORD PTR tv68[ebp], 0
$LN1@operator:

; 1201 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??R?$default_delete@VXConfig@@@std@@QBEXPAVXConfig@@@Z ENDP ; std::default_delete<XConfig>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ?get_deleter@?$_Unique_ptr_base@VXConfig@@U?$default_delete@VXConfig@@@std@@$00@std@@QAEAAU?$default_delete@VXConfig@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get_deleter@?$_Unique_ptr_base@VXConfig@@U?$default_delete@VXConfig@@@std@@$00@std@@QAEAAU?$default_delete@VXConfig@@@2@XZ PROC ; std::_Unique_ptr_base<XConfig,std::default_delete<XConfig>,1>::get_deleter, COMDAT
; _this$ = ecx

; 1312 : 		{	// return reference to deleter

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 1314 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?get_deleter@?$_Unique_ptr_base@VXConfig@@U?$default_delete@VXConfig@@@std@@$00@std@@QAEAAU?$default_delete@VXConfig@@@2@XZ ENDP ; std::_Unique_ptr_base<XConfig,std::default_delete<XConfig>,1>::get_deleter
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GXConfig@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GXConfig@@QAEPAXI@Z PROC				; XConfig::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1XConfig@@QAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GXConfig@@QAEPAXI@Z ENDP				; XConfig::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Unused_capacity@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ PROC ; std::vector<char,std::allocator<char> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1014 : 		{	// micro-optimization for capacity() - size()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1015 : 		return (this->_Myend - this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]

; 1016 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Unused_capacity@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::vector<char,std::allocator<char> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@DV?$allocator@D@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -32						; size = 4
__Ptr$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?_Reallocate@?$vector@DV?$allocator@D@std@@@std@@IAEXI@Z PROC ; std::vector<char,std::allocator<char> >::_Reallocate, COMDAT
; _this$ = ecx

; 1587 : 		{	// move to array of exactly _Count elements

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Reallocate@?$vector@DV?$allocator@D@std@@@std@@IAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR __Ptr$[ebp], eax

; 1589 : 
; 1590 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);

	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPAD00@Z ; std::vector<char,std::allocator<char> >::_Umove<char *>
	jmp	SHORT $LN5@Reallocate
__catch$?_Reallocate@?$vector@DV?$allocator@D@std@@@std@@IAEXI@Z$0:

; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate

; 1594 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1595 : 		_CATCH_END

	mov	eax, $LN8@Reallocate
	ret	0
$LN5@Reallocate:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Reallocate@?$vector@DV?$allocator@D@std@@@std@@IAEXI@Z$1
$LN8@Reallocate:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Reallocate@?$vector@DV?$allocator@D@std@@@std@@IAEXI@Z$1:

; 1596 : 
; 1597 : 		size_type _Size = size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	mov	DWORD PTR __Size$[ebp], eax

; 1598 : 		if (this->_Myfirst != pointer())

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN1@Reallocate

; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z ; std::vector<char,std::allocator<char> >::_Destroy

; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN1@Reallocate:

; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1606 : 		this->_Myend = _Ptr + _Count;

	mov	eax, DWORD PTR __Ptr$[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1607 : 		this->_Mylast = _Ptr + _Size;

	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, DWORD PTR __Size$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 1608 : 		this->_Myfirst = _Ptr;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [ecx], edx
$LN4@Reallocate:

; 1609 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate@?$vector@DV?$allocator@D@std@@@std@@IAEXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Reallocate@?$vector@DV?$allocator@D@std@@@std@@IAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Reallocate@?$vector@DV?$allocator@D@std@@@std@@IAEXI@Z ENDP ; std::vector<char,std::allocator<char> >::_Reallocate
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Add@?$List@UTimedPacket@@@@QAEIABUTimedPacket@@@Z
_TEXT	SEGMENT
tv73 = -8						; size = 4
_this$ = -4						; size = 4
_val$ = 8						; size = 4
?Add@?$List@UTimedPacket@@@@QAEIABUTimedPacket@@@Z PROC	; List<TimedPacket>::Add, COMDAT
; _this$ = ecx

; 45   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 46   :         array = (T*)ReAllocate(array, sizeof(T)*++num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	DWORD PTR tv73[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR tv73[ebp]
	shl	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 47   :         mcpy(&array[(num-1)], (void*)&val, sizeof(T));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, eax
	mov	eax, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], eax

; 48   :         return num-1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	sub	eax, 1

; 49   :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?Add@?$List@UTimedPacket@@@@QAEIABUTimedPacket@@@Z ENDP	; List<TimedPacket>::Add
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Add@?$List@UNetworkPacket@@@@QAEIABUNetworkPacket@@@Z
_TEXT	SEGMENT
tv73 = -8						; size = 4
_this$ = -4						; size = 4
_val$ = 8						; size = 4
?Add@?$List@UNetworkPacket@@@@QAEIABUNetworkPacket@@@Z PROC ; List<NetworkPacket>::Add, COMDAT
; _this$ = ecx

; 45   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 46   :         array = (T*)ReAllocate(array, sizeof(T)*++num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	DWORD PTR tv73[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR [edx+4], eax
	imul	ecx, DWORD PTR tv73[ebp], 20
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 47   :         mcpy(&array[(num-1)], (void*)&val, sizeof(T));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	imul	ecx, eax, 20
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, ecx
	mov	ecx, DWORD PTR _val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], ecx

; 48   :         return num-1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1

; 49   :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?Add@?$List@UNetworkPacket@@@@QAEIABUNetworkPacket@@@Z ENDP ; List<NetworkPacket>::Add
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n@PADIU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXPADIAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_default_fill_n@PADIU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXPADIAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<char *,unsigned int,std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 690  : 	{	// copy _Count * _Val_type(_First)() to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 691  : 	_Uninit_def_fill_n(_First, _Count, _Al,
; 692  : 		_Val_type(_First), _Ptr_cat(_First, _First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@DD@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAD0@Z ; std::_Ptr_cat<char,char>
	add	esp, 8
	mov	BYTE PTR $T1[ebp], al
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Val_type@PAD@std@@YAPADPAD@Z	; std::_Val_type<char *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Uninit_def_fill_n@DID@std@@YAXPADIAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_def_fill_n<char,unsigned int,char>
	add	esp, 20					; 00000014H

; 693  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_default_fill_n@PADIU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXPADIAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<char *,unsigned int,std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ??$_Umove@PAD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPAD00@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Alval$ = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPAD00@Z PROC ; std::vector<char,std::allocator<char> >::_Umove<char *>, COMDAT
; _this$ = ecx

; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());

	lea	eax, DWORD PTR __Alval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char> > >::_Getal

; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));

	lea	ecx, DWORD PTR __Alval$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninitialized_move@PADPADU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAPADPAD00AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z ; std::_Uninitialized_move<char *,char *,std::_Wrap_alloc<std::allocator<char> > >
	add	esp, 16					; 00000010H

; 1649 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPAD00@Z ENDP ; std::vector<char,std::allocator<char> >::_Umove<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xutility
;	COMDAT ??$_Val_type@PAD@std@@YAPADPAD@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAD@std@@YAPADPAD@Z PROC			; std::_Val_type<char *>, COMDAT

; 645  : 	{	// return value type from arbitrary argument

	push	ebp
	mov	ebp, esp

; 646  : 	return (0);

	xor	eax, eax

; 647  : 	}

	pop	ebp
	ret	0
??$_Val_type@PAD@std@@YAPADPAD@Z ENDP			; std::_Val_type<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory
;	COMDAT ??$_Uninit_def_fill_n@DID@std@@YAXPADIAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_def_fill_n@DID@std@@YAXPADIAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_def_fill_n<char,unsigned int,char>, COMDAT

; 681  : 	{	// copy _Count * _Valty() to raw _First, using _Al, scalar type

	push	ebp
	mov	ebp, esp

; 682  : 	_Fill_n(_First, _Count, (_Valty)0);

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	?_Fill_n@std@@YAPADPADID@Z		; std::_Fill_n
	add	esp, 12					; 0000000cH

; 683  : 	}

	pop	ebp
	ret	0
??$_Uninit_def_fill_n@DID@std@@YAXPADIAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_def_fill_n<char,unsigned int,char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PADPADU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAPADPAD00AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PADPADU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAPADPAD00AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z PROC ; std::_Uninitialized_move<char *,char *,std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 492  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp

; 493  : 	return (_Rechecked(_Dest,
; 494  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 495  : 			_Unchecked(_Dest), _Al)));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Unchecked@PAD@std@@YAPADPAD@Z	; std::_Unchecked<char *>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??$_Unchecked@PAD@std@@YAPADPAD@Z	; std::_Unchecked<char *>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked@PAD@std@@YAPADPAD@Z	; std::_Unchecked<char *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PADPADU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAPADPAD00AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z ; std::_Uninit_move<char *,char *,std::_Wrap_alloc<std::allocator<char> > >
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Rechecked@PADPAD@std@@YAAAPADAAPADPAD@Z ; std::_Rechecked<char *,char *>
	add	esp, 8
	mov	eax, DWORD PTR [eax]

; 496  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_move@PADPADU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAPADPAD00AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z ENDP ; std::_Uninitialized_move<char *,char *,std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PADPADU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAPADPAD00AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_move@PADPADU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAPADPAD00AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z PROC ; std::_Uninit_move<char *,char *,std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 482  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 483  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@DD@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAD0@Z ; std::_Ptr_cat<char,char>
	add	esp, 8
	mov	BYTE PTR $T1[ebp], al
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Val_type@PAD@std@@YAPADPAD@Z	; std::_Val_type<char *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninit_move@DDD@std@@YAPADPAD00AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<char,char,char>
	add	esp, 24					; 00000018H

; 485  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_move@PADPADU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAPADPAD00AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z ENDP ; std::_Uninit_move<char *,char *,std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory
;	COMDAT ??$_Uninit_move@DDD@std@@YAPADPAD00AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@DDD@std@@YAPADPAD00AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<char,char,char>, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	push	ecx

; 470  : 	_DEBUG_RANGE(_First, _Last);
; 471  : 	_DEBUG_POINTER(_Dest);
; 472  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	add	eax, DWORD PTR __Count$[ebp]

; 475  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_move@DDD@std@@YAPADPAD00AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<char,char,char>
_TEXT	ENDS
END

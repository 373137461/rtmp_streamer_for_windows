; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

	TITLE	F:\songmm_moon_stone_obs\OBS\Source\OBSVideoCapture.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_R0?AUVideoPacketData@@@8			; VideoPacketData `RTTI Type Descriptor'
PUBLIC	??_R0?AUVideoSegment@@@8			; VideoSegment `RTTI Type Descriptor'
PUBLIC	??_R0?AW4PacketType@@@8				; enum PacketType `RTTI Type Descriptor'
EXTRN	__imp_?SetParallelCallCount@ProfilerNode@@QAEXK@Z:PROC
EXTRN	__imp__DebugBreak@0:PROC
EXTRN	__imp_?GetQPCTimeNS@@YA_KXZ:PROC
EXTRN	__imp_?GetQPCTime100NS@@YA_KXZ:PROC
EXTRN	__imp__x264_picture_init:PROC
EXTRN	__imp__x264_picture_clean:PROC
EXTRN	__imp__x264_picture_alloc:PROC
EXTRN	__imp__GetSysColor@4:PROC
EXTRN	__imp_?DumpLastProfileData@@YGXXZ:PROC
EXTRN	__imp__UpdateWindow@4:PROC
;	COMDAT ?bWarnedAboutNoAudio@?JJ@??MainCaptureLoop@OBS@@AAEXXZ@4_NA
_BSS	SEGMENT
?bWarnedAboutNoAudio@?JJ@??MainCaptureLoop@OBS@@AAEXXZ@4_NA DB 01H DUP (?) ; `OBS::MainCaptureLoop'::`153'::bWarnedAboutNoAudio
_BSS	ENDS
;	COMDAT ??_R0?AW4PacketType@@@8
data$r	SEGMENT
??_R0?AW4PacketType@@@8 DD FLAT:??_7type_info@@6B@	; enum PacketType `RTTI Type Descriptor'
	DD	00H
	DB	'.?AW4PacketType@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AUVideoSegment@@@8
data$r	SEGMENT
??_R0?AUVideoSegment@@@8 DD FLAT:??_7type_info@@6B@	; VideoSegment `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUVideoSegment@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AUVideoPacketData@@@8
data$r	SEGMENT
??_R0?AUVideoPacketData@@@8 DD FLAT:??_7type_info@@6B@	; VideoPacketData `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUVideoPacketData@@', 00H
$SG4294781542 DB 00H
$SG4294781539 DB 00H
$SG4294781532 DB 00H
$SG4294781529 DB 00H
$SG4294781513 DB 00H
	ORG $+2
$SG4294781565 DB 'none', 00H
	ORG $+3
$SG4294781564 DB 'spatial', 00H
$SG4294781561 DB 'dia', 00H
$SG4294781560 DB 'hex', 00H
$SG4294781563 DB 'temporal', 00H
	ORG $+3
$SG4294781562 DB 'auto', 00H
	ORG $+3
$SG4294781557 DB 'tesa', 00H
	ORG $+3
$SG4294781556 DB 'none', 00H
	ORG $+3
$SG4294781559 DB 'umh', 00H
$SG4294781558 DB 'esa', 00H
$SG4294781553 DB 'undef', 00H
	ORG $+2
$SG4294781552 DB 'show', 00H
	ORG $+3
$SG4294781555 DB 'strict', 00H
	ORG $+1
$SG4294781554 DB 'normal', 00H
	ORG $+1
$SG4294781549 DB 'pal', 00H
$SG4294781548 DB 'ntsc', 00H
	ORG $+3
$SG4294781551 DB 'crop', 00H
	ORG $+3
$SG4294781550 DB 'component', 00H
	ORG $+2
$SG4294781545 DB 'undef', 00H
	ORG $+2
$SG4294781544 DB 'off', 00H
$SG4294781547 DB 'secam', 00H
	ORG $+2
$SG4294781546 DB 'mac', 00H
$SG4294781541 DB 'bt709', 00H
	ORG $+2
$SG4294781540 DB 'undef', 00H
	ORG $+2
$SG4294781543 DB 'on', 00H
	ORG $+1
$SG4294781537 DB 'bt470bg', 00H
$SG4294781536 DB 'smpte170m', 00H
	ORG $+2
$SG4294781538 DB 'bt470m', 00H
	ORG $+1
$SG4294781533 DB 'bt2020', 00H
	ORG $+1
$SG4294781535 DB 'smpte240m', 00H
	ORG $+2
$SG4294781534 DB 'film', 00H
	ORG $+3
$SG4294781528 DB 'bt470m', 00H
	ORG $+1
$SG4294781531 DB 'bt709', 00H
	ORG $+2
$SG4294781530 DB 'undef', 00H
	ORG $+2
$SG4294781525 DB 'smpte240m', 00H
	ORG $+2
$SG4294781524 DB 'linear', 00H
	ORG $+1
$SG4294781527 DB 'bt470bg', 00H
$SG4294781526 DB 'smpte170m', 00H
	ORG $+2
$SG4294781521 DB 'iec61966-2-4', 00H
	ORG $+3
$SG4294781520 DB 'bt1361e', 00H
$SG4294781523 DB 'log100', 00H
	ORG $+1
$SG4294781522 DB 'log316', 00H
	ORG $+1
$SG4294781517 DB 'bt2020-12', 00H
	ORG $+2
$SG4294781516 DB 'GBR', 00H
$SG4294781519 DB 'iec61966-2-1', 00H
	ORG $+3
$SG4294781518 DB 'bt2020-10', 00H
	ORG $+2
$SG4294781512 DB 'fcc', 00H
$SG4294781515 DB 'bt709', 00H
	ORG $+2
$SG4294781514 DB 'undef', 00H
	ORG $+2
$SG4294781509 DB 'smpte240m', 00H
	ORG $+2
$SG4294781508 DB 'YCgCo', 00H
	ORG $+2
$SG4294781511 DB 'bt470bg', 00H
$SG4294781510 DB 'smpte170m', 00H
	ORG $+2
$SG4294781505 DB 'none', 00H
	ORG $+3
$SG4294781504 DB 'vbr', 00H
$SG4294781507 DB 'bt2020nc', 00H
	ORG $+3
$SG4294781506 DB 'bt2020c', 00H
$SG4294781501 DB 'superfast', 00H
	ORG $+2
$SG4294781500 DB 'veryfast', 00H
	ORG $+3
$SG4294781503 DB 'cbr', 00H
$SG4294781502 DB 'ultrafast', 00H
	ORG $+2
$SG4294781497 DB 'medium', 00H
	ORG $+1
$SG4294781496 DB 'slow', 00H
	ORG $+3
$SG4294781499 DB 'faster', 00H
	ORG $+1
$SG4294781498 DB 'fast', 00H
	ORG $+3
$SG4294781493 DB 'placebo', 00H
$SG4294781492 DB 'film', 00H
	ORG $+3
$SG4294781495 DB 'slower', 00H
	ORG $+1
$SG4294781494 DB 'veryslow', 00H
	ORG $+3
$SG4294781489 DB 'stillimage', 00H
	ORG $+1
$SG4294781488 DB 'psnr', 00H
	ORG $+3
$SG4294781491 DB 'animation', 00H
	ORG $+2
$SG4294781490 DB 'grain', 00H
	ORG $+2
$SG4294781485 DB 'zerolatency', 00H
$SG4294781484 DB 'baseline', 00H
	ORG $+3
$SG4294781487 DB 'ssim', 00H
	ORG $+3
$SG4294781486 DB 'fastdecode', 00H
	ORG $+1
$SG4294781481 DB 'high10', 00H
	ORG $+1
$SG4294781480 DB 'high422', 00H
$SG4294781483 DB 'main', 00H
	ORG $+3
$SG4294781482 DB 'high', 00H
	ORG $+3
$SG4294781477 DB 'C', 00H, 'o', 00H, 'n', 00H, 'v', 00H, 'e', 00H, 'r', 00H
	DB	't', 00H, '4', 00H, '4', 00H, '4', 00H, 'T', 00H, 'h', 00H, 'r'
	DB	00H, 'e', 00H, 'a', 00H, 'd', 00H, 's', 00H, 00H, 00H
$SG4294781476 DB 's', 00H, 'e', 00H, 'n', 00H, 'd', 00H, 'i', 00H, 'n', 00H
	DB	'g', 00H, ' ', 00H, 's', 00H, 't', 00H, 'u', 00H, 'f', 00H, 'f'
	DB	00H, ' ', 00H, 'o', 00H, 'u', 00H, 't', 00H, 00H, 00H
$SG4294781479 DB 'high444', 00H
$SG4294781478 DB 'C', 00H, 'o', 00H, 'n', 00H, 'v', 00H, 'e', 00H, 'r', 00H
	DB	't', 00H, '4', 00H, '4', 00H, '4', 00H, 'T', 00H, 'h', 00H, 'r'
	DB	00H, 'e', 00H, 'a', 00H, 'd', 00H, 00H, 00H
	ORG $+2
$SG4294781473 DB 'E', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H
	DB	'r', 00H, 'L', 00H, 'a', 00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG4294781472 DB 'e', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H
	DB	'r', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'r', 00H, 'e', 00H, 'a'
	DB	00H, 'd', 00H, ' ', 00H, 'f', 00H, 'r', 00H, 'a', 00H, 'm', 00H
	DB	'e', 00H, 00H, 00H
	ORG $+2
$SG4294781469 DB 'L', 00H, 'o', 00H, 'g', 00H, 'L', 00H, 'o', 00H, 'n', 00H
	DB	'g', 00H, 'F', 00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H, 's'
	DB	00H, 'P', 00H, 'r', 00H, 'o', 00H, 'f', 00H, 'i', 00H, 'l', 00H
	DB	'e', 00H, 00H, 00H
	ORG $+2
$SG4294781475 DB 'T', 00H, 'r', 00H, 'i', 00H, 'e', 00H, 'd', 00H, ' ', 00H
	DB	't', 00H, 'o', 00H, ' ', 00H, 's', 00H, 'l', 00H, 'e', 00H, 'e'
	DB	00H, 'p', 00H, ' ', 00H, 'f', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'%', 00H, 'u', 00H, ' ', 00H, 's', 00H, 'e', 00H, 'c', 00H, 'o'
	DB	00H, 'n', 00H, 'd', 00H, 's', 00H, ',', 00H, ' ', 00H, 't', 00H
	DB	'h', 00H, 'a', 00H, 't', 00H, ' ', 00H, 'c', 00H, 'a', 00H, 'n'
	DB	00H, '''', 00H, 't', 00H, ' ', 00H, 'b', 00H, 'e', 00H, ' ', 00H
	DB	'r', 00H, 'i', 00H, 'g', 00H, 'h', 00H, 't', 00H, '!', 00H, ' '
	DB	00H, 'T', 00H, 'r', 00H, 'i', 00H, 'g', 00H, 'g', 00H, 'e', 00H
	DB	'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'b', 00H, 'r'
	DB	00H, 'e', 00H, 'a', 00H, 'k', 00H, 'p', 00H, 'o', 00H, 'i', 00H
	DB	'n', 00H, 't', 00H, '.', 00H, 00H, 00H
	ORG $+2
$SG4294781474 DB 'F', 00H, 'l', 00H, 'u', 00H, 's', 00H, 'h', 00H, 'B', 00H
	DB	'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'd'
	DB	00H, 'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, ':', 00H
	DB	' ', 00H, 'F', 00H, 'l', 00H, 'u', 00H, 's', 00H, 'h', 00H, 'i'
	DB	00H, 'n', 00H, 'g', 00H, ' ', 00H, '%', 00H, 'd', 00H, ' ', 00H
	DB	'p', 00H, 'a', 00H, 'c', 00H, 'k', 00H, 'e', 00H, 't', 00H, 's'
	DB	00H, ' ', 00H, 'o', 00H, 'v', 00H, 'e', 00H, 'r', 00H, ' ', 00H
	DB	'%', 00H, 'd', 00H, ' ', 00H, 'm', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG4294781468 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294781471 DB 'T', 00H, 'o', 00H, 't', 00H, 'a', 00H, 'l', 00H, ' ', 00H
	DB	'f', 00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H, 's', 00H, ' '
	DB	00H, 'e', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H
	DB	'd', 00H, ':', 00H, ' ', 00H, '%', 00H, 'd', 00H, ',', 00H, ' '
	DB	00H, 't', 00H, 'o', 00H, 't', 00H, 'a', 00H, 'l', 00H, ' ', 00H
	DB	'f', 00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H, 's', 00H, ' '
	DB	00H, 'd', 00H, 'u', 00H, 'p', 00H, 'l', 00H, 'i', 00H, 'c', 00H
	DB	'a', 00H, 't', 00H, 'e', 00H, 'd', 00H, ':', 00H, ' ', 00H, '%'
	DB	00H, 'd', 00H, ' ', 00H, '(', 00H, '%', 00H, '0', 00H, '.', 00H
	DB	'2', 00H, 'f', 00H, '%', 00H, '%', 00H, ')', 00H, 00H, 00H
$SG4294781470 DB 'N', 00H, 'u', 00H, 'm', 00H, 'b', 00H, 'e', 00H, 'r', 00H
	DB	' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 'f', 00H, 'r', 00H, 'a'
	DB	00H, 'm', 00H, 'e', 00H, 's', 00H, ' ', 00H, 's', 00H, 'k', 00H
	DB	'i', 00H, 'p', 00H, 'p', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'd'
	DB	00H, 'u', 00H, 'e', 00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H
	DB	'e', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r'
	DB	00H, ' ', 00H, 'l', 00H, 'a', 00H, 'g', 00H, ':', 00H, ' ', 00H
	DB	'%', 00H, 'd', 00H, ' ', 00H, '(', 00H, '%', 00H, '0', 00H, '.'
	DB	00H, '2', 00H, 'f', 00H, '%', 00H, '%', 00H, ')', 00H, 00H, 00H
$SG4294781465 DB 'y', 00H, 'u', 00H, 'v', 00H, 'M', 00H, 'a', 00H, 't', 00H
	DB	00H, 00H
	ORG $+2
$SG4294781464 DB 'b', 00H, 'a', 00H, 's', 00H, 'e', 00H, 'D', 00H, 'i', 00H
	DB	'm', 00H, 'e', 00H, 'n', 00H, 's', 00H, 'i', 00H, 'o', 00H, 'n'
	DB	00H, 'I', 00H, 00H, 00H
	ORG $+2
$SG4294781467 DB 'L', 00H, 'o', 00H, 'g', 00H, 'L', 00H, 'o', 00H, 'n', 00H
	DB	'g', 00H, 'F', 00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H, 's'
	DB	00H, 'P', 00H, 'r', 00H, 'o', 00H, 'f', 00H, 'i', 00H, 'l', 00H
	DB	'e', 00H, 'P', 00H, 'e', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'n'
	DB	00H, 't', 00H, 'a', 00H, 'g', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG4294781466 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294781461 DB 'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, ' ', 00H
	DB	'E', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG4294781460 DB 'M', 00H, 'a', 00H, 'x', 00H, 'B', 00H, 'i', 00H, 't', 00H
	DB	'r', 00H, 'a', 00H, 't', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG4294781463 DB 't', 00H, 'r', 00H, 'a', 00H, 'n', 00H, 's', 00H, 'i', 00H
	DB	't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 'T', 00H, 'i', 00H, 'm'
	DB	00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG4294781462 DB 'C', 00H, 'o', 00H, 'n', 00H, 'g', 00H, 'e', 00H, 's', 00H
	DB	't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 'C', 00H, 'o', 00H, 'n'
	DB	00H, 't', 00H, 'r', 00H, 'o', 00H, 'l', 00H, 00H, 00H
$SG4294781457 DB 't', 00H, 'i', 00H, 'm', 00H, 'e', 00H, ' ', 00H, 'l', 00H
	DB	'e', 00H, 'f', 00H, 't', 00H, ':', 00H, ' ', 00H, '%', 00H, 'd'
	DB	00H, 0dH, 00H, 0aH, 00H, 00H, 00H
$SG4294781456 DB 's', 00H, 'c', 00H, 'e', 00H, 'n', 00H, 'e', 00H, '-', 00H
	DB	'>', 00H, 'P', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'r', 00H, 'o'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, 's', 00H, 00H, 00H
$SG4294781459 DB 'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, ' ', 00H
	DB	'E', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG4294781458 DB 'v', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, ' ', 00H
	DB	't', 00H, 'h', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 'd', 00H, ' '
	DB	00H, 'f', 00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG4294781453 DB 'c', 00H, 'o', 00H, 'n', 00H, 'v', 00H, 'e', 00H, 'r', 00H
	DB	's', 00H, 'i', 00H, 'o', 00H, 'n', 00H, ' ', 00H, 't', 00H, 'o'
	DB	00H, ' ', 00H, '4', 00H, ':', 00H, '2', 00H, ':', 00H, '0', 00H
	DB	00H, 00H
$SG4294781454 DB 'C', 00H, 'o', 00H, 'p', 00H, 'y', 00H, 'R', 00H, 'e', 00H
	DB	's', 00H, 'o', 00H, 'u', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 00H
	DB	00H
	ORG $+2
$SG4294781452 DB 'Y', 00H, 'o', 00H, 'u', 00H, 'r', 00H, ' ', 00H, 'v', 00H
	DB	'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, ' ', 00H, 'c', 00H, 'a'
	DB	00H, 'r', 00H, 'd', 00H, ' ', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'd', 00H, 'r', 00H, 'i', 00H, 'v', 00H, 'e', 00H, 'r', 00H, ' '
	DB	00H, 'f', 00H, 'r', 00H, 'o', 00H, 'z', 00H, 'e', 00H, ' ', 00H
	DB	'a', 00H, 'n', 00H, 'd', 00H, ' ', 00H, 'w', 00H, 'a', 00H, 's'
	DB	00H, ' ', 00H, 'r', 00H, 'e', 00H, 's', 00H, 'e', 00H, 't', 00H
	DB	'.', 00H, ' ', 00H, 'P', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 's'
	DB	00H, 'e', 00H, ' ', 00H, 'c', 00H, 'h', 00H, 'e', 00H, 'c', 00H
	DB	'k', 00H, ' ', 00H, 'f', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'p'
	DB	00H, 'o', 00H, 's', 00H, 's', 00H, 'i', 00H, 'b', 00H, 'l', 00H
	DB	'e', 00H, ' ', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'd', 00H, 'w'
	DB	00H, 'a', 00H, 'r', 00H, 'e', 00H, ' ', 00H, '/', 00H, ' ', 00H
	DB	'd', 00H, 'r', 00H, 'i', 00H, 'v', 00H, 'e', 00H, 'r', 00H, ' '
	DB	00H, 'i', 00H, 's', 00H, 's', 00H, 'u', 00H, 'e', 00H, 's', 00H
	DB	'.', 00H, 00H, 00H
	ORG $+2
$SG4294781455 DB 'G', 00H, 'P', 00H, 'U', 00H, ' ', 00H, 'd', 00H, 'o', 00H
	DB	'w', 00H, 'n', 00H, 'l', 00H, 'o', 00H, 'a', 00H, 'd', 00H, ' '
	DB	00H, 'a', 00H, 'n', 00H, 'd', 00H, ' ', 00H, 'c', 00H, 'o', 00H
	DB	'n', 00H, 'v', 00H, 'e', 00H, 'r', 00H, 's', 00H, 'i', 00H, 'o'
	DB	00H, 'n', 00H, 00H, 00H
$SG4294781449 DB 'Y', 00H, 'o', 00H, 'u', 00H, 'r', 00H, ' ', 00H, 'v', 00H
	DB	'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, ' ', 00H, 'd', 00H, 'r'
	DB	00H, 'i', 00H, 'v', 00H, 'e', 00H, 'r', 00H, ' ', 00H, 'r', 00H
	DB	'e', 00H, 'p', 00H, 'o', 00H, 'r', 00H, 't', 00H, 'e', 00H, 'd'
	DB	00H, ' ', 00H, 'a', 00H, 'n', 00H, ' ', 00H, 'i', 00H, 'n', 00H
	DB	'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H, ' ', 00H, 'c'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, '.', 00H, ' ', 00H, 'P', 00H
	DB	'l', 00H, 'e', 00H, 'a', 00H, 's', 00H, 'e', 00H, ' ', 00H, 'c'
	DB	00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, ' ', 00H, 'f', 00H
	DB	'o', 00H, 'r', 00H, ' ', 00H, 'p', 00H, 'o', 00H, 's', 00H, 's'
	DB	00H, 'i', 00H, 'b', 00H, 'l', 00H, 'e', 00H, ' ', 00H, 'd', 00H
	DB	'r', 00H, 'i', 00H, 'v', 00H, 'e', 00H, 'r', 00H, ' ', 00H, 'i'
	DB	00H, 's', 00H, 's', 00H, 'u', 00H, 'e', 00H, 's', 00H, '.', 00H
	DB	00H, 00H
	ORG $+2
$SG4294781448 DB 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, '_', 00H, 'E', 00H
	DB	'R', 00H, 'R', 00H, 'O', 00H, 'R', 00H, '_', 00H, 'D', 00H, 'E'
	DB	00H, 'V', 00H, 'I', 00H, 'C', 00H, 'E', 00H, '_', 00H, 'R', 00H
	DB	'E', 00H, 'M', 00H, 'O', 00H, 'V', 00H, 'E', 00H, 'D', 00H, 00H
	DB	00H
$SG4294781451 DB 'Y', 00H, 'o', 00H, 'u', 00H, 'r', 00H, ' ', 00H, 'v', 00H
	DB	'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, ' ', 00H, 'c', 00H, 'a'
	DB	00H, 'r', 00H, 'd', 00H, ' ', 00H, 'd', 00H, 'i', 00H, 's', 00H
	DB	'a', 00H, 'p', 00H, 'p', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'e'
	DB	00H, 'd', 00H, ' ', 00H, 'f', 00H, 'r', 00H, 'o', 00H, 'm', 00H
	DB	' ', 00H, 't', 00H, 'h', 00H, 'e', 00H, ' ', 00H, 's', 00H, 'y'
	DB	00H, 's', 00H, 't', 00H, 'e', 00H, 'm', 00H, '.', 00H, ' ', 00H
	DB	'P', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 's', 00H, 'e', 00H, ' '
	DB	00H, 'c', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, ' ', 00H
	DB	'f', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'p', 00H, 'o', 00H, 's'
	DB	00H, 's', 00H, 'i', 00H, 'b', 00H, 'l', 00H, 'e', 00H, ' ', 00H
	DB	'h', 00H, 'a', 00H, 'r', 00H, 'd', 00H, 'w', 00H, 'a', 00H, 'r'
	DB	00H, 'e', 00H, ' ', 00H, '/', 00H, ' ', 00H, 'd', 00H, 'r', 00H
	DB	'i', 00H, 'v', 00H, 'e', 00H, 'r', 00H, ' ', 00H, 'i', 00H, 's'
	DB	00H, 's', 00H, 'u', 00H, 'e', 00H, 's', 00H, '.', 00H, 00H, 00H
	ORG $+2
$SG4294781445 DB 'T', 00H, 'e', 00H, 'x', 00H, 't', 00H, 'u', 00H, 'r', 00H
	DB	'e', 00H, '-', 00H, '>', 00H, 'M', 00H, 'a', 00H, 'p', 00H, ' '
	DB	00H, 'f', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	':', 00H, ' ', 00H, '0', 00H, 'x', 00H, '%', 00H, '0', 00H, '8'
	DB	00H, 'x', 00H, 00H, 00H
$SG4294781442 DB 'f', 00H, 'l', 00H, 'u', 00H, 's', 00H, 'h', 00H, 00H, 00H
$SG4294781450 DB 'Y', 00H, 'o', 00H, 'u', 00H, 'r', 00H, ' ', 00H, 'v', 00H
	DB	'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, ' ', 00H, 'd', 00H, 'r'
	DB	00H, 'i', 00H, 'v', 00H, 'e', 00H, 'r', 00H, ' ', 00H, 'r', 00H
	DB	'e', 00H, 'p', 00H, 'o', 00H, 'r', 00H, 't', 00H, 'e', 00H, 'd'
	DB	00H, ' ', 00H, 'a', 00H, 'n', 00H, ' ', 00H, 'i', 00H, 'n', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'n', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 'e', 00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H, '.', 00H
	DB	' ', 00H, 'P', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 's', 00H, 'e'
	DB	00H, ' ', 00H, 'c', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H
	DB	' ', 00H, 'f', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, 's', 00H, 'i', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	' ', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'd', 00H, 'w', 00H, 'a'
	DB	00H, 'r', 00H, 'e', 00H, ' ', 00H, '/', 00H, ' ', 00H, 'd', 00H
	DB	'r', 00H, 'i', 00H, 'v', 00H, 'e', 00H, 'r', 00H, ' ', 00H, 'i'
	DB	00H, 's', 00H, 's', 00H, 'u', 00H, 'e', 00H, 's', 00H, '.', 00H
	DB	00H, 00H
$SG4294781444 DB 'C', 00H, 'o', 00H, 'n', 00H, 'g', 00H, 'e', 00H, 's', 00H
	DB	't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, ' ', 00H, 'd', 00H, 'e'
	DB	00H, 't', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'e', 00H, 'd', 00H
	DB	',', 00H, ' ', 00H, 'd', 00H, 'r', 00H, 'o', 00H, 'p', 00H, 'p'
	DB	00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'b', 00H, 'i', 00H
	DB	't', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, 't'
	DB	00H, 'o', 00H, ' ', 00H, '%', 00H, 'd', 00H, ' ', 00H, 'k', 00H
	DB	'b', 00H, 'p', 00H, 's', 00H, 00H, 00H
	ORG $+3
$SG4294781447 DB ' ', 00H, 'T', 00H, 'h', 00H, 'i', 00H, 's', 00H, ' ', 00H
	DB	'e', 00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'c'
	DB	00H, 'a', 00H, 'n', 00H, ' ', 00H, 'a', 00H, 'l', 00H, 's', 00H
	DB	'o', 00H, ' ', 00H, 'o', 00H, 'c', 00H, 'c', 00H, 'u', 00H, 'r'
	DB	00H, ' ', 00H, 'i', 00H, 'f', 00H, ' ', 00H, 'y', 00H, 'o', 00H
	DB	'u', 00H, ' ', 00H, 'h', 00H, 'a', 00H, 'v', 00H, 'e', 00H, ' '
	DB	00H, 'e', 00H, 'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	'd', 00H, ' ', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'n', 00H, 'c'
	DB	00H, 'l', 00H, ' ', 00H, 'i', 00H, 'n', 00H, ' ', 00H, 'x', 00H
	DB	'2', 00H, '6', 00H, '4', 00H, ' ', 00H, 'c', 00H, 'u', 00H, 's'
	DB	00H, 't', 00H, 'o', 00H, 'm', 00H, ' ', 00H, 's', 00H, 'e', 00H
	DB	't', 00H, 't', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 's', 00H, '.'
	DB	00H, 00H, 00H
	ORG $+2
$SG4294781446 DB 'T', 00H, 'e', 00H, 'x', 00H, 't', 00H, 'u', 00H, 'r', 00H
	DB	'e', 00H, '-', 00H, '>', 00H, 'M', 00H, 'a', 00H, 'p', 00H, ' '
	DB	00H, 'f', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	':', 00H, ' ', 00H, '0', 00H, 'x', 00H, '%', 00H, '0', 00H, '8'
	DB	00H, 'x', 00H, ' ', 00H, '0', 00H, 'x', 00H, '%', 00H, '0', 00H
	DB	'8', 00H, 'x', 00H, 0dH, 00H, 0aH, 00H, 0dH, 00H, 0aH, 00H, '%'
	DB	00H, 's', 00H, 00H, 00H
$SG4294781441 DB 'T', 00H, 'o', 00H, 't', 00H, 'a', 00H, 'l', 00H, ' ', 00H
	DB	'f', 00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H, 's', 00H, ' '
	DB	00H, 'r', 00H, 'e', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'r', 00H
	DB	'e', 00H, 'd', 00H, ':', 00H, ' ', 00H, '%', 00H, 'd', 00H, ','
	DB	00H, ' ', 00H, 'n', 00H, 'u', 00H, 'm', 00H, 'b', 00H, 'e', 00H
	DB	'r', 00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 'l', 00H, 'a'
	DB	00H, 't', 00H, 'e', 00H, ' ', 00H, 'f', 00H, 'r', 00H, 'a', 00H
	DB	'm', 00H, 'e', 00H, 's', 00H, ':', 00H, ' ', 00H, '%', 00H, 'd'
	DB	00H, ' ', 00H, '(', 00H, '%', 00H, '0', 00H, '.', 00H, '2', 00H
	DB	'f', 00H, '%', 00H, '%', 00H, ')', 00H, ' ', 00H, '(', 00H, 'i'
	DB	00H, 't', 00H, '''', 00H, 's', 00H, ' ', 00H, 'o', 00H, 'k', 00H
	DB	'a', 00H, 'y', 00H, ' ', 00H, 'f', 00H, 'o', 00H, 'r', 00H, ' '
	DB	00H, 's', 00H, 'o', 00H, 'm', 00H, 'e', 00H, ' ', 00H, 'f', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H, 's', 00H, ' ', 00H, 't'
	DB	00H, 'o', 00H, ' ', 00H, 'b', 00H, 'e', 00H, ' ', 00H, 'l', 00H
	DB	'a', 00H, 't', 00H, 'e', 00H, ')', 00H, 00H, 00H
$SG4294781443 DB 'C', 00H, 'o', 00H, 'n', 00H, 'g', 00H, 'e', 00H, 's', 00H
	DB	't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, ' ', 00H, 'd', 00H, 'e'
	DB	00H, 't', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'e', 00H, 'd', 00H
	DB	',', 00H, ' ', 00H, 'd', 00H, 'r', 00H, 'o', 00H, 'p', 00H, 'p'
	DB	00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'b', 00H, 'i', 00H
	DB	't', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, 't'
	DB	00H, 'o', 00H, ' ', 00H, '%', 00H, 'd', 00H, ' ', 00H, 'k', 00H
	DB	'b', 00H, 'p', 00H, 's', 00H, 00H, 00H
_yuvFullMat DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	03e800000r			; 0.25
	DD	03f000000r			; 0.5
	DD	03e800000r			; 0.25
	DD	000000000r			; 0
	DD	0be7eff19r			; -0.24902
	DD	03efefef8r			; 0.498039
	DD	0be7eff19r			; -0.24902
	DD	03f008084r			; 0.501961
	DD	03efefef8r			; 0.498039
	DD	000000000r			; 0
	DD	0befefef8r			; -0.498039
	DD	03f008084r			; 0.501961
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	03e86809dr			; 0.2627
	DD	03f2d9168r			; 0.678
	DD	03d72e48fr			; 0.0593
	DD	000000000r			; 0
	DD	0be0e6b83r			; -0.139082
	DD	0beb7c936r			; -0.358957
	DD	03efefef8r			; 0.498039
	DD	03f008084r			; 0.501961
	DD	03efefef8r			; 0.498039
	DD	0beea7cbfr			; -0.457983
	DD	0bd2412cfr			; -0.040057
	DD	03f008084r			; 0.501961
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	03e59b3d0r			; 0.2126
	DD	03f371759r			; 0.7152
	DD	03d93dd98r			; 0.0722
	DD	000000000r			; 0
	DD	0bde9b952r			; -0.114123
	DD	0bec490a3r			; -0.383916
	DD	03efefef8r			; 0.498039
	DD	03f008084r			; 0.501961
	DD	03efefef8r			; 0.498039
	DD	0bee79d4er			; -0.452372
	DD	0bd3b0d52r			; -0.045667
	DD	03f008084r			; 0.501961
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	03e594af5r			; 0.2122
	DD	03f338866r			; 0.7013
	DD	03db126e9r			; 0.0865
	DD	000000000r			; 0
	DD	0bdecef67r			; -0.115691
	DD	0bec3c31er			; -0.382348
	DD	03efefef8r			; 0.498039
	DD	03f008084r			; 0.501961
	DD	03efefef8r			; 0.498039
	DD	0bee2ff6dr			; -0.443355
	DD	0bd5ffc54r			; -0.054684
	DD	03f008084r			; 0.501961
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	03e991687r			; 0.299
	DD	03f1645a2r			; 0.587
	DD	03de978d5r			; 0.114
	DD	000000000r			; 0
	DD	0be2c1b97r			; -0.168074
	DD	0bea8f12cr			; -0.329965
	DD	03efefef8r			; 0.498039
	DD	03f008084r			; 0.501961
	DD	03efefef8r			; 0.498039
	DD	0bed5870er			; -0.417046
	DD	0bda5e02fr			; -0.080994
	DD	03f008084r			; 0.501961
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
_yuvMat	DD	000000000r			; 0
	DD	03f5bdbe4r			; 0.858824
	DD	000000000r			; 0
	DD	03d808073r			; 0.062745
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f5bdbe4r			; 0.858824
	DD	03d808073r			; 0.062745
	DD	03f5bdbe4r			; 0.858824
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03d808073r			; 0.062745
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	03e5bdbe4r			; 0.214706
	DD	03edbdbe4r			; 0.429412
	DD	03e5bdbe4r			; 0.214706
	DD	03d808073r			; 0.062745
	DD	0be60e0ebr			; -0.219608
	DD	03ee0e0ebr			; 0.439216
	DD	0be60e0ebr			; -0.219608
	DD	03f008084r			; 0.501961
	DD	03ee0e0ebr			; 0.439216
	DD	000000000r			; 0
	DD	0bee0e0ebr			; -0.439216
	DD	03f008084r			; 0.501961
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	03e670718r			; 0.225613
	DD	03f15106fr			; 0.582282
	DD	03d5099e1r			; 0.050928
	DD	03d808073r			; 0.062745
	DD	0bdfb328br			; -0.122655
	DD	0bea21427r			; -0.31656
	DD	03ee0e0ebr			; 0.439216
	DD	03f008084r			; 0.501961
	DD	03ee0e0ebr			; 0.439216
	DD	0bececaacr			; -0.40389
	DD	0bd10b0f2r			; -0.035325
	DD	03f008084r			; 0.501961
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	03e3af7d3r			; 0.182586
	DD	03f1d3e3er			; 0.614231
	DD	03d7dfb0dr			; 0.062007
	DD	03d808073r			; 0.062745
	DD	0bdce1e71r			; -0.100644
	DD	0bead594fr			; -0.338572
	DD	03ee0e0ebr			; 0.439216
	DD	03f008084r			; 0.501961
	DD	03ee0e0ebr			; 0.439216
	DD	0becc4220r			; -0.398942
	DD	0bd24f65ar			; -0.040274
	DD	03f008084r			; 0.501961
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	03e3a9da6r			; 0.182242
	DD	03f1a2fe0r			; 0.602293
	DD	03d98244fr			; 0.074288
	DD	03d808073r			; 0.062745
	DD	0bdd0f388r			; -0.102027
	DD	0beaca409r			; -0.337189
	DD	03ee0e0ebr			; 0.439216
	DD	03f008084r			; 0.501961
	DD	03ee0e0ebr			; 0.439216
	DD	0bec82fd7r			; -0.39099
	DD	0bd4588a0r			; -0.048226
	DD	03f008084r			; 0.501961
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	03e8379b7r			; 0.256788
	DD	03f010e99r			; 0.504129
	DD	03dc882f1r			; 0.097906
	DD	03d808073r			; 0.062745
	DD	0be17c7c5r			; -0.148223
	DD	0be94fd09r			; -0.290993
	DD	03ee0e0ebr			; 0.439216
	DD	03f008084r			; 0.501961
	DD	03ee0e0ebr			; 0.439216
	DD	0bebc4eb5r			; -0.367788
	DD	0bd924852r			; -0.071427
	DD	03f008084r			; 0.501961
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
PUBLIC	??$_Construct@PAE@?$vector@EV?$allocator@E@std@@@std@@QAEXPAE0Uforward_iterator_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Construct<unsigned char *>
PUBLIC	??$_Construct@PAE@?$vector@EV?$allocator@E@std@@@std@@QAEXPAE0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Construct<unsigned char *>
PUBLIC	??$?0PAEX@?$vector@EV?$allocator@E@std@@@std@@QAE@PAE0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> ><unsigned char *,void>
PUBLIC	??$?0PAEPAE@?$_Ref_count_obj@$$CBV?$vector@EV?$allocator@E@std@@@std@@@std@@QAE@$$QAPAE0@Z ; std::_Ref_count_obj<std::vector<unsigned char,std::allocator<unsigned char> > const >::_Ref_count_obj<std::vector<unsigned char,std::allocator<unsigned char> > const ><unsigned char *,unsigned char *>
PUBLIC	??$forward@PAE@std@@YA$$QAPAEAAPAE@Z		; std::forward<unsigned char *>
PUBLIC	??$make_shared@$$CBV?$vector@EV?$allocator@E@std@@@std@@PAEPAE@std@@YA?AV?$shared_ptr@$$CBV?$vector@EV?$allocator@E@std@@@std@@@0@$$QAPAE0@Z ; std::make_shared<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned char *,unsigned char *>
PUBLIC	?Clear@?$List@PAX@@QAEXXZ			; List<void *>::Clear
PUBLIC	?Add@?$List@PAX@@QAEIABQAX@Z			; List<void *>::Add
PUBLIC	?Clear@?$List@W4PacketType@@@@QAEXXZ		; List<enum PacketType>::Clear
PUBLIC	?SetSize@?$List@UVideoSegment@@@@QAEHI@Z	; List<VideoSegment>::SetSize
PUBLIC	?_Reset@?$_Func_class@X$$$V@std@@IAEXABV12@@Z	; std::_Func_class<void>::_Reset
PUBLIC	?Array@?$List@UVideoPacketData@@@@QBEPAUVideoPacketData@@XZ ; List<VideoPacketData>::Array
PUBLIC	??6?$List@PAX@@QAEAAV0@ABQAX@Z			; List<void *>::operator<<
PUBLIC	?Num@?$List@PAX@@QBEIXZ				; List<void *>::Num
PUBLIC	?Array@?$List@PAX@@QBEPAPAXXZ			; List<void *>::Array
PUBLIC	??1?$List@PAX@@QAE@XZ				; List<void *>::~List<void *>
PUBLIC	??0?$List@PAX@@QAE@XZ				; List<void *>::List<void *>
PUBLIC	??A?$List@W4PacketType@@@@QBEAAW4PacketType@@I@Z ; List<enum PacketType>::operator[]
PUBLIC	??1?$List@W4PacketType@@@@QAE@XZ		; List<enum PacketType>::~List<enum PacketType>
PUBLIC	??0?$List@W4PacketType@@@@QAE@XZ		; List<enum PacketType>::List<enum PacketType>
PUBLIC	??A?$List@UDataPacket@@@@QBEAAUDataPacket@@I@Z	; List<DataPacket>::operator[]
PUBLIC	??1?$List@UDataPacket@@@@QAE@XZ			; List<DataPacket>::~List<DataPacket>
PUBLIC	??0?$List@UDataPacket@@@@QAE@XZ			; List<DataPacket>::List<DataPacket>
PUBLIC	?Remove@?$List@UFrameAudio@@@@QAEXI@Z		; List<FrameAudio>::Remove
PUBLIC	?Clear@?$CircularList@I@@QAEXXZ			; CircularList<unsigned int>::Clear
PUBLIC	?Last@?$List@UVideoSegment@@@@QBEAAUVideoSegment@@XZ ; List<VideoSegment>::Last
PUBLIC	??A?$List@UVideoSegment@@@@QAEAAUVideoSegment@@I@Z ; List<VideoSegment>::operator[]
PUBLIC	?CreateNew@?$List@UVideoSegment@@@@QAEPAUVideoSegment@@XZ ; List<VideoSegment>::CreateNew
PUBLIC	?Remove@?$List@UVideoSegment@@@@QAEXI@Z		; List<VideoSegment>::Remove
PUBLIC	?Num@?$List@UVideoSegment@@@@QBEIXZ		; List<VideoSegment>::Num
PUBLIC	??4?$function@$$A6AXXZ@std@@QAEAAV01@ABV01@@Z	; std::function<void __cdecl(void)>::operator=
PUBLIC	??A?$List@UVideoPacketData@@@@QAEAAUVideoPacketData@@I@Z ; List<VideoPacketData>::operator[]
PUBLIC	?Clear@?$List@UVideoPacketData@@@@QAEXXZ	; List<VideoPacketData>::Clear
PUBLIC	?TransferFrom@?$List@UVideoPacketData@@@@QAEXAAV1@@Z ; List<VideoPacketData>::TransferFrom
PUBLIC	?SetSize@?$List@UVideoPacketData@@@@QAEHI@Z	; List<VideoPacketData>::SetSize
PUBLIC	?Num@?$List@UVideoPacketData@@@@QBEIXZ		; List<VideoPacketData>::Num
PUBLIC	??1?$List@UVideoPacketData@@@@QAE@XZ		; List<VideoPacketData>::~List<VideoPacketData>
PUBLIC	??0?$List@UVideoPacketData@@@@QAE@XZ		; List<VideoPacketData>::List<VideoPacketData>
PUBLIC	?MainCaptureLoop@OBS@@AAEXXZ			; OBS::MainCaptureLoop
PUBLIC	?DrawPreview@OBS@@AAEXABUVect2@@00HW4PreviewDrawType@@@Z ; OBS::DrawPreview
PUBLIC	?EncodeLoop@OBS@@AAEXXZ				; OBS::EncodeLoop
PUBLIC	?FlushBufferedVideo@OBS@@AAEIXZ			; OBS::FlushBufferedVideo
PUBLIC	?SleepToNS@@YG_N_K@Z				; SleepToNS
PUBLIC	?ProcessFrame@OBS@@AAE_NAAUFrameProcessInfo@@@Z	; OBS::ProcessFrame
PUBLIC	??4StopInfo@OBS@@QAEAAU01@ABU01@@Z		; OBS::StopInfo::operator=
PUBLIC	?HandleStreamStopInfo@OBS@@AAE_NAAUStopInfo@1@W4PacketType@@ABUVideoSegment@@@Z ; OBS::HandleStreamStopInfo
PUBLIC	?SendFrame@OBS@@AAEXAAUVideoSegment@@_K@Z	; OBS::SendFrame
PUBLIC	??0EncoderPicture@@QAE@XZ			; EncoderPicture::EncoderPicture
PUBLIC	?BufferVideoData@OBS@@AAE_NABV?$List@UDataPacket@@@@ABV?$List@W4PacketType@@@@KK_KAAUVideoSegment@@@Z ; OBS::BufferVideoData
PUBLIC	?Convert444Thread@@YGKPAUConvert444Data@@@Z	; Convert444Thread
PUBLIC	?GetRenderFrameControlSize@OBS@@QBE?AUVect2@@XZ	; OBS::GetRenderFrameControlSize
PUBLIC	?GetRenderFrameOffset@OBS@@QBE?AUVect2@@XZ	; OBS::GetRenderFrameOffset
PUBLIC	?GetRenderFrameSize@OBS@@QBE?AUVect2@@XZ	; OBS::GetRenderFrameSize
PUBLIC	?Clear@VideoSegment@@QAEXXZ			; VideoSegment::Clear
PUBLIC	??1VideoSegment@@QAE@XZ				; VideoSegment::~VideoSegment
PUBLIC	??0VideoSegment@@QAE@XZ				; VideoSegment::VideoSegment
PUBLIC	?Clear@VideoPacketData@@QAEXXZ			; VideoPacketData::Clear
PUBLIC	?SetViewport@@YAXMMMM@Z				; SetViewport
PUBLIC	?Ortho@@YAXMMMMMM@Z				; Ortho
PUBLIC	?ClearColorBuffer@@YAXK@Z			; ClearColorBuffer
PUBLIC	?BlendFunction@@YAXW4GSBlendType@@0M@Z		; BlendFunction
PUBLIC	?EnableBlending@@YAXH@Z				; EnableBlending
PUBLIC	?SetRenderTarget@@YAXPAVTexture@@@Z		; SetRenderTarget
PUBLIC	?LoadVertexShader@@YAXPAVShader@@@Z		; LoadVertexShader
PUBLIC	??K@YA?AUVect2@@MABU0@@Z			; operator/
PUBLIC	__InlineInterlockedExchangePointer
PUBLIC	?MainCaptureThread@OBS@@CGKPAX@Z		; OBS::MainCaptureThread
PUBLIC	?EncodeThread@OBS@@CGKPAX@Z			; OBS::EncodeThread
	ALIGN	4

__Tuple_alloc DB 01H DUP (?)
	ALIGN	4

_ignore	DB	01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
	ALIGN	4

_piecewise_construct DB 01H DUP (?)
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Construct@PAE@?$vector@EV?$allocator@E@std@@@std@@QAEXPAE0Uforward_iterator_tag@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Construct@PAE@?$vector@EV?$allocator@E@std@@@std@@QAEXPAE0Uforward_iterator_tag@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Construct@PAE@?$vector@EV?$allocator@E@std@@@std@@QAEXPAE0Uforward_iterator_tag@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Construct@PAE@?$vector@EV?$allocator@E@std@@@std@@QAEXPAE0Uforward_iterator_tag@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Construct@PAE@?$vector@EV?$allocator@E@std@@@std@@QAEXPAE0Uforward_iterator_tag@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Construct@PAE@?$vector@EV?$allocator@E@std@@@std@@QAEXPAE0Uforward_iterator_tag@1@@Z$2
__catchsym$??$_Construct@PAE@?$vector@EV?$allocator@E@std@@@std@@QAEXPAE0Uforward_iterator_tag@1@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Construct@PAE@?$vector@EV?$allocator@E@std@@@std@@QAEXPAE0Uforward_iterator_tag@1@@Z$0
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
_ignore$initializer$ DD FLAT:??__Eignore@std@@YAXXZ
__Tuple_alloc$initializer$ DD FLAT:??__E_Tuple_alloc@std@@YAXXZ
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obsvideocapture.cpp
;	COMDAT ?EncodeThread@OBS@@CGKPAX@Z
_TEXT	SEGMENT
_lpUnused$ = 8						; size = 4
?EncodeThread@OBS@@CGKPAX@Z PROC			; OBS::EncodeThread, COMDAT

; 37   : {

	push	ebp
	mov	ebp, esp

; 38   :     App->EncodeLoop();

	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?EncodeLoop@OBS@@AAEXXZ			; OBS::EncodeLoop

; 39   :     return 0;

	xor	eax, eax

; 40   : }

	pop	ebp
	ret	4
?EncodeThread@OBS@@CGKPAX@Z ENDP			; OBS::EncodeThread
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obsvideocapture.cpp
;	COMDAT ?MainCaptureThread@OBS@@CGKPAX@Z
_TEXT	SEGMENT
_lpUnused$ = 8						; size = 4
?MainCaptureThread@OBS@@CGKPAX@Z PROC			; OBS::MainCaptureThread, COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp

; 44   :     App->MainCaptureLoop();

	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?MainCaptureLoop@OBS@@AAEXXZ		; OBS::MainCaptureLoop

; 45   :     return 0;

	xor	eax, eax

; 46   : }

	pop	ebp
	ret	4
?MainCaptureThread@OBS@@CGKPAX@Z ENDP			; OBS::MainCaptureThread
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
;	COMDAT __InlineInterlockedExchangePointer
_TEXT	SEGMENT
_Destination$ = 8					; size = 4
_Value$ = 12						; size = 4
__InlineInterlockedExchangePointer PROC			; COMDAT

; 5256 : {

	push	ebp
	mov	ebp, esp

; 5257 :     return (PVOID)InterlockedExchange((LONG volatile *) Destination,
; 5258 :                                       (LONG) Value);

	mov	eax, DWORD PTR _Value$[ebp]
	mov	ecx, DWORD PTR _Destination$[ebp]
	xchg	DWORD PTR [ecx], eax

; 5259 : }

	pop	ebp
	ret	0
__InlineInterlockedExchangePointer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\xmath.h
;	COMDAT ??K@YA?AUVect2@@MABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_f$ = 12						; size = 4
_v$ = 16						; size = 4
??K@YA?AUVect2@@MABU0@@Z PROC				; operator/, COMDAT

; 273  : inline Vect2 operator/(float f, const Vect2 &v) {return Vect2(f/v.x, f/v.y);}

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR _f$[ebp]
	divss	xmm0, DWORD PTR [eax+4]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR _f$[ebp]
	divss	xmm0, DWORD PTR [ecx]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0Vect2@@QAE@MM@Z
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	ebp
	ret	0
??K@YA?AUVect2@@MABU0@@Z ENDP				; operator/
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 70   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3451 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\tuple
;	COMDAT ??__Eignore@std@@YAXXZ
text$di	SEGMENT
??__Eignore@std@@YAXXZ PROC				; std::`dynamic initializer for 'ignore'', COMDAT

; 59   : const _Ignore ignore;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET _ignore
	call	??0_Ignore@std@@QAE@XZ			; std::_Ignore::_Ignore
	pop	ebp
	ret	0
??__Eignore@std@@YAXXZ ENDP				; std::`dynamic initializer for 'ignore''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\tuple
;	COMDAT ??__E_Tuple_alloc@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__E_Tuple_alloc@std@@YAXXZ PROC			; std::`dynamic initializer for '_Tuple_alloc'', COMDAT

; 66   : const _Tuple_alloc_t _Tuple_alloc = _Tuple_alloc_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__E_Tuple_alloc@std@@YAXXZ ENDP			; std::`dynamic initializer for '_Tuple_alloc''
text$di	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\graphicssystem.h
;	COMDAT ?LoadVertexShader@@YAXPAVShader@@@Z
_TEXT	SEGMENT
_vShader$ = 8						; size = 4
?LoadVertexShader@@YAXPAVShader@@@Z PROC		; LoadVertexShader, COMDAT

; 673  : inline void  LoadVertexShader(Shader *vShader)                  {GS->LoadVertexShader(vShader);}

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _vShader$[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp_?GS@@3PAVGraphicsSystem@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?GS@@3PAVGraphicsSystem@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+80]
	call	eax
	pop	ebp
	ret	0
?LoadVertexShader@@YAXPAVShader@@@Z ENDP		; LoadVertexShader
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\graphicssystem.h
;	COMDAT ?SetRenderTarget@@YAXPAVTexture@@@Z
_TEXT	SEGMENT
_texture$ = 8						; size = 4
?SetRenderTarget@@YAXPAVTexture@@@Z PROC		; SetRenderTarget, COMDAT

; 680  : inline void  SetRenderTarget(Texture *texture) {GS->SetRenderTarget(texture);}

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _texture$[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp_?GS@@3PAVGraphicsSystem@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?GS@@3PAVGraphicsSystem@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+96]
	call	eax
	pop	ebp
	ret	0
?SetRenderTarget@@YAXPAVTexture@@@Z ENDP		; SetRenderTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\graphicssystem.h
;	COMDAT ?EnableBlending@@YAXH@Z
_TEXT	SEGMENT
_bEnabled$ = 8						; size = 4
?EnableBlending@@YAXH@Z PROC				; EnableBlending, COMDAT

; 685  : inline void  EnableBlending(BOOL bEnabled)                      {GS->EnableBlending(bEnabled);}

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _bEnabled$[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp_?GS@@3PAVGraphicsSystem@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?GS@@3PAVGraphicsSystem@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+104]
	call	eax
	pop	ebp
	ret	0
?EnableBlending@@YAXH@Z ENDP				; EnableBlending
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\graphicssystem.h
;	COMDAT ?BlendFunction@@YAXW4GSBlendType@@0M@Z
_TEXT	SEGMENT
_srcFactor$ = 8						; size = 4
_destFactor$ = 12					; size = 4
_fFactor$ = 16						; size = 4
?BlendFunction@@YAXW4GSBlendType@@0M@Z PROC		; BlendFunction, COMDAT

; 686  : inline void  BlendFunction(GSBlendType srcFactor, GSBlendType destFactor, float fFactor=1.0f) {GS->BlendFunction(srcFactor, destFactor, fFactor);}

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR _fFactor$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _destFactor$[ebp]
	push	eax
	mov	ecx, DWORD PTR _srcFactor$[ebp]
	push	ecx
	mov	edx, DWORD PTR __imp_?GS@@3PAVGraphicsSystem@@A
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __imp_?GS@@3PAVGraphicsSystem@@A
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+108]
	call	eax
	pop	ebp
	ret	0
?BlendFunction@@YAXW4GSBlendType@@0M@Z ENDP		; BlendFunction
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\graphicssystem.h
;	COMDAT ?ClearColorBuffer@@YAXK@Z
_TEXT	SEGMENT
_color$ = 8						; size = 4
?ClearColorBuffer@@YAXK@Z PROC				; ClearColorBuffer, COMDAT

; 689  :     {GS->ClearColorBuffer(color);}

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _color$[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp_?GS@@3PAVGraphicsSystem@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?GS@@3PAVGraphicsSystem@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	pop	ebp
	ret	0
?ClearColorBuffer@@YAXK@Z ENDP				; ClearColorBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\graphicssystem.h
;	COMDAT ?Ortho@@YAXMMMMMM@Z
_TEXT	SEGMENT
_left$ = 8						; size = 4
_right$ = 12						; size = 4
_top$ = 16						; size = 4
_bottom$ = 20						; size = 4
_znear$ = 24						; size = 4
_zfar$ = 28						; size = 4
?Ortho@@YAXMMMMMM@Z PROC				; Ortho, COMDAT

; 705  :     {GS->Ortho(left, right, top, bottom, znear, zfar);}

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR _zfar$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _znear$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _bottom$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _top$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _right$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _left$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR __imp_?GS@@3PAVGraphicsSystem@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __imp_?GS@@3PAVGraphicsSystem@@A
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+128]
	call	edx
	pop	ebp
	ret	0
?Ortho@@YAXMMMMMM@Z ENDP				; Ortho
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\graphicssystem.h
;	COMDAT ?SetViewport@@YAXMMMM@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_width$ = 16						; size = 4
_height$ = 20						; size = 4
?SetViewport@@YAXMMMM@Z PROC				; SetViewport, COMDAT

; 709  : inline void  SetViewport(float x, float y, float width, float height) {GS->SetViewport(x, y, width, height);}

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR _height$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _width$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR __imp_?GS@@3PAVGraphicsSystem@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __imp_?GS@@3PAVGraphicsSystem@@A
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+136]
	call	edx
	pop	ebp
	ret	0
?SetViewport@@YAXMMMM@Z ENDP				; SetViewport
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ?Clear@VideoPacketData@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@VideoPacketData@@QAEXXZ PROC			; VideoPacketData::Clear, COMDAT
; _this$ = ecx

; 583  :     inline void Clear() {data.Clear();}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@E@@QAEXXZ			; List<unsigned char>::Clear
	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@VideoPacketData@@QAEXXZ ENDP			; VideoPacketData::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ??0VideoSegment@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0VideoSegment@@QAE@XZ PROC				; VideoSegment::VideoSegment, COMDAT
; _this$ = ecx

; 592  :     inline VideoSegment() : timestamp(0), pts(0) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$List@UVideoPacketData@@@@QAE@XZ	; List<VideoPacketData>::List<VideoPacketData>
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0VideoSegment@@QAE@XZ ENDP				; VideoSegment::VideoSegment
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ??1VideoSegment@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1VideoSegment@@QAE@XZ PROC				; VideoSegment::~VideoSegment, COMDAT
; _this$ = ecx

; 593  :     inline ~VideoSegment() {Clear();}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@VideoSegment@@QAEXXZ		; VideoSegment::Clear
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$List@UVideoPacketData@@@@QAE@XZ	; List<VideoPacketData>::~List<VideoPacketData>
	mov	esp, ebp
	pop	ebp
	ret	0
??1VideoSegment@@QAE@XZ ENDP				; VideoSegment::~VideoSegment
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ?Clear@VideoSegment@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
?Clear@VideoSegment@@QAEXXZ PROC			; VideoSegment::Clear, COMDAT
; _this$ = ecx

; 595  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 596  :         for(UINT i=0; i<packets.Num(); i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN3@Clear
$LN2@Clear:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN3@Clear:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Num@?$List@UVideoPacketData@@@@QBEIXZ	; List<VideoPacketData>::Num
	cmp	DWORD PTR _i$1[ebp], eax
	jae	SHORT $LN1@Clear

; 597  :             packets[i].Clear();

	mov	ecx, DWORD PTR _i$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UVideoPacketData@@@@QAEAAUVideoPacketData@@I@Z ; List<VideoPacketData>::operator[]
	mov	ecx, eax
	call	?Clear@VideoPacketData@@QAEXXZ		; VideoPacketData::Clear
	jmp	SHORT $LN2@Clear
$LN1@Clear:

; 598  :         packets.Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@UVideoPacketData@@@@QAEXXZ ; List<VideoPacketData>::Clear

; 599  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@VideoSegment@@QAEXXZ ENDP			; VideoSegment::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ?GetRenderFrameSize@OBS@@QBE?AUVect2@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetRenderFrameSize@OBS@@QBE?AUVect2@@XZ PROC		; OBS::GetRenderFrameSize, COMDAT
; _this$ = ecx

; 1224 :     inline Vect2 GetRenderFrameSize() const         {return Vect2(float(renderFrameWidth), float(renderFrameHeight));}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+640]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+636]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0Vect2@@QAE@MM@Z
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetRenderFrameSize@OBS@@QBE?AUVect2@@XZ ENDP		; OBS::GetRenderFrameSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ?GetRenderFrameOffset@OBS@@QBE?AUVect2@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetRenderFrameOffset@OBS@@QBE?AUVect2@@XZ PROC		; OBS::GetRenderFrameOffset, COMDAT
; _this$ = ecx

; 1225 :     inline Vect2 GetRenderFrameOffset() const       {return Vect2(float(renderFrameX), float(renderFrameY));}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+648]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+644]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0Vect2@@QAE@MM@Z
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetRenderFrameOffset@OBS@@QBE?AUVect2@@XZ ENDP		; OBS::GetRenderFrameOffset
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ?GetRenderFrameControlSize@OBS@@QBE?AUVect2@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetRenderFrameControlSize@OBS@@QBE?AUVect2@@XZ PROC	; OBS::GetRenderFrameControlSize, COMDAT
; _this$ = ecx

; 1226 :     inline Vect2 GetRenderFrameControlSize() const  {return Vect2(float(renderFrameCtrlWidth), float(renderFrameCtrlHeight));}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+656]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+652]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0Vect2@@QAE@MM@Z
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetRenderFrameControlSize@OBS@@QBE?AUVect2@@XZ ENDP	; OBS::GetRenderFrameControlSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obsvideocapture.cpp
;	COMDAT ?Convert444Thread@@YGKPAUConvert444Data@@@Z
_TEXT	SEGMENT
__curProfiler$1 = -52					; size = 48
tv75 = -4						; size = 4
_data$ = 8						; size = 4
?Convert444Thread@@YGKPAUConvert444Data@@@Z PROC	; Convert444Thread, COMDAT

; 61   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
$LN6@Convert444:

; 62   :     do
; 63   :     {
; 64   :         WaitForSingleObject(data->hSignalConvert, INFINITE);

	push	-1
	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	DWORD PTR __imp__WaitForSingleObject@8

; 65   :         if(data->bKillThread) break;

	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+17]
	test	eax, eax
	je	SHORT $LN3@Convert444
	jmp	$LN4@Convert444
$LN3@Convert444:

; 66   :         profileParallelSegment("Convert444Thread", "Convert444Threads", data->numThreads);

	mov	ecx, DWORD PTR _data$[ebp]
	cmp	DWORD PTR [ecx+52], 1
	jne	SHORT $LN9@Convert444
	mov	DWORD PTR tv75[ebp], OFFSET $SG4294781478
	jmp	SHORT $LN10@Convert444
$LN9@Convert444:
	mov	DWORD PTR tv75[ebp], OFFSET $SG4294781477
$LN10@Convert444:
	push	0
	mov	edx, DWORD PTR tv75[ebp]
	push	edx
	lea	ecx, DWORD PTR __curProfiler$1[ebp]
	call	DWORD PTR __imp_??0ProfilerNode@@QAE@PB_W_N@Z
	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	lea	ecx, DWORD PTR __curProfiler$1[ebp]
	call	DWORD PTR __imp_?SetParallelCallCount@ProfilerNode@@QAEXK@Z

; 67   :         if(data->bNV12)

	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+16]
	test	eax, eax
	je	SHORT $LN2@Convert444

; 68   :             Convert444toNV12(data->input, data->width, data->inPitch, data->outPitch, data->height, data->startY, data->endY, data->output);

	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	mov	eax, DWORD PTR [edx+48]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	?Convert444toNV12@@YAXPAEHHHHHHPAPAE@Z	; Convert444toNV12
	add	esp, 32					; 00000020H

; 69   :         else

	jmp	SHORT $LN1@Convert444
$LN2@Convert444:

; 70   :             Convert444toNV12(data->input, data->width, data->inPitch, data->width, data->height, data->startY, data->endY, data->output);

	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	mov	eax, DWORD PTR [edx+48]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	?Convert444toNV12@@YAXPAEHHHHHHPAPAE@Z	; Convert444toNV12
	add	esp, 32					; 00000020H
$LN1@Convert444:

; 71   : 
; 72   :         SetEvent(data->hSignalComplete);

	mov	ecx, DWORD PTR _data$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	DWORD PTR __imp__SetEvent@4

; 73   :     }while(!data->bKillThread);

	lea	ecx, DWORD PTR __curProfiler$1[ebp]
	call	DWORD PTR __imp_??1ProfilerNode@@QAE@XZ
	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, BYTE PTR [eax+17]
	test	ecx, ecx
	je	$LN6@Convert444
$LN4@Convert444:

; 74   : 
; 75   :     return 0;

	xor	eax, eax

; 76   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Convert444Thread@@YGKPAUConvert444Data@@@Z ENDP	; Convert444Thread
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obsvideocapture.cpp
;	COMDAT ?BufferVideoData@OBS@@AAE_NABV?$List@UDataPacket@@@@ABV?$List@W4PacketType@@@@KK_KAAUVideoSegment@@@Z
_TEXT	SEGMENT
tv240 = -40						; size = 8
tv237 = -32						; size = 8
tv217 = -24						; size = 4
_i$1 = -20						; size = 4
_segmentIn$ = -16					; size = 4
_i$2 = -12						; size = 4
_this$ = -8						; size = 4
_dataReady$ = -1					; size = 1
_inputPackets$ = 8					; size = 4
_inputTypes$ = 12					; size = 4
_timestamp$ = 16					; size = 4
_out_pts$ = 20						; size = 4
_firstFrameTime$ = 24					; size = 8
_segmentOut$ = 32					; size = 4
?BufferVideoData@OBS@@AAE_NABV?$List@UDataPacket@@@@ABV?$List@W4PacketType@@@@KK_KAAUVideoSegment@@@Z PROC ; OBS::BufferVideoData, COMDAT
; _this$ = ecx

; 79   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 80   :     VideoSegment &segmentIn = *bufferedVideo.CreateNew();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 960				; 000003c0H
	call	?CreateNew@?$List@UVideoSegment@@@@QAEPAUVideoSegment@@XZ ; List<VideoSegment>::CreateNew
	mov	DWORD PTR _segmentIn$[ebp], eax

; 81   :     segmentIn.timestamp = timestamp;

	mov	eax, DWORD PTR _segmentIn$[ebp]
	mov	ecx, DWORD PTR _timestamp$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 82   :     segmentIn.pts = out_pts;

	mov	edx, DWORD PTR _segmentIn$[ebp]
	mov	eax, DWORD PTR _out_pts$[ebp]
	mov	DWORD PTR [edx+12], eax

; 83   : 
; 84   :     segmentIn.packets.SetSize(inputPackets.Num());

	mov	ecx, DWORD PTR _inputPackets$[ebp]
	call	?Num@?$List@UDataPacket@@@@QBEIXZ	; List<DataPacket>::Num
	push	eax
	mov	ecx, DWORD PTR _segmentIn$[ebp]
	call	?SetSize@?$List@UVideoPacketData@@@@QAEHI@Z ; List<VideoPacketData>::SetSize

; 85   :     for(UINT i=0; i<inputPackets.Num(); i++)

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN8@BufferVide
$LN7@BufferVide:
	mov	ecx, DWORD PTR _i$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$2[ebp], ecx
$LN8@BufferVide:
	mov	ecx, DWORD PTR _inputPackets$[ebp]
	call	?Num@?$List@UDataPacket@@@@QBEIXZ	; List<DataPacket>::Num
	cmp	DWORD PTR _i$2[ebp], eax
	jae	SHORT $LN6@BufferVide

; 86   :     {
; 87   :         segmentIn.packets[i].data.CopyArray(inputPackets[i].lpPacket, inputPackets[i].size);

	mov	edx, DWORD PTR _i$2[ebp]
	push	edx
	mov	ecx, DWORD PTR _inputPackets$[ebp]
	call	??A?$List@UDataPacket@@@@QBEAAUDataPacket@@I@Z ; List<DataPacket>::operator[]
	mov	eax, DWORD PTR [eax+4]
	push	eax
	mov	ecx, DWORD PTR _i$2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _inputPackets$[ebp]
	call	??A?$List@UDataPacket@@@@QBEAAUDataPacket@@I@Z ; List<DataPacket>::operator[]
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR _i$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _segmentIn$[ebp]
	call	??A?$List@UVideoPacketData@@@@QAEAAUVideoPacketData@@I@Z ; List<VideoPacketData>::operator[]
	mov	ecx, eax
	call	?CopyArray@?$List@E@@QAEXPBEI@Z		; List<unsigned char>::CopyArray

; 88   :         segmentIn.packets[i].type =  inputTypes[i];

	mov	ecx, DWORD PTR _i$2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _inputTypes$[ebp]
	call	??A?$List@W4PacketType@@@@QBEAAW4PacketType@@I@Z ; List<enum PacketType>::operator[]
	mov	esi, eax
	mov	edx, DWORD PTR _i$2[ebp]
	push	edx
	mov	ecx, DWORD PTR _segmentIn$[ebp]
	call	??A?$List@UVideoPacketData@@@@QAEAAUVideoPacketData@@I@Z ; List<VideoPacketData>::operator[]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax+8], ecx

; 89   :     }

	jmp	SHORT $LN7@BufferVide
$LN6@BufferVide:

; 90   : 
; 91   :     bool dataReady = false;

	mov	BYTE PTR _dataReady$[ebp], 0

; 92   : 
; 93   :     OSEnterMutex(hSoundDataMutex);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1152]
	push	eax
	call	DWORD PTR __imp_?OSEnterMutex@@YGXPAX@Z

; 94   :     for (UINT i = 0; i < pendingAudioFrames.Num(); i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN5@BufferVide
$LN4@BufferVide:
	mov	ecx, DWORD PTR _i$1[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$1[ebp], ecx
$LN5@BufferVide:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1208				; 000004b8H
	call	?Num@?$List@UFrameAudio@@@@QBEIXZ	; List<FrameAudio>::Num
	cmp	DWORD PTR _i$1[ebp], eax
	jae	$LN3@BufferVide

; 95   :     {
; 96   :         if (firstFrameTime < pendingAudioFrames[i].timestamp && pendingAudioFrames[i].timestamp - firstFrameTime >= bufferedVideo[0].timestamp)

	mov	edx, DWORD PTR _i$1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1208				; 000004b8H
	call	??A?$List@UFrameAudio@@@@QAEAAUFrameAudio@@I@Z ; List<FrameAudio>::operator[]
	mov	DWORD PTR tv217[ebp], eax
	mov	eax, DWORD PTR tv217[ebp]
	mov	ecx, DWORD PTR _firstFrameTime$[ebp+4]
	cmp	ecx, DWORD PTR [eax+12]
	ja	SHORT $LN2@BufferVide
	jb	SHORT $LN11@BufferVide
	mov	edx, DWORD PTR tv217[ebp]
	mov	eax, DWORD PTR _firstFrameTime$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN2@BufferVide
$LN11@BufferVide:
	mov	ecx, DWORD PTR _i$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1208				; 000004b8H
	call	??A?$List@UFrameAudio@@@@QAEAAUFrameAudio@@I@Z ; List<FrameAudio>::operator[]
	mov	esi, DWORD PTR [eax+8]
	sub	esi, DWORD PTR _firstFrameTime$[ebp]
	mov	edi, DWORD PTR [eax+12]
	sbb	edi, DWORD PTR _firstFrameTime$[ebp+4]
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 960				; 000003c0H
	call	??A?$List@UVideoSegment@@@@QAEAAUVideoSegment@@I@Z ; List<VideoSegment>::operator[]
	mov	edx, DWORD PTR [eax+8]
	xor	eax, eax
	mov	DWORD PTR tv237[ebp], esi
	mov	DWORD PTR tv237[ebp+4], edi
	mov	DWORD PTR tv240[ebp], edx
	mov	DWORD PTR tv240[ebp+4], eax
	mov	ecx, DWORD PTR tv237[ebp+4]
	cmp	ecx, DWORD PTR tv240[ebp+4]
	jb	SHORT $LN2@BufferVide
	ja	SHORT $LN12@BufferVide
	mov	edx, DWORD PTR tv237[ebp]
	cmp	edx, DWORD PTR tv240[ebp]
	jb	SHORT $LN2@BufferVide
$LN12@BufferVide:

; 97   :         {
; 98   :             dataReady = true;

	mov	BYTE PTR _dataReady$[ebp], 1

; 99   :             break;

	jmp	SHORT $LN3@BufferVide
$LN2@BufferVide:

; 100  :         }
; 101  :     }

	jmp	$LN4@BufferVide
$LN3@BufferVide:

; 102  :     OSLeaveMutex(hSoundDataMutex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1152]
	push	ecx
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z

; 103  : 
; 104  :     if (dataReady)

	movzx	edx, BYTE PTR _dataReady$[ebp]
	test	edx, edx
	je	SHORT $LN1@BufferVide

; 105  :     {
; 106  :         segmentOut.packets.TransferFrom(bufferedVideo[0].packets);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 960				; 000003c0H
	call	??A?$List@UVideoSegment@@@@QAEAAUVideoSegment@@I@Z ; List<VideoSegment>::operator[]
	push	eax
	mov	ecx, DWORD PTR _segmentOut$[ebp]
	call	?TransferFrom@?$List@UVideoPacketData@@@@QAEXAAV1@@Z ; List<VideoPacketData>::TransferFrom

; 107  :         segmentOut.timestamp = bufferedVideo[0].timestamp;

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 960				; 000003c0H
	call	??A?$List@UVideoSegment@@@@QAEAAUVideoSegment@@I@Z ; List<VideoSegment>::operator[]
	mov	ecx, DWORD PTR _segmentOut$[ebp]
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx

; 108  :         segmentOut.pts = bufferedVideo[0].pts;

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 960				; 000003c0H
	call	??A?$List@UVideoSegment@@@@QAEAAUVideoSegment@@I@Z ; List<VideoSegment>::operator[]
	mov	ecx, DWORD PTR _segmentOut$[ebp]
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx

; 109  :         bufferedVideo.Remove(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 960				; 000003c0H
	call	?Remove@?$List@UVideoSegment@@@@QAEXI@Z	; List<VideoSegment>::Remove

; 110  : 
; 111  :         return true;

	mov	al, 1
	jmp	SHORT $LN9@BufferVide
$LN1@BufferVide:

; 112  :     }
; 113  : 
; 114  :     return false;

	xor	al, al
$LN9@BufferVide:

; 115  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?BufferVideoData@OBS@@AAE_NABV?$List@UDataPacket@@@@ABV?$List@W4PacketType@@@@KK_KAAUVideoSegment@@@Z ENDP ; OBS::BufferVideoData
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obsvideocapture.cpp
;	COMDAT ??0EncoderPicture@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0EncoderPicture@@QAE@XZ PROC				; EncoderPicture::EncoderPicture, COMDAT
; _this$ = ecx

; 123  :     EncoderPicture() : picOut(nullptr), mfxOut(nullptr) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0EncoderPicture@@QAE@XZ ENDP				; EncoderPicture::EncoderPicture
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obsvideocapture.cpp
;	COMDAT ?SendFrame@OBS@@AAEXAAUVideoSegment@@_K@Z
_TEXT	SEGMENT
_shared_data$1 = -84					; size = 8
_shared_data$2 = -76					; size = 8
$T3 = -68						; size = 4
$T4 = -64						; size = 4
$T5 = -60						; size = 4
$T6 = -56						; size = 4
tv394 = -52						; size = 4
tv355 = -48						; size = 4
tv297 = -44						; size = 4
tv236 = -40						; size = 4
tv209 = -36						; size = 4
tv167 = -32						; size = 4
tv438 = -28						; size = 4
tv86 = -24						; size = 4
_i$7 = -20						; size = 4
_audioData$8 = -16					; size = 4
_audioTimestamp$9 = -12					; size = 4
_packet$10 = -8						; size = 4
_this$ = -4						; size = 4
_curSegment$ = 8					; size = 4
_firstFrameTime$ = 12					; size = 8
?SendFrame@OBS@@AAEXAAUVideoSegment@@_K@Z PROC		; OBS::SendFrame, COMDAT
; _this$ = ecx

; 144  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 145  :     if(!bSentHeaders)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+989]
	test	ecx, ecx
	jne	SHORT $LN28@SendFrame

; 146  :     {
; 147  :         if(network && curSegment.packets[0].data[0] == 0x17) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	??B?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QBE_NXZ ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN28@SendFrame
	push	0
	push	0
	mov	ecx, DWORD PTR _curSegment$[ebp]
	call	??A?$List@UVideoPacketData@@@@QAEAAUVideoPacketData@@I@Z ; List<VideoPacketData>::operator[]
	mov	ecx, eax
	call	??A?$List@E@@QAEAAEI@Z			; List<unsigned char>::operator[]
	movzx	eax, BYTE PTR [eax]
	cmp	eax, 23					; 00000017H
	jne	SHORT $LN28@SendFrame

; 148  :             network->BeginPublishing();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	??C?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QBEPAVNetworkStream@@XZ ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::operator->
	mov	DWORD PTR tv86[ebp], eax
	mov	ecx, DWORD PTR tv86[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv86[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 149  :             bSentHeaders = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+989], 1
$LN28@SendFrame:

; 150  :         }
; 151  :     }
; 152  : 
; 153  :     OSEnterMutex(hSoundDataMutex);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1152]
	push	eax
	call	DWORD PTR __imp_?OSEnterMutex@@YGXPAX@Z

; 154  : 
; 155  :     if(pendingAudioFrames.Num())

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1208				; 000004b8H
	call	?Num@?$List@UFrameAudio@@@@QBEIXZ	; List<FrameAudio>::Num
	test	eax, eax
	je	$LN26@SendFrame
$LN25@SendFrame:

; 156  :     {
; 157  :         while(pendingAudioFrames.Num())

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1208				; 000004b8H
	call	?Num@?$List@UFrameAudio@@@@QBEIXZ	; List<FrameAudio>::Num
	test	eax, eax
	je	$LN26@SendFrame

; 158  :         {
; 159  :             if(firstFrameTime < pendingAudioFrames[0].timestamp)

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1208				; 000004b8H
	call	??A?$List@UFrameAudio@@@@QAEAAUFrameAudio@@I@Z ; List<FrameAudio>::operator[]
	mov	DWORD PTR tv438[ebp], eax
	mov	ecx, DWORD PTR tv438[ebp]
	mov	edx, DWORD PTR _firstFrameTime$[ebp+4]
	cmp	edx, DWORD PTR [ecx+12]
	ja	$LN23@SendFrame
	jb	SHORT $LN31@SendFrame
	mov	eax, DWORD PTR tv438[ebp]
	mov	ecx, DWORD PTR _firstFrameTime$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	$LN23@SendFrame
$LN31@SendFrame:

; 160  :             {
; 161  :                 UINT audioTimestamp = UINT(pendingAudioFrames[0].timestamp-firstFrameTime);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1208				; 000004b8H
	call	??A?$List@UFrameAudio@@@@QAEAAUFrameAudio@@I@Z ; List<FrameAudio>::operator[]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR _firstFrameTime$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sbb	eax, DWORD PTR _firstFrameTime$[ebp+4]
	mov	DWORD PTR _audioTimestamp$9[ebp], edx

; 162  : 
; 163  :                 //stop sending audio packets when we reach an audio timestamp greater than the video timestamp
; 164  :                 if(audioTimestamp > curSegment.timestamp)

	mov	ecx, DWORD PTR _curSegment$[ebp]
	mov	edx, DWORD PTR _audioTimestamp$9[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jbe	SHORT $LN22@SendFrame

; 165  :                     break;

	jmp	$LN26@SendFrame
$LN22@SendFrame:

; 166  : 
; 167  :                 if(audioTimestamp == 0 || audioTimestamp > lastAudioTimestamp)

	cmp	DWORD PTR _audioTimestamp$9[ebp], 0
	je	SHORT $LN20@SendFrame
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _audioTimestamp$9[ebp]
	cmp	ecx, DWORD PTR [eax+992]
	jbe	$LN21@SendFrame
$LN20@SendFrame:

; 168  :                 {
; 169  :                     List<BYTE> &audioData = pendingAudioFrames[0].audioData;

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1208				; 000004b8H
	call	??A?$List@UFrameAudio@@@@QAEAAUFrameAudio@@I@Z ; List<FrameAudio>::operator[]
	mov	DWORD PTR _audioData$8[ebp], eax

; 170  :                     if(audioData.Num())

	mov	ecx, DWORD PTR _audioData$8[ebp]
	call	?Num@?$List@E@@QBEIXZ			; List<unsigned char>::Num
	test	eax, eax
	je	$LN21@SendFrame

; 171  :                     {
; 172  :                         //Log(TEXT("a:%u, %llu"), audioTimestamp, frameInfo.firstFrameTime+audioTimestamp);
; 173  : 
; 174  :                         if(network)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	??B?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QBE_NXZ ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN18@SendFrame

; 175  :                             network->SendPacket(audioData.Array(), audioData.Num(), audioTimestamp, PacketType_Audio);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	??C?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QBEPAVNetworkStream@@XZ ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::operator->
	mov	DWORD PTR tv167[ebp], eax
	push	4
	mov	eax, DWORD PTR _audioTimestamp$9[ebp]
	push	eax
	mov	ecx, DWORD PTR _audioData$8[ebp]
	call	?Num@?$List@E@@QBEIXZ			; List<unsigned char>::Num
	push	eax
	mov	ecx, DWORD PTR _audioData$8[ebp]
	call	?Array@?$List@E@@QBEPAEXZ		; List<unsigned char>::Array
	push	eax
	mov	ecx, DWORD PTR tv167[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv167[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
$LN18@SendFrame:

; 176  : 
; 177  :                         if (fileStream || replayBufferStream)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1028				; 00000404H
	call	??B?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@QBE_NXZ ; std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >::operator bool
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN16@SendFrame
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1064				; 00000428H
	call	??B?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@QBE_NXZ ; std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >::operator bool
	movzx	edx, al
	test	edx, edx
	je	$LN17@SendFrame
$LN16@SendFrame:

; 178  :                         {
; 179  :                             auto shared_data = std::make_shared<const std::vector<BYTE>>(audioData.Array(), audioData.Array() + audioData.Num());

	mov	ecx, DWORD PTR _audioData$8[ebp]
	call	?Array@?$List@E@@QBEPAEXZ		; List<unsigned char>::Array
	mov	esi, eax
	mov	ecx, DWORD PTR _audioData$8[ebp]
	call	?Num@?$List@E@@QBEIXZ			; List<unsigned char>::Num
	add	esi, eax
	mov	DWORD PTR $T6[ebp], esi
	mov	ecx, DWORD PTR _audioData$8[ebp]
	call	?Array@?$List@E@@QBEPAEXZ		; List<unsigned char>::Array
	mov	DWORD PTR $T5[ebp], eax
	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	lea	ecx, DWORD PTR $T5[ebp]
	push	ecx
	lea	edx, DWORD PTR _shared_data$2[ebp]
	push	edx
	call	??$make_shared@$$CBV?$vector@EV?$allocator@E@std@@@std@@PAEPAE@std@@YA?AV?$shared_ptr@$$CBV?$vector@EV?$allocator@E@std@@@std@@@0@$$QAPAE0@Z ; std::make_shared<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned char *,unsigned char *>
	add	esp, 12					; 0000000cH

; 180  :                             if (fileStream)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1028				; 00000404H
	call	??B?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@QBE_NXZ ; std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN15@SendFrame

; 181  :                                 fileStream->AddPacket(shared_data, audioTimestamp, audioTimestamp, PacketType_Audio);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1028				; 00000404H
	call	??C?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@QBEPAVVideoFileStream@@XZ ; std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >::operator->
	mov	DWORD PTR tv209[ebp], eax
	push	4
	mov	ecx, DWORD PTR _audioTimestamp$9[ebp]
	push	ecx
	mov	edx, DWORD PTR _audioTimestamp$9[ebp]
	push	edx
	sub	esp, 8
	mov	ecx, esp
	lea	eax, DWORD PTR _shared_data$2[ebp]
	push	eax
	call	??0?$shared_ptr@$$CBV?$vector@EV?$allocator@E@std@@@std@@@std@@QAE@ABV01@@Z ; std::shared_ptr<std::vector<unsigned char,std::allocator<unsigned char> > const >::shared_ptr<std::vector<unsigned char,std::allocator<unsigned char> > const >
	mov	ecx, DWORD PTR tv209[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv209[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
$LN15@SendFrame:

; 182  :                             if (replayBufferStream)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1064				; 00000428H
	call	??B?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@QBE_NXZ ; std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN14@SendFrame

; 183  :                                 replayBufferStream->AddPacket(shared_data, audioTimestamp, audioTimestamp, PacketType_Audio);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1064				; 00000428H
	call	??C?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@QBEPAVVideoFileStream@@XZ ; std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >::operator->
	mov	DWORD PTR tv236[ebp], eax
	push	4
	mov	edx, DWORD PTR _audioTimestamp$9[ebp]
	push	edx
	mov	eax, DWORD PTR _audioTimestamp$9[ebp]
	push	eax
	sub	esp, 8
	mov	ecx, esp
	lea	edx, DWORD PTR _shared_data$2[ebp]
	push	edx
	call	??0?$shared_ptr@$$CBV?$vector@EV?$allocator@E@std@@@std@@@std@@QAE@ABV01@@Z ; std::shared_ptr<std::vector<unsigned char,std::allocator<unsigned char> > const >::shared_ptr<std::vector<unsigned char,std::allocator<unsigned char> > const >
	mov	eax, DWORD PTR tv236[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv236[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
$LN14@SendFrame:

; 184  :                         }

	lea	ecx, DWORD PTR _shared_data$2[ebp]
	call	??1?$shared_ptr@$$CBV?$vector@EV?$allocator@E@std@@@std@@@std@@QAE@XZ ; std::shared_ptr<std::vector<unsigned char,std::allocator<unsigned char> > const >::~shared_ptr<std::vector<unsigned char,std::allocator<unsigned char> > const >
$LN17@SendFrame:

; 185  : 
; 186  :                         audioData.Clear();

	mov	ecx, DWORD PTR _audioData$8[ebp]
	call	?Clear@?$List@E@@QAEXXZ			; List<unsigned char>::Clear

; 187  : 
; 188  :                         lastAudioTimestamp = audioTimestamp;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _audioTimestamp$9[ebp]
	mov	DWORD PTR [ecx+992], edx
$LN21@SendFrame:

; 189  :                     }
; 190  :                 }
; 191  :             }
; 192  :             else

	jmp	SHORT $LN13@SendFrame
$LN23@SendFrame:

; 193  :                 nop();

	call	?nop@@YAXXZ				; nop
$LN13@SendFrame:

; 194  : 
; 195  :             pendingAudioFrames[0].audioData.Clear();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1208				; 000004b8H
	call	??A?$List@UFrameAudio@@@@QAEAAUFrameAudio@@I@Z ; List<FrameAudio>::operator[]
	mov	ecx, eax
	call	?Clear@?$List@E@@QAEXXZ			; List<unsigned char>::Clear

; 196  :             pendingAudioFrames.Remove(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1208				; 000004b8H
	call	?Remove@?$List@UFrameAudio@@@@QAEXI@Z	; List<FrameAudio>::Remove

; 197  :         }

	jmp	$LN25@SendFrame
$LN26@SendFrame:

; 198  :     }
; 199  : 
; 200  :     OSLeaveMutex(hSoundDataMutex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1152]
	push	ecx
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z

; 201  : 
; 202  :     for(UINT i=0; i<curSegment.packets.Num(); i++)

	mov	DWORD PTR _i$7[ebp], 0
	jmp	SHORT $LN12@SendFrame
$LN11@SendFrame:
	mov	edx, DWORD PTR _i$7[ebp]
	add	edx, 1
	mov	DWORD PTR _i$7[ebp], edx
$LN12@SendFrame:
	mov	ecx, DWORD PTR _curSegment$[ebp]
	call	?Num@?$List@UVideoPacketData@@@@QBEIXZ	; List<VideoPacketData>::Num
	cmp	DWORD PTR _i$7[ebp], eax
	jae	$LN29@SendFrame

; 203  :     {
; 204  :         VideoPacketData &packet = curSegment.packets[i];

	mov	eax, DWORD PTR _i$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _curSegment$[ebp]
	call	??A?$List@UVideoPacketData@@@@QAEAAUVideoPacketData@@I@Z ; List<VideoPacketData>::operator[]
	mov	DWORD PTR _packet$10[ebp], eax

; 205  : 
; 206  :         if(packet.type == PacketType_VideoHighest)

	mov	ecx, DWORD PTR _packet$10[ebp]
	cmp	DWORD PTR [ecx+8], 3
	jne	SHORT $LN9@SendFrame

; 207  :             bRequestKeyframe = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1104], 0
$LN9@SendFrame:

; 208  : 
; 209  :         //Log(TEXT("v:%u, %llu"), curSegment.timestamp, frameInfo.firstFrameTime+curSegment.timestamp);
; 210  : 
; 211  :         if (network)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	??B?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QBE_NXZ ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@SendFrame

; 212  :         {
; 213  :             if (!HandleStreamStopInfo(networkStop, packet.type, curSegment))

	mov	ecx, DWORD PTR _curSegment$[ebp]
	push	ecx
	mov	edx, DWORD PTR _packet$10[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HandleStreamStopInfo@OBS@@AAE_NAAUStopInfo@1@W4PacketType@@ABUVideoSegment@@@Z ; OBS::HandleStreamStopInfo
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN8@SendFrame

; 214  :                 network->SendPacket(packet.data.Array(), packet.data.Num(), curSegment.timestamp, packet.type);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	??C?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QBEPAVNetworkStream@@XZ ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::operator->
	mov	DWORD PTR tv297[ebp], eax
	mov	eax, DWORD PTR _packet$10[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _curSegment$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _packet$10[ebp]
	call	?Num@?$List@E@@QBEIXZ			; List<unsigned char>::Num
	push	eax
	mov	ecx, DWORD PTR _packet$10[ebp]
	call	?Array@?$List@E@@QBEPAEXZ		; List<unsigned char>::Array
	push	eax
	mov	ecx, DWORD PTR tv297[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv297[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
$LN8@SendFrame:

; 215  :         }
; 216  : 
; 217  :         if (fileStream || replayBufferStream)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1028				; 00000404H
	call	??B?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@QBE_NXZ ; std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >::operator bool
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN5@SendFrame
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1064				; 00000428H
	call	??B?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@QBE_NXZ ; std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >::operator bool
	movzx	edx, al
	test	edx, edx
	je	$LN6@SendFrame
$LN5@SendFrame:

; 218  :         {
; 219  :             auto shared_data = std::make_shared<const std::vector<BYTE>>(packet.data.Array(), packet.data.Array() + packet.data.Num());

	mov	ecx, DWORD PTR _packet$10[ebp]
	call	?Array@?$List@E@@QBEPAEXZ		; List<unsigned char>::Array
	mov	esi, eax
	mov	ecx, DWORD PTR _packet$10[ebp]
	call	?Num@?$List@E@@QBEIXZ			; List<unsigned char>::Num
	add	esi, eax
	mov	DWORD PTR $T4[ebp], esi
	mov	ecx, DWORD PTR _packet$10[ebp]
	call	?Array@?$List@E@@QBEPAEXZ		; List<unsigned char>::Array
	mov	DWORD PTR $T3[ebp], eax
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	lea	edx, DWORD PTR _shared_data$1[ebp]
	push	edx
	call	??$make_shared@$$CBV?$vector@EV?$allocator@E@std@@@std@@PAEPAE@std@@YA?AV?$shared_ptr@$$CBV?$vector@EV?$allocator@E@std@@@std@@@0@$$QAPAE0@Z ; std::make_shared<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned char *,unsigned char *>
	add	esp, 12					; 0000000cH

; 220  :             if (fileStream)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1028				; 00000404H
	call	??B?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@QBE_NXZ ; std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@SendFrame

; 221  :             {
; 222  :                 if (!HandleStreamStopInfo(fileStreamStop, packet.type, curSegment))

	mov	ecx, DWORD PTR _curSegment$[ebp]
	push	ecx
	mov	edx, DWORD PTR _packet$10[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1032				; 00000408H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HandleStreamStopInfo@OBS@@AAE_NAAUStopInfo@1@W4PacketType@@ABUVideoSegment@@@Z ; OBS::HandleStreamStopInfo
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN4@SendFrame

; 223  :                     fileStream->AddPacket(shared_data, curSegment.timestamp, curSegment.pts, packet.type);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1028				; 00000404H
	call	??C?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@QBEPAVVideoFileStream@@XZ ; std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >::operator->
	mov	DWORD PTR tv355[ebp], eax
	mov	eax, DWORD PTR _packet$10[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _curSegment$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _curSegment$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	sub	esp, 8
	mov	ecx, esp
	lea	eax, DWORD PTR _shared_data$1[ebp]
	push	eax
	call	??0?$shared_ptr@$$CBV?$vector@EV?$allocator@E@std@@@std@@@std@@QAE@ABV01@@Z ; std::shared_ptr<std::vector<unsigned char,std::allocator<unsigned char> > const >::shared_ptr<std::vector<unsigned char,std::allocator<unsigned char> > const >
	mov	ecx, DWORD PTR tv355[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv355[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
$LN4@SendFrame:

; 224  :             }
; 225  :             if (replayBufferStream)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1064				; 00000428H
	call	??B?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@QBE_NXZ ; std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@SendFrame

; 226  :             {
; 227  :                 if (!HandleStreamStopInfo(replayBufferStop, packet.type, curSegment))

	mov	edx, DWORD PTR _curSegment$[ebp]
	push	edx
	mov	eax, DWORD PTR _packet$10[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1072				; 00000430H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HandleStreamStopInfo@OBS@@AAE_NAAUStopInfo@1@W4PacketType@@ABUVideoSegment@@@Z ; OBS::HandleStreamStopInfo
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@SendFrame

; 228  :                     replayBufferStream->AddPacket(shared_data, curSegment.timestamp, curSegment.pts, packet.type);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1064				; 00000428H
	call	??C?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@QBEPAVVideoFileStream@@XZ ; std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >::operator->
	mov	DWORD PTR tv394[ebp], eax
	mov	ecx, DWORD PTR _packet$10[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _curSegment$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _curSegment$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	sub	esp, 8
	mov	ecx, esp
	lea	edx, DWORD PTR _shared_data$1[ebp]
	push	edx
	call	??0?$shared_ptr@$$CBV?$vector@EV?$allocator@E@std@@@std@@@std@@QAE@ABV01@@Z ; std::shared_ptr<std::vector<unsigned char,std::allocator<unsigned char> > const >::shared_ptr<std::vector<unsigned char,std::allocator<unsigned char> > const >
	mov	eax, DWORD PTR tv394[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv394[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
$LN2@SendFrame:

; 229  :             }
; 230  :         }

	lea	ecx, DWORD PTR _shared_data$1[ebp]
	call	??1?$shared_ptr@$$CBV?$vector@EV?$allocator@E@std@@@std@@@std@@QAE@XZ ; std::shared_ptr<std::vector<unsigned char,std::allocator<unsigned char> > const >::~shared_ptr<std::vector<unsigned char,std::allocator<unsigned char> > const >
$LN6@SendFrame:

; 231  :     }

	jmp	$LN11@SendFrame
$LN29@SendFrame:

; 232  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SendFrame@OBS@@AAEXAAUVideoSegment@@_K@Z ENDP		; OBS::SendFrame
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obsvideocapture.cpp
;	COMDAT ?HandleStreamStopInfo@OBS@@AAE_NAAUStopInfo@1@W4PacketType@@ABUVideoSegment@@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T1 = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_info$ = 8						; size = 4
_type$ = 12						; size = 4
_segment$ = 16						; size = 4
?HandleStreamStopInfo@OBS@@AAE_NAAUStopInfo@1@W4PacketType@@ABUVideoSegment@@@Z PROC ; OBS::HandleStreamStopInfo, COMDAT
; _this$ = ecx

; 235  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 236  :     if (type == PacketType_Audio || !info.func)

	cmp	DWORD PTR _type$[ebp], 4
	je	SHORT $LN3@HandleStre
	mov	ecx, DWORD PTR _info$[ebp]
	add	ecx, 8
	call	??B?$function@$$A6AXXZ@std@@QBE_NXZ	; std::function<void __cdecl(void)>::operator bool
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@HandleStre
$LN3@HandleStre:

; 237  :         return false;

	xor	al, al
	jmp	SHORT $LN5@HandleStre
$LN4@HandleStre:

; 238  : 
; 239  :     if (segment.pts < info.time)

	mov	ecx, DWORD PTR _segment$[ebp]
	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	cmp	eax, DWORD PTR [edx]
	jae	SHORT $LN2@HandleStre

; 240  :         return false;

	xor	al, al
	jmp	SHORT $LN5@HandleStre
$LN2@HandleStre:

; 241  : 
; 242  :     if (!info.timeSeen)

	mov	ecx, DWORD PTR _info$[ebp]
	movzx	edx, BYTE PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN1@HandleStre

; 243  :     {
; 244  :         info.timeSeen = true;

	mov	eax, DWORD PTR _info$[ebp]
	mov	BYTE PTR [eax+4], 1

; 245  :         return false;

	xor	al, al
	jmp	SHORT $LN5@HandleStre
$LN1@HandleStre:

; 246  :     }
; 247  : 
; 248  :     info.func();

	mov	ecx, DWORD PTR _info$[ebp]
	add	ecx, 8
	call	??R?$_Func_class@X$$$V@std@@QBEXXZ	; std::_Func_class<void>::operator()

; 249  :     info = {};

	lea	ecx, DWORD PTR $T1[ebp]
	call	??0StopInfo@OBS@@QAE@XZ
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _info$[ebp]
	call	??4StopInfo@OBS@@QAEAAU01@ABU01@@Z
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1StopInfo@OBS@@QAE@XZ

; 250  :     return true;

	mov	al, 1
$LN5@HandleStre:

; 251  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?HandleStreamStopInfo@OBS@@AAE_NAAUStopInfo@1@W4PacketType@@ABUVideoSegment@@@Z ENDP ; OBS::HandleStreamStopInfo
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??4StopInfo@OBS@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4StopInfo@OBS@@QAEAAU01@ABU01@@Z PROC			; OBS::StopInfo::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+4]
	mov	BYTE PTR [eax+4], dl
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??4?$function@$$A6AXXZ@std@@QAEAAV01@ABV01@@Z ; std::function<void __cdecl(void)>::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4StopInfo@OBS@@QAEAAU01@ABU01@@Z ENDP			; OBS::StopInfo::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obsvideocapture.cpp
;	COMDAT ?ProcessFrame@OBS@@AAE_NAAUFrameProcessInfo@@@Z
_TEXT	SEGMENT
__curProfiler$1 = -108					; size = 48
_curSegment$ = -60					; size = 16
_videoPacketTypes$ = -44				; size = 8
_videoPackets$ = -36					; size = 8
$T2 = -28						; size = 4
_out_pts$ = -24						; size = 4
tv140 = -20						; size = 4
_picIn$ = -16						; size = 4
tv88 = -12						; size = 4
_this$ = -8						; size = 4
$T3 = -3						; size = 1
_bProcessedFrame$ = -2					; size = 1
_bSendFrame$ = -1					; size = 1
_frameInfo$ = 8						; size = 4
?ProcessFrame@OBS@@AAE_NAAUFrameProcessInfo@@@Z PROC	; OBS::ProcessFrame, COMDAT
; _this$ = ecx

; 254  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	DWORD PTR _this$[ebp], ecx

; 255  :     List<DataPacket> videoPackets;

	lea	ecx, DWORD PTR _videoPackets$[ebp]
	call	??0?$List@UDataPacket@@@@QAE@XZ		; List<DataPacket>::List<DataPacket>

; 256  :     List<PacketType> videoPacketTypes;

	lea	ecx, DWORD PTR _videoPacketTypes$[ebp]
	call	??0?$List@W4PacketType@@@@QAE@XZ	; List<enum PacketType>::List<enum PacketType>

; 257  : 
; 258  :     //------------------------------------
; 259  :     // encode
; 260  : 
; 261  :     bufferedTimes << frameInfo.frameTimestamp;

	mov	eax, DWORD PTR _frameInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T2[ebp], ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 968				; 000003c8H
	call	??6?$CircularList@I@@QAEAAV0@ABI@Z	; CircularList<unsigned int>::operator<<

; 262  : 
; 263  :     VideoSegment curSegment;

	lea	ecx, DWORD PTR _curSegment$[ebp]
	call	??0VideoSegment@@QAE@XZ			; VideoSegment::VideoSegment

; 264  :     bool bProcessedFrame, bSendFrame = false;

	mov	BYTE PTR _bSendFrame$[ebp], 0

; 265  :     VOID *picIn;
; 266  : 
; 267  :     //profileIn("call to encoder");
; 268  : 
; 269  :     if (bShutdownEncodeThread)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+632]
	test	ecx, ecx
	je	SHORT $LN5@ProcessFra

; 270  :         picIn = NULL;

	mov	DWORD PTR _picIn$[ebp], 0

; 271  :     else

	jmp	SHORT $LN4@ProcessFra
$LN5@ProcessFra:

; 272  :         picIn = frameInfo.pic->picOut ? (LPVOID)frameInfo.pic->picOut : (LPVOID)frameInfo.pic->mfxOut;

	mov	edx, DWORD PTR _frameInfo$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN8@ProcessFra
	mov	ecx, DWORD PTR _frameInfo$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv88[ebp], eax
	jmp	SHORT $LN9@ProcessFra
$LN8@ProcessFra:
	mov	ecx, DWORD PTR _frameInfo$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR tv88[ebp], eax
$LN9@ProcessFra:
	mov	ecx, DWORD PTR tv88[ebp]
	mov	DWORD PTR _picIn$[ebp], ecx
$LN4@ProcessFra:

; 273  : 
; 274  :     DWORD out_pts = 0;

	mov	DWORD PTR _out_pts$[ebp], 0

; 275  :     videoEncoder->Encode(picIn, videoPackets, videoPacketTypes, bufferedTimes[0], out_pts);

	lea	edx, DWORD PTR _out_pts$[ebp]
	push	edx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 968				; 000003c8H
	call	??A?$CircularList@I@@QAEAAII@Z		; CircularList<unsigned int>::operator[]
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR _videoPacketTypes$[ebp]
	push	ecx
	lea	edx, DWORD PTR _videoPackets$[ebp]
	push	edx
	mov	eax, DWORD PTR _picIn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+148]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+148]
	mov	eax, DWORD PTR [edx]
	call	eax

; 276  : 
; 277  :     bProcessedFrame = (videoPackets.Num() != 0);

	lea	ecx, DWORD PTR _videoPackets$[ebp]
	call	?Num@?$List@UDataPacket@@@@QBEIXZ	; List<DataPacket>::Num
	test	eax, eax
	je	SHORT $LN10@ProcessFra
	mov	DWORD PTR tv140[ebp], 1
	jmp	SHORT $LN11@ProcessFra
$LN10@ProcessFra:
	mov	DWORD PTR tv140[ebp], 0
$LN11@ProcessFra:
	mov	cl, BYTE PTR tv140[ebp]
	mov	BYTE PTR _bProcessedFrame$[ebp], cl

; 278  : 
; 279  :     //buffer video data before sending out
; 280  :     if(bProcessedFrame)

	movzx	edx, BYTE PTR _bProcessedFrame$[ebp]
	test	edx, edx
	je	SHORT $LN3@ProcessFra

; 281  :     {
; 282  :         bSendFrame = BufferVideoData(videoPackets, videoPacketTypes, bufferedTimes[0], out_pts, frameInfo.firstFrameTime, curSegment);

	lea	eax, DWORD PTR _curSegment$[ebp]
	push	eax
	mov	ecx, DWORD PTR _frameInfo$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR [ecx+8]
	push	eax
	mov	ecx, DWORD PTR _out_pts$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 968				; 000003c8H
	call	??A?$CircularList@I@@QAEAAII@Z		; CircularList<unsigned int>::operator[]
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR _videoPacketTypes$[ebp]
	push	eax
	lea	ecx, DWORD PTR _videoPackets$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferVideoData@OBS@@AAE_NABV?$List@UDataPacket@@@@ABV?$List@W4PacketType@@@@KK_KAAUVideoSegment@@@Z ; OBS::BufferVideoData
	mov	BYTE PTR _bSendFrame$[ebp], al

; 283  :         bufferedTimes.Remove(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 968				; 000003c8H
	call	?Remove@?$CircularList@I@@QAEXI@Z	; CircularList<unsigned int>::Remove

; 284  :     }
; 285  :     else

	jmp	SHORT $LN2@ProcessFra
$LN3@ProcessFra:

; 286  :         nop();

	call	?nop@@YAXXZ				; nop
$LN2@ProcessFra:

; 287  : 
; 288  :     //profileOut;
; 289  : 
; 290  :     //------------------------------------
; 291  :     // upload
; 292  : 
; 293  :     profileIn("sending stuff out");

	push	0
	push	OFFSET $SG4294781476
	lea	ecx, DWORD PTR __curProfiler$1[ebp]
	call	DWORD PTR __imp_??0ProfilerNode@@QAE@PB_W_N@Z

; 294  : 
; 295  :     //send headers before the first frame if not yet sent
; 296  :     if(bSendFrame)

	movzx	edx, BYTE PTR _bSendFrame$[ebp]
	test	edx, edx
	je	SHORT $LN1@ProcessFra

; 297  :         SendFrame(curSegment, frameInfo.firstFrameTime);

	mov	eax, DWORD PTR _frameInfo$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR [eax+8]
	push	edx
	lea	eax, DWORD PTR _curSegment$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendFrame@OBS@@AAEXAAUVideoSegment@@_K@Z ; OBS::SendFrame
$LN1@ProcessFra:

; 298  : 
; 299  :     profileOut;

	lea	ecx, DWORD PTR __curProfiler$1[ebp]
	call	DWORD PTR __imp_??1ProfilerNode@@QAE@XZ

; 300  : 
; 301  :     return bProcessedFrame;

	mov	cl, BYTE PTR _bProcessedFrame$[ebp]
	mov	BYTE PTR $T3[ebp], cl
	lea	ecx, DWORD PTR _curSegment$[ebp]
	call	??1VideoSegment@@QAE@XZ			; VideoSegment::~VideoSegment
	lea	ecx, DWORD PTR _videoPacketTypes$[ebp]
	call	??1?$List@W4PacketType@@@@QAE@XZ	; List<enum PacketType>::~List<enum PacketType>
	lea	ecx, DWORD PTR _videoPackets$[ebp]
	call	??1?$List@UDataPacket@@@@QAE@XZ		; List<DataPacket>::~List<DataPacket>
	mov	al, BYTE PTR $T3[ebp]

; 302  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ProcessFrame@OBS@@AAE_NAAUFrameProcessInfo@@@Z ENDP	; OBS::ProcessFrame
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obsvideocapture.cpp
;	COMDAT ?SleepToNS@@YG_N_K@Z
_TEXT	SEGMENT
_t$ = -12						; size = 8
_milliseconds$ = -4					; size = 4
_qwNSTime$ = 8						; size = 8
?SleepToNS@@YG_N_K@Z PROC				; SleepToNS, COMDAT

; 306  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 307  :     QWORD t = GetQPCTimeNS();

	call	DWORD PTR __imp_?GetQPCTimeNS@@YA_KXZ
	mov	DWORD PTR _t$[ebp], eax
	mov	DWORD PTR _t$[ebp+4], edx

; 308  : 
; 309  :     if (t >= qwNSTime)

	mov	eax, DWORD PTR _t$[ebp+4]
	cmp	eax, DWORD PTR _qwNSTime$[ebp+4]
	jb	SHORT $LN6@SleepToNS
	ja	SHORT $LN9@SleepToNS
	mov	ecx, DWORD PTR _t$[ebp]
	cmp	ecx, DWORD PTR _qwNSTime$[ebp]
	jb	SHORT $LN6@SleepToNS
$LN9@SleepToNS:

; 310  :         return false;

	xor	al, al
	jmp	SHORT $LN7@SleepToNS
$LN6@SleepToNS:

; 311  : 
; 312  :     unsigned int milliseconds = (unsigned int)((qwNSTime - t)/1000000);

	mov	edx, DWORD PTR _qwNSTime$[ebp]
	sub	edx, DWORD PTR _t$[ebp]
	mov	eax, DWORD PTR _qwNSTime$[ebp+4]
	sbb	eax, DWORD PTR _t$[ebp+4]
	push	0
	push	1000000					; 000f4240H
	push	eax
	push	edx
	call	__aulldiv
	mov	DWORD PTR _milliseconds$[ebp], eax

; 313  :     if (milliseconds > 1) //also accounts for windows 8 sleep problem

	cmp	DWORD PTR _milliseconds$[ebp], 1
	jbe	SHORT $LN3@SleepToNS

; 314  :     {
; 315  :         //trap suspicious sleeps that should never happen
; 316  :         if (milliseconds > 10000)

	cmp	DWORD PTR _milliseconds$[ebp], 10000	; 00002710H
	jbe	SHORT $LN4@SleepToNS

; 317  :         {
; 318  :             Log(TEXT("Tried to sleep for %u seconds, that can't be right! Triggering breakpoint."), milliseconds);

	mov	ecx, DWORD PTR _milliseconds$[ebp]
	push	ecx
	push	OFFSET $SG4294781475
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8

; 319  :             DebugBreak();

	call	DWORD PTR __imp__DebugBreak@0
$LN4@SleepToNS:

; 320  :         }
; 321  :         OSSleep(milliseconds);

	mov	edx, DWORD PTR _milliseconds$[ebp]
	push	edx
	call	DWORD PTR __imp_?OSSleep@@YGXK@Z
$LN3@SleepToNS:

; 322  :     }
; 323  : 
; 324  :     for (;;)
; 325  :     {
; 326  :         t = GetQPCTimeNS();

	call	DWORD PTR __imp_?GetQPCTimeNS@@YA_KXZ
	mov	DWORD PTR _t$[ebp], eax
	mov	DWORD PTR _t$[ebp+4], edx

; 327  :         if (t >= qwNSTime)

	mov	eax, DWORD PTR _t$[ebp+4]
	cmp	eax, DWORD PTR _qwNSTime$[ebp+4]
	jb	SHORT $LN1@SleepToNS
	ja	SHORT $LN10@SleepToNS
	mov	ecx, DWORD PTR _t$[ebp]
	cmp	ecx, DWORD PTR _qwNSTime$[ebp]
	jb	SHORT $LN1@SleepToNS
$LN10@SleepToNS:

; 328  :             return true;

	mov	al, 1
	jmp	SHORT $LN7@SleepToNS
$LN1@SleepToNS:

; 329  :         Sleep(1);

	push	1
	call	DWORD PTR __imp__Sleep@4

; 330  :     }

	jmp	SHORT $LN3@SleepToNS
$LN7@SleepToNS:

; 331  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SleepToNS@@YG_N_K@Z ENDP				; SleepToNS
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obsvideocapture.cpp
;	COMDAT ?FlushBufferedVideo@OBS@@AAEIXZ
_TEXT	SEGMENT
tv188 = -52						; size = 8
tv185 = -44						; size = 8
_startTime$1 = -36					; size = 8
_curTime$2 = -28					; size = 8
_lastTimestamp$3 = -20					; size = 4
_baseTimestamp$4 = -16					; size = 4
_framesFlushed$ = -12					; size = 4
_i$5 = -8						; size = 4
_this$ = -4						; size = 4
?FlushBufferedVideo@OBS@@AAEIXZ PROC			; OBS::FlushBufferedVideo, COMDAT
; _this$ = ecx

; 360  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 361  :     UINT framesFlushed = 0;

	mov	DWORD PTR _framesFlushed$[ebp], 0

; 362  : 
; 363  :     if (bufferedVideo.Num())

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 960				; 000003c0H
	call	?Num@?$List@UVideoSegment@@@@QBEIXZ	; List<VideoSegment>::Num
	test	eax, eax
	je	$LN6@FlushBuffe

; 364  :     {
; 365  :         QWORD startTime = GetQPCTimeMS();

	call	DWORD PTR __imp_?GetQPCTimeMS@@YA_KXZ
	mov	DWORD PTR _startTime$1[ebp], eax
	mov	DWORD PTR _startTime$1[ebp+4], edx

; 366  :         DWORD baseTimestamp = bufferedVideo[0].timestamp;

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 960				; 000003c0H
	call	??A?$List@UVideoSegment@@@@QAEAAUVideoSegment@@I@Z ; List<VideoSegment>::operator[]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _baseTimestamp$4[ebp], eax

; 367  :         DWORD lastTimestamp = bufferedVideo.Last().timestamp;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 960				; 000003c0H
	call	?Last@?$List@UVideoSegment@@@@QBEAAUVideoSegment@@XZ ; List<VideoSegment>::Last
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _lastTimestamp$3[ebp], ecx

; 368  : 
; 369  :         Log(TEXT("FlushBufferedVideo: Flushing %d packets over %d ms"), bufferedVideo.Num(), (lastTimestamp - baseTimestamp));

	mov	edx, DWORD PTR _lastTimestamp$3[ebp]
	sub	edx, DWORD PTR _baseTimestamp$4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 960				; 000003c0H
	call	?Num@?$List@UVideoSegment@@@@QBEIXZ	; List<VideoSegment>::Num
	push	eax
	push	OFFSET $SG4294781474
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 12					; 0000000cH

; 370  : 
; 371  :         for (UINT i = 0; i<bufferedVideo.Num(); i++)

	mov	DWORD PTR _i$5[ebp], 0
	jmp	SHORT $LN5@FlushBuffe
$LN4@FlushBuffe:
	mov	eax, DWORD PTR _i$5[ebp]
	add	eax, 1
	mov	DWORD PTR _i$5[ebp], eax
$LN5@FlushBuffe:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 960				; 000003c0H
	call	?Num@?$List@UVideoSegment@@@@QBEIXZ	; List<VideoSegment>::Num
	cmp	DWORD PTR _i$5[ebp], eax
	jae	$LN3@FlushBuffe

; 372  :         {
; 373  :             //we measure our own time rather than sleep between frames due to potential sleep drift
; 374  :             QWORD curTime;
; 375  : 
; 376  :             curTime = GetQPCTimeMS();

	call	DWORD PTR __imp_?GetQPCTimeMS@@YA_KXZ
	mov	DWORD PTR _curTime$2[ebp], eax
	mov	DWORD PTR _curTime$2[ebp+4], edx
$LN2@FlushBuffe:

; 377  :             while (curTime - startTime < bufferedVideo[i].timestamp - baseTimestamp)

	mov	esi, DWORD PTR _curTime$2[ebp]
	sub	esi, DWORD PTR _startTime$1[ebp]
	mov	edi, DWORD PTR _curTime$2[ebp+4]
	sbb	edi, DWORD PTR _startTime$1[ebp+4]
	mov	ecx, DWORD PTR _i$5[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 960				; 000003c0H
	call	??A?$List@UVideoSegment@@@@QAEAAUVideoSegment@@I@Z ; List<VideoSegment>::operator[]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR _baseTimestamp$4[ebp]
	xor	eax, eax
	mov	DWORD PTR tv185[ebp], esi
	mov	DWORD PTR tv185[ebp+4], edi
	mov	DWORD PTR tv188[ebp], edx
	mov	DWORD PTR tv188[ebp+4], eax
	mov	ecx, DWORD PTR tv185[ebp+4]
	cmp	ecx, DWORD PTR tv188[ebp+4]
	ja	SHORT $LN1@FlushBuffe
	jb	SHORT $LN9@FlushBuffe
	mov	edx, DWORD PTR tv185[ebp]
	cmp	edx, DWORD PTR tv188[ebp]
	jae	SHORT $LN1@FlushBuffe
$LN9@FlushBuffe:

; 378  :             {
; 379  :                 OSSleep(1);

	push	1
	call	DWORD PTR __imp_?OSSleep@@YGXK@Z

; 380  :                 curTime = GetQPCTimeMS();

	call	DWORD PTR __imp_?GetQPCTimeMS@@YA_KXZ
	mov	DWORD PTR _curTime$2[ebp], eax
	mov	DWORD PTR _curTime$2[ebp+4], edx

; 381  :             }

	jmp	SHORT $LN2@FlushBuffe
$LN1@FlushBuffe:

; 382  : 
; 383  :             SendFrame(bufferedVideo[i], firstFrameTimestamp);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1116]
	push	ecx
	mov	edx, DWORD PTR [eax+1112]
	push	edx
	mov	eax, DWORD PTR _i$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 960				; 000003c0H
	call	??A?$List@UVideoSegment@@@@QAEAAUVideoSegment@@I@Z ; List<VideoSegment>::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendFrame@OBS@@AAEXAAUVideoSegment@@_K@Z ; OBS::SendFrame

; 384  :             bufferedVideo[i].Clear();

	mov	ecx, DWORD PTR _i$5[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 960				; 000003c0H
	call	??A?$List@UVideoSegment@@@@QAEAAUVideoSegment@@I@Z ; List<VideoSegment>::operator[]
	mov	ecx, eax
	call	?Clear@VideoSegment@@QAEXXZ		; VideoSegment::Clear

; 385  : 
; 386  :             framesFlushed++;

	mov	edx, DWORD PTR _framesFlushed$[ebp]
	add	edx, 1
	mov	DWORD PTR _framesFlushed$[ebp], edx

; 387  :         }

	jmp	$LN4@FlushBuffe
$LN3@FlushBuffe:

; 388  : 
; 389  :         bufferedVideo.Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 960				; 000003c0H
	call	?Clear@?$List@UVideoSegment@@@@QAEXXZ	; List<VideoSegment>::Clear
$LN6@FlushBuffe:

; 390  :     }
; 391  : 
; 392  :     return framesFlushed;

	mov	eax, DWORD PTR _framesFlushed$[ebp]

; 393  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?FlushBufferedVideo@OBS@@AAEIXZ ENDP			; OBS::FlushBufferedVideo
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obsvideocapture.cpp
;	COMDAT ?EncodeLoop@OBS@@AAEXXZ
_TEXT	SEGMENT
__curProfiler$1 = -200					; size = 48
_bufferedTimes$ = -152					; size = 20
tv253 = -132						; size = 8
tv241 = -124						; size = 8
_frameInfo$2 = -116					; size = 16
_skipThreshold$ = -100					; size = 4
tv499 = -96						; size = 4
tv446 = -92						; size = 4
tv375 = -88						; size = 4
tv454 = -84						; size = 4
tv81 = -80						; size = 8
_lastPic$ = -72						; size = 4
tv455 = -68						; size = 4
_streamTimeStart$ = -64					; size = 8
_curFrameTimestamp$3 = -56				; size = 4
_frameTimeNS$ = -52					; size = 8
_messageTime$ = -44					; size = 8
_numTotalDuplicatedFrames$ = -36			; size = 4
_encoderInfo$ = -32					; size = 4
_numFramesSkipped$ = -28				; size = 4
_no_sleep_counter$ = -24				; size = 4
_sleepTargetTime$ = -20					; size = 8
_numTotalFrames$ = -12					; size = 4
_bufferedFrames$ = -6					; size = 1
_bUsingQSV$ = -5					; size = 1
_this$ = -4						; size = 4
?EncodeLoop@OBS@@AAEXXZ PROC				; OBS::EncodeLoop, COMDAT
; _this$ = ecx

; 396  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 200				; 000000c8H
	mov	DWORD PTR _this$[ebp], ecx

; 397  :     QWORD streamTimeStart = GetQPCTimeNS();

	call	DWORD PTR __imp_?GetQPCTimeNS@@YA_KXZ
	mov	DWORD PTR _streamTimeStart$[ebp], eax
	mov	DWORD PTR _streamTimeStart$[ebp+4], edx

; 398  :     QWORD frameTimeNS = 1000000000/fps;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, 1000000000				; 3b9aca00H
	xor	edx, edx
	div	DWORD PTR [ecx+892]
	xor	edx, edx
	mov	DWORD PTR _frameTimeNS$[ebp], eax
	mov	DWORD PTR _frameTimeNS$[ebp+4], edx

; 399  :     bool bufferedFrames = true; //to avoid constantly polling number of frames

	mov	BYTE PTR _bufferedFrames$[ebp], 1

; 400  :     int numTotalDuplicatedFrames = 0, numTotalFrames = 0, numFramesSkipped = 0;

	mov	DWORD PTR _numTotalDuplicatedFrames$[ebp], 0
	mov	DWORD PTR _numTotalFrames$[ebp], 0
	mov	DWORD PTR _numFramesSkipped$[ebp], 0

; 401  : 
; 402  :     bufferedTimes.Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 968				; 000003c8H
	call	?Clear@?$CircularList@I@@QAEXXZ		; CircularList<unsigned int>::Clear

; 403  : 
; 404  :     bool bUsingQSV = videoEncoder->isQSV();//GlobalConfig->GetInt(TEXT("Video Encoding"), TEXT("UseQSV")) != 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+148]
	mov	edx, DWORD PTR [eax+40]
	call	edx
	mov	BYTE PTR _bUsingQSV$[ebp], al

; 405  : 
; 406  :     QWORD sleepTargetTime = streamTimeStart+frameTimeNS;

	mov	eax, DWORD PTR _streamTimeStart$[ebp]
	add	eax, DWORD PTR _frameTimeNS$[ebp]
	mov	ecx, DWORD PTR _streamTimeStart$[ebp+4]
	adc	ecx, DWORD PTR _frameTimeNS$[ebp+4]
	mov	DWORD PTR _sleepTargetTime$[ebp], eax
	mov	DWORD PTR _sleepTargetTime$[ebp+4], ecx

; 407  :     latestVideoTime = firstSceneTimestamp = streamTimeStart/1000000;

	push	0
	push	1000000					; 000f4240H
	mov	edx, DWORD PTR _streamTimeStart$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _streamTimeStart$[ebp]
	push	eax
	call	__aulldiv
	mov	DWORD PTR tv81[ebp], eax
	mov	DWORD PTR tv81[ebp+4], edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv81[ebp]
	mov	DWORD PTR [ecx+1000], edx
	mov	eax, DWORD PTR tv81[ebp+4]
	mov	DWORD PTR [ecx+1004], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv81[ebp]
	mov	DWORD PTR [ecx+1008], edx
	mov	eax, DWORD PTR tv81[ebp+4]
	mov	DWORD PTR [ecx+1012], eax

; 408  :     latestVideoTimeNS = streamTimeStart;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _streamTimeStart$[ebp]
	mov	DWORD PTR [ecx+1016], edx
	mov	eax, DWORD PTR _streamTimeStart$[ebp+4]
	mov	DWORD PTR [ecx+1020], eax

; 409  : 
; 410  :     firstFrameTimestamp = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1112], 0
	mov	DWORD PTR [ecx+1116], 0

; 411  : 
; 412  :     UINT encoderInfo = 0;

	mov	DWORD PTR _encoderInfo$[ebp], 0

; 413  :     QWORD messageTime = 0;

	xorpd	xmm0, xmm0
	movlpd	QWORD PTR _messageTime$[ebp], xmm0

; 414  : 
; 415  :     EncoderPicture *lastPic = NULL;

	mov	DWORD PTR _lastPic$[ebp], 0

; 416  : 
; 417  :     UINT skipThreshold = encoderSkipThreshold*2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+164]
	shl	eax, 1
	mov	DWORD PTR _skipThreshold$[ebp], eax

; 418  :     UINT no_sleep_counter = 0;

	mov	DWORD PTR _no_sleep_counter$[ebp], 0

; 419  : 
; 420  :     CircularList<QWORD> bufferedTimes;

	lea	ecx, DWORD PTR _bufferedTimes$[ebp]
	call	??0?$CircularList@_K@@QAE@XZ		; CircularList<unsigned __int64>::CircularList<unsigned __int64>
$LN24@EncodeLoop:

; 421  : 
; 422  :     while (!bShutdownEncodeThread || (bufferedFrames && (!bTestStream || bUsingQSV))) {

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+632]
	test	edx, edx
	je	SHORT $LN21@EncodeLoop
	movzx	eax, BYTE PTR _bufferedFrames$[ebp]
	test	eax, eax
	je	$LN23@EncodeLoop
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+620]
	test	edx, edx
	je	SHORT $LN21@EncodeLoop
	movzx	eax, BYTE PTR _bUsingQSV$[ebp]
	test	eax, eax
	je	$LN23@EncodeLoop
$LN21@EncodeLoop:

; 423  :         if (!SleepToNS(sleepTargetTime += (frameTimeNS/2)))

	push	0
	push	2
	mov	ecx, DWORD PTR _frameTimeNS$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _frameTimeNS$[ebp]
	push	edx
	call	__aulldiv
	add	eax, DWORD PTR _sleepTargetTime$[ebp]
	adc	edx, DWORD PTR _sleepTargetTime$[ebp+4]
	mov	DWORD PTR _sleepTargetTime$[ebp], eax
	mov	DWORD PTR _sleepTargetTime$[ebp+4], edx
	mov	eax, DWORD PTR _sleepTargetTime$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _sleepTargetTime$[ebp]
	push	ecx
	call	?SleepToNS@@YG_N_K@Z			; SleepToNS
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN20@EncodeLoop

; 424  :             no_sleep_counter++;

	mov	eax, DWORD PTR _no_sleep_counter$[ebp]
	add	eax, 1
	mov	DWORD PTR _no_sleep_counter$[ebp], eax

; 425  :         else

	jmp	SHORT $LN19@EncodeLoop
$LN20@EncodeLoop:

; 426  :             no_sleep_counter = 0;

	mov	DWORD PTR _no_sleep_counter$[ebp], 0
$LN19@EncodeLoop:

; 427  : 
; 428  :         latestVideoTime = sleepTargetTime/1000000;

	push	0
	push	1000000					; 000f4240H
	mov	ecx, DWORD PTR _sleepTargetTime$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _sleepTargetTime$[ebp]
	push	edx
	call	__aulldiv
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1008], eax
	mov	DWORD PTR [ecx+1012], edx

; 429  :         latestVideoTimeNS = sleepTargetTime;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _sleepTargetTime$[ebp]
	mov	DWORD PTR [edx+1016], eax
	mov	ecx, DWORD PTR _sleepTargetTime$[ebp+4]
	mov	DWORD PTR [edx+1020], ecx

; 430  : 
; 431  :         if (no_sleep_counter < skipThreshold) {

	mov	edx, DWORD PTR _no_sleep_counter$[ebp]
	cmp	edx, DWORD PTR _skipThreshold$[ebp]
	jae	$LN18@EncodeLoop

; 432  :             SetEvent(hVideoEvent);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1124]
	push	ecx
	call	DWORD PTR __imp__SetEvent@4

; 433  :             if (encoderInfo) {

	cmp	DWORD PTR _encoderInfo$[ebp], 0
	je	SHORT $LN14@EncodeLoop

; 434  :                 if (messageTime == 0) {

	mov	edx, DWORD PTR _messageTime$[ebp]
	or	edx, DWORD PTR _messageTime$[ebp+4]
	jne	SHORT $LN16@EncodeLoop

; 435  :                     messageTime = latestVideoTime+3000;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1008]
	add	ecx, 3000				; 00000bb8H
	mov	edx, DWORD PTR [eax+1012]
	adc	edx, 0
	mov	DWORD PTR _messageTime$[ebp], ecx
	mov	DWORD PTR _messageTime$[ebp+4], edx
	jmp	SHORT $LN14@EncodeLoop
$LN16@EncodeLoop:

; 436  :                 } else if (latestVideoTime >= messageTime) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv375[ebp], eax
	mov	ecx, DWORD PTR tv375[ebp]
	mov	edx, DWORD PTR [ecx+1012]
	cmp	edx, DWORD PTR _messageTime$[ebp+4]
	jb	SHORT $LN14@EncodeLoop
	ja	SHORT $LN31@EncodeLoop
	mov	eax, DWORD PTR tv375[ebp]
	mov	ecx, DWORD PTR [eax+1008]
	cmp	ecx, DWORD PTR _messageTime$[ebp]
	jb	SHORT $LN14@EncodeLoop
$LN31@EncodeLoop:

; 437  :                     RemoveStreamInfo(encoderInfo);

	mov	edx, DWORD PTR _encoderInfo$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveStreamInfo@OBS@@QAEXI@Z		; OBS::RemoveStreamInfo

; 438  :                     encoderInfo = 0;

	mov	DWORD PTR _encoderInfo$[ebp], 0

; 439  :                     messageTime = 0;

	xorpd	xmm0, xmm0
	movlpd	QWORD PTR _messageTime$[ebp], xmm0
$LN14@EncodeLoop:

; 440  :                 }
; 441  :             }
; 442  :         } else {

	jmp	SHORT $LN13@EncodeLoop
$LN18@EncodeLoop:

; 443  :             numFramesSkipped++;

	mov	eax, DWORD PTR _numFramesSkipped$[ebp]
	add	eax, 1
	mov	DWORD PTR _numFramesSkipped$[ebp], eax

; 444  :             if (!encoderInfo)

	cmp	DWORD PTR _encoderInfo$[ebp], 0
	jne	SHORT $LN12@EncodeLoop

; 445  :                 encoderInfo = AddStreamInfo(Str("EncoderLag"), StreamInfoPriority_Critical);

	push	3
	push	OFFSET $SG4294781473
	mov	ecx, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddStreamInfo@OBS@@QAEIPB_WW4StreamInfoPriority@@@Z ; OBS::AddStreamInfo
	mov	DWORD PTR _encoderInfo$[ebp], eax
$LN12@EncodeLoop:

; 446  :             messageTime = 0;

	xorpd	xmm0, xmm0
	movlpd	QWORD PTR _messageTime$[ebp], xmm0
$LN13@EncodeLoop:

; 447  :         }
; 448  : 
; 449  :         if (!SleepToNS(sleepTargetTime += (frameTimeNS/2)))

	push	0
	push	2
	mov	edx, DWORD PTR _frameTimeNS$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _frameTimeNS$[ebp]
	push	eax
	call	__aulldiv
	add	eax, DWORD PTR _sleepTargetTime$[ebp]
	adc	edx, DWORD PTR _sleepTargetTime$[ebp+4]
	mov	DWORD PTR _sleepTargetTime$[ebp], eax
	mov	DWORD PTR _sleepTargetTime$[ebp+4], edx
	mov	ecx, DWORD PTR _sleepTargetTime$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _sleepTargetTime$[ebp]
	push	edx
	call	?SleepToNS@@YG_N_K@Z			; SleepToNS
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN11@EncodeLoop

; 450  :             no_sleep_counter++;

	mov	ecx, DWORD PTR _no_sleep_counter$[ebp]
	add	ecx, 1
	mov	DWORD PTR _no_sleep_counter$[ebp], ecx

; 451  :         else

	jmp	SHORT $LN10@EncodeLoop
$LN11@EncodeLoop:

; 452  :             no_sleep_counter = 0;

	mov	DWORD PTR _no_sleep_counter$[ebp], 0
$LN10@EncodeLoop:

; 453  :         bufferedTimes << latestVideoTime;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1008				; 000003f0H
	push	edx
	lea	ecx, DWORD PTR _bufferedTimes$[ebp]
	call	??6?$CircularList@_K@@QAEAAV0@AB_K@Z	; CircularList<unsigned __int64>::operator<<

; 454  : 
; 455  :         if (curFramePic && firstFrameTimestamp) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1120], 0
	je	$LN9@EncodeLoop
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv446[ebp], ecx
	mov	edx, DWORD PTR tv446[ebp]
	mov	eax, DWORD PTR tv446[ebp]
	mov	ecx, DWORD PTR [edx+1112]
	or	ecx, DWORD PTR [eax+1116]
	je	$LN9@EncodeLoop
$LN8@EncodeLoop:

; 456  :             while (bufferedTimes[0] < firstFrameTimestamp)

	push	0
	lea	ecx, DWORD PTR _bufferedTimes$[ebp]
	call	??A?$CircularList@_K@@QAEAA_KI@Z	; CircularList<unsigned __int64>::operator[]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv454[ebp], eax
	mov	DWORD PTR tv455[ebp], edx
	mov	eax, DWORD PTR tv454[ebp]
	mov	ecx, DWORD PTR tv455[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+1116]
	ja	SHORT $LN7@EncodeLoop
	jb	SHORT $LN32@EncodeLoop
	mov	eax, DWORD PTR tv454[ebp]
	mov	ecx, DWORD PTR tv455[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+1112]
	jae	SHORT $LN7@EncodeLoop
$LN32@EncodeLoop:

; 457  :                 bufferedTimes.Remove(0);

	push	0
	lea	ecx, DWORD PTR _bufferedTimes$[ebp]
	call	?Remove@?$CircularList@_K@@QAEXI@Z	; CircularList<unsigned __int64>::Remove
	jmp	SHORT $LN8@EncodeLoop
$LN7@EncodeLoop:

; 458  : 
; 459  :             DWORD curFrameTimestamp = DWORD(bufferedTimes[0] - firstFrameTimestamp);

	push	0
	lea	ecx, DWORD PTR _bufferedTimes$[ebp]
	call	??A?$CircularList@_K@@QAEAA_KI@Z	; CircularList<unsigned __int64>::operator[]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	sub	edx, DWORD PTR [ecx+1112]
	mov	eax, DWORD PTR [eax+4]
	sbb	eax, DWORD PTR [ecx+1116]
	mov	DWORD PTR _curFrameTimestamp$3[ebp], edx

; 460  :             bufferedTimes.Remove(0);

	push	0
	lea	ecx, DWORD PTR _bufferedTimes$[ebp]
	call	?Remove@?$CircularList@_K@@QAEXI@Z	; CircularList<unsigned __int64>::Remove

; 461  : 
; 462  :             profileIn("encoder thread frame");

	push	0
	push	OFFSET $SG4294781472
	lea	ecx, DWORD PTR __curProfiler$1[ebp]
	call	DWORD PTR __imp_??0ProfilerNode@@QAE@PB_W_N@Z

; 463  : 
; 464  :             FrameProcessInfo frameInfo;
; 465  :             frameInfo.firstFrameTime = firstFrameTimestamp;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1112]
	mov	DWORD PTR _frameInfo$2[ebp+8], edx
	mov	eax, DWORD PTR [ecx+1116]
	mov	DWORD PTR _frameInfo$2[ebp+12], eax

; 466  :             frameInfo.frameTimestamp = curFrameTimestamp;

	mov	ecx, DWORD PTR _curFrameTimestamp$3[ebp]
	mov	DWORD PTR _frameInfo$2[ebp+4], ecx

; 467  :             frameInfo.pic = curFramePic;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1120]
	mov	DWORD PTR _frameInfo$2[ebp], eax

; 468  : 
; 469  :             if (lastPic == frameInfo.pic)

	mov	ecx, DWORD PTR _lastPic$[ebp]
	cmp	ecx, DWORD PTR _frameInfo$2[ebp]
	jne	SHORT $LN6@EncodeLoop

; 470  :                 numTotalDuplicatedFrames++;

	mov	edx, DWORD PTR _numTotalDuplicatedFrames$[ebp]
	add	edx, 1
	mov	DWORD PTR _numTotalDuplicatedFrames$[ebp], edx
$LN6@EncodeLoop:

; 471  : 
; 472  :             if(bUsingQSV)

	movzx	eax, BYTE PTR _bUsingQSV$[ebp]
	test	eax, eax
	je	SHORT $LN5@EncodeLoop

; 473  :                 curFramePic->mfxOut->Data.TimeStamp = curFrameTimestamp;

	mov	ecx, DWORD PTR _curFrameTimestamp$3[ebp]
	xor	edx, edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1120]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+120], ecx
	mov	DWORD PTR [eax+124], edx

; 474  :             else

	jmp	SHORT $LN4@EncodeLoop
$LN5@EncodeLoop:

; 475  :                 curFramePic->picOut->i_pts = curFrameTimestamp;

	mov	ecx, DWORD PTR _curFrameTimestamp$3[ebp]
	xor	edx, edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1120]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], edx
$LN4@EncodeLoop:

; 476  : 
; 477  :             ProcessFrame(frameInfo);

	lea	ecx, DWORD PTR _frameInfo$2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ProcessFrame@OBS@@AAE_NAAUFrameProcessInfo@@@Z ; OBS::ProcessFrame

; 478  : 
; 479  :             lastPic = frameInfo.pic;

	mov	edx, DWORD PTR _frameInfo$2[ebp]
	mov	DWORD PTR _lastPic$[ebp], edx

; 480  : 
; 481  :             profileOut;

	lea	ecx, DWORD PTR __curProfiler$1[ebp]
	call	DWORD PTR __imp_??1ProfilerNode@@QAE@XZ

; 482  : 
; 483  :             numTotalFrames++;

	mov	eax, DWORD PTR _numTotalFrames$[ebp]
	add	eax, 1
	mov	DWORD PTR _numTotalFrames$[ebp], eax
$LN9@EncodeLoop:

; 484  :         }
; 485  : 
; 486  :         if (bShutdownEncodeThread)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+632]
	test	edx, edx
	je	SHORT $LN3@EncodeLoop

; 487  :             bufferedFrames = videoEncoder->HasBufferedFrames();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+148]
	mov	edx, DWORD PTR [eax+48]
	call	edx
	mov	BYTE PTR _bufferedFrames$[ebp], al
$LN3@EncodeLoop:

; 488  :     }

	jmp	$LN24@EncodeLoop
$LN23@EncodeLoop:

; 489  : 
; 490  :     //if (bTestStream)
; 491  :     //    bufferedVideo.Clear();
; 492  : 
; 493  :     //flush all video frames in the "scene buffering time" buffer
; 494  :     if (firstFrameTimestamp)

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv499[ebp], eax
	mov	ecx, DWORD PTR tv499[ebp]
	mov	edx, DWORD PTR tv499[ebp]
	mov	eax, DWORD PTR [ecx+1112]
	or	eax, DWORD PTR [edx+1116]
	je	SHORT $LN2@EncodeLoop

; 495  :         numTotalFrames += FlushBufferedVideo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FlushBufferedVideo@OBS@@AAEIXZ		; OBS::FlushBufferedVideo
	add	eax, DWORD PTR _numTotalFrames$[ebp]
	mov	DWORD PTR _numTotalFrames$[ebp], eax
$LN2@EncodeLoop:

; 496  : 
; 497  :     Log(TEXT("Total frames encoded: %d, total frames duplicated: %d (%0.2f%%)"), numTotalFrames, numTotalDuplicatedFrames, (numTotalFrames > 0) ? (double(numTotalDuplicatedFrames)/double(numTotalFrames))*100.0 : 0.0f);

	cmp	DWORD PTR _numTotalFrames$[ebp], 0
	jle	SHORT $LN27@EncodeLoop
	cvtsi2sd xmm0, DWORD PTR _numTotalDuplicatedFrames$[ebp]
	cvtsi2sd xmm1, DWORD PTR _numTotalFrames$[ebp]
	divsd	xmm0, xmm1
	mulsd	xmm0, QWORD PTR __real@4059000000000000
	movsd	QWORD PTR tv241[ebp], xmm0
	jmp	SHORT $LN28@EncodeLoop
$LN27@EncodeLoop:
	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR tv241[ebp], xmm0
$LN28@EncodeLoop:
	sub	esp, 8
	movsd	xmm0, QWORD PTR tv241[ebp]
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _numTotalDuplicatedFrames$[ebp]
	push	ecx
	mov	edx, DWORD PTR _numTotalFrames$[ebp]
	push	edx
	push	OFFSET $SG4294781471
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 20					; 00000014H

; 498  :     if (numFramesSkipped)

	cmp	DWORD PTR _numFramesSkipped$[ebp], 0
	je	SHORT $LN1@EncodeLoop

; 499  :         Log(TEXT("Number of frames skipped due to encoder lag: %d (%0.2f%%)"), numFramesSkipped, (numTotalFrames > 0) ? (double(numFramesSkipped)/double(numTotalFrames))*100.0 : 0.0f);

	cmp	DWORD PTR _numTotalFrames$[ebp], 0
	jle	SHORT $LN29@EncodeLoop
	cvtsi2sd xmm0, DWORD PTR _numFramesSkipped$[ebp]
	cvtsi2sd xmm1, DWORD PTR _numTotalFrames$[ebp]
	divsd	xmm0, xmm1
	mulsd	xmm0, QWORD PTR __real@4059000000000000
	movsd	QWORD PTR tv253[ebp], xmm0
	jmp	SHORT $LN30@EncodeLoop
$LN29@EncodeLoop:
	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR tv253[ebp], xmm0
$LN30@EncodeLoop:
	sub	esp, 8
	movsd	xmm0, QWORD PTR tv253[ebp]
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _numFramesSkipped$[ebp]
	push	eax
	push	OFFSET $SG4294781470
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 16					; 00000010H
$LN1@EncodeLoop:

; 500  : 
; 501  :     SetEvent(hVideoEvent);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1124]
	push	edx
	call	DWORD PTR __imp__SetEvent@4

; 502  :     bShutdownVideoThread = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+631], 1

; 503  : }

	lea	ecx, DWORD PTR _bufferedTimes$[ebp]
	call	??1?$CircularList@_K@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
?EncodeLoop@OBS@@AAEXXZ ENDP				; OBS::EncodeLoop
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obsvideocapture.cpp
;	COMDAT ?DrawPreview@OBS@@AAEXABUVect2@@00HW4PreviewDrawType@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_renderFrameSize$ = 8					; size = 4
_renderFrameOffset$ = 12				; size = 4
_renderFrameCtrlSize$ = 16				; size = 4
_curRenderTarget$ = 20					; size = 4
_type$ = 24						; size = 4
?DrawPreview@OBS@@AAEXABUVect2@@00HW4PreviewDrawType@@@Z PROC ; OBS::DrawPreview, COMDAT
; _this$ = ecx

; 506  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 507  :     LoadVertexShader(mainVertexShader);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	call	?LoadVertexShader@@YAXPAVShader@@@Z	; LoadVertexShader
	add	esp, 4

; 508  :     LoadPixelShader(mainPixelShader);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	call	?LoadPixelShader@@YAXPAVShader@@@Z	; LoadPixelShader

; 509  : 
; 510  :     Ortho(0.0f, renderFrameCtrlSize.x, renderFrameCtrlSize.y, 0.0f, -100.0f, 100.0f);

	movss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c2c80000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _renderFrameCtrlSize$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+4]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _renderFrameCtrlSize$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	call	?Ortho@@YAXMMMMMM@Z			; Ortho
	add	esp, 24					; 00000018H

; 511  :     if(type != Preview_Projector
; 512  :        && (renderFrameCtrlSize.x != oldRenderFrameCtrlWidth
; 513  :            || renderFrameCtrlSize.y != oldRenderFrameCtrlHeight))

	cmp	DWORD PTR _type$[ebp], 2
	je	SHORT $LN8@DrawPrevie
	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+660]
	mov	ecx, DWORD PTR _renderFrameCtrlSize$[ebp]
	movss	xmm1, DWORD PTR [ecx]
	ucomiss	xmm1, xmm0
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN7@DrawPrevie
	mov	edx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+664]
	mov	eax, DWORD PTR _renderFrameCtrlSize$[ebp]
	movss	xmm1, DWORD PTR [eax+4]
	ucomiss	xmm1, xmm0
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN8@DrawPrevie
$LN7@DrawPrevie:

; 514  :     {
; 515  :         // User is drag resizing the window. We don't recreate the swap chains so our coordinates are wrong
; 516  :         SetViewport(0.0f, 0.0f, (float)oldRenderFrameCtrlWidth, (float)oldRenderFrameCtrlHeight);

	mov	ecx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+664]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+660]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	call	?SetViewport@@YAXMMMM@Z			; SetViewport
	add	esp, 16					; 00000010H

; 517  :     }
; 518  :     else

	jmp	SHORT $LN6@DrawPrevie
$LN8@DrawPrevie:

; 519  :         SetViewport(0.0f, 0.0f, renderFrameCtrlSize.x, renderFrameCtrlSize.y);

	mov	eax, DWORD PTR _renderFrameCtrlSize$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _renderFrameCtrlSize$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	call	?SetViewport@@YAXMMMM@Z			; SetViewport
	add	esp, 16					; 00000010H
$LN6@DrawPrevie:

; 520  : 
; 521  :     // Draw background (Black if fullscreen/projector, window colour otherwise)
; 522  :     if(type == Preview_Fullscreen || type == Preview_Projector)

	cmp	DWORD PTR _type$[ebp], 1
	je	SHORT $LN4@DrawPrevie
	cmp	DWORD PTR _type$[ebp], 2
	jne	SHORT $LN5@DrawPrevie
$LN4@DrawPrevie:

; 523  :         ClearColorBuffer(0x000000);

	push	0
	call	?ClearColorBuffer@@YAXK@Z		; ClearColorBuffer
	add	esp, 4

; 524  :     else

	jmp	SHORT $LN3@DrawPrevie
$LN5@DrawPrevie:

; 525  :         ClearColorBuffer(GetSysColor(COLOR_BTNFACE));

	push	15					; 0000000fH
	call	DWORD PTR __imp__GetSysColor@4
	push	eax
	call	?ClearColorBuffer@@YAXK@Z		; ClearColorBuffer
	add	esp, 4
$LN3@DrawPrevie:

; 526  : 
; 527  :     if(bTransitioning)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+45]
	test	eax, eax
	je	SHORT $LN2@DrawPrevie

; 528  :         DrawSprite(transitionTexture, 0xFFFFFFFF,
; 529  :                 renderFrameOffset.x, renderFrameOffset.y,
; 530  :                 renderFrameOffset.x + renderFrameSize.x, renderFrameOffset.y + renderFrameSize.y);

	mov	ecx, DWORD PTR _renderFrameOffset$[ebp]
	mov	edx, DWORD PTR _renderFrameSize$[ebp]
	movss	xmm0, DWORD PTR [ecx+4]
	addss	xmm0, DWORD PTR [edx+4]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _renderFrameOffset$[ebp]
	mov	ecx, DWORD PTR _renderFrameSize$[ebp]
	movss	xmm0, DWORD PTR [eax]
	addss	xmm0, DWORD PTR [ecx]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _renderFrameOffset$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+4]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _renderFrameOffset$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [esp], xmm0
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	call	?DrawSprite@@YAXPAVTexture@@KMMMM@Z	; DrawSprite
	add	esp, 24					; 00000018H

; 531  :     else

	jmp	SHORT $LN1@DrawPrevie
$LN2@DrawPrevie:

; 532  :         DrawSprite(mainRenderTextures[curRenderTarget], 0xFFFFFFFF,
; 533  :                 renderFrameOffset.x, renderFrameOffset.y,
; 534  :                 renderFrameOffset.x + renderFrameSize.x, renderFrameOffset.y + renderFrameSize.y);

	mov	eax, DWORD PTR _renderFrameOffset$[ebp]
	mov	ecx, DWORD PTR _renderFrameSize$[ebp]
	movss	xmm0, DWORD PTR [eax+4]
	addss	xmm0, DWORD PTR [ecx+4]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _renderFrameOffset$[ebp]
	mov	eax, DWORD PTR _renderFrameSize$[ebp]
	movss	xmm0, DWORD PTR [edx]
	addss	xmm0, DWORD PTR [eax]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _renderFrameOffset$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+4]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _renderFrameOffset$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx]
	movss	DWORD PTR [esp], xmm0
	push	-1
	mov	eax, DWORD PTR _curRenderTarget$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+20]
	push	edx
	call	?DrawSprite@@YAXPAVTexture@@KMMMM@Z	; DrawSprite
	add	esp, 24					; 00000018H
$LN1@DrawPrevie:

; 535  : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?DrawPreview@OBS@@AAEXABUVect2@@00HW4PreviewDrawType@@@Z ENDP ; OBS::DrawPreview
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obsvideocapture.cpp
;	COMDAT ?MainCaptureLoop@OBS@@AAEXXZ
_TEXT	SEGMENT
__curProfiler$1 = -1184					; size = 48
__curProfiler$2 = -1136					; size = 48
__curProfiler$3 = -1088					; size = 48
__curProfiler$4 = -1040					; size = 48
__curProfiler$5 = -992					; size = 48
__curProfiler$6 = -944					; size = 48
$T7 = -896						; size = 8
$T8 = -888						; size = 8
_lastPic$ = -880					; size = 8
$T9 = -872						; size = 8
$T10 = -864						; size = 8
$T11 = -856						; size = 8
$T12 = -848						; size = 8
$T13 = -840						; size = 8
tv1859 = -832						; size = 8
tv2415 = -824						; size = 8
tv1881 = -816						; size = 8
tv1891 = -808						; size = 8
$T14 = -800						; size = 8
tv1913 = -792						; size = 8
$T15 = -784						; size = 8
tv2430 = -776						; size = 8
_renderFrameSize$16 = -768				; size = 8
tv2405 = -760						; size = 8
_renderFrameOffset$17 = -752				; size = 8
tv1903 = -744						; size = 8
_renderFrameCtrlSize$18 = -736				; size = 8
_prevPicOut$19 = -728					; size = 4
tv2450 = -724						; size = 8
tv1869 = -716						; size = 8
_output$20 = -708					; size = 8
tv1760 = -700						; size = 8
_scaleSize$ = -692					; size = 8
tv765 = -684						; size = 4
$T21 = -680						; size = 4
$T22 = -676						; size = 4
_yuvRenderTexture$23 = -672				; size = 4
_prevCopyTexture$24 = -668				; size = 4
_lastStrain$ = -664					; size = 8
_oldPixelShader$25 = -656				; size = 4
tv2841 = -652						; size = 8
_d3dTransitionTex$26 = -644				; size = 4
tv2809 = -640						; size = 8
$T27 = -632						; size = 4
tv2657 = -628						; size = 8
_d3dYUV$28 = -620					; size = 4
_firstFrameTimeMS$ = -616				; size = 8
_projectorAspect$29 = -608				; size = 4
_renderFrameOffset$30 = -604				; size = 8
_hTransitionTime$ = -596				; size = 4
_data$31 = -592						; size = 4
$T32 = -588						; size = 4
$T33 = -584						; size = 4
_d3dSceneTex$34 = -580					; size = 4
_logLongFramesProfilePercentage$ = -576			; size = 4
_bCongestionControl$ = -572				; size = 4
_prevOutBuffer$35 = -568				; size = 4
_completeEvents$ = -564					; size = 8
_fSeconds$36 = -556					; size = 8
tv2149 = -548						; size = 4
tv1823 = -544						; size = 4
tv1624 = -540						; size = 4
tv2401 = -536						; size = 4
tv1579 = -532						; size = 4
tv1657 = -528						; size = 4
tv1491 = -524						; size = 4
tv614 = -520						; size = 4
tv72 = -516						; size = 4
tv1670 = -512						; size = 4
tv1247 = -508						; size = 4
tv2176 = -504						; size = 4
_hScaleVal$ = -500					; size = 4
tv668 = -496						; size = 4
tv1062 = -492						; size = 4
tv576 = -488						; size = 4
tv1028 = -484						; size = 4
_copyTexture$37 = -480					; size = 4
tv994 = -476						; size = 4
tv1661 = -472						; size = 4
tv889 = -468						; size = 4
_lastFramesDropped$ = -464				; size = 4
tv2446 = -460						; size = 4
tv2426 = -456						; size = 4
_reason$38 = -452					; size = 4
_frameLengthNS$ = -448					; size = 8
_nextOutBuffer$39 = -440				; size = 4
_renderFrameSize$40 = -436				; size = 8
tv1277 = -428						; size = 4
_projectorSize$41 = -424				; size = 8
tv1213 = -416						; size = 4
_renderStartTime$42 = -412				; size = 8
tv1079 = -404						; size = 4
_streamTimeStart$ = -400				; size = 8
tv1045 = -392						; size = 4
tv479 = -388						; size = 4
tv1011 = -384						; size = 4
tv451 = -380						; size = 4
tv979 = -376						; size = 4
tv405 = -372						; size = 4
_fProjectorHeight$43 = -368				; size = 4
tv285 = -364						; size = 4
_fProjectorWidth$44 = -360				; size = 4
tv245 = -356						; size = 4
tv2411 = -352						; size = 4
tv1909 = -348						; size = 4
tv736 = -344						; size = 4
tv1899 = -340						; size = 4
tv623 = -336						; size = 4
tv1887 = -332						; size = 4
tv600 = -328						; size = 4
tv1877 = -324						; size = 4
tv1865 = -320						; size = 4
tv1280 = -316						; size = 4
_map$45 = -312						; size = 8
_copyTexture$46 = -304					; size = 4
_picOut$47 = -300					; size = 4
_outputSize$ = -296					; size = 8
_frameDelta$48 = -288					; size = 8
$T49 = -280						; size = 4
_curStreamTime$50 = -276				; size = 8
_baseAspect$51 = -268					; size = 4
_lastAdjustmentTime$ = -264				; size = 8
_message$52 = -256					; size = 8
_bpsTime$ = -248					; size = 8
_i$53 = -240						; size = 4
_data$54 = -236						; size = 4
_i$55 = -232						; size = 4
_baseSize$ = -228					; size = 8
_i$56 = -220						; size = 4
_curBytesSent$57 = -216					; size = 8
_result$58 = -208					; size = 4
_data$59 = -204						; size = 4
_prevTexture$60 = -200					; size = 4
_fpsCounter$ = -196					; size = 4
_nextPicOut$61 = -192					; size = 4
_i$62 = -188						; size = 4
tv1495 = -184						; size = 4
_lastStreamTime$ = -180					; size = 8
_renderStartTimeMS$63 = -172				; size = 8
_i$64 = -164						; size = 4
_numLongFrames$ = -160					; size = 4
_i$65 = -156						; size = 4
_adjustmentStreamId$ = -152				; size = 4
_copyWait$ = -148					; size = 4
_curOutBuffer$ = -144					; size = 4
_defaultBitRate$ = -140					; size = 4
_i$66 = -136						; size = 4
_h420Threads$ = -132					; size = 4
_hMatrix$ = -128					; size = 4
_bLogLongFramesProfile$ = -122				; size = 1
_bDynamicBitrateSupported$ = -121			; size = 1
_numTotalFrames$ = -120					; size = 4
_curCopyTexture$ = -116					; size = 4
_i$67 = -112						; size = 4
_numSecondsWaited$ = -108				; size = 4
_curYUVTexture$ = -104					; size = 4
_bWasLaggedFrame$ = -99					; size = 1
_bFirstFrame$ = -98					; size = 1
_bRenderView$68 = -97					; size = 1
_numThreads$ = -96					; size = 4
_bFirstImage$ = -89					; size = 1
_curRenderTarget$ = -88					; size = 4
_i$69 = -84						; size = 4
_currentBitRate$ = -80					; size = 4
_i$70 = -76						; size = 4
_i$71 = -72						; size = 4
_bUpdateBPS$72 = -65					; size = 1
_bFirstEncode$ = -64					; size = 1
_bUseThreaded420$ = -63					; size = 1
_bUsingQSV$ = -62					; size = 1
_bEncode$ = -61						; size = 1
_convertInfo$ = -60					; size = 4
_this$ = -56						; size = 4
_outPics$ = -52						; size = 24
_lastBytesSent$ = -28					; size = 24
__$ArrayPad$ = -4					; size = 4
?MainCaptureLoop@OBS@@AAEXXZ PROC			; OBS::MainCaptureLoop, COMDAT
; _this$ = ecx

; 604  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1184				; 000004a0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 605  :     int curRenderTarget = 0, curYUVTexture = 0, curCopyTexture = 0;

	mov	DWORD PTR _curRenderTarget$[ebp], 0
	mov	DWORD PTR _curYUVTexture$[ebp], 0
	mov	DWORD PTR _curCopyTexture$[ebp], 0

; 606  :     int copyWait = NUM_RENDER_BUFFERS-1;

	mov	DWORD PTR _copyWait$[ebp], 1

; 607  : 
; 608  :     bSentHeaders = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+989], 0

; 609  :     bFirstAudioPacket = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+990], 1

; 610  : 
; 611  :     bool bLogLongFramesProfile = GlobalConfig->GetInt(TEXT("General"), TEXT("LogLongFramesProfile"), LOGLONGFRAMESDEFAULT) != 0;

	push	0
	push	OFFSET $SG4294781469
	push	OFFSET $SG4294781468
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	test	eax, eax
	je	SHORT $LN164@MainCaptur
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN165@MainCaptur
$LN164@MainCaptur:
	mov	DWORD PTR tv72[ebp], 0
$LN165@MainCaptur:
	mov	dl, BYTE PTR tv72[ebp]
	mov	BYTE PTR _bLogLongFramesProfile$[ebp], dl

; 612  :     float logLongFramesProfilePercentage = GlobalConfig->GetFloat(TEXT("General"), TEXT("LogLongFramesProfilePercentage"), 10.f);

	push	ecx
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG4294781467
	push	OFFSET $SG4294781466
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?GetFloat@ConfigFile@@QAEMPB_W0M@Z
	fstp	DWORD PTR _logLongFramesProfilePercentage$[ebp]

; 613  : 
; 614  :     Vect2 baseSize    = Vect2(float(baseCX), float(baseCY));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+860]
	mov	DWORD PTR tv1823[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv1823[ebp]
	mov	edx, DWORD PTR tv1823[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv1859[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv1859[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	DWORD PTR tv1865[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv1865[ebp]
	mov	edx, DWORD PTR tv1865[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv1869[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv1869[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _baseSize$[ebp]
	call	DWORD PTR __imp_??0Vect2@@QAE@MM@Z

; 615  :     Vect2 outputSize  = Vect2(float(outputCX), float(outputCY));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+876]
	mov	DWORD PTR tv1877[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv1877[ebp]
	mov	edx, DWORD PTR tv1877[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv1881[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv1881[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+872]
	mov	DWORD PTR tv1887[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv1887[ebp]
	mov	edx, DWORD PTR tv1887[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv1891[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv1891[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _outputSize$[ebp]
	call	DWORD PTR __imp_??0Vect2@@QAE@MM@Z

; 616  :     Vect2 scaleSize   = Vect2(float(scaleCX), float(scaleCY));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+868]
	mov	DWORD PTR tv1899[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv1899[ebp]
	mov	edx, DWORD PTR tv1899[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv1903[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv1903[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+864]
	mov	DWORD PTR tv1909[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv1909[ebp]
	mov	edx, DWORD PTR tv1909[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv1913[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv1913[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _scaleSize$[ebp]
	call	DWORD PTR __imp_??0Vect2@@QAE@MM@Z

; 617  : 
; 618  :     HANDLE hMatrix   = yuvScalePixelShader->GetParameterByName(TEXT("yuvMat"));

	push	OFFSET $SG4294781465
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+60]
	mov	edx, DWORD PTR [eax+16]
	call	edx
	mov	DWORD PTR _hMatrix$[ebp], eax

; 619  :     HANDLE hScaleVal = yuvScalePixelShader->GetParameterByName(TEXT("baseDimensionI"));

	push	OFFSET $SG4294781464
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+60]
	mov	edx, DWORD PTR [eax+16]
	call	edx
	mov	DWORD PTR _hScaleVal$[ebp], eax

; 620  : 
; 621  :     HANDLE hTransitionTime = transitionPixelShader->GetParameterByName(TEXT("transitionTime"));

	push	OFFSET $SG4294781463
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+64]
	mov	edx, DWORD PTR [eax+16]
	call	edx
	mov	DWORD PTR _hTransitionTime$[ebp], eax

; 622  : 
; 623  :     //----------------------------------------
; 624  :     // x264 input buffers
; 625  : 
; 626  :     int curOutBuffer = 0;

	mov	DWORD PTR _curOutBuffer$[ebp], 0

; 627  : 
; 628  :     bool bUsingQSV = videoEncoder->isQSV();//GlobalConfig->GetInt(TEXT("Video Encoding"), TEXT("UseQSV")) != 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+148]
	mov	edx, DWORD PTR [eax+40]
	call	edx
	mov	BYTE PTR _bUsingQSV$[ebp], al

; 629  :     bUsing444 = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+896], 0

; 630  : 
; 631  :     EncoderPicture lastPic;

	lea	ecx, DWORD PTR _lastPic$[ebp]
	call	??0EncoderPicture@@QAE@XZ		; EncoderPicture::EncoderPicture

; 632  :     EncoderPicture outPics[NUM_OUT_BUFFERS];

	push	OFFSET ??0EncoderPicture@@QAE@XZ	; EncoderPicture::EncoderPicture
	push	3
	push	8
	lea	ecx, DWORD PTR _outPics$[ebp]
	push	ecx
	call	??_H@YGXPAXIHP6EPAX0@Z@Z

; 633  : 
; 634  :     for(int i=0; i<NUM_OUT_BUFFERS; i++)

	mov	DWORD PTR _i$67[ebp], 0
	jmp	SHORT $LN161@MainCaptur
$LN160@MainCaptur:
	mov	edx, DWORD PTR _i$67[ebp]
	add	edx, 1
	mov	DWORD PTR _i$67[ebp], edx
$LN161@MainCaptur:
	cmp	DWORD PTR _i$67[ebp], 3
	jge	$LN159@MainCaptur

; 635  :     {
; 636  :         if(bUsingQSV)

	movzx	eax, BYTE PTR _bUsingQSV$[ebp]
	test	eax, eax
	je	SHORT $LN158@MainCaptur

; 637  :         {
; 638  :             outPics[i].mfxOut = new mfxFrameSurface1;

	push	160					; 000000a0H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T21[ebp], eax
	mov	ecx, DWORD PTR _i$67[ebp]
	mov	edx, DWORD PTR $T21[ebp]
	mov	DWORD PTR _outPics$[ebp+ecx*8+4], edx

; 639  :             memset(outPics[i].mfxOut, 0, sizeof(mfxFrameSurface1));

	push	160					; 000000a0H
	push	0
	mov	eax, DWORD PTR _i$67[ebp]
	mov	ecx, DWORD PTR _outPics$[ebp+eax*8+4]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 640  :             mfxFrameData& data = outPics[i].mfxOut->Data;

	mov	edx, DWORD PTR _i$67[ebp]
	mov	eax, DWORD PTR _outPics$[ebp+edx*8+4]
	add	eax, 88					; 00000058H
	mov	DWORD PTR _data$31[ebp], eax

; 641  :             videoEncoder->RequestBuffers(&data);

	mov	ecx, DWORD PTR _data$31[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+148]
	mov	eax, DWORD PTR [edx+4]
	call	eax

; 642  :         }
; 643  :         else

	jmp	SHORT $LN157@MainCaptur
$LN158@MainCaptur:

; 644  :         {
; 645  :             outPics[i].picOut = new x264_picture_t;

	push	192					; 000000c0H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T22[ebp], eax
	mov	ecx, DWORD PTR _i$67[ebp]
	mov	edx, DWORD PTR $T22[ebp]
	mov	DWORD PTR _outPics$[ebp+ecx*8], edx

; 646  :             x264_picture_init(outPics[i].picOut);

	mov	eax, DWORD PTR _i$67[ebp]
	mov	ecx, DWORD PTR _outPics$[ebp+eax*8]
	push	ecx
	call	DWORD PTR __imp__x264_picture_init
	add	esp, 4
$LN157@MainCaptur:

; 647  :         }
; 648  :     }

	jmp	$LN160@MainCaptur
$LN159@MainCaptur:

; 649  : 
; 650  :     if(bUsing444)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+896]
	test	eax, eax
	je	SHORT $LN156@MainCaptur

; 651  :     {
; 652  :         for(int i=0; i<NUM_OUT_BUFFERS; i++)

	mov	DWORD PTR _i$64[ebp], 0
	jmp	SHORT $LN155@MainCaptur
$LN154@MainCaptur:
	mov	ecx, DWORD PTR _i$64[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$64[ebp], ecx
$LN155@MainCaptur:
	cmp	DWORD PTR _i$64[ebp], 3
	jge	SHORT $LN153@MainCaptur

; 653  :         {
; 654  :             outPics[i].picOut->img.i_csp   = X264_CSP_BGRA; //although the x264 input says BGR, x264 actually will expect packed UYV

	mov	edx, DWORD PTR _i$64[ebp]
	mov	eax, DWORD PTR _outPics$[ebp+edx*8]
	mov	DWORD PTR [eax+36], 11			; 0000000bH

; 655  :             outPics[i].picOut->img.i_plane = 1;

	mov	ecx, DWORD PTR _i$64[ebp]
	mov	edx, DWORD PTR _outPics$[ebp+ecx*8]
	mov	DWORD PTR [edx+40], 1

; 656  :         }

	jmp	SHORT $LN154@MainCaptur
$LN153@MainCaptur:

; 657  :     }
; 658  :     else

	jmp	SHORT $LN148@MainCaptur
$LN156@MainCaptur:

; 659  :     {
; 660  :         if(!bUsingQSV)

	movzx	eax, BYTE PTR _bUsingQSV$[ebp]
	test	eax, eax
	jne	SHORT $LN148@MainCaptur

; 661  :             for(int i=0; i<NUM_OUT_BUFFERS; i++)

	mov	DWORD PTR _i$55[ebp], 0
	jmp	SHORT $LN150@MainCaptur
$LN149@MainCaptur:
	mov	ecx, DWORD PTR _i$55[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$55[ebp], ecx
$LN150@MainCaptur:
	cmp	DWORD PTR _i$55[ebp], 3
	jge	SHORT $LN148@MainCaptur

; 662  :                 x264_picture_alloc(outPics[i].picOut, X264_CSP_NV12, outputCX, outputCY);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+876]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+872]
	push	edx
	push	3
	mov	eax, DWORD PTR _i$55[ebp]
	mov	ecx, DWORD PTR _outPics$[ebp+eax*8]
	push	ecx
	call	DWORD PTR __imp__x264_picture_alloc
	add	esp, 16					; 00000010H
	jmp	SHORT $LN149@MainCaptur
$LN148@MainCaptur:

; 663  :     }
; 664  : 
; 665  :     int bCongestionControl = AppConfig->GetInt (TEXT("Video Encoding"), TEXT("CongestionControl"), 0);

	push	0
	push	OFFSET $SG4294781462
	push	OFFSET $SG4294781461
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _bCongestionControl$[ebp], eax

; 666  :     bool bDynamicBitrateSupported = App->GetVideoEncoder()->DynamicBitrateSupported();

	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?GetVideoEncoder@OBS@@QBEPAVVideoEncoder@@XZ ; OBS::GetVideoEncoder
	mov	DWORD PTR tv245[ebp], eax
	mov	edx, DWORD PTR tv245[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv245[ebp]
	mov	edx, DWORD PTR [eax+16]
	call	edx
	mov	BYTE PTR _bDynamicBitrateSupported$[ebp], al

; 667  :     int defaultBitRate = AppConfig->GetInt(TEXT("Video Encoding"), TEXT("MaxBitrate"), 1000);

	push	1000					; 000003e8H
	push	OFFSET $SG4294781460
	push	OFFSET $SG4294781459
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _defaultBitRate$[ebp], eax

; 668  :     int currentBitRate = defaultBitRate;

	mov	eax, DWORD PTR _defaultBitRate$[ebp]
	mov	DWORD PTR _currentBitRate$[ebp], eax

; 669  :     QWORD lastAdjustmentTime = 0;

	xorpd	xmm0, xmm0
	movlpd	QWORD PTR _lastAdjustmentTime$[ebp], xmm0

; 670  :     UINT adjustmentStreamId = 0;

	mov	DWORD PTR _adjustmentStreamId$[ebp], 0

; 671  : 
; 672  :     //std::unique_ptr<ProfilerNode> encodeThreadProfiler;
; 673  : 
; 674  :     //----------------------------------------
; 675  :     // time/timestamp stuff
; 676  : 
; 677  :     bool bWasLaggedFrame = false;

	mov	BYTE PTR _bWasLaggedFrame$[ebp], 0

; 678  : 
; 679  :     totalStreamTime = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+928], 0

; 680  :     lastAudioTimestamp = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+992], 0

; 681  : 
; 682  :     //----------------------------------------
; 683  :     // start audio capture streams
; 684  : 
; 685  :     desktopAudio->StartCapture();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+112]
	mov	edx, DWORD PTR [eax+36]
	call	edx

; 686  :     if(micAudio) micAudio->StartCapture();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+116], 0
	je	SHORT $LN147@MainCaptur
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+116]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+116]
	mov	eax, DWORD PTR [edx+36]
	call	eax
$LN147@MainCaptur:

; 687  : 
; 688  :     //----------------------------------------
; 689  :     // status bar/statistics stuff
; 690  : 
; 691  :     DWORD fpsCounter = 0;

	mov	DWORD PTR _fpsCounter$[ebp], 0

; 692  : 
; 693  :     int numLongFrames = 0;

	mov	DWORD PTR _numLongFrames$[ebp], 0

; 694  :     int numTotalFrames = 0;

	mov	DWORD PTR _numTotalFrames$[ebp], 0

; 695  : 
; 696  :     bytesPerSec = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+916], 0

; 697  :     captureFPS = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+920], 0

; 698  :     curFramesDropped = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+924], 0

; 699  :     curStrain = 0.0;

	mov	ecx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR [ecx+936], xmm0

; 700  :     PostMessage(hwndMain, OBS_UPDATESTATUSBAR, 0, 0);

	push	0
	push	0
	push	1031					; 00000407H
	mov	edx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	edx
	call	DWORD PTR __imp__PostMessageW@16

; 701  : 
; 702  :     QWORD lastBytesSent[3] = {0, 0, 0};

	xorpd	xmm0, xmm0
	movlpd	QWORD PTR _lastBytesSent$[ebp], xmm0
	xorpd	xmm0, xmm0
	movlpd	QWORD PTR _lastBytesSent$[ebp+8], xmm0
	xorpd	xmm0, xmm0
	movlpd	QWORD PTR _lastBytesSent$[ebp+16], xmm0

; 703  :     DWORD lastFramesDropped = 0;

	mov	DWORD PTR _lastFramesDropped$[ebp], 0

; 704  :     double bpsTime = 0.0;

	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR _bpsTime$[ebp], xmm0

; 705  : 
; 706  :     double lastStrain = 0.0f;

	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR _lastStrain$[ebp], xmm0

; 707  :     DWORD numSecondsWaited = 0;

	mov	DWORD PTR _numSecondsWaited$[ebp], 0

; 708  : 
; 709  :     //----------------------------------------
; 710  :     // 444->420 thread data
; 711  : 
; 712  :     int numThreads = MAX(OSGetTotalCores()-2, 1);

	call	DWORD PTR __imp_?OSGetTotalCores@@YGHXZ
	sub	eax, 2
	cmp	eax, 1
	jle	SHORT $LN166@MainCaptur
	call	DWORD PTR __imp_?OSGetTotalCores@@YGHXZ
	sub	eax, 2
	mov	DWORD PTR tv285[ebp], eax
	jmp	SHORT $LN167@MainCaptur
$LN166@MainCaptur:
	mov	DWORD PTR tv285[ebp], 1
$LN167@MainCaptur:
	mov	eax, DWORD PTR tv285[ebp]
	mov	DWORD PTR _numThreads$[ebp], eax

; 713  :     HANDLE *h420Threads = (HANDLE*)Allocate(sizeof(HANDLE)*numThreads);

	mov	ecx, DWORD PTR _numThreads$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	mov	DWORD PTR _h420Threads$[ebp], eax

; 714  :     Convert444Data *convertInfo = (Convert444Data*)Allocate(sizeof(Convert444Data)*numThreads);

	imul	ecx, DWORD PTR _numThreads$[ebp], 56
	push	ecx
	mov	edx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	mov	DWORD PTR _convertInfo$[ebp], eax

; 715  : 
; 716  :     zero(h420Threads, sizeof(HANDLE)*numThreads);

	mov	ecx, DWORD PTR _numThreads$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _h420Threads$[ebp]
	push	edx
	call	?zero@@YGXPAXI@Z			; zero

; 717  :     zero(convertInfo, sizeof(Convert444Data)*numThreads);

	imul	eax, DWORD PTR _numThreads$[ebp], 56
	push	eax
	mov	ecx, DWORD PTR _convertInfo$[ebp]
	push	ecx
	call	?zero@@YGXPAXI@Z			; zero

; 718  : 
; 719  :     for(int i=0; i<numThreads; i++)

	mov	DWORD PTR _i$71[ebp], 0
	jmp	SHORT $LN146@MainCaptur
$LN145@MainCaptur:
	mov	edx, DWORD PTR _i$71[ebp]
	add	edx, 1
	mov	DWORD PTR _i$71[ebp], edx
$LN146@MainCaptur:
	mov	eax, DWORD PTR _i$71[ebp]
	cmp	eax, DWORD PTR _numThreads$[ebp]
	jge	$LN144@MainCaptur

; 720  :     {
; 721  :         convertInfo[i].width  = outputCX;

	imul	ecx, DWORD PTR _i$71[ebp], 56
	mov	edx, DWORD PTR _convertInfo$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+872]
	mov	DWORD PTR [edx+ecx+28], eax

; 722  :         convertInfo[i].height = outputCY;

	imul	ecx, DWORD PTR _i$71[ebp], 56
	mov	edx, DWORD PTR _convertInfo$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+876]
	mov	DWORD PTR [edx+ecx+32], eax

; 723  :         convertInfo[i].hSignalConvert  = CreateEvent(NULL, FALSE, FALSE, NULL);

	push	0
	push	0
	push	0
	push	0
	call	DWORD PTR __imp__CreateEventW@16
	imul	ecx, DWORD PTR _i$71[ebp], 56
	mov	edx, DWORD PTR _convertInfo$[ebp]
	mov	DWORD PTR [edx+ecx+20], eax

; 724  :         convertInfo[i].hSignalComplete = CreateEvent(NULL, FALSE, FALSE, NULL);

	push	0
	push	0
	push	0
	push	0
	call	DWORD PTR __imp__CreateEventW@16
	imul	ecx, DWORD PTR _i$71[ebp], 56
	mov	edx, DWORD PTR _convertInfo$[ebp]
	mov	DWORD PTR [edx+ecx+24], eax

; 725  :         convertInfo[i].bNV12 = bUsingQSV;

	imul	eax, DWORD PTR _i$71[ebp], 56
	mov	ecx, DWORD PTR _convertInfo$[ebp]
	mov	dl, BYTE PTR _bUsingQSV$[ebp]
	mov	BYTE PTR [ecx+eax+16], dl

; 726  :         convertInfo[i].numThreads = numThreads;

	imul	eax, DWORD PTR _i$71[ebp], 56
	mov	ecx, DWORD PTR _convertInfo$[ebp]
	mov	edx, DWORD PTR _numThreads$[ebp]
	mov	DWORD PTR [ecx+eax+52], edx

; 727  : 
; 728  :         if(i == 0)

	cmp	DWORD PTR _i$71[ebp], 0
	jne	SHORT $LN143@MainCaptur

; 729  :             convertInfo[i].startY = 0;

	imul	eax, DWORD PTR _i$71[ebp], 56
	mov	ecx, DWORD PTR _convertInfo$[ebp]
	mov	DWORD PTR [ecx+eax+44], 0

; 730  :         else

	jmp	SHORT $LN142@MainCaptur
$LN143@MainCaptur:

; 731  :             convertInfo[i].startY = convertInfo[i-1].endY;

	mov	edx, DWORD PTR _i$71[ebp]
	sub	edx, 1
	imul	eax, edx, 56
	imul	ecx, DWORD PTR _i$71[ebp], 56
	mov	edx, DWORD PTR _convertInfo$[ebp]
	mov	esi, DWORD PTR _convertInfo$[ebp]
	mov	eax, DWORD PTR [esi+eax+48]
	mov	DWORD PTR [edx+ecx+44], eax
$LN142@MainCaptur:

; 732  : 
; 733  :         if(i == (numThreads-1))

	mov	ecx, DWORD PTR _numThreads$[ebp]
	sub	ecx, 1
	cmp	DWORD PTR _i$71[ebp], ecx
	jne	SHORT $LN141@MainCaptur

; 734  :             convertInfo[i].endY = outputCY;

	imul	edx, DWORD PTR _i$71[ebp], 56
	mov	eax, DWORD PTR _convertInfo$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+876]
	mov	DWORD PTR [eax+edx+48], ecx

; 735  :         else

	jmp	SHORT $LN140@MainCaptur
$LN141@MainCaptur:

; 736  :             convertInfo[i].endY = ((outputCY/numThreads)*(i+1)) & 0xFFFFFFFE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+876]
	xor	edx, edx
	div	DWORD PTR _numThreads$[ebp]
	mov	ecx, DWORD PTR _i$71[ebp]
	add	ecx, 1
	imul	eax, ecx
	and	eax, -2					; fffffffeH
	imul	edx, DWORD PTR _i$71[ebp], 56
	mov	ecx, DWORD PTR _convertInfo$[ebp]
	mov	DWORD PTR [ecx+edx+48], eax
$LN140@MainCaptur:

; 737  :     }

	jmp	$LN145@MainCaptur
$LN144@MainCaptur:

; 738  : 
; 739  :     bool bEncode;
; 740  :     bool bFirstFrame = true;

	mov	BYTE PTR _bFirstFrame$[ebp], 1

; 741  :     bool bFirstImage = true;

	mov	BYTE PTR _bFirstImage$[ebp], 1

; 742  :     bool bFirstEncode = true;

	mov	BYTE PTR _bFirstEncode$[ebp], 1

; 743  :     bool bUseThreaded420 = bUseMultithreadedOptimizations && (OSGetTotalCores() > 1) && !bUsing444;

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+621]
	test	eax, eax
	je	SHORT $LN168@MainCaptur
	call	DWORD PTR __imp_?OSGetTotalCores@@YGHXZ
	cmp	eax, 1
	jle	SHORT $LN168@MainCaptur
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+896]
	test	edx, edx
	jne	SHORT $LN168@MainCaptur
	mov	DWORD PTR tv405[ebp], 1
	jmp	SHORT $LN169@MainCaptur
$LN168@MainCaptur:
	mov	DWORD PTR tv405[ebp], 0
$LN169@MainCaptur:
	mov	al, BYTE PTR tv405[ebp]
	mov	BYTE PTR _bUseThreaded420$[ebp], al

; 744  : 
; 745  :     List<HANDLE> completeEvents;

	lea	ecx, DWORD PTR _completeEvents$[ebp]
	call	??0?$List@PAX@@QAE@XZ			; List<void *>::List<void *>

; 746  : 
; 747  :     if(bUseThreaded420)

	movzx	ecx, BYTE PTR _bUseThreaded420$[ebp]
	test	ecx, ecx
	je	SHORT $LN136@MainCaptur

; 748  :     {
; 749  :         for(int i=0; i<numThreads; i++)

	mov	DWORD PTR _i$66[ebp], 0
	jmp	SHORT $LN138@MainCaptur
$LN137@MainCaptur:
	mov	edx, DWORD PTR _i$66[ebp]
	add	edx, 1
	mov	DWORD PTR _i$66[ebp], edx
$LN138@MainCaptur:
	mov	eax, DWORD PTR _i$66[ebp]
	cmp	eax, DWORD PTR _numThreads$[ebp]
	jge	SHORT $LN136@MainCaptur

; 750  :         {
; 751  :             h420Threads[i] = OSCreateThread((XTHREAD)Convert444Thread, convertInfo+i);

	imul	ecx, DWORD PTR _i$66[ebp], 56
	add	ecx, DWORD PTR _convertInfo$[ebp]
	push	ecx
	push	OFFSET ?Convert444Thread@@YGKPAUConvert444Data@@@Z ; Convert444Thread
	call	DWORD PTR __imp_?OSCreateThread@@YGPAXP6GKPAX@Z0@Z
	mov	edx, DWORD PTR _i$66[ebp]
	mov	ecx, DWORD PTR _h420Threads$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 752  :             completeEvents << convertInfo[i].hSignalComplete;

	imul	edx, DWORD PTR _i$66[ebp], 56
	mov	eax, DWORD PTR _convertInfo$[ebp]
	lea	ecx, DWORD PTR [eax+edx+24]
	push	ecx
	lea	ecx, DWORD PTR _completeEvents$[ebp]
	call	??6?$List@PAX@@QAEAAV0@ABQAX@Z		; List<void *>::operator<<

; 753  :         }

	jmp	SHORT $LN137@MainCaptur
$LN136@MainCaptur:

; 754  :     }
; 755  : 
; 756  :     //----------------------------------------
; 757  : 
; 758  :     QWORD streamTimeStart  = GetQPCTimeNS();

	call	DWORD PTR __imp_?GetQPCTimeNS@@YA_KXZ
	mov	DWORD PTR _streamTimeStart$[ebp], eax
	mov	DWORD PTR _streamTimeStart$[ebp+4], edx

; 759  :     QWORD lastStreamTime   = 0;

	xorpd	xmm0, xmm0
	movlpd	QWORD PTR _lastStreamTime$[ebp], xmm0

; 760  :     QWORD firstFrameTimeMS = streamTimeStart/1000000;

	push	0
	push	1000000					; 000f4240H
	mov	edx, DWORD PTR _streamTimeStart$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _streamTimeStart$[ebp]
	push	eax
	call	__aulldiv
	mov	DWORD PTR _firstFrameTimeMS$[ebp], eax
	mov	DWORD PTR _firstFrameTimeMS$[ebp+4], edx

; 761  :     QWORD frameLengthNS    = 1000000000/fps;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, 1000000000				; 3b9aca00H
	xor	edx, edx
	div	DWORD PTR [ecx+892]
	xor	edx, edx
	mov	DWORD PTR _frameLengthNS$[ebp], eax
	mov	DWORD PTR _frameLengthNS$[ebp+4], edx
$LN135@MainCaptur:

; 762  : 
; 763  :     while(WaitForSingleObject(hVideoEvent, INFINITE) == WAIT_OBJECT_0)

	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1124]
	push	ecx
	call	DWORD PTR __imp__WaitForSingleObject@8
	test	eax, eax
	jne	$LN134@MainCaptur

; 764  :     {
; 765  :         if (bShutdownVideoThread)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+631]
	test	eax, eax
	je	SHORT $LN133@MainCaptur

; 766  :             break;

	jmp	$LN134@MainCaptur
$LN133@MainCaptur:

; 767  : 
; 768  :         QWORD renderStartTime = GetQPCTimeNS();

	call	DWORD PTR __imp_?GetQPCTimeNS@@YA_KXZ
	mov	DWORD PTR _renderStartTime$42[ebp], eax
	mov	DWORD PTR _renderStartTime$42[ebp+4], edx

; 769  :         totalStreamTime = DWORD((renderStartTime-streamTimeStart)/1000000);

	mov	ecx, DWORD PTR _renderStartTime$42[ebp]
	sub	ecx, DWORD PTR _streamTimeStart$[ebp]
	mov	edx, DWORD PTR _renderStartTime$42[ebp+4]
	sbb	edx, DWORD PTR _streamTimeStart$[ebp+4]
	push	0
	push	1000000					; 000f4240H
	push	edx
	push	ecx
	call	__aulldiv
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+928], eax

; 770  : 
; 771  :         bool bRenderView = !IsIconic(hwndMain) && bRenderViewEnabled;

	mov	edx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	edx
	call	DWORD PTR __imp__IsIconic@4
	test	eax, eax
	jne	SHORT $LN170@MainCaptur
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+742]
	test	ecx, ecx
	je	SHORT $LN170@MainCaptur
	mov	DWORD PTR tv451[ebp], 1
	jmp	SHORT $LN171@MainCaptur
$LN170@MainCaptur:
	mov	DWORD PTR tv451[ebp], 0
$LN171@MainCaptur:
	mov	dl, BYTE PTR tv451[ebp]
	mov	BYTE PTR _bRenderView$68[ebp], dl

; 772  : 
; 773  :         QWORD renderStartTimeMS = renderStartTime/1000000;

	push	0
	push	1000000					; 000f4240H
	mov	eax, DWORD PTR _renderStartTime$42[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _renderStartTime$42[ebp]
	push	ecx
	call	__aulldiv
	mov	DWORD PTR _renderStartTimeMS$63[ebp], eax
	mov	DWORD PTR _renderStartTimeMS$63[ebp+4], edx

; 774  : 
; 775  :         QWORD curStreamTime = latestVideoTimeNS;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1016]
	mov	DWORD PTR _curStreamTime$50[ebp], eax
	mov	ecx, DWORD PTR [edx+1020]
	mov	DWORD PTR _curStreamTime$50[ebp+4], ecx

; 776  :         if (!lastStreamTime)

	mov	edx, DWORD PTR _lastStreamTime$[ebp]
	or	edx, DWORD PTR _lastStreamTime$[ebp+4]
	jne	SHORT $LN132@MainCaptur

; 777  :             lastStreamTime = curStreamTime-frameLengthNS;

	mov	eax, DWORD PTR _curStreamTime$50[ebp]
	sub	eax, DWORD PTR _frameLengthNS$[ebp]
	mov	ecx, DWORD PTR _curStreamTime$50[ebp+4]
	sbb	ecx, DWORD PTR _frameLengthNS$[ebp+4]
	mov	DWORD PTR _lastStreamTime$[ebp], eax
	mov	DWORD PTR _lastStreamTime$[ebp+4], ecx
$LN132@MainCaptur:

; 778  :         QWORD frameDelta = curStreamTime-lastStreamTime;

	mov	edx, DWORD PTR _curStreamTime$50[ebp]
	sub	edx, DWORD PTR _lastStreamTime$[ebp]
	mov	eax, DWORD PTR _curStreamTime$50[ebp+4]
	sbb	eax, DWORD PTR _lastStreamTime$[ebp+4]
	mov	DWORD PTR _frameDelta$48[ebp], edx
	mov	DWORD PTR _frameDelta$48[ebp+4], eax

; 779  :         //if (!lastStreamTime)
; 780  :         //    lastStreamTime = renderStartTime-frameLengthNS;
; 781  :         //QWORD frameDelta = renderStartTime-lastStreamTime;
; 782  :         double fSeconds = double(frameDelta)*0.000000001;

	mov	edx, DWORD PTR _frameDelta$48[ebp+4]
	mov	ecx, DWORD PTR _frameDelta$48[ebp]
	call	__ultod3
	mulsd	xmm0, QWORD PTR __real@3e112e0be826d695
	movsd	QWORD PTR _fSeconds$36[ebp], xmm0

; 783  :         //lastStreamTime = renderStartTime;
; 784  : 
; 785  :         bool bUpdateBPS = false;

	mov	BYTE PTR _bUpdateBPS$72[ebp], 0

; 786  : 
; 787  :         profileIn("video thread frame");

	push	0
	push	OFFSET $SG4294781458
	lea	ecx, DWORD PTR __curProfiler$1[ebp]
	call	DWORD PTR __imp_??0ProfilerNode@@QAE@PB_W_N@Z

; 788  : 
; 789  :         //Log(TEXT("Stream Time: %llu"), curStreamTime);
; 790  :         //Log(TEXT("frameDelta: %lf"), fSeconds);
; 791  : 
; 792  :         //------------------------------------
; 793  : 
; 794  :         if(bRequestKeyframe && keyframeWait > 0)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+1104]
	test	edx, edx
	je	SHORT $LN130@MainCaptur
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1108], 0
	jle	SHORT $LN130@MainCaptur

; 795  :         {
; 796  :             keyframeWait -= int(frameDelta);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1108]
	sub	edx, DWORD PTR _frameDelta$48[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1108], edx

; 797  : 
; 798  :             if(keyframeWait <= 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1108], 0
	jg	SHORT $LN130@MainCaptur

; 799  :             {
; 800  :                 GetVideoEncoder()->RequestKeyframe();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetVideoEncoder@OBS@@QBEPAVVideoEncoder@@XZ ; OBS::GetVideoEncoder
	mov	DWORD PTR tv479[ebp], eax
	mov	edx, DWORD PTR tv479[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv479[ebp]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 801  :                 bRequestKeyframe = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1104], 0
$LN130@MainCaptur:

; 802  :             }
; 803  :         }
; 804  : 
; 805  :         if(!pushToTalkDown && pushToTalkTimeLeft > 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1240], 0
	jne	$LN128@MainCaptur
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv2149[ebp], edx
	mov	eax, DWORD PTR tv2149[ebp]
	cmp	DWORD PTR [eax+1260], 0
	jl	$LN128@MainCaptur
	jg	SHORT $LN200@MainCaptur
	mov	ecx, DWORD PTR tv2149[ebp]
	cmp	DWORD PTR [ecx+1256], 0
	jbe	$LN128@MainCaptur
$LN200@MainCaptur:

; 806  :         {
; 807  :             pushToTalkTimeLeft -= int(frameDelta);

	mov	eax, DWORD PTR _frameDelta$48[ebp]
	cdq
	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [ecx+1256]
	sub	esi, eax
	mov	eax, DWORD PTR [ecx+1260]
	sbb	eax, edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1256], esi
	mov	DWORD PTR [ecx+1260], eax

; 808  :             OSDebugOut(TEXT("time left: %d\r\n"), pushToTalkTimeLeft);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1260]
	push	eax
	mov	ecx, DWORD PTR [edx+1256]
	push	ecx
	push	OFFSET $SG4294781457
	call	DWORD PTR __imp_?OSDebugOut@@YAXPB_WZZ
	add	esp, 12					; 0000000cH

; 809  :             if(pushToTalkTimeLeft <= 0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv2176[ebp], edx
	mov	eax, DWORD PTR tv2176[ebp]
	cmp	DWORD PTR [eax+1260], 0
	jg	SHORT $LN128@MainCaptur
	jl	SHORT $LN201@MainCaptur
	mov	ecx, DWORD PTR tv2176[ebp]
	cmp	DWORD PTR [ecx+1256], 0
	ja	SHORT $LN128@MainCaptur
$LN201@MainCaptur:

; 810  :             {
; 811  :                 pushToTalkTimeLeft = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1256], 0
	mov	DWORD PTR [edx+1260], 0

; 812  :                 bPushToTalkOn = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1245], 0
$LN128@MainCaptur:

; 813  :             }
; 814  :         }
; 815  : 
; 816  :         //------------------------------------
; 817  : 
; 818  :         OSEnterMutex(hSceneMutex);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+956]
	push	edx
	call	DWORD PTR __imp_?OSEnterMutex@@YGXPAX@Z

; 819  : 
; 820  :         if (bPleaseEnableProjector)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+707]
	test	ecx, ecx
	je	SHORT $LN127@MainCaptur

; 821  :             ActuallyEnableProjector();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ActuallyEnableProjector@OBS@@AAEXXZ	; OBS::ActuallyEnableProjector
	jmp	SHORT $LN125@MainCaptur
$LN127@MainCaptur:

; 822  :         else if(bPleaseDisableProjector)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+708]
	test	eax, eax
	je	SHORT $LN125@MainCaptur

; 823  :             DisableProjector();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DisableProjector@OBS@@AAEXXZ		; OBS::DisableProjector
$LN125@MainCaptur:

; 824  : 
; 825  :         if(bResizeRenderView)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+694]
	test	edx, edx
	je	SHORT $LN124@MainCaptur

; 826  :         {
; 827  :             GS->ResizeView();

	mov	eax, DWORD PTR __imp_?GS@@3PAVGraphicsSystem@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __imp_?GS@@3PAVGraphicsSystem@@A
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax]
	call	edx

; 828  :             bResizeRenderView = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+694], 0
$LN124@MainCaptur:

; 829  :         }
; 830  : 
; 831  :         //------------------------------------
; 832  : 
; 833  :         if(scene)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+144], 0
	je	$LN117@MainCaptur

; 834  :         {
; 835  :             profileIn("scene->Preprocess");

	push	0
	push	OFFSET $SG4294781456
	lea	ecx, DWORD PTR __curProfiler$6[ebp]
	call	DWORD PTR __imp_??0ProfilerNode@@QAE@PB_W_N@Z

; 836  :             scene->Preprocess();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+144]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+144]
	mov	eax, DWORD PTR [edx+20]
	call	eax

; 837  : 
; 838  :             for(UINT i=0; i<globalSources.Num(); i++)

	mov	DWORD PTR _i$56[ebp], 0
	jmp	SHORT $LN122@MainCaptur
$LN121@MainCaptur:
	mov	ecx, DWORD PTR _i$56[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$56[ebp], ecx
$LN122@MainCaptur:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1376				; 00000560H
	call	?Num@?$List@UGlobalSourceInfo@@@@QBEIXZ	; List<GlobalSourceInfo>::Num
	cmp	DWORD PTR _i$56[ebp], eax
	jae	SHORT $LN120@MainCaptur

; 839  :                 globalSources[i].source->Preprocess();

	mov	edx, DWORD PTR _i$56[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1376				; 00000560H
	call	??A?$List@UGlobalSourceInfo@@@@QAEAAUGlobalSourceInfo@@I@Z ; List<GlobalSourceInfo>::operator[]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR tv576[ebp], eax
	mov	ecx, DWORD PTR tv576[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv576[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	jmp	SHORT $LN121@MainCaptur
$LN120@MainCaptur:

; 840  : 
; 841  :             profileOut;

	lea	ecx, DWORD PTR __curProfiler$6[ebp]
	call	DWORD PTR __imp_??1ProfilerNode@@QAE@XZ

; 842  : 
; 843  :             scene->Tick(float(fSeconds));

	cvtsd2ss xmm0, QWORD PTR _fSeconds$36[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+144]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+144]
	mov	eax, DWORD PTR [edx+16]
	call	eax

; 844  : 
; 845  :             for(UINT i=0; i<globalSources.Num(); i++)

	mov	DWORD PTR _i$62[ebp], 0
	jmp	SHORT $LN119@MainCaptur
$LN118@MainCaptur:
	mov	ecx, DWORD PTR _i$62[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$62[ebp], ecx
$LN119@MainCaptur:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1376				; 00000560H
	call	?Num@?$List@UGlobalSourceInfo@@@@QBEIXZ	; List<GlobalSourceInfo>::Num
	cmp	DWORD PTR _i$62[ebp], eax
	jae	SHORT $LN117@MainCaptur

; 846  :                 globalSources[i].source->Tick(float(fSeconds));

	mov	edx, DWORD PTR _i$62[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1376				; 00000560H
	call	??A?$List@UGlobalSourceInfo@@@@QAEAAUGlobalSourceInfo@@I@Z ; List<GlobalSourceInfo>::operator[]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR tv600[ebp], eax
	cvtsd2ss xmm0, QWORD PTR _fSeconds$36[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR tv600[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv600[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	jmp	SHORT $LN118@MainCaptur
$LN117@MainCaptur:

; 847  :         }
; 848  : 
; 849  :         //------------------------------------
; 850  : 
; 851  :         QWORD curBytesSent = 0;

	xorpd	xmm0, xmm0
	movlpd	QWORD PTR _curBytesSent$57[ebp], xmm0

; 852  :         
; 853  :         if (network) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	??B?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QBE_NXZ ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN116@MainCaptur

; 854  :             curBytesSent = network->GetCurrentSentBytes();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	??C?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QBEPAVNetworkStream@@XZ ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::operator->
	mov	DWORD PTR tv614[ebp], eax
	mov	edx, DWORD PTR tv614[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv614[ebp]
	mov	edx, DWORD PTR [eax+16]
	call	edx
	mov	DWORD PTR _curBytesSent$57[ebp], eax
	mov	DWORD PTR _curBytesSent$57[ebp+4], edx

; 855  :             curFramesDropped = network->NumDroppedFrames();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	??C?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QBEPAVNetworkStream@@XZ ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::operator->
	mov	DWORD PTR tv623[ebp], eax
	mov	eax, DWORD PTR tv623[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv623[ebp]
	mov	eax, DWORD PTR [edx+20]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+924], eax
	jmp	SHORT $LN114@MainCaptur
$LN116@MainCaptur:

; 856  :         } else if (numSecondsWaited) {

	cmp	DWORD PTR _numSecondsWaited$[ebp], 0
	je	SHORT $LN114@MainCaptur

; 857  :             //reset stats if the network disappears
; 858  :             bytesPerSec = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+916], 0

; 859  :             bpsTime = 0;

	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR _bpsTime$[ebp], xmm0

; 860  :             numSecondsWaited = 0;

	mov	DWORD PTR _numSecondsWaited$[ebp], 0

; 861  :             curBytesSent = 0;

	xorpd	xmm0, xmm0
	movlpd	QWORD PTR _curBytesSent$57[ebp], xmm0

; 862  :             zero(lastBytesSent, sizeof(lastBytesSent));

	push	24					; 00000018H
	lea	eax, DWORD PTR _lastBytesSent$[ebp]
	push	eax
	call	?zero@@YGXPAXI@Z			; zero
$LN114@MainCaptur:

; 863  :         }
; 864  : 
; 865  :         bpsTime += fSeconds;

	movsd	xmm0, QWORD PTR _bpsTime$[ebp]
	addsd	xmm0, QWORD PTR _fSeconds$36[ebp]
	movsd	QWORD PTR _bpsTime$[ebp], xmm0

; 866  :         if(bpsTime > 1.0f)

	movsd	xmm0, QWORD PTR _bpsTime$[ebp]
	comisd	xmm0, QWORD PTR __real@3ff0000000000000
	jbe	$LN113@MainCaptur

; 867  :         {
; 868  :             if(numSecondsWaited < 3)

	cmp	DWORD PTR _numSecondsWaited$[ebp], 3
	jae	SHORT $LN112@MainCaptur

; 869  :                 ++numSecondsWaited;

	mov	ecx, DWORD PTR _numSecondsWaited$[ebp]
	add	ecx, 1
	mov	DWORD PTR _numSecondsWaited$[ebp], ecx
$LN112@MainCaptur:

; 870  : 
; 871  :             //bytesPerSec = DWORD(curBytesSent - lastBytesSent);
; 872  :             bytesPerSec = DWORD(curBytesSent - lastBytesSent[0]) / numSecondsWaited;

	mov	edx, 8
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _curBytesSent$57[ebp]
	sub	ecx, DWORD PTR _lastBytesSent$[ebp+eax]
	mov	edx, DWORD PTR _curBytesSent$57[ebp+4]
	sbb	edx, DWORD PTR _lastBytesSent$[ebp+eax+4]
	mov	eax, ecx
	xor	edx, edx
	div	DWORD PTR _numSecondsWaited$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+916], eax

; 873  : 
; 874  :             if(bpsTime > 2.0)

	movsd	xmm0, QWORD PTR _bpsTime$[ebp]
	comisd	xmm0, QWORD PTR __real@4000000000000000
	jbe	SHORT $LN111@MainCaptur

; 875  :                 bpsTime = 0.0f;

	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR _bpsTime$[ebp], xmm0

; 876  :             else

	jmp	SHORT $LN110@MainCaptur
$LN111@MainCaptur:

; 877  :                 bpsTime -= 1.0;

	movsd	xmm0, QWORD PTR _bpsTime$[ebp]
	subsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR _bpsTime$[ebp], xmm0
$LN110@MainCaptur:

; 878  : 
; 879  :             if(numSecondsWaited == 3)

	cmp	DWORD PTR _numSecondsWaited$[ebp], 3
	jne	SHORT $LN109@MainCaptur

; 880  :             {
; 881  :                 lastBytesSent[0] = lastBytesSent[1];

	mov	edx, 8
	shl	edx, 0
	mov	eax, 8
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _lastBytesSent$[ebp+edx]
	mov	DWORD PTR _lastBytesSent$[ebp+ecx], eax
	mov	edx, DWORD PTR _lastBytesSent$[ebp+edx+4]
	mov	DWORD PTR _lastBytesSent$[ebp+ecx+4], edx

; 882  :                 lastBytesSent[1] = lastBytesSent[2];

	mov	eax, 8
	shl	eax, 1
	mov	ecx, 8
	shl	ecx, 0
	mov	edx, DWORD PTR _lastBytesSent$[ebp+eax]
	mov	DWORD PTR _lastBytesSent$[ebp+ecx], edx
	mov	eax, DWORD PTR _lastBytesSent$[ebp+eax+4]
	mov	DWORD PTR _lastBytesSent$[ebp+ecx+4], eax

; 883  :                 lastBytesSent[2] = curBytesSent;

	mov	ecx, 8
	shl	ecx, 1
	mov	edx, DWORD PTR _curBytesSent$57[ebp]
	mov	DWORD PTR _lastBytesSent$[ebp+ecx], edx
	mov	eax, DWORD PTR _curBytesSent$57[ebp+4]
	mov	DWORD PTR _lastBytesSent$[ebp+ecx+4], eax

; 884  :             }
; 885  :             else

	jmp	SHORT $LN108@MainCaptur
$LN109@MainCaptur:

; 886  :                 lastBytesSent[numSecondsWaited] = curBytesSent;

	mov	ecx, DWORD PTR _numSecondsWaited$[ebp]
	mov	edx, DWORD PTR _curBytesSent$57[ebp]
	mov	DWORD PTR _lastBytesSent$[ebp+ecx*8], edx
	mov	eax, DWORD PTR _curBytesSent$57[ebp+4]
	mov	DWORD PTR _lastBytesSent$[ebp+ecx*8+4], eax
$LN108@MainCaptur:

; 887  : 
; 888  :             captureFPS = fpsCounter;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _fpsCounter$[ebp]
	mov	DWORD PTR [ecx+920], edx

; 889  :             fpsCounter = 0;

	mov	DWORD PTR _fpsCounter$[ebp], 0

; 890  : 
; 891  :             bUpdateBPS = true;

	mov	BYTE PTR _bUpdateBPS$72[ebp], 1
$LN113@MainCaptur:

; 892  :         }
; 893  : 
; 894  :         fpsCounter++;

	mov	eax, DWORD PTR _fpsCounter$[ebp]
	add	eax, 1
	mov	DWORD PTR _fpsCounter$[ebp], eax

; 895  : 
; 896  :         if(network) curStrain = network->GetPacketStrain();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	??B?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QBE_NXZ ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN107@MainCaptur
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	??C?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QBEPAVNetworkStream@@XZ ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::operator->
	mov	DWORD PTR tv668[ebp], eax
	mov	edx, DWORD PTR tv668[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv668[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	eax, DWORD PTR _this$[ebp]
	fstp	QWORD PTR [eax+936]
$LN107@MainCaptur:

; 897  : 
; 898  :         EnableBlending(TRUE);

	push	1
	call	?EnableBlending@@YAXH@Z			; EnableBlending

; 899  :         BlendFunction(GS_BLEND_SRCALPHA, GS_BLEND_INVSRCALPHA);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	5
	push	4
	call	?BlendFunction@@YAXW4GSBlendType@@0M@Z	; BlendFunction
	add	esp, 12					; 0000000cH

; 900  : 
; 901  :         //------------------------------------
; 902  :         // render the mini render texture
; 903  : 
; 904  :         LoadVertexShader(mainVertexShader);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	call	?LoadVertexShader@@YAXPAVShader@@@Z	; LoadVertexShader
	add	esp, 4

; 905  :         LoadPixelShader(mainPixelShader);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?LoadPixelShader@@YAXPAVShader@@@Z	; LoadPixelShader
	add	esp, 4

; 906  : 
; 907  :         SetRenderTarget(mainRenderTextures[curRenderTarget]);

	mov	edx, DWORD PTR _curRenderTarget$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+20]
	push	ecx
	call	?SetRenderTarget@@YAXPAVTexture@@@Z	; SetRenderTarget

; 908  : 
; 909  :         Ortho(0.0f, baseSize.x, baseSize.y, 0.0f, -100.0f, 100.0f);

	movss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c2c80000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _baseSize$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _baseSize$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	call	?Ortho@@YAXMMMMMM@Z			; Ortho

; 910  :         SetViewport(0, 0, baseSize.x, baseSize.y);

	add	esp, 20					; 00000014H
	movss	xmm0, DWORD PTR _baseSize$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _baseSize$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	call	?SetViewport@@YAXMMMM@Z			; SetViewport
	add	esp, 16					; 00000010H

; 911  : 
; 912  :         if(scene)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+144], 0
	je	SHORT $LN106@MainCaptur

; 913  :             scene->Render();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+144]
	mov	edx, DWORD PTR [eax+24]
	call	edx
$LN106@MainCaptur:

; 914  : 
; 915  :         //------------------------------------
; 916  : 
; 917  :         if(bTransitioning)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+45]
	test	ecx, ecx
	je	$LN100@MainCaptur

; 918  :         {
; 919  :             if(!lastRenderTexture)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+36], 0
	jne	$LN104@MainCaptur

; 920  :             {
; 921  :                 lastRenderTexture = CreateTexture(baseCX, baseCY, GS_BGRA, NULL, FALSE, TRUE);

	push	1
	push	0
	push	0
	push	6
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+860]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+856]
	push	eax
	call	?CreateTexture@@YAPAVTexture@@IIW4GSColorFormat@@PAXHH@Z ; CreateTexture
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 922  :                 if(lastRenderTexture)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+36], 0
	je	SHORT $LN103@MainCaptur

; 923  :                 {
; 924  :                     D3D10Texture *d3dTransitionTex = static_cast<D3D10Texture*>(lastRenderTexture);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR _d3dTransitionTex$26[ebp], ecx

; 925  :                     D3D10Texture *d3dSceneTex = static_cast<D3D10Texture*>(mainRenderTextures[lastRenderTarget]);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+852]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+20]
	mov	DWORD PTR _d3dSceneTex$34[ebp], edx

; 926  :                     GetD3D()->CopyResource(d3dTransitionTex->texture, d3dSceneTex->texture);

	call	?GetD3D@@YAPAUID3D10Device@@XZ		; GetD3D
	mov	DWORD PTR tv736[ebp], eax
	mov	eax, DWORD PTR _d3dSceneTex$34[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _d3dTransitionTex$26[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR tv736[ebp]
	push	ecx
	mov	edx, DWORD PTR tv736[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+132]
	call	ecx

; 927  :                 }
; 928  :                 else

	jmp	SHORT $LN102@MainCaptur
$LN103@MainCaptur:

; 929  :                     bTransitioning = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+45], 0
$LN102@MainCaptur:
	jmp	SHORT $LN100@MainCaptur
$LN104@MainCaptur:

; 930  :             }
; 931  :             else if(transitionAlpha >= 1.0f)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+48]
	comiss	xmm0, DWORD PTR __real@3f800000
	jb	SHORT $LN100@MainCaptur

; 932  :             {
; 933  :                 delete lastRenderTexture;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR $T32[ebp], edx
	mov	eax, DWORD PTR $T32[ebp]
	mov	DWORD PTR $T49[ebp], eax
	cmp	DWORD PTR $T49[ebp], 0
	je	SHORT $LN172@MainCaptur
	push	1
	mov	ecx, DWORD PTR $T49[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T49[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv765[ebp], eax
	jmp	SHORT $LN173@MainCaptur
$LN172@MainCaptur:
	mov	DWORD PTR tv765[ebp], 0
$LN173@MainCaptur:

; 934  :                 lastRenderTexture = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+36], 0

; 935  : 
; 936  :                 bTransitioning = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+45], 0
$LN100@MainCaptur:

; 937  :             }
; 938  :         }
; 939  : 
; 940  :         if(bTransitioning)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+45]
	test	ecx, ecx
	je	$LN99@MainCaptur

; 941  :         {
; 942  :             transitionAlpha += float(fSeconds) * 5.0f;

	cvtsd2ss xmm0, QWORD PTR _fSeconds$36[ebp]
	mulss	xmm0, DWORD PTR __real@40a00000
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+48]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+48], xmm0

; 943  :             if(transitionAlpha > 1.0f)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+48]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN98@MainCaptur

; 944  :                 transitionAlpha = 1.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+48], xmm0
$LN98@MainCaptur:

; 945  : 
; 946  :             SetRenderTarget(transitionTexture);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	call	?SetRenderTarget@@YAXPAVTexture@@@Z	; SetRenderTarget
	add	esp, 4

; 947  : 
; 948  :             Shader *oldPixelShader = GetCurrentPixelShader();

	call	?GetCurrentPixelShader@@YAPAVShader@@XZ	; GetCurrentPixelShader
	mov	DWORD PTR _oldPixelShader$25[ebp], eax

; 949  :             LoadPixelShader(transitionPixelShader);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+64]
	push	eax
	call	?LoadPixelShader@@YAXPAVShader@@@Z	; LoadPixelShader
	add	esp, 4

; 950  : 
; 951  :             transitionPixelShader->SetFloat(hTransitionTime, transitionAlpha);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+48]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _hTransitionTime$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+64]
	mov	edx, DWORD PTR [eax+28]
	call	edx

; 952  :             LoadTexture(mainRenderTextures[curRenderTarget], 1U);

	push	1
	mov	eax, DWORD PTR _curRenderTarget$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+20]
	push	edx
	call	?LoadTexture@@YAXPAVTexture@@I@Z	; LoadTexture

; 953  : 
; 954  :             DrawSpriteEx(lastRenderTexture, 0xFFFFFFFF,
; 955  :                 0, 0, baseSize.x, baseSize.y, 0.0f, 0.0f, 1.0f, 1.0f);

	add	esp, 4
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _baseSize$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _baseSize$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	?DrawSpriteEx@@YAXPAVTexture@@KMMMMMMMM@Z ; DrawSpriteEx
	add	esp, 40					; 00000028H

; 956  : 
; 957  :             LoadTexture(nullptr, 1U);

	push	1
	push	0
	call	?LoadTexture@@YAXPAVTexture@@I@Z	; LoadTexture
	add	esp, 8

; 958  :             LoadPixelShader(oldPixelShader);

	mov	edx, DWORD PTR _oldPixelShader$25[ebp]
	push	edx
	call	?LoadPixelShader@@YAXPAVShader@@@Z	; LoadPixelShader
	add	esp, 4
$LN99@MainCaptur:

; 959  :         }
; 960  : 
; 961  :         EnableBlending(FALSE);

	push	0
	call	?EnableBlending@@YAXH@Z			; EnableBlending
	add	esp, 4

; 962  : 
; 963  : 
; 964  :         //------------------------------------
; 965  :         // render the mini view thingy
; 966  : 
; 967  :         if (bProjector) {

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+709]
	test	ecx, ecx
	je	$LN97@MainCaptur

; 968  :             SetRenderTarget(projectorTexture);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+736]
	push	eax
	call	?SetRenderTarget@@YAXPAVTexture@@@Z	; SetRenderTarget
	add	esp, 4

; 969  : 
; 970  :             Vect2 renderFrameSize, renderFrameOffset;

	lea	ecx, DWORD PTR _renderFrameSize$40[ebp]
	call	DWORD PTR __imp_??0Vect2@@QAE@XZ
	lea	ecx, DWORD PTR _renderFrameOffset$30[ebp]
	call	DWORD PTR __imp_??0Vect2@@QAE@XZ

; 971  :             Vect2 projectorSize = Vect2(float(projectorWidth), float(projectorHeight));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+724]
	mov	DWORD PTR tv2401[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv2401[ebp]
	mov	eax, DWORD PTR tv2401[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv2405[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv2405[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+720]
	mov	DWORD PTR tv2411[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv2411[ebp]
	mov	eax, DWORD PTR tv2411[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv2415[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv2415[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _projectorSize$41[ebp]
	call	DWORD PTR __imp_??0Vect2@@QAE@MM@Z

; 972  : 
; 973  :             float projectorAspect = (projectorSize.x / projectorSize.y);

	movss	xmm0, DWORD PTR _projectorSize$41[ebp]
	divss	xmm0, DWORD PTR _projectorSize$41[ebp+4]
	movss	DWORD PTR _projectorAspect$29[ebp], xmm0

; 974  :             float baseAspect = (baseSize.x / baseSize.y);

	movss	xmm0, DWORD PTR _baseSize$[ebp]
	divss	xmm0, DWORD PTR _baseSize$[ebp+4]
	movss	DWORD PTR _baseAspect$51[ebp], xmm0

; 975  : 
; 976  :             if (projectorAspect < baseAspect) {

	movss	xmm0, DWORD PTR _baseAspect$51[ebp]
	comiss	xmm0, DWORD PTR _projectorAspect$29[ebp]
	jbe	$LN96@MainCaptur

; 977  :                 float fProjectorWidth = float(projectorWidth);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+720]
	mov	DWORD PTR tv2426[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv2426[ebp]
	mov	eax, DWORD PTR tv2426[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv2430[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv2430[ebp]
	movss	DWORD PTR _fProjectorWidth$44[ebp], xmm0

; 978  : 
; 979  :                 renderFrameSize   = Vect2(fProjectorWidth, fProjectorWidth / baseAspect);

	movss	xmm0, DWORD PTR _fProjectorWidth$44[ebp]
	divss	xmm0, DWORD PTR _baseAspect$51[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fProjectorWidth$44[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T13[ebp]
	call	DWORD PTR __imp_??0Vect2@@QAE@MM@Z
	push	eax
	lea	ecx, DWORD PTR _renderFrameSize$40[ebp]
	call	DWORD PTR __imp_??4Vect2@@QAEAAU0@ABU0@@Z

; 980  :                 renderFrameOffset = Vect2(0.0f, (projectorSize.y-renderFrameSize.y) * 0.5f);

	movss	xmm0, DWORD PTR _projectorSize$41[ebp+4]
	subss	xmm0, DWORD PTR _renderFrameSize$40[ebp+4]
	mulss	xmm0, DWORD PTR __real@3f000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T12[ebp]
	call	DWORD PTR __imp_??0Vect2@@QAE@MM@Z
	push	eax
	lea	ecx, DWORD PTR _renderFrameOffset$30[ebp]
	call	DWORD PTR __imp_??4Vect2@@QAEAAU0@ABU0@@Z

; 981  :             } else {

	jmp	$LN95@MainCaptur
$LN96@MainCaptur:

; 982  :                 float fProjectorHeight = float(projectorHeight);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+724]
	mov	DWORD PTR tv2446[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv2446[ebp]
	mov	eax, DWORD PTR tv2446[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv2450[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv2450[ebp]
	movss	DWORD PTR _fProjectorHeight$43[ebp], xmm0

; 983  : 
; 984  :                 renderFrameSize   = Vect2(fProjectorHeight * baseAspect, fProjectorHeight);

	push	ecx
	movss	xmm0, DWORD PTR _fProjectorHeight$43[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _fProjectorHeight$43[ebp]
	mulss	xmm0, DWORD PTR _baseAspect$51[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T11[ebp]
	call	DWORD PTR __imp_??0Vect2@@QAE@MM@Z
	push	eax
	lea	ecx, DWORD PTR _renderFrameSize$40[ebp]
	call	DWORD PTR __imp_??4Vect2@@QAEAAU0@ABU0@@Z

; 985  :                 renderFrameOffset = Vect2((projectorSize.x-renderFrameSize.x) * 0.5f, 0.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _projectorSize$41[ebp]
	subss	xmm0, DWORD PTR _renderFrameSize$40[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T7[ebp]
	call	DWORD PTR __imp_??0Vect2@@QAE@MM@Z
	push	eax
	lea	ecx, DWORD PTR _renderFrameOffset$30[ebp]
	call	DWORD PTR __imp_??4Vect2@@QAEAAU0@ABU0@@Z
$LN95@MainCaptur:

; 986  :             }
; 987  : 
; 988  :             DrawPreview(renderFrameSize, renderFrameOffset, projectorSize, curRenderTarget, Preview_Projector);

	push	2
	mov	ecx, DWORD PTR _curRenderTarget$[ebp]
	push	ecx
	lea	edx, DWORD PTR _projectorSize$41[ebp]
	push	edx
	lea	eax, DWORD PTR _renderFrameOffset$30[ebp]
	push	eax
	lea	ecx, DWORD PTR _renderFrameSize$40[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawPreview@OBS@@AAEXABUVect2@@00HW4PreviewDrawType@@@Z ; OBS::DrawPreview

; 989  : 
; 990  :             SetRenderTarget(NULL);

	push	0
	call	?SetRenderTarget@@YAXPAVTexture@@@Z	; SetRenderTarget
	add	esp, 4
$LN97@MainCaptur:

; 991  :         }
; 992  : 
; 993  :         if(bRenderView)

	movzx	edx, BYTE PTR _bRenderView$68[ebp]
	test	edx, edx
	je	$LN94@MainCaptur

; 994  :         {
; 995  :             // Cache
; 996  :             const Vect2 renderFrameSize = GetRenderFrameSize();

	lea	eax, DWORD PTR _renderFrameSize$16[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRenderFrameSize@OBS@@QBE?AUVect2@@XZ ; OBS::GetRenderFrameSize

; 997  :             const Vect2 renderFrameOffset = GetRenderFrameOffset();

	lea	ecx, DWORD PTR _renderFrameOffset$17[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRenderFrameOffset@OBS@@QBE?AUVect2@@XZ ; OBS::GetRenderFrameOffset

; 998  :             const Vect2 renderFrameCtrlSize = GetRenderFrameControlSize();

	lea	edx, DWORD PTR _renderFrameCtrlSize$18[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRenderFrameControlSize@OBS@@QBE?AUVect2@@XZ ; OBS::GetRenderFrameControlSize

; 999  : 
; 1000 :             SetRenderTarget(NULL);

	push	0
	call	?SetRenderTarget@@YAXPAVTexture@@@Z	; SetRenderTarget
	add	esp, 4

; 1001 :             DrawPreview(renderFrameSize, renderFrameOffset, renderFrameCtrlSize, curRenderTarget,
; 1002 :                     bFullscreenMode ? Preview_Fullscreen : Preview_Standard);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+740]
	test	ecx, ecx
	je	SHORT $LN174@MainCaptur
	mov	DWORD PTR tv889[ebp], 1
	jmp	SHORT $LN175@MainCaptur
$LN174@MainCaptur:
	mov	DWORD PTR tv889[ebp], 0
$LN175@MainCaptur:
	mov	edx, DWORD PTR tv889[ebp]
	push	edx
	mov	eax, DWORD PTR _curRenderTarget$[ebp]
	push	eax
	lea	ecx, DWORD PTR _renderFrameCtrlSize$18[ebp]
	push	ecx
	lea	edx, DWORD PTR _renderFrameOffset$17[ebp]
	push	edx
	lea	eax, DWORD PTR _renderFrameSize$16[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawPreview@OBS@@AAEXABUVect2@@00HW4PreviewDrawType@@@Z ; OBS::DrawPreview

; 1003 : 
; 1004 :             //draw selections if in edit mode
; 1005 :             if(bEditMode && !bSizeChanging)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+741]
	test	edx, edx
	je	SHORT $LN92@MainCaptur
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+693]
	test	ecx, ecx
	jne	SHORT $LN92@MainCaptur

; 1006 :             {
; 1007 :                 if(scene) {

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+144], 0
	je	SHORT $LN92@MainCaptur

; 1008 :                     LoadVertexShader(solidVertexShader);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	push	ecx
	call	?LoadVertexShader@@YAXPAVShader@@@Z	; LoadVertexShader
	add	esp, 4

; 1009 :                     LoadPixelShader(solidPixelShader);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	push	eax
	call	?LoadPixelShader@@YAXPAVShader@@@Z	; LoadPixelShader
	add	esp, 4

; 1010 :                     solidPixelShader->SetColor(solidPixelShader->GetParameter(0), 0xFF0000);

	push	16711680				; 00ff0000H
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+72]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+72]
	call	DWORD PTR __imp_?SetColor@Shader@@QAEXPAXK@Z

; 1011 :                     scene->RenderSelections(solidPixelShader);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+144]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+144]
	mov	eax, DWORD PTR [edx+32]
	call	eax
$LN92@MainCaptur:

; 1012 :                 }
; 1013 :             }
; 1014 :         }

	jmp	SHORT $LN90@MainCaptur
$LN94@MainCaptur:

; 1015 :         else if(bForceRenderViewErase)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+743]
	test	edx, edx
	je	SHORT $LN90@MainCaptur

; 1016 :         {
; 1017 :             InvalidateRect(hwndRenderFrame, NULL, TRUE);

	push	1
	push	0
	mov	eax, DWORD PTR ?hwndRenderFrame@@3PAUHWND__@@A ; hwndRenderFrame
	push	eax
	call	DWORD PTR __imp__InvalidateRect@12

; 1018 :             UpdateWindow(hwndRenderFrame);

	mov	ecx, DWORD PTR ?hwndRenderFrame@@3PAUHWND__@@A ; hwndRenderFrame
	push	ecx
	call	DWORD PTR __imp__UpdateWindow@4

; 1019 :             bForceRenderViewErase = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+743], 0
$LN90@MainCaptur:

; 1020 :         }
; 1021 : 
; 1022 :         //------------------------------------
; 1023 :         // actual stream output
; 1024 : 
; 1025 :         LoadVertexShader(mainVertexShader);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	call	?LoadVertexShader@@YAXPAVShader@@@Z	; LoadVertexShader
	add	esp, 4

; 1026 :         LoadPixelShader(yuvScalePixelShader);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	push	eax
	call	?LoadPixelShader@@YAXPAVShader@@@Z	; LoadPixelShader
	add	esp, 4

; 1027 : 
; 1028 :         Texture *yuvRenderTexture = yuvRenderTextures[curRenderTarget];

	mov	ecx, DWORD PTR _curRenderTarget$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+28]
	mov	DWORD PTR _yuvRenderTexture$23[ebp], eax

; 1029 :         SetRenderTarget(yuvRenderTexture);

	mov	ecx, DWORD PTR _yuvRenderTexture$23[ebp]
	push	ecx
	call	?SetRenderTarget@@YAXPAVTexture@@@Z	; SetRenderTarget
	add	esp, 4

; 1030 : 
; 1031 :         switch(colorDesc.matrix)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+912]
	mov	DWORD PTR tv979[ebp], eax
	cmp	DWORD PTR tv979[ebp], 9
	ja	$LN82@MainCaptur
	mov	ecx, DWORD PTR tv979[ebp]
	jmp	DWORD PTR $LN207@MainCaptur[ecx*4]
$LN87@MainCaptur:

; 1032 :         {
; 1033 :         case ColorMatrix_GBR:
; 1034 :             yuvScalePixelShader->SetMatrix(hMatrix, colorDesc.fullRange ? (float*)yuvFullMat[0] : (float*)yuvMat[0]);

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+900], 0
	je	SHORT $LN176@MainCaptur
	mov	eax, 64					; 00000040H
	imul	ecx, eax, 0
	add	ecx, OFFSET _yuvFullMat
	mov	DWORD PTR tv994[ebp], ecx
	jmp	SHORT $LN177@MainCaptur
$LN176@MainCaptur:
	mov	edx, 64					; 00000040H
	imul	eax, edx, 0
	add	eax, OFFSET _yuvMat
	mov	DWORD PTR tv994[ebp], eax
$LN177@MainCaptur:
	mov	ecx, DWORD PTR tv994[ebp]
	push	ecx
	mov	edx, DWORD PTR _hMatrix$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+60]
	mov	edx, DWORD PTR [eax+36]
	call	edx

; 1035 :             break;

	jmp	$LN88@MainCaptur
$LN86@MainCaptur:

; 1036 :         case ColorMatrix_YCgCo:
; 1037 :             yuvScalePixelShader->SetMatrix(hMatrix, colorDesc.fullRange ? (float*)yuvFullMat[1] : (float*)yuvMat[1]);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+900], 0
	je	SHORT $LN178@MainCaptur
	mov	ecx, 64					; 00000040H
	shl	ecx, 0
	add	ecx, OFFSET _yuvFullMat
	mov	DWORD PTR tv1011[ebp], ecx
	jmp	SHORT $LN179@MainCaptur
$LN178@MainCaptur:
	mov	edx, 64					; 00000040H
	shl	edx, 0
	add	edx, OFFSET _yuvMat
	mov	DWORD PTR tv1011[ebp], edx
$LN179@MainCaptur:
	mov	eax, DWORD PTR tv1011[ebp]
	push	eax
	mov	ecx, DWORD PTR _hMatrix$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+60]
	mov	eax, DWORD PTR [edx+36]
	call	eax

; 1038 :             break;

	jmp	$LN88@MainCaptur
$LN85@MainCaptur:

; 1039 :         case ColorMatrix_BT2020NCL:
; 1040 :             yuvScalePixelShader->SetMatrix(hMatrix, colorDesc.fullRange ? (float*)yuvFullMat[2] : (float*)yuvMat[2]);

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+900], 0
	je	SHORT $LN180@MainCaptur
	mov	edx, 64					; 00000040H
	shl	edx, 1
	add	edx, OFFSET _yuvFullMat
	mov	DWORD PTR tv1028[ebp], edx
	jmp	SHORT $LN181@MainCaptur
$LN180@MainCaptur:
	mov	eax, 64					; 00000040H
	shl	eax, 1
	add	eax, OFFSET _yuvMat
	mov	DWORD PTR tv1028[ebp], eax
$LN181@MainCaptur:
	mov	ecx, DWORD PTR tv1028[ebp]
	push	ecx
	mov	edx, DWORD PTR _hMatrix$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+60]
	mov	edx, DWORD PTR [eax+36]
	call	edx

; 1041 :             break;

	jmp	$LN88@MainCaptur
$LN84@MainCaptur:

; 1042 :         case ColorMatrix_BT709:
; 1043 :             yuvScalePixelShader->SetMatrix(hMatrix, colorDesc.fullRange ? (float*)yuvFullMat[3] : (float*)yuvMat[3]);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+900], 0
	je	SHORT $LN182@MainCaptur
	mov	ecx, 64					; 00000040H
	imul	edx, ecx, 3
	add	edx, OFFSET _yuvFullMat
	mov	DWORD PTR tv1045[ebp], edx
	jmp	SHORT $LN183@MainCaptur
$LN182@MainCaptur:
	mov	eax, 64					; 00000040H
	imul	ecx, eax, 3
	add	ecx, OFFSET _yuvMat
	mov	DWORD PTR tv1045[ebp], ecx
$LN183@MainCaptur:
	mov	edx, DWORD PTR tv1045[ebp]
	push	edx
	mov	eax, DWORD PTR _hMatrix$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+60]
	mov	eax, DWORD PTR [edx+36]
	call	eax

; 1044 :             break;

	jmp	$LN88@MainCaptur
$LN83@MainCaptur:

; 1045 :         case ColorMatrix_SMPTE240M:
; 1046 :             yuvScalePixelShader->SetMatrix(hMatrix, colorDesc.fullRange ? (float*)yuvFullMat[4] : (float*)yuvMat[4]);

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+900], 0
	je	SHORT $LN184@MainCaptur
	mov	edx, 64					; 00000040H
	shl	edx, 2
	add	edx, OFFSET _yuvFullMat
	mov	DWORD PTR tv1062[ebp], edx
	jmp	SHORT $LN185@MainCaptur
$LN184@MainCaptur:
	mov	eax, 64					; 00000040H
	shl	eax, 2
	add	eax, OFFSET _yuvMat
	mov	DWORD PTR tv1062[ebp], eax
$LN185@MainCaptur:
	mov	ecx, DWORD PTR tv1062[ebp]
	push	ecx
	mov	edx, DWORD PTR _hMatrix$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+60]
	mov	edx, DWORD PTR [eax+36]
	call	edx

; 1047 :             break;

	jmp	SHORT $LN88@MainCaptur
$LN82@MainCaptur:

; 1048 :         default:
; 1049 :             yuvScalePixelShader->SetMatrix(hMatrix, colorDesc.fullRange ? (float*)yuvFullMat[5] : (float*)yuvMat[5]);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+900], 0
	je	SHORT $LN186@MainCaptur
	mov	ecx, 64					; 00000040H
	imul	edx, ecx, 5
	add	edx, OFFSET _yuvFullMat
	mov	DWORD PTR tv1079[ebp], edx
	jmp	SHORT $LN187@MainCaptur
$LN186@MainCaptur:
	mov	eax, 64					; 00000040H
	imul	ecx, eax, 5
	add	ecx, OFFSET _yuvMat
	mov	DWORD PTR tv1079[ebp], ecx
$LN187@MainCaptur:
	mov	edx, DWORD PTR tv1079[ebp]
	push	edx
	mov	eax, DWORD PTR _hMatrix$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+60]
	mov	eax, DWORD PTR [edx+36]
	call	eax
$LN88@MainCaptur:

; 1050 :         }
; 1051 : 
; 1052 :         if(downscale < 2.01)

	mov	ecx, DWORD PTR _this$[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+880]
	movsd	xmm1, QWORD PTR __real@4000147ae147ae14
	comisd	xmm1, xmm0
	jbe	SHORT $LN81@MainCaptur

; 1053 :             yuvScalePixelShader->SetVector2(hScaleVal, 1.0f/baseSize);

	lea	edx, DWORD PTR _baseSize$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T9[ebp]
	push	eax
	call	??K@YA?AUVect2@@MABU0@@Z		; operator/
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _hScaleVal$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+60]
	mov	eax, DWORD PTR [edx+44]
	call	eax
	jmp	SHORT $LN79@MainCaptur
$LN81@MainCaptur:

; 1054 :         else if(downscale < 3.01)

	mov	ecx, DWORD PTR _this$[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+880]
	movsd	xmm1, QWORD PTR __real@4008147ae147ae14
	comisd	xmm1, xmm0
	jbe	SHORT $LN79@MainCaptur

; 1055 :             yuvScalePixelShader->SetVector2(hScaleVal, 1.0f/(outputSize*3.0f));

	push	ecx
	movss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR $T8[ebp]
	push	edx
	lea	ecx, DWORD PTR _outputSize$[ebp]
	call	DWORD PTR __imp_??DVect2@@QBE?AU0@M@Z
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T10[ebp]
	push	eax
	call	??K@YA?AUVect2@@MABU0@@Z		; operator/
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _hScaleVal$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+60]
	mov	eax, DWORD PTR [edx+44]
	call	eax
$LN79@MainCaptur:

; 1056 : 
; 1057 :         Ortho(0.0f, outputSize.x, outputSize.y, 0.0f, -100.0f, 100.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c2c80000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _outputSize$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _outputSize$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	call	?Ortho@@YAXMMMMMM@Z			; Ortho

; 1058 :         SetViewport(0.0f, 0.0f, outputSize.x, outputSize.y);

	add	esp, 20					; 00000014H
	movss	xmm0, DWORD PTR _outputSize$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _outputSize$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	call	?SetViewport@@YAXMMMM@Z			; SetViewport
	add	esp, 16					; 00000010H

; 1059 : 
; 1060 :         //why am I using scaleSize instead of outputSize for the texture?
; 1061 :         //because outputSize can be trimmed by up to three pixels due to 128-bit alignment.
; 1062 :         //using the scale function with outputSize can cause slightly inaccurate scaled images
; 1063 :         if(bTransitioning)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+45]
	test	edx, edx
	je	$LN78@MainCaptur

; 1064 :             DrawSpriteEx(transitionTexture, 0xFFFFFFFF, 0.0f, 0.0f, scaleSize.x, scaleSize.y, 0.0f, 0.0f, 1.0f, 1.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _scaleSize$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _scaleSize$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	call	?DrawSpriteEx@@YAXPAVTexture@@KMMMMMMMM@Z ; DrawSpriteEx
	add	esp, 40					; 00000028H

; 1065 :         else

	jmp	$LN77@MainCaptur
$LN78@MainCaptur:

; 1066 :             DrawSpriteEx(mainRenderTextures[curRenderTarget], 0xFFFFFFFF, 0.0f, 0.0f, outputSize.x, outputSize.y, 0.0f, 0.0f, 1.0f, 1.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _outputSize$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _outputSize$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	-1
	mov	edx, DWORD PTR _curRenderTarget$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+20]
	push	ecx
	call	?DrawSpriteEx@@YAXPAVTexture@@KMMMMMMMM@Z ; DrawSpriteEx
	add	esp, 40					; 00000028H
$LN77@MainCaptur:

; 1067 : 
; 1068 :         //------------------------------------
; 1069 : 
; 1070 :         if (bProjector && !copyWait)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+709]
	test	eax, eax
	je	SHORT $LN76@MainCaptur
	cmp	DWORD PTR _copyWait$[ebp], 0
	jne	SHORT $LN76@MainCaptur

; 1071 :             projectorSwap->Present(0, 0);

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+32]
	call	eax
$LN76@MainCaptur:

; 1072 : 
; 1073 :         if(bRenderView && !copyWait)

	movzx	ecx, BYTE PTR _bRenderView$68[ebp]
	test	ecx, ecx
	je	SHORT $LN75@MainCaptur
	cmp	DWORD PTR _copyWait$[ebp], 0
	jne	SHORT $LN75@MainCaptur

; 1074 :             static_cast<D3D10System*>(GS)->swap->Present(0, 0);

	push	0
	push	0
	mov	edx, DWORD PTR __imp_?GS@@3PAVGraphicsSystem@@A
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR __imp_?GS@@3PAVGraphicsSystem@@A
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+76]
	mov	eax, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR [eax+32]
	call	ecx
$LN75@MainCaptur:

; 1075 : 
; 1076 :         OSLeaveMutex(hSceneMutex);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+956]
	push	eax
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z

; 1077 : 
; 1078 :         //------------------------------------
; 1079 :         // present/upload
; 1080 : 
; 1081 :         profileIn("GPU download and conversion");

	push	0
	push	OFFSET $SG4294781455
	lea	ecx, DWORD PTR __curProfiler$3[ebp]
	call	DWORD PTR __imp_??0ProfilerNode@@QAE@PB_W_N@Z

; 1082 : 
; 1083 :         bEncode = true;

	mov	BYTE PTR _bEncode$[ebp], 1

; 1084 : 
; 1085 :         if(copyWait)

	cmp	DWORD PTR _copyWait$[ebp], 0
	je	SHORT $LN74@MainCaptur

; 1086 :         {
; 1087 :             copyWait--;

	mov	ecx, DWORD PTR _copyWait$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _copyWait$[ebp], ecx

; 1088 :             bEncode = false;

	mov	BYTE PTR _bEncode$[ebp], 0

; 1089 :         }
; 1090 :         else

	jmp	$LN66@MainCaptur
$LN74@MainCaptur:

; 1091 :         {
; 1092 :             //audio sometimes takes a bit to start -- do not start processing frames until audio has started capturing
; 1093 :             if(!bRecievedFirstAudioFrame)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+988]
	test	eax, eax
	jne	SHORT $LN72@MainCaptur

; 1094 :             {
; 1095 :                 static bool bWarnedAboutNoAudio = false;
; 1096 :                 if (renderStartTimeMS-firstFrameTimeMS > 10000 && !bWarnedAboutNoAudio)

	mov	ecx, DWORD PTR _renderStartTimeMS$63[ebp]
	sub	ecx, DWORD PTR _firstFrameTimeMS$[ebp]
	mov	edx, DWORD PTR _renderStartTimeMS$63[ebp+4]
	sbb	edx, DWORD PTR _firstFrameTimeMS$[ebp+4]
	mov	DWORD PTR tv2657[ebp], ecx
	mov	DWORD PTR tv2657[ebp+4], edx
	cmp	DWORD PTR tv2657[ebp+4], 0
	ja	SHORT $LN202@MainCaptur
	cmp	DWORD PTR tv2657[ebp], 10000		; 00002710H
	jbe	SHORT $LN71@MainCaptur
$LN202@MainCaptur:
	movzx	eax, BYTE PTR ?bWarnedAboutNoAudio@?JJ@??MainCaptureLoop@OBS@@AAEXXZ@4_NA
	test	eax, eax
	jne	SHORT $LN71@MainCaptur

; 1097 :                 {
; 1098 :                     bWarnedAboutNoAudio = true;

	mov	BYTE PTR ?bWarnedAboutNoAudio@?JJ@??MainCaptureLoop@OBS@@AAEXXZ@4_NA, 1
$LN71@MainCaptur:

; 1099 :                     //AddStreamInfo (TEXT ("WARNING: OBS is not receiving audio frames. Please check your audio devices."), StreamInfoPriority_Critical); 
; 1100 :                 }
; 1101 :                 bEncode = false;

	mov	BYTE PTR _bEncode$[ebp], 0
	jmp	SHORT $LN69@MainCaptur
$LN72@MainCaptur:

; 1102 :             }
; 1103 :             else if(bFirstFrame)

	movzx	ecx, BYTE PTR _bFirstFrame$[ebp]
	test	ecx, ecx
	je	SHORT $LN69@MainCaptur

; 1104 :             {
; 1105 :                 firstFrameTimestamp = lastStreamTime/1000000;

	push	0
	push	1000000					; 000f4240H
	mov	edx, DWORD PTR _lastStreamTime$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _lastStreamTime$[ebp]
	push	eax
	call	__aulldiv
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1112], eax
	mov	DWORD PTR [ecx+1116], edx

; 1106 :                 bFirstFrame = false;

	mov	BYTE PTR _bFirstFrame$[ebp], 0
$LN69@MainCaptur:

; 1107 :             }
; 1108 : 
; 1109 :             if(!bEncode)

	movzx	edx, BYTE PTR _bEncode$[ebp]
	test	edx, edx
	jne	SHORT $LN66@MainCaptur

; 1110 :             {
; 1111 :                 if(curYUVTexture == (NUM_RENDER_BUFFERS-1))

	cmp	DWORD PTR _curYUVTexture$[ebp], 1
	jne	SHORT $LN67@MainCaptur

; 1112 :                     curYUVTexture = 0;

	mov	DWORD PTR _curYUVTexture$[ebp], 0

; 1113 :                 else

	jmp	SHORT $LN66@MainCaptur
$LN67@MainCaptur:

; 1114 :                     curYUVTexture++;

	mov	eax, DWORD PTR _curYUVTexture$[ebp]
	add	eax, 1
	mov	DWORD PTR _curYUVTexture$[ebp], eax
$LN66@MainCaptur:

; 1115 :             }
; 1116 :         }
; 1117 : 
; 1118 :         lastStreamTime = curStreamTime;

	mov	ecx, DWORD PTR _curStreamTime$50[ebp]
	mov	DWORD PTR _lastStreamTime$[ebp], ecx
	mov	edx, DWORD PTR _curStreamTime$50[ebp+4]
	mov	DWORD PTR _lastStreamTime$[ebp+4], edx

; 1119 : 
; 1120 :         if(bEncode)

	movzx	eax, BYTE PTR _bEncode$[ebp]
	test	eax, eax
	je	$LN26@MainCaptur

; 1121 :         {
; 1122 :             UINT prevCopyTexture = (curCopyTexture == 0) ? NUM_RENDER_BUFFERS-1 : curCopyTexture-1;

	cmp	DWORD PTR _curCopyTexture$[ebp], 0
	jne	SHORT $LN188@MainCaptur
	mov	DWORD PTR tv1213[ebp], 1
	jmp	SHORT $LN189@MainCaptur
$LN188@MainCaptur:
	mov	ecx, DWORD PTR _curCopyTexture$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv1213[ebp], ecx
$LN189@MainCaptur:
	mov	edx, DWORD PTR tv1213[ebp]
	mov	DWORD PTR _prevCopyTexture$24[ebp], edx

; 1123 : 
; 1124 :             ID3D10Texture2D *copyTexture = copyTextures[curCopyTexture];

	mov	eax, DWORD PTR _curCopyTexture$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+12]
	mov	DWORD PTR _copyTexture$46[ebp], edx

; 1125 :             profileIn("CopyResource");

	push	0
	push	OFFSET $SG4294781454
	lea	ecx, DWORD PTR __curProfiler$4[ebp]
	call	DWORD PTR __imp_??0ProfilerNode@@QAE@PB_W_N@Z

; 1126 : 
; 1127 :             if(!bFirstEncode && bUseThreaded420)

	movzx	eax, BYTE PTR _bFirstEncode$[ebp]
	test	eax, eax
	jne	SHORT $LN64@MainCaptur
	movzx	ecx, BYTE PTR _bUseThreaded420$[ebp]
	test	ecx, ecx
	je	SHORT $LN64@MainCaptur

; 1128 :             {
; 1129 :                 WaitForMultipleObjects(completeEvents.Num(), completeEvents.Array(), TRUE, INFINITE);

	push	-1
	push	1
	lea	ecx, DWORD PTR _completeEvents$[ebp]
	call	?Array@?$List@PAX@@QBEPAPAXXZ		; List<void *>::Array
	push	eax
	lea	ecx, DWORD PTR _completeEvents$[ebp]
	call	?Num@?$List@PAX@@QBEIXZ			; List<void *>::Num
	push	eax
	call	DWORD PTR __imp__WaitForMultipleObjects@16

; 1130 :                 copyTexture->Unmap(0);

	push	0
	mov	edx, DWORD PTR _copyTexture$46[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _copyTexture$46[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+44]
	call	edx
$LN64@MainCaptur:

; 1131 :             }
; 1132 : 
; 1133 :             D3D10Texture *d3dYUV = static_cast<D3D10Texture*>(yuvRenderTextures[curYUVTexture]);

	mov	eax, DWORD PTR _curYUVTexture$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+28]
	mov	DWORD PTR _d3dYUV$28[ebp], edx

; 1134 :             GetD3D()->CopyResource(copyTexture, d3dYUV->texture);

	call	?GetD3D@@YAPAUID3D10Device@@XZ		; GetD3D
	mov	DWORD PTR tv1247[ebp], eax
	mov	eax, DWORD PTR _d3dYUV$28[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _copyTexture$46[ebp]
	push	edx
	mov	eax, DWORD PTR tv1247[ebp]
	push	eax
	mov	ecx, DWORD PTR tv1247[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+132]
	call	eax

; 1135 :             profileOut;

	lea	ecx, DWORD PTR __curProfiler$4[ebp]
	call	DWORD PTR __imp_??1ProfilerNode@@QAE@XZ

; 1136 : 
; 1137 :             ID3D10Texture2D *prevTexture = copyTextures[prevCopyTexture];

	mov	ecx, DWORD PTR _prevCopyTexture$24[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+12]
	mov	DWORD PTR _prevTexture$60[ebp], eax

; 1138 : 
; 1139 :             if(bFirstImage) //ignore the first frame

	movzx	ecx, BYTE PTR _bFirstImage$[ebp]
	test	ecx, ecx
	je	SHORT $LN63@MainCaptur

; 1140 :                 bFirstImage = false;

	mov	BYTE PTR _bFirstImage$[ebp], 0

; 1141 :             else

	jmp	$LN39@MainCaptur
$LN63@MainCaptur:

; 1142 :             {
; 1143 :                 HRESULT result;
; 1144 :                 D3D10_MAPPED_TEXTURE2D map;
; 1145 :                 if(SUCCEEDED(result = prevTexture->Map(0, D3D10_MAP_READ, 0, &map)))

	lea	edx, DWORD PTR _map$45[ebp]
	push	edx
	push	0
	push	1
	push	0
	mov	eax, DWORD PTR _prevTexture$60[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _prevTexture$60[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+40]
	call	eax
	mov	DWORD PTR _result$58[ebp], eax
	cmp	DWORD PTR _result$58[ebp], 0
	jl	$LN61@MainCaptur

; 1146 :                 {
; 1147 :                     int prevOutBuffer = (curOutBuffer == 0) ? NUM_OUT_BUFFERS-1 : curOutBuffer-1;

	cmp	DWORD PTR _curOutBuffer$[ebp], 0
	jne	SHORT $LN190@MainCaptur
	mov	DWORD PTR tv1277[ebp], 2
	jmp	SHORT $LN191@MainCaptur
$LN190@MainCaptur:
	mov	ecx, DWORD PTR _curOutBuffer$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv1277[ebp], ecx
$LN191@MainCaptur:
	mov	edx, DWORD PTR tv1277[ebp]
	mov	DWORD PTR _prevOutBuffer$35[ebp], edx

; 1148 :                     int nextOutBuffer = (curOutBuffer == NUM_OUT_BUFFERS-1) ? 0 : curOutBuffer+1;

	cmp	DWORD PTR _curOutBuffer$[ebp], 2
	jne	SHORT $LN192@MainCaptur
	mov	DWORD PTR tv1280[ebp], 0
	jmp	SHORT $LN193@MainCaptur
$LN192@MainCaptur:
	mov	eax, DWORD PTR _curOutBuffer$[ebp]
	add	eax, 1
	mov	DWORD PTR tv1280[ebp], eax
$LN193@MainCaptur:
	mov	ecx, DWORD PTR tv1280[ebp]
	mov	DWORD PTR _nextOutBuffer$39[ebp], ecx

; 1149 : 
; 1150 :                     EncoderPicture &prevPicOut = outPics[prevOutBuffer];

	mov	edx, DWORD PTR _prevOutBuffer$35[ebp]
	lea	eax, DWORD PTR _outPics$[ebp+edx*8]
	mov	DWORD PTR _prevPicOut$19[ebp], eax

; 1151 :                     EncoderPicture &picOut = outPics[curOutBuffer];

	mov	ecx, DWORD PTR _curOutBuffer$[ebp]
	lea	edx, DWORD PTR _outPics$[ebp+ecx*8]
	mov	DWORD PTR _picOut$47[ebp], edx

; 1152 :                     EncoderPicture &nextPicOut = outPics[nextOutBuffer];

	mov	eax, DWORD PTR _nextOutBuffer$39[ebp]
	lea	ecx, DWORD PTR _outPics$[ebp+eax*8]
	mov	DWORD PTR _nextPicOut$61[ebp], ecx

; 1153 : 
; 1154 :                     if(!bUsing444)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+896]
	test	eax, eax
	jne	$LN60@MainCaptur

; 1155 :                     {
; 1156 :                         profileIn("conversion to 4:2:0");

	push	0
	push	OFFSET $SG4294781453
	lea	ecx, DWORD PTR __curProfiler$2[ebp]
	call	DWORD PTR __imp_??0ProfilerNode@@QAE@PB_W_N@Z

; 1157 : 
; 1158 :                         if(bUseThreaded420)

	movzx	ecx, BYTE PTR _bUseThreaded420$[ebp]
	test	ecx, ecx
	je	$LN59@MainCaptur

; 1159 :                         {
; 1160 :                             for(int i=0; i<numThreads; i++)

	mov	DWORD PTR _i$69[ebp], 0
	jmp	SHORT $LN58@MainCaptur
$LN57@MainCaptur:
	mov	edx, DWORD PTR _i$69[ebp]
	add	edx, 1
	mov	DWORD PTR _i$69[ebp], edx
$LN58@MainCaptur:
	mov	eax, DWORD PTR _i$69[ebp]
	cmp	eax, DWORD PTR _numThreads$[ebp]
	jge	$LN56@MainCaptur

; 1161 :                             {
; 1162 :                                 convertInfo[i].input     = (LPBYTE)map.pData;

	imul	ecx, DWORD PTR _i$69[ebp], 56
	mov	edx, DWORD PTR _convertInfo$[ebp]
	mov	eax, DWORD PTR _map$45[ebp]
	mov	DWORD PTR [edx+ecx], eax

; 1163 :                                 convertInfo[i].inPitch   = map.RowPitch;

	imul	ecx, DWORD PTR _i$69[ebp], 56
	mov	edx, DWORD PTR _convertInfo$[ebp]
	mov	eax, DWORD PTR _map$45[ebp+4]
	mov	DWORD PTR [edx+ecx+36], eax

; 1164 :                                 if(bUsingQSV)

	movzx	ecx, BYTE PTR _bUsingQSV$[ebp]
	test	ecx, ecx
	je	$LN55@MainCaptur

; 1165 :                                 {
; 1166 :                                     mfxFrameData& data = nextPicOut.mfxOut->Data;

	mov	edx, DWORD PTR _nextPicOut$61[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 88					; 00000058H
	mov	DWORD PTR _data$59[ebp], eax

; 1167 :                                     videoEncoder->RequestBuffers(&data);

	mov	ecx, DWORD PTR _data$59[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+148]
	mov	eax, DWORD PTR [edx+4]
	call	eax

; 1168 :                                     convertInfo[i].outPitch  = data.Pitch;

	mov	ecx, DWORD PTR _data$59[ebp]
	movzx	edx, WORD PTR [ecx+46]
	imul	eax, DWORD PTR _i$69[ebp], 56
	mov	ecx, DWORD PTR _convertInfo$[ebp]
	mov	DWORD PTR [ecx+eax+40], edx

; 1169 :                                     convertInfo[i].output[0] = data.Y;

	imul	edx, DWORD PTR _i$69[ebp], 56
	add	edx, DWORD PTR _convertInfo$[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _data$59[ebp]
	mov	eax, DWORD PTR [eax+48]
	mov	DWORD PTR [edx+ecx+4], eax

; 1170 :                                     convertInfo[i].output[1] = data.UV;

	imul	ecx, DWORD PTR _i$69[ebp], 56
	add	ecx, DWORD PTR _convertInfo$[ebp]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _data$59[ebp]
	mov	eax, DWORD PTR [eax+52]
	mov	DWORD PTR [ecx+edx+4], eax

; 1171 :                                 }
; 1172 :                                 else

	jmp	SHORT $LN54@MainCaptur
$LN55@MainCaptur:

; 1173 :                                 {
; 1174 :                                     convertInfo[i].output[0] = nextPicOut.picOut->img.plane[0];

	mov	ecx, DWORD PTR _nextPicOut$61[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	imul	eax, DWORD PTR _i$69[ebp], 56
	add	eax, DWORD PTR _convertInfo$[ebp]
	mov	esi, 4
	imul	esi, esi, 0
	mov	ecx, DWORD PTR [edx+ecx+60]
	mov	DWORD PTR [eax+esi+4], ecx

; 1175 :                                     convertInfo[i].output[1] = nextPicOut.picOut->img.plane[1];

	mov	edx, DWORD PTR _nextPicOut$61[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, 4
	shl	ecx, 0
	imul	edx, DWORD PTR _i$69[ebp], 56
	add	edx, DWORD PTR _convertInfo$[ebp]
	mov	esi, 4
	shl	esi, 0
	mov	eax, DWORD PTR [eax+ecx+60]
	mov	DWORD PTR [edx+esi+4], eax

; 1176 :                                     convertInfo[i].output[2] = nextPicOut.picOut->img.plane[2];

	mov	ecx, DWORD PTR _nextPicOut$61[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, 4
	shl	eax, 1
	imul	ecx, DWORD PTR _i$69[ebp], 56
	add	ecx, DWORD PTR _convertInfo$[ebp]
	mov	esi, 4
	shl	esi, 1
	mov	edx, DWORD PTR [edx+eax+60]
	mov	DWORD PTR [ecx+esi+4], edx
$LN54@MainCaptur:

; 1177 : 								}
; 1178 :                                 SetEvent(convertInfo[i].hSignalConvert);

	imul	eax, DWORD PTR _i$69[ebp], 56
	mov	ecx, DWORD PTR _convertInfo$[ebp]
	mov	edx, DWORD PTR [ecx+eax+20]
	push	edx
	call	DWORD PTR __imp__SetEvent@4

; 1179 :                             }

	jmp	$LN57@MainCaptur
$LN56@MainCaptur:

; 1180 : 
; 1181 :                             if(bFirstEncode)

	movzx	eax, BYTE PTR _bFirstEncode$[ebp]
	test	eax, eax
	je	SHORT $LN53@MainCaptur

; 1182 :                                 bFirstEncode = bEncode = false;

	mov	BYTE PTR _bEncode$[ebp], 0
	mov	cl, BYTE PTR _bEncode$[ebp]
	mov	BYTE PTR _bFirstEncode$[ebp], cl
$LN53@MainCaptur:

; 1183 :                         }
; 1184 :                         else

	jmp	$LN52@MainCaptur
$LN59@MainCaptur:

; 1185 :                         {
; 1186 :                             if(bUsingQSV)

	movzx	edx, BYTE PTR _bUsingQSV$[ebp]
	test	edx, edx
	je	$LN51@MainCaptur

; 1187 :                             {
; 1188 :                                 mfxFrameData& data = picOut.mfxOut->Data;

	mov	eax, DWORD PTR _picOut$47[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 88					; 00000058H
	mov	DWORD PTR _data$54[ebp], ecx

; 1189 :                                 videoEncoder->RequestBuffers(&data);

	mov	edx, DWORD PTR _data$54[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+148]
	mov	edx, DWORD PTR [eax+4]
	call	edx

; 1190 :                                 LPBYTE output[] = {data.Y, data.UV};

	mov	eax, DWORD PTR _data$54[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR _output$20[ebp], ecx
	mov	edx, DWORD PTR _data$54[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	DWORD PTR _output$20[ebp+4], eax

; 1191 :                                 Convert444toNV12((LPBYTE)map.pData, outputCX, map.RowPitch, data.Pitch, outputCY, 0, outputCY, output);

	lea	ecx, DWORD PTR _output$20[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+876]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+876]
	push	edx
	mov	eax, DWORD PTR _data$54[ebp]
	movzx	ecx, WORD PTR [eax+46]
	push	ecx
	mov	edx, DWORD PTR _map$45[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+872]
	push	ecx
	mov	edx, DWORD PTR _map$45[ebp]
	push	edx
	call	?Convert444toNV12@@YAXPAEHHHHHHPAPAE@Z	; Convert444toNV12
	add	esp, 32					; 00000020H

; 1192 :                             }
; 1193 :                             else

	jmp	SHORT $LN50@MainCaptur
$LN51@MainCaptur:

; 1194 :                                 Convert444toNV12((LPBYTE)map.pData, outputCX, map.RowPitch, outputCX, outputCY, 0, outputCY, picOut.picOut->img.plane);

	mov	eax, DWORD PTR _picOut$47[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 60					; 0000003cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+876]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+876]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+872]
	push	ecx
	mov	edx, DWORD PTR _map$45[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+872]
	push	ecx
	mov	edx, DWORD PTR _map$45[ebp]
	push	edx
	call	?Convert444toNV12@@YAXPAEHHHHHHPAPAE@Z	; Convert444toNV12
	add	esp, 32					; 00000020H
$LN50@MainCaptur:

; 1195 :                             prevTexture->Unmap(0);

	push	0
	mov	eax, DWORD PTR _prevTexture$60[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _prevTexture$60[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+44]
	call	eax
$LN52@MainCaptur:

; 1196 :                         }
; 1197 : 
; 1198 :                         profileOut;

	lea	ecx, DWORD PTR __curProfiler$2[ebp]
	call	DWORD PTR __imp_??1ProfilerNode@@QAE@XZ
$LN60@MainCaptur:

; 1199 :                     }
; 1200 : 
; 1201 :                     if(bEncode)

	movzx	ecx, BYTE PTR _bEncode$[ebp]
	test	ecx, ecx
	je	SHORT $LN49@MainCaptur

; 1202 :                     {
; 1203 :                         //encodeThreadProfiler.reset(::new ProfilerNode(TEXT("EncodeThread"), true));
; 1204 :                         //encodeThreadProfiler->MonitorThread(hEncodeThread);
; 1205 :                         InterlockedExchangePointer((volatile PVOID*)&curFramePic, &picOut);

	mov	edx, DWORD PTR _picOut$47[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1120				; 00000460H
	push	eax
	call	__InlineInterlockedExchangePointer
	add	esp, 8
$LN49@MainCaptur:

; 1206 :                     }
; 1207 : 
; 1208 :                     curOutBuffer = nextOutBuffer;

	mov	ecx, DWORD PTR _nextOutBuffer$39[ebp]
	mov	DWORD PTR _curOutBuffer$[ebp], ecx

; 1209 :                 }
; 1210 :                 else

	jmp	$LN39@MainCaptur
$LN61@MainCaptur:

; 1211 :                 {
; 1212 :                     //We have to crash, or we end up deadlocking the thread when the convert threads are never signalled
; 1213 :                     if (result == DXGI_ERROR_DEVICE_REMOVED)

	cmp	DWORD PTR _result$58[ebp], -2005270523	; 887a0005H
	jne	$LN47@MainCaptur

; 1214 :                     {
; 1215 :                         String message;

	lea	ecx, DWORD PTR _message$52[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 1216 : 
; 1217 :                         HRESULT reason = GetD3D()->GetDeviceRemovedReason();

	call	?GetD3D@@YAPAUID3D10Device@@XZ		; GetD3D
	mov	DWORD PTR tv1491[ebp], eax
	mov	edx, DWORD PTR tv1491[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv1491[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+252]
	call	edx
	mov	DWORD PTR _reason$38[ebp], eax

; 1218 : 
; 1219 :                         switch (reason)

	mov	eax, DWORD PTR _reason$38[ebp]
	mov	DWORD PTR tv1495[ebp], eax
	mov	ecx, DWORD PTR tv1495[ebp]
	add	ecx, 2005270527				; 7785ffffH
	mov	DWORD PTR tv1495[ebp], ecx
	cmp	DWORD PTR tv1495[ebp], 31		; 0000001fH
	ja	SHORT $LN40@MainCaptur
	mov	edx, DWORD PTR tv1495[ebp]
	movzx	eax, BYTE PTR $LN203@MainCaptur[edx]
	jmp	DWORD PTR $LN208@MainCaptur[eax*4]
$LN44@MainCaptur:

; 1220 :                         {
; 1221 :                         case DXGI_ERROR_DEVICE_RESET:
; 1222 :                         case DXGI_ERROR_DEVICE_HUNG:
; 1223 :                             message = TEXT("Your video card or driver froze and was reset. Please check for possible hardware / driver issues.");

	push	OFFSET $SG4294781452
	lea	ecx, DWORD PTR _message$52[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z

; 1224 :                             break;

	jmp	SHORT $LN45@MainCaptur
$LN43@MainCaptur:

; 1225 :                         case DXGI_ERROR_DEVICE_REMOVED:
; 1226 :                             message = TEXT("Your video card disappeared from the system. Please check for possible hardware / driver issues.");

	push	OFFSET $SG4294781451
	lea	ecx, DWORD PTR _message$52[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z

; 1227 :                             break;

	jmp	SHORT $LN45@MainCaptur
$LN42@MainCaptur:

; 1228 :                         case DXGI_ERROR_DRIVER_INTERNAL_ERROR:
; 1229 :                             message = TEXT("Your video driver reported an internal error. Please check for possible hardware / driver issues.");

	push	OFFSET $SG4294781450
	lea	ecx, DWORD PTR _message$52[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z

; 1230 :                             break;

	jmp	SHORT $LN45@MainCaptur
$LN41@MainCaptur:

; 1231 :                         case DXGI_ERROR_INVALID_CALL:
; 1232 :                             message = TEXT("Your video driver reported an invalid call. Please check for possible driver issues.");

	push	OFFSET $SG4294781449
	lea	ecx, DWORD PTR _message$52[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z

; 1233 :                             break;

	jmp	SHORT $LN45@MainCaptur
$LN40@MainCaptur:

; 1234 :                         default:
; 1235 :                             message = TEXT("DXGI_ERROR_DEVICE_REMOVED");

	push	OFFSET $SG4294781448
	lea	ecx, DWORD PTR _message$52[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z
$LN45@MainCaptur:

; 1236 :                             break;
; 1237 :                         }
; 1238 : 
; 1239 :                         message << TEXT(" This error can also occur if you have enabled opencl in x264 custom settings.");

	push	OFFSET $SG4294781447
	lea	ecx, DWORD PTR _message$52[ebp]
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z

; 1240 : 
; 1241 :                         CrashError (TEXT("Texture->Map failed: 0x%08x 0x%08x\r\n\r\n%s"), result, reason, message.Array());

	lea	ecx, DWORD PTR _message$52[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	mov	ecx, DWORD PTR _reason$38[ebp]
	push	ecx
	mov	edx, DWORD PTR _result$58[ebp]
	push	edx
	push	OFFSET $SG4294781446
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ

; 1242 :                     }

	lea	ecx, DWORD PTR _message$52[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 1243 :                     else

	jmp	SHORT $LN39@MainCaptur
$LN47@MainCaptur:

; 1244 :                         CrashError (TEXT("Texture->Map failed: 0x%08x"), result);

	mov	eax, DWORD PTR _result$58[ebp]
	push	eax
	push	OFFSET $SG4294781445
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ
$LN39@MainCaptur:

; 1245 :                 }
; 1246 :             }
; 1247 : 
; 1248 :             if(curCopyTexture == (NUM_RENDER_BUFFERS-1))

	cmp	DWORD PTR _curCopyTexture$[ebp], 1
	jne	SHORT $LN38@MainCaptur

; 1249 :                 curCopyTexture = 0;

	mov	DWORD PTR _curCopyTexture$[ebp], 0

; 1250 :             else

	jmp	SHORT $LN37@MainCaptur
$LN38@MainCaptur:

; 1251 :                 curCopyTexture++;

	mov	ecx, DWORD PTR _curCopyTexture$[ebp]
	add	ecx, 1
	mov	DWORD PTR _curCopyTexture$[ebp], ecx
$LN37@MainCaptur:

; 1252 : 
; 1253 :             if(curYUVTexture == (NUM_RENDER_BUFFERS-1))

	cmp	DWORD PTR _curYUVTexture$[ebp], 1
	jne	SHORT $LN36@MainCaptur

; 1254 :                 curYUVTexture = 0;

	mov	DWORD PTR _curYUVTexture$[ebp], 0

; 1255 :             else

	jmp	SHORT $LN35@MainCaptur
$LN36@MainCaptur:

; 1256 :                 curYUVTexture++;

	mov	edx, DWORD PTR _curYUVTexture$[ebp]
	add	edx, 1
	mov	DWORD PTR _curYUVTexture$[ebp], edx
$LN35@MainCaptur:

; 1257 : 
; 1258 :             if (bCongestionControl && bDynamicBitrateSupported && !bTestStream && totalStreamTime > 15000)

	cmp	DWORD PTR _bCongestionControl$[ebp], 0
	je	$LN26@MainCaptur
	movzx	eax, BYTE PTR _bDynamicBitrateSupported$[ebp]
	test	eax, eax
	je	$LN26@MainCaptur
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+620]
	test	edx, edx
	jne	$LN26@MainCaptur
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+928], 15000		; 00003a98H
	jbe	$LN26@MainCaptur

; 1259 :             {
; 1260 :                 if (curStrain > 25)

	mov	ecx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [ecx+936]
	comisd	xmm0, QWORD PTR __real@4039000000000000
	jbe	$LN33@MainCaptur

; 1261 :                 {
; 1262 :                     if (renderStartTimeMS - lastAdjustmentTime > 1500)

	mov	edx, DWORD PTR _renderStartTimeMS$63[ebp]
	sub	edx, DWORD PTR _lastAdjustmentTime$[ebp]
	mov	eax, DWORD PTR _renderStartTimeMS$63[ebp+4]
	sbb	eax, DWORD PTR _lastAdjustmentTime$[ebp+4]
	mov	DWORD PTR tv2809[ebp], edx
	mov	DWORD PTR tv2809[ebp+4], eax
	cmp	DWORD PTR tv2809[ebp+4], 0
	ja	SHORT $LN204@MainCaptur
	cmp	DWORD PTR tv2809[ebp], 1500		; 000005dcH
	jbe	$LN32@MainCaptur
$LN204@MainCaptur:

; 1263 :                     {
; 1264 :                         if (currentBitRate > 100)

	cmp	DWORD PTR _currentBitRate$[ebp], 100	; 00000064H
	jle	$LN31@MainCaptur

; 1265 :                         {
; 1266 :                             currentBitRate = (int)(currentBitRate * (1.0 - (curStrain / 400)));

	cvtsi2sd xmm0, DWORD PTR _currentBitRate$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movsd	xmm1, QWORD PTR [ecx+936]
	divsd	xmm1, QWORD PTR __real@4079000000000000
	movsd	xmm2, QWORD PTR __real@3ff0000000000000
	subsd	xmm2, xmm1
	mulsd	xmm0, xmm2
	cvttsd2si edx, xmm0
	mov	DWORD PTR _currentBitRate$[ebp], edx

; 1267 :                             App->GetVideoEncoder()->SetBitRate(currentBitRate, -1);

	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?GetVideoEncoder@OBS@@QBEPAVVideoEncoder@@XZ ; OBS::GetVideoEncoder
	mov	DWORD PTR tv1579[ebp], eax
	push	-1
	mov	eax, DWORD PTR _currentBitRate$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv1579[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv1579[ebp]
	mov	eax, DWORD PTR [edx+20]
	call	eax

; 1268 :                             if (!adjustmentStreamId)

	cmp	DWORD PTR _adjustmentStreamId$[ebp], 0
	jne	SHORT $LN30@MainCaptur

; 1269 :                                 adjustmentStreamId = App->AddStreamInfo (FormattedString(TEXT("Congestion detected, dropping bitrate to %d kbps"), currentBitRate).Array(), StreamInfoPriority_Low);

	push	0
	mov	ecx, DWORD PTR _currentBitRate$[ebp]
	push	ecx
	push	OFFSET $SG4294781444
	lea	edx, DWORD PTR $T15[ebp]
	push	edx
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?AddStreamInfo@OBS@@QAEIPB_WW4StreamInfoPriority@@@Z ; OBS::AddStreamInfo
	mov	DWORD PTR _adjustmentStreamId$[ebp], eax
	lea	ecx, DWORD PTR $T15[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 1270 :                             else

	jmp	SHORT $LN29@MainCaptur
$LN30@MainCaptur:

; 1271 :                                 App->SetStreamInfo(adjustmentStreamId, FormattedString(TEXT("Congestion detected, dropping bitrate to %d kbps"), currentBitRate).Array());

	mov	eax, DWORD PTR _currentBitRate$[ebp]
	push	eax
	push	OFFSET $SG4294781443
	lea	ecx, DWORD PTR $T14[ebp]
	push	ecx
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	mov	edx, DWORD PTR _adjustmentStreamId$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?SetStreamInfo@OBS@@QAEXIPB_W@Z		; OBS::SetStreamInfo
	lea	ecx, DWORD PTR $T14[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN29@MainCaptur:

; 1272 : 
; 1273 :                             bUpdateBPS = true;

	mov	BYTE PTR _bUpdateBPS$72[ebp], 1
$LN31@MainCaptur:

; 1274 :                         }
; 1275 : 
; 1276 :                         lastAdjustmentTime = renderStartTimeMS;

	mov	eax, DWORD PTR _renderStartTimeMS$63[ebp]
	mov	DWORD PTR _lastAdjustmentTime$[ebp], eax
	mov	ecx, DWORD PTR _renderStartTimeMS$63[ebp+4]
	mov	DWORD PTR _lastAdjustmentTime$[ebp+4], ecx
$LN32@MainCaptur:

; 1277 :                     }
; 1278 :                 }

	jmp	$LN26@MainCaptur
$LN33@MainCaptur:

; 1279 :                 else if (currentBitRate < defaultBitRate && curStrain < 5 && lastStrain < 5)

	mov	edx, DWORD PTR _currentBitRate$[ebp]
	cmp	edx, DWORD PTR _defaultBitRate$[ebp]
	jge	$LN26@MainCaptur
	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR __real@4014000000000000
	comisd	xmm0, QWORD PTR [eax+936]
	jbe	$LN26@MainCaptur
	movsd	xmm0, QWORD PTR __real@4014000000000000
	comisd	xmm0, QWORD PTR _lastStrain$[ebp]
	jbe	$LN26@MainCaptur

; 1280 :                 {
; 1281 :                     if (renderStartTimeMS - lastAdjustmentTime > 5000)

	mov	ecx, DWORD PTR _renderStartTimeMS$63[ebp]
	sub	ecx, DWORD PTR _lastAdjustmentTime$[ebp]
	mov	edx, DWORD PTR _renderStartTimeMS$63[ebp+4]
	sbb	edx, DWORD PTR _lastAdjustmentTime$[ebp+4]
	mov	DWORD PTR tv2841[ebp], ecx
	mov	DWORD PTR tv2841[ebp+4], edx
	cmp	DWORD PTR tv2841[ebp+4], 0
	ja	SHORT $LN205@MainCaptur
	cmp	DWORD PTR tv2841[ebp], 5000		; 00001388H
	jbe	$LN26@MainCaptur
$LN205@MainCaptur:

; 1282 :                     {
; 1283 :                         if (currentBitRate < defaultBitRate)

	mov	eax, DWORD PTR _currentBitRate$[ebp]
	cmp	eax, DWORD PTR _defaultBitRate$[ebp]
	jge	SHORT $LN24@MainCaptur

; 1284 :                         {
; 1285 :                             currentBitRate += (int)(defaultBitRate * 0.05);

	cvtsi2sd xmm0, DWORD PTR _defaultBitRate$[ebp]
	mulsd	xmm0, QWORD PTR __real@3fa999999999999a
	cvttsd2si ecx, xmm0
	add	ecx, DWORD PTR _currentBitRate$[ebp]
	mov	DWORD PTR _currentBitRate$[ebp], ecx

; 1286 :                             if (currentBitRate > defaultBitRate)

	mov	edx, DWORD PTR _currentBitRate$[ebp]
	cmp	edx, DWORD PTR _defaultBitRate$[ebp]
	jle	SHORT $LN24@MainCaptur

; 1287 :                                 currentBitRate = defaultBitRate;

	mov	eax, DWORD PTR _defaultBitRate$[ebp]
	mov	DWORD PTR _currentBitRate$[ebp], eax
$LN24@MainCaptur:

; 1288 :                         }
; 1289 : 
; 1290 :                         App->GetVideoEncoder()->SetBitRate(currentBitRate, -1);

	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?GetVideoEncoder@OBS@@QBEPAVVideoEncoder@@XZ ; OBS::GetVideoEncoder
	mov	DWORD PTR tv1624[ebp], eax
	push	-1
	mov	ecx, DWORD PTR _currentBitRate$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv1624[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv1624[ebp]
	mov	edx, DWORD PTR [eax+20]
	call	edx

; 1291 :                         /*if (!adjustmentStreamId)
; 1292 :                             App->AddStreamInfo (FormattedString(TEXT("Congestion clearing, raising bitrate to %d kbps"), currentBitRate).Array(), StreamInfoPriority_Low);
; 1293 :                         else
; 1294 :                             App->SetStreamInfo(adjustmentStreamId, FormattedString(TEXT("Congestion clearing, raising bitrate to %d kbps"), currentBitRate).Array());*/
; 1295 : 
; 1296 :                         App->RemoveStreamInfo(adjustmentStreamId);

	mov	eax, DWORD PTR _adjustmentStreamId$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?RemoveStreamInfo@OBS@@QAEXI@Z		; OBS::RemoveStreamInfo

; 1297 :                         adjustmentStreamId = 0;

	mov	DWORD PTR _adjustmentStreamId$[ebp], 0

; 1298 : 
; 1299 :                         bUpdateBPS = true;

	mov	BYTE PTR _bUpdateBPS$72[ebp], 1

; 1300 : 
; 1301 :                         lastAdjustmentTime = renderStartTimeMS;

	mov	ecx, DWORD PTR _renderStartTimeMS$63[ebp]
	mov	DWORD PTR _lastAdjustmentTime$[ebp], ecx
	mov	edx, DWORD PTR _renderStartTimeMS$63[ebp+4]
	mov	DWORD PTR _lastAdjustmentTime$[ebp+4], edx
$LN26@MainCaptur:

; 1302 :                     }
; 1303 :                 }
; 1304 :             }
; 1305 :         }
; 1306 : 
; 1307 :         lastRenderTarget = curRenderTarget;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _curRenderTarget$[ebp]
	mov	DWORD PTR [eax+852], ecx

; 1308 : 
; 1309 :         if(curRenderTarget == (NUM_RENDER_BUFFERS-1))

	cmp	DWORD PTR _curRenderTarget$[ebp], 1
	jne	SHORT $LN23@MainCaptur

; 1310 :             curRenderTarget = 0;

	mov	DWORD PTR _curRenderTarget$[ebp], 0

; 1311 :         else

	jmp	SHORT $LN22@MainCaptur
$LN23@MainCaptur:

; 1312 :             curRenderTarget++;

	mov	edx, DWORD PTR _curRenderTarget$[ebp]
	add	edx, 1
	mov	DWORD PTR _curRenderTarget$[ebp], edx
$LN22@MainCaptur:

; 1313 : 
; 1314 :         if(bUpdateBPS || !CloseDouble(curStrain, lastStrain) || curFramesDropped != lastFramesDropped)

	movzx	eax, BYTE PTR _bUpdateBPS$72[ebp]
	test	eax, eax
	jne	SHORT $LN20@MainCaptur
	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@3f50624dd2f1a9fc
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _lastStrain$[ebp]
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	sub	esp, 8
	movsd	xmm0, QWORD PTR [ecx+936]
	movsd	QWORD PTR [esp], xmm0
	call	?CloseDouble@@YAHNNN@Z			; CloseDouble
	add	esp, 24					; 00000018H
	test	eax, eax
	je	SHORT $LN20@MainCaptur
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+924]
	cmp	eax, DWORD PTR _lastFramesDropped$[ebp]
	je	SHORT $LN21@MainCaptur
$LN20@MainCaptur:

; 1315 :         {
; 1316 :             PostMessage(hwndMain, OBS_UPDATESTATUSBAR, 0, 0);

	push	0
	push	0
	push	1031					; 00000407H
	mov	ecx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	ecx
	call	DWORD PTR __imp__PostMessageW@16

; 1317 :             lastStrain = curStrain;

	mov	edx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [edx+936]
	movsd	QWORD PTR _lastStrain$[ebp], xmm0

; 1318 : 
; 1319 :             lastFramesDropped = curFramesDropped;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+924]
	mov	DWORD PTR _lastFramesDropped$[ebp], ecx
$LN21@MainCaptur:

; 1320 :         }
; 1321 : 
; 1322 :         //------------------------------------
; 1323 :         // we're about to sleep so we should flush the d3d command queue
; 1324 :         profileIn("flush");

	push	0
	push	OFFSET $SG4294781442
	lea	ecx, DWORD PTR __curProfiler$5[ebp]
	call	DWORD PTR __imp_??0ProfilerNode@@QAE@PB_W_N@Z

; 1325 :         GetD3D()->Flush();

	call	?GetD3D@@YAPAUID3D10Device@@XZ		; GetD3D
	mov	DWORD PTR tv1657[ebp], eax
	mov	edx, DWORD PTR tv1657[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv1657[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+280]
	call	edx

; 1326 :         profileOut;

	lea	ecx, DWORD PTR __curProfiler$5[ebp]
	call	DWORD PTR __imp_??1ProfilerNode@@QAE@XZ

; 1327 :         profileOut;

	lea	ecx, DWORD PTR __curProfiler$3[ebp]
	call	DWORD PTR __imp_??1ProfilerNode@@QAE@XZ

; 1328 :         profileOut; //frame

	lea	ecx, DWORD PTR __curProfiler$1[ebp]
	call	DWORD PTR __imp_??1ProfilerNode@@QAE@XZ

; 1329 : 
; 1330 :         //------------------------------------
; 1331 :         // frame sync
; 1332 : 
; 1333 :         //QWORD renderStopTime = GetQPCTimeNS();
; 1334 : 
; 1335 :         if(bWasLaggedFrame = (frameDelta > frameLengthNS))

	mov	eax, DWORD PTR _frameDelta$48[ebp+4]
	cmp	eax, DWORD PTR _frameLengthNS$[ebp+4]
	jb	SHORT $LN194@MainCaptur
	ja	SHORT $LN206@MainCaptur
	mov	ecx, DWORD PTR _frameDelta$48[ebp]
	cmp	ecx, DWORD PTR _frameLengthNS$[ebp]
	jbe	SHORT $LN194@MainCaptur
$LN206@MainCaptur:
	mov	DWORD PTR tv1661[ebp], 1
	jmp	SHORT $LN195@MainCaptur
$LN194@MainCaptur:
	mov	DWORD PTR tv1661[ebp], 0
$LN195@MainCaptur:
	mov	dl, BYTE PTR tv1661[ebp]
	mov	BYTE PTR _bWasLaggedFrame$[ebp], dl
	movzx	eax, BYTE PTR _bWasLaggedFrame$[ebp]
	test	eax, eax
	je	SHORT $LN18@MainCaptur

; 1336 :         {
; 1337 :             numLongFrames++;

	mov	ecx, DWORD PTR _numLongFrames$[ebp]
	add	ecx, 1
	mov	DWORD PTR _numLongFrames$[ebp], ecx

; 1338 :             if(bLogLongFramesProfile && (numLongFrames/float(max(1, numTotalFrames)) * 100.) > logLongFramesProfilePercentage)

	movzx	edx, BYTE PTR _bLogLongFramesProfile$[ebp]
	test	edx, edx
	je	SHORT $LN18@MainCaptur
	cmp	DWORD PTR _numTotalFrames$[ebp], 1
	jge	SHORT $LN196@MainCaptur
	mov	DWORD PTR tv1670[ebp], 1
	jmp	SHORT $LN197@MainCaptur
$LN196@MainCaptur:
	mov	eax, DWORD PTR _numTotalFrames$[ebp]
	mov	DWORD PTR tv1670[ebp], eax
$LN197@MainCaptur:
	cvtsi2ss xmm0, DWORD PTR _numLongFrames$[ebp]
	cvtsi2ss xmm1, DWORD PTR tv1670[ebp]
	divss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@4059000000000000
	cvtss2sd xmm1, DWORD PTR _logLongFramesProfilePercentage$[ebp]
	comisd	xmm0, xmm1
	jbe	SHORT $LN18@MainCaptur

; 1339 :                 DumpLastProfileData();

	call	DWORD PTR __imp_?DumpLastProfileData@@YGXXZ
$LN18@MainCaptur:

; 1340 :         }
; 1341 : 
; 1342 :         //OSDebugOut(TEXT("Frame adjust time: %d, "), frameTimeAdjust-totalTime);
; 1343 : 
; 1344 :         numTotalFrames++;

	mov	ecx, DWORD PTR _numTotalFrames$[ebp]
	add	ecx, 1
	mov	DWORD PTR _numTotalFrames$[ebp], ecx

; 1345 :     }

	jmp	$LN135@MainCaptur
$LN134@MainCaptur:

; 1346 : 
; 1347 :     DisableProjector();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DisableProjector@OBS@@AAEXXZ		; OBS::DisableProjector

; 1348 : 
; 1349 :     //encodeThreadProfiler.reset();
; 1350 : 
; 1351 :     if(!bUsing444)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+896]
	test	eax, eax
	jne	$LN1@MainCaptur

; 1352 :     {
; 1353 :         if(bUseThreaded420)

	movzx	ecx, BYTE PTR _bUseThreaded420$[ebp]
	test	ecx, ecx
	je	$LN9@MainCaptur

; 1354 :         {
; 1355 :             for(int i=0; i<numThreads; i++)

	mov	DWORD PTR _i$70[ebp], 0
	jmp	SHORT $LN15@MainCaptur
$LN14@MainCaptur:
	mov	edx, DWORD PTR _i$70[ebp]
	add	edx, 1
	mov	DWORD PTR _i$70[ebp], edx
$LN15@MainCaptur:
	mov	eax, DWORD PTR _i$70[ebp]
	cmp	eax, DWORD PTR _numThreads$[ebp]
	jge	$LN13@MainCaptur

; 1356 :             {
; 1357 :                 if(h420Threads[i])

	mov	ecx, DWORD PTR _i$70[ebp]
	mov	edx, DWORD PTR _h420Threads$[ebp]
	cmp	DWORD PTR [edx+ecx*4], 0
	je	SHORT $LN12@MainCaptur

; 1358 :                 {
; 1359 :                     convertInfo[i].bKillThread = true;

	imul	eax, DWORD PTR _i$70[ebp], 56
	mov	ecx, DWORD PTR _convertInfo$[ebp]
	mov	BYTE PTR [ecx+eax+17], 1

; 1360 :                     SetEvent(convertInfo[i].hSignalConvert);

	imul	edx, DWORD PTR _i$70[ebp], 56
	mov	eax, DWORD PTR _convertInfo$[ebp]
	mov	ecx, DWORD PTR [eax+edx+20]
	push	ecx
	call	DWORD PTR __imp__SetEvent@4

; 1361 : 
; 1362 :                     OSTerminateThread(h420Threads[i], 10000);

	push	10000					; 00002710H
	mov	edx, DWORD PTR _i$70[ebp]
	mov	eax, DWORD PTR _h420Threads$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	DWORD PTR __imp_?OSTerminateThread@@YGHPAXK@Z

; 1363 :                     h420Threads[i] = NULL;

	mov	edx, DWORD PTR _i$70[ebp]
	mov	eax, DWORD PTR _h420Threads$[ebp]
	mov	DWORD PTR [eax+edx*4], 0
$LN12@MainCaptur:

; 1364 :                 }
; 1365 : 
; 1366 :                 if(convertInfo[i].hSignalConvert)

	imul	ecx, DWORD PTR _i$70[ebp], 56
	mov	edx, DWORD PTR _convertInfo$[ebp]
	cmp	DWORD PTR [edx+ecx+20], 0
	je	SHORT $LN11@MainCaptur

; 1367 :                 {
; 1368 :                     CloseHandle(convertInfo[i].hSignalConvert);

	imul	eax, DWORD PTR _i$70[ebp], 56
	mov	ecx, DWORD PTR _convertInfo$[ebp]
	mov	edx, DWORD PTR [ecx+eax+20]
	push	edx
	call	DWORD PTR __imp__CloseHandle@4

; 1369 :                     convertInfo[i].hSignalConvert = NULL;

	imul	eax, DWORD PTR _i$70[ebp], 56
	mov	ecx, DWORD PTR _convertInfo$[ebp]
	mov	DWORD PTR [ecx+eax+20], 0
$LN11@MainCaptur:

; 1370 :                 }
; 1371 : 
; 1372 :                 if(convertInfo[i].hSignalComplete)

	imul	edx, DWORD PTR _i$70[ebp], 56
	mov	eax, DWORD PTR _convertInfo$[ebp]
	cmp	DWORD PTR [eax+edx+24], 0
	je	SHORT $LN10@MainCaptur

; 1373 :                 {
; 1374 :                     CloseHandle(convertInfo[i].hSignalComplete);

	imul	ecx, DWORD PTR _i$70[ebp], 56
	mov	edx, DWORD PTR _convertInfo$[ebp]
	mov	eax, DWORD PTR [edx+ecx+24]
	push	eax
	call	DWORD PTR __imp__CloseHandle@4

; 1375 :                     convertInfo[i].hSignalComplete = NULL;

	imul	ecx, DWORD PTR _i$70[ebp], 56
	mov	edx, DWORD PTR _convertInfo$[ebp]
	mov	DWORD PTR [edx+ecx+24], 0
$LN10@MainCaptur:

; 1376 :                 }
; 1377 :             }

	jmp	$LN14@MainCaptur
$LN13@MainCaptur:

; 1378 : 
; 1379 :             if(!bFirstEncode)

	movzx	eax, BYTE PTR _bFirstEncode$[ebp]
	test	eax, eax
	jne	SHORT $LN9@MainCaptur

; 1380 :             {
; 1381 :                 ID3D10Texture2D *copyTexture = copyTextures[curCopyTexture];

	mov	ecx, DWORD PTR _curCopyTexture$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+12]
	mov	DWORD PTR _copyTexture$37[ebp], eax

; 1382 :                 copyTexture->Unmap(0);

	push	0
	mov	ecx, DWORD PTR _copyTexture$37[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _copyTexture$37[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+44]
	call	ecx
$LN9@MainCaptur:

; 1383 :             }
; 1384 :         }
; 1385 : 
; 1386 :         if(bUsingQSV)

	movzx	edx, BYTE PTR _bUsingQSV$[ebp]
	test	edx, edx
	je	SHORT $LN8@MainCaptur

; 1387 :             for(int i = 0; i < NUM_OUT_BUFFERS; i++)

	mov	DWORD PTR _i$53[ebp], 0
	jmp	SHORT $LN7@MainCaptur
$LN6@MainCaptur:
	mov	eax, DWORD PTR _i$53[ebp]
	add	eax, 1
	mov	DWORD PTR _i$53[ebp], eax
$LN7@MainCaptur:
	cmp	DWORD PTR _i$53[ebp], 3
	jge	SHORT $LN5@MainCaptur

; 1388 :                 delete outPics[i].mfxOut;

	mov	ecx, DWORD PTR _i$53[ebp]
	mov	edx, DWORD PTR _outPics$[ebp+ecx*8+4]
	mov	DWORD PTR $T33[ebp], edx
	mov	eax, DWORD PTR $T33[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	jmp	SHORT $LN6@MainCaptur
$LN5@MainCaptur:
	jmp	SHORT $LN1@MainCaptur
$LN8@MainCaptur:

; 1389 :         else
; 1390 :             for(int i=0; i<NUM_OUT_BUFFERS; i++)

	mov	DWORD PTR _i$65[ebp], 0
	jmp	SHORT $LN3@MainCaptur
$LN2@MainCaptur:
	mov	ecx, DWORD PTR _i$65[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$65[ebp], ecx
$LN3@MainCaptur:
	cmp	DWORD PTR _i$65[ebp], 3
	jge	SHORT $LN1@MainCaptur

; 1391 :             {
; 1392 :                 x264_picture_clean(outPics[i].picOut);

	mov	edx, DWORD PTR _i$65[ebp]
	mov	eax, DWORD PTR _outPics$[ebp+edx*8]
	push	eax
	call	DWORD PTR __imp__x264_picture_clean
	add	esp, 4

; 1393 :                 delete outPics[i].picOut;

	mov	ecx, DWORD PTR _i$65[ebp]
	mov	edx, DWORD PTR _outPics$[ebp+ecx*8]
	mov	DWORD PTR $T27[ebp], edx
	mov	eax, DWORD PTR $T27[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1394 :             }

	jmp	SHORT $LN2@MainCaptur
$LN1@MainCaptur:

; 1395 :     }
; 1396 : 
; 1397 :     Free(h420Threads);

	mov	ecx, DWORD PTR _h420Threads$[ebp]
	push	ecx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4

; 1398 :     Free(convertInfo);

	mov	edx, DWORD PTR _convertInfo$[ebp]
	push	edx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4

; 1399 : 
; 1400 :     Log(TEXT("Total frames rendered: %d, number of late frames: %d (%0.2f%%) (it's okay for some frames to be late)"), numTotalFrames, numLongFrames, (numTotalFrames > 0) ? (double(numLongFrames)/double(numTotalFrames))*100.0 : 0.0f);

	cmp	DWORD PTR _numTotalFrames$[ebp], 0
	jle	SHORT $LN198@MainCaptur
	cvtsi2sd xmm0, DWORD PTR _numLongFrames$[ebp]
	cvtsi2sd xmm1, DWORD PTR _numTotalFrames$[ebp]
	divsd	xmm0, xmm1
	mulsd	xmm0, QWORD PTR __real@4059000000000000
	movsd	QWORD PTR tv1760[ebp], xmm0
	jmp	SHORT $LN199@MainCaptur
$LN198@MainCaptur:
	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR tv1760[ebp], xmm0
$LN199@MainCaptur:
	sub	esp, 8
	movsd	xmm0, QWORD PTR tv1760[ebp]
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _numLongFrames$[ebp]
	push	eax
	mov	ecx, DWORD PTR _numTotalFrames$[ebp]
	push	ecx
	push	OFFSET $SG4294781441
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 20					; 00000014H

; 1401 : }

	lea	ecx, DWORD PTR _completeEvents$[ebp]
	call	??1?$List@PAX@@QAE@XZ			; List<void *>::~List<void *>
$LN162@MainCaptur:
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN207@MainCaptur:
	DD	$LN87@MainCaptur
	DD	$LN84@MainCaptur
	DD	$LN82@MainCaptur
	DD	$LN82@MainCaptur
	DD	$LN82@MainCaptur
	DD	$LN82@MainCaptur
	DD	$LN82@MainCaptur
	DD	$LN83@MainCaptur
	DD	$LN86@MainCaptur
	DD	$LN85@MainCaptur
$LN208@MainCaptur:
	DD	$LN41@MainCaptur
	DD	$LN43@MainCaptur
	DD	$LN44@MainCaptur
	DD	$LN42@MainCaptur
	DD	$LN40@MainCaptur
$LN203@MainCaptur:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	1
	DB	2
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
?MainCaptureLoop@OBS@@AAEXXZ ENDP			; OBS::MainCaptureLoop
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??0?$List@UVideoPacketData@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$List@UVideoPacketData@@@@QAE@XZ PROC		; List<VideoPacketData>::List<VideoPacketData>, COMDAT
; _this$ = ecx

; 35   :     inline List() : array(NULL), num(0) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@UVideoPacketData@@@@QAE@XZ ENDP		; List<VideoPacketData>::List<VideoPacketData>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??1?$List@UVideoPacketData@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$List@UVideoPacketData@@@@QAE@XZ PROC		; List<VideoPacketData>::~List<VideoPacketData>, COMDAT
; _this$ = ecx

; 37   :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 38   :         Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@UVideoPacketData@@@@QAEXXZ ; List<VideoPacketData>::Clear

; 39   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@UVideoPacketData@@@@QAE@XZ ENDP		; List<VideoPacketData>::~List<VideoPacketData>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Num@?$List@UVideoPacketData@@@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Num@?$List@UVideoPacketData@@@@QBEIXZ PROC		; List<VideoPacketData>::Num, COMDAT
; _this$ = ecx

; 42   :     inline unsigned int Num() const     {return num;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?Num@?$List@UVideoPacketData@@@@QBEIXZ ENDP		; List<VideoPacketData>::Num
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?SetSize@?$List@UVideoPacketData@@@@QAEHI@Z
_TEXT	SEGMENT
_bClear$ = -16						; size = 4
_oldNum$ = -12						; size = 4
tv70 = -8						; size = 4
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?SetSize@?$List@UVideoPacketData@@@@QAEHI@Z PROC	; List<VideoPacketData>::SetSize, COMDAT
; _this$ = ecx

; 205  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 206  :         if(num == n)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _n$[ebp]
	jne	SHORT $LN4@SetSize

; 207  :             return FALSE;

	xor	eax, eax
	jmp	$LN5@SetSize
	jmp	SHORT $LN3@SetSize
$LN4@SetSize:

; 208  :         else if(!n)

	cmp	DWORD PTR _n$[ebp], 0
	jne	SHORT $LN3@SetSize

; 209  :         {
; 210  :             Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@UVideoPacketData@@@@QAEXXZ ; List<VideoPacketData>::Clear

; 211  :             return TRUE;

	mov	eax, 1
	jmp	$LN5@SetSize
$LN3@SetSize:

; 212  :         }
; 213  : 
; 214  :         BOOL bClear=(n>num);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jbe	SHORT $LN7@SetSize
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN8@SetSize
$LN7@SetSize:
	mov	DWORD PTR tv70[ebp], 0
$LN8@SetSize:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _bClear$[ebp], ecx

; 215  :         UINT oldNum=num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _oldNum$[ebp], eax

; 216  : 
; 217  :         num = n;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 218  :         array = (T*)ReAllocate(array, sizeof(T)*num);

	mov	eax, DWORD PTR _this$[ebp]
	imul	ecx, DWORD PTR [eax+4], 12
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 219  : 
; 220  :         if(bClear)

	cmp	DWORD PTR _bClear$[ebp], 0
	je	SHORT $LN1@SetSize

; 221  :             zero(&array[oldNum], sizeof(T)*(num-oldNum));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, DWORD PTR _oldNum$[ebp]
	imul	ecx, eax, 12
	push	ecx
	imul	edx, DWORD PTR _oldNum$[ebp], 12
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax]
	push	edx
	call	?zero@@YGXPAXI@Z			; zero
$LN1@SetSize:

; 222  : 
; 223  :         return TRUE;

	mov	eax, 1
$LN5@SetSize:

; 224  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetSize@?$List@UVideoPacketData@@@@QAEHI@Z ENDP	; List<VideoPacketData>::SetSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?TransferFrom@?$List@UVideoPacketData@@@@QAEXAAV1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_list$ = 8						; size = 4
?TransferFrom@?$List@UVideoPacketData@@@@QAEXAAV1@@Z PROC ; List<VideoPacketData>::TransferFrom, COMDAT
; _this$ = ecx

; 307  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 308  :         if(array) Clear();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@TransferFr
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@UVideoPacketData@@@@QAEXXZ ; List<VideoPacketData>::Clear
$LN1@TransferFr:

; 309  :         array = list.Array();

	mov	ecx, DWORD PTR _list$[ebp]
	call	?Array@?$List@UVideoPacketData@@@@QBEPAUVideoPacketData@@XZ ; List<VideoPacketData>::Array
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 310  :         num   = list.Num();

	mov	ecx, DWORD PTR _list$[ebp]
	call	?Num@?$List@UVideoPacketData@@@@QBEIXZ	; List<VideoPacketData>::Num
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax

; 311  :         zero(&list, sizeof(List<T>));

	push	8
	mov	eax, DWORD PTR _list$[ebp]
	push	eax
	call	?zero@@YGXPAXI@Z			; zero

; 312  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?TransferFrom@?$List@UVideoPacketData@@@@QAEXAAV1@@Z ENDP ; List<VideoPacketData>::TransferFrom
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Clear@?$List@UVideoPacketData@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@?$List@UVideoPacketData@@@@QAEXXZ PROC		; List<VideoPacketData>::Clear, COMDAT
; _this$ = ecx

; 334  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 335  :         if(array)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Clear

; 336  :         {
; 337  :             /*if(IsBadWritePtr(array, sizeof(T)*num))
; 338  :                 CrashError(TEXT("what the.."));*/
; 339  :             Free(array);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4

; 340  :             array = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 341  :             num = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$LN2@Clear:

; 342  :         }
; 343  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$List@UVideoPacketData@@@@QAEXXZ ENDP		; List<VideoPacketData>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??A?$List@UVideoPacketData@@@@QAEAAUVideoPacketData@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$List@UVideoPacketData@@@@QAEAAUVideoPacketData@@I@Z PROC ; List<VideoPacketData>::operator[], COMDAT
; _this$ = ecx

; 379  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  :         assert(index < num);
; 381  :         if(index >= num) {DumpError(TEXT("Out of range!  List<%S>::operator[](%d)"), typeid(T).name(), index); return array[0];}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN1@operator
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	push	OFFSET ?__type_info_root_node@@3U__type_info_node@@A ; __type_info_root_node
	mov	ecx, OFFSET ??_R0?AUVideoPacketData@@@8
	call	?name@type_info@@QBEPBDPAU__type_info_node@@@Z ; type_info::name
	push	eax
	push	OFFSET ??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp_?DumpError@@YAXPB_WZZ
	mov	eax, 12					; 0000000cH
	imul	eax, eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN3@operator
$LN1@operator:

; 382  :         return array[index];

	imul	eax, DWORD PTR _index$[ebp], 12
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx]
$LN3@operator:

; 383  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@UVideoPacketData@@@@QAEAAUVideoPacketData@@I@Z ENDP ; List<VideoPacketData>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??4?$function@$$A6AXXZ@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??4?$function@$$A6AXXZ@std@@QAEAAV01@ABV01@@Z PROC	; std::function<void __cdecl(void)>::operator=, COMDAT
; _this$ = ecx

; 633  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 634  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	SHORT $LN1@operator

; 635  : 			{	// clean up and copy
; 636  : 			this->_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Func_class@X$$$V@std@@IAEXXZ	; std::_Func_class<void>::_Tidy

; 637  : 			this->_Reset((const _Mybase&)_Right);

	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reset@?$_Func_class@X$$$V@std@@IAEXABV12@@Z ; std::_Func_class<void>::_Reset
$LN1@operator:

; 638  : 			}
; 639  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 640  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$function@$$A6AXXZ@std@@QAEAAV01@ABV01@@Z ENDP	; std::function<void __cdecl(void)>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Num@?$List@UVideoSegment@@@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Num@?$List@UVideoSegment@@@@QBEIXZ PROC		; List<VideoSegment>::Num, COMDAT
; _this$ = ecx

; 42   :     inline unsigned int Num() const     {return num;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?Num@?$List@UVideoSegment@@@@QBEIXZ ENDP		; List<VideoSegment>::Num
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Remove@?$List@UVideoSegment@@@@QAEXI@Z
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?Remove@?$List@UVideoSegment@@@@QAEXI@Z PROC		; List<VideoSegment>::Remove, COMDAT
; _this$ = ecx

; 88   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 89   :         assert(index < num);
; 90   :         if(index >= num) return;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN2@Remove
	jmp	$LN3@Remove
$LN2@Remove:

; 91   : 
; 92   :         if(!--num) {Free(array); array=NULL; return;}

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	mov	DWORD PTR tv68[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv68[ebp]
	mov	DWORD PTR [ecx+4], edx
	cmp	DWORD PTR tv68[ebp], 0
	jne	SHORT $LN1@Remove
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 0
	jmp	SHORT $LN3@Remove
$LN1@Remove:

; 93   : 
; 94   :         mcpy(&array[index], &array[index+1], sizeof(T)*(num-index));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR _index$[ebp]
	shl	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _index$[ebp]
	add	edx, 1
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _index$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 95   : 
; 96   :         array = (T*)ReAllocate(array, sizeof(T)*num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$LN3@Remove:

; 97   :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?Remove@?$List@UVideoSegment@@@@QAEXI@Z ENDP		; List<VideoSegment>::Remove
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?CreateNew@?$List@UVideoSegment@@@@QAEPAUVideoSegment@@XZ
_TEXT	SEGMENT
_value$ = -8						; size = 4
_this$ = -4						; size = 4
?CreateNew@?$List@UVideoSegment@@@@QAEPAUVideoSegment@@XZ PROC ; List<VideoSegment>::CreateNew, COMDAT
; _this$ = ecx

; 346  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 347  :         SetSize(num+1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSize@?$List@UVideoSegment@@@@QAEHI@Z ; List<VideoSegment>::SetSize

; 348  : 
; 349  :         T *value = &array[num-1];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR _value$[ebp], eax

; 350  : 
; 351  :         return value;

	mov	eax, DWORD PTR _value$[ebp]

; 352  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?CreateNew@?$List@UVideoSegment@@@@QAEPAUVideoSegment@@XZ ENDP ; List<VideoSegment>::CreateNew
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??A?$List@UVideoSegment@@@@QAEAAUVideoSegment@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$List@UVideoSegment@@@@QAEAAUVideoSegment@@I@Z PROC	; List<VideoSegment>::operator[], COMDAT
; _this$ = ecx

; 379  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  :         assert(index < num);
; 381  :         if(index >= num) {DumpError(TEXT("Out of range!  List<%S>::operator[](%d)"), typeid(T).name(), index); return array[0];}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN1@operator
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	push	OFFSET ?__type_info_root_node@@3U__type_info_node@@A ; __type_info_root_node
	mov	ecx, OFFSET ??_R0?AUVideoSegment@@@8
	call	?name@type_info@@QBEPBDPAU__type_info_node@@@Z ; type_info::name
	push	eax
	push	OFFSET ??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp_?DumpError@@YAXPB_WZZ
	mov	eax, 16					; 00000010H
	imul	eax, eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN3@operator
$LN1@operator:

; 382  :         return array[index];

	mov	eax, DWORD PTR _index$[ebp]
	shl	eax, 4
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx]
$LN3@operator:

; 383  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@UVideoSegment@@@@QAEAAUVideoSegment@@I@Z ENDP	; List<VideoSegment>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Last@?$List@UVideoSegment@@@@QBEAAUVideoSegment@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Last@?$List@UVideoSegment@@@@QBEAAUVideoSegment@@XZ PROC ; List<VideoSegment>::Last, COMDAT
; _this$ = ecx

; 446  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 447  :         assert(num > 0);
; 448  : 
; 449  :         return array[num-1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, 1
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]

; 450  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?Last@?$List@UVideoSegment@@@@QBEAAUVideoSegment@@XZ ENDP ; List<VideoSegment>::Last
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Clear@?$CircularList@I@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@?$CircularList@I@@QAEXXZ PROC			; CircularList<unsigned int>::Clear, COMDAT
; _this$ = ecx

; 913  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  :         storedNum = startID = endID = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0

; 915  :         List::Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@I@@QAEXXZ			; List<unsigned int>::Clear

; 916  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$CircularList@I@@QAEXXZ ENDP			; CircularList<unsigned int>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Remove@?$List@UFrameAudio@@@@QAEXI@Z
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?Remove@?$List@UFrameAudio@@@@QAEXI@Z PROC		; List<FrameAudio>::Remove, COMDAT
; _this$ = ecx

; 88   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 89   :         assert(index < num);
; 90   :         if(index >= num) return;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN2@Remove
	jmp	$LN3@Remove
$LN2@Remove:

; 91   : 
; 92   :         if(!--num) {Free(array); array=NULL; return;}

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	mov	DWORD PTR tv68[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv68[ebp]
	mov	DWORD PTR [ecx+4], edx
	cmp	DWORD PTR tv68[ebp], 0
	jne	SHORT $LN1@Remove
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 0
	jmp	SHORT $LN3@Remove
$LN1@Remove:

; 93   : 
; 94   :         mcpy(&array[index], &array[index+1], sizeof(T)*(num-index));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR _index$[ebp]
	shl	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _index$[ebp]
	add	edx, 1
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _index$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 95   : 
; 96   :         array = (T*)ReAllocate(array, sizeof(T)*num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$LN3@Remove:

; 97   :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?Remove@?$List@UFrameAudio@@@@QAEXI@Z ENDP		; List<FrameAudio>::Remove
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??0?$List@UDataPacket@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$List@UDataPacket@@@@QAE@XZ PROC			; List<DataPacket>::List<DataPacket>, COMDAT
; _this$ = ecx

; 35   :     inline List() : array(NULL), num(0) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@UDataPacket@@@@QAE@XZ ENDP			; List<DataPacket>::List<DataPacket>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??1?$List@UDataPacket@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$List@UDataPacket@@@@QAE@XZ PROC			; List<DataPacket>::~List<DataPacket>, COMDAT
; _this$ = ecx

; 37   :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 38   :         Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@UDataPacket@@@@QAEXXZ	; List<DataPacket>::Clear

; 39   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@UDataPacket@@@@QAE@XZ ENDP			; List<DataPacket>::~List<DataPacket>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??A?$List@UDataPacket@@@@QBEAAUDataPacket@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$List@UDataPacket@@@@QBEAAUDataPacket@@I@Z PROC	; List<DataPacket>::operator[], COMDAT
; _this$ = ecx

; 386  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 387  :         assert(index < num);
; 388  :         if (index >= num) { DumpError(TEXT("Out of range!  List<%S>::operator[](%d)"), typeid(T).name(), index); return array[0]; }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN1@operator
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	push	OFFSET ?__type_info_root_node@@3U__type_info_node@@A ; __type_info_root_node
	mov	ecx, OFFSET ??_R0?AUDataPacket@@@8
	call	?name@type_info@@QBEPBDPAU__type_info_node@@@Z ; type_info::name
	push	eax
	push	OFFSET ??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp_?DumpError@@YAXPB_WZZ
	mov	eax, 8
	imul	eax, eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN3@operator
$LN1@operator:

; 389  :         return array[index];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _index$[ebp]
	lea	eax, DWORD PTR [eax+ecx*8]
$LN3@operator:

; 390  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@UDataPacket@@@@QBEAAUDataPacket@@I@Z ENDP	; List<DataPacket>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??0?$List@W4PacketType@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$List@W4PacketType@@@@QAE@XZ PROC			; List<enum PacketType>::List<enum PacketType>, COMDAT
; _this$ = ecx

; 35   :     inline List() : array(NULL), num(0) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@W4PacketType@@@@QAE@XZ ENDP			; List<enum PacketType>::List<enum PacketType>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??1?$List@W4PacketType@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$List@W4PacketType@@@@QAE@XZ PROC			; List<enum PacketType>::~List<enum PacketType>, COMDAT
; _this$ = ecx

; 37   :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 38   :         Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@W4PacketType@@@@QAEXXZ	; List<enum PacketType>::Clear

; 39   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@W4PacketType@@@@QAE@XZ ENDP			; List<enum PacketType>::~List<enum PacketType>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??A?$List@W4PacketType@@@@QBEAAW4PacketType@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$List@W4PacketType@@@@QBEAAW4PacketType@@I@Z PROC	; List<enum PacketType>::operator[], COMDAT
; _this$ = ecx

; 386  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 387  :         assert(index < num);
; 388  :         if (index >= num) { DumpError(TEXT("Out of range!  List<%S>::operator[](%d)"), typeid(T).name(), index); return array[0]; }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN1@operator
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	push	OFFSET ?__type_info_root_node@@3U__type_info_node@@A ; __type_info_root_node
	mov	ecx, OFFSET ??_R0?AW4PacketType@@@8
	call	?name@type_info@@QBEPBDPAU__type_info_node@@@Z ; type_info::name
	push	eax
	push	OFFSET ??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp_?DumpError@@YAXPB_WZZ
	mov	eax, 4
	imul	eax, eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN3@operator
$LN1@operator:

; 389  :         return array[index];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _index$[ebp]
	lea	eax, DWORD PTR [eax+ecx*4]
$LN3@operator:

; 390  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@W4PacketType@@@@QBEAAW4PacketType@@I@Z ENDP	; List<enum PacketType>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??0?$List@PAX@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$List@PAX@@QAE@XZ PROC				; List<void *>::List<void *>, COMDAT
; _this$ = ecx

; 35   :     inline List() : array(NULL), num(0) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@PAX@@QAE@XZ ENDP				; List<void *>::List<void *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??1?$List@PAX@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$List@PAX@@QAE@XZ PROC				; List<void *>::~List<void *>, COMDAT
; _this$ = ecx

; 37   :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 38   :         Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@PAX@@QAEXXZ		; List<void *>::Clear

; 39   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@PAX@@QAE@XZ ENDP				; List<void *>::~List<void *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Array@?$List@PAX@@QBEPAPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Array@?$List@PAX@@QBEPAPAXXZ PROC			; List<void *>::Array, COMDAT
; _this$ = ecx

; 41   :     inline T* Array() const             {return array;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	esp, ebp
	pop	ebp
	ret	0
?Array@?$List@PAX@@QBEPAPAXXZ ENDP			; List<void *>::Array
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Num@?$List@PAX@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Num@?$List@PAX@@QBEIXZ PROC				; List<void *>::Num, COMDAT
; _this$ = ecx

; 42   :     inline unsigned int Num() const     {return num;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?Num@?$List@PAX@@QBEIXZ ENDP				; List<void *>::Num
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??6?$List@PAX@@QAEAAV0@ABQAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_val$ = 8						; size = 4
??6?$List@PAX@@QAEAAV0@ABQAX@Z PROC			; List<void *>::operator<<, COMDAT
; _this$ = ecx

; 366  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 367  :         Add(val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Add@?$List@PAX@@QAEIABQAX@Z		; List<void *>::Add

; 368  :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 369  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??6?$List@PAX@@QAEAAV0@ABQAX@Z ENDP			; List<void *>::operator<<
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Array@?$List@UVideoPacketData@@@@QBEPAUVideoPacketData@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Array@?$List@UVideoPacketData@@@@QBEPAUVideoPacketData@@XZ PROC ; List<VideoPacketData>::Array, COMDAT
; _this$ = ecx

; 41   :     inline T* Array() const             {return array;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	esp, ebp
	pop	ebp
	ret	0
?Array@?$List@UVideoPacketData@@@@QBEPAUVideoPacketData@@XZ ENDP ; List<VideoPacketData>::Array
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ?_Reset@?$_Func_class@X$$$V@std@@IAEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Reset@?$_Func_class@X$$$V@std@@IAEXABV12@@Z PROC	; std::_Func_class<void>::_Reset, COMDAT
; _this$ = ecx

; 335  : 		{	// copy _Right's stored object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 336  : 		if (_Right._Impl == 0)

	mov	eax, DWORD PTR __Right$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN4@Reset

; 337  : 			_Set(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set@?$_Func_class@X$$$V@std@@AAEXPAV?$_Func_base@X$$$V@2@@Z ; std::_Func_class<void>::_Set
	jmp	SHORT $LN5@Reset
$LN4@Reset:

; 338  : 		else if (_Right._Local())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Local@?$_Func_class@X$$$V@std@@ABE_NXZ ; std::_Func_class<void>::_Local
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Reset

; 339  : 			_Set(_Right._Impl->_Copy((void *)&_Space));

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+16]
	mov	edx, DWORD PTR [eax]
	call	edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set@?$_Func_class@X$$$V@std@@AAEXPAV?$_Func_base@X$$$V@2@@Z ; std::_Func_class<void>::_Set

; 340  : 		else

	jmp	SHORT $LN5@Reset
$LN2@Reset:

; 341  : 			_Set(_Right._Impl->_Copy(0));

	push	0
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+16]
	mov	edx, DWORD PTR [eax]
	call	edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set@?$_Func_class@X$$$V@std@@AAEXPAV?$_Func_base@X$$$V@2@@Z ; std::_Func_class<void>::_Set
$LN5@Reset:

; 342  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Reset@?$_Func_class@X$$$V@std@@IAEXABV12@@Z ENDP	; std::_Func_class<void>::_Reset
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?SetSize@?$List@UVideoSegment@@@@QAEHI@Z
_TEXT	SEGMENT
_bClear$ = -16						; size = 4
_oldNum$ = -12						; size = 4
tv70 = -8						; size = 4
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?SetSize@?$List@UVideoSegment@@@@QAEHI@Z PROC		; List<VideoSegment>::SetSize, COMDAT
; _this$ = ecx

; 205  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 206  :         if(num == n)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _n$[ebp]
	jne	SHORT $LN4@SetSize

; 207  :             return FALSE;

	xor	eax, eax
	jmp	$LN5@SetSize
	jmp	SHORT $LN3@SetSize
$LN4@SetSize:

; 208  :         else if(!n)

	cmp	DWORD PTR _n$[ebp], 0
	jne	SHORT $LN3@SetSize

; 209  :         {
; 210  :             Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@UVideoSegment@@@@QAEXXZ	; List<VideoSegment>::Clear

; 211  :             return TRUE;

	mov	eax, 1
	jmp	$LN5@SetSize
$LN3@SetSize:

; 212  :         }
; 213  : 
; 214  :         BOOL bClear=(n>num);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jbe	SHORT $LN7@SetSize
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN8@SetSize
$LN7@SetSize:
	mov	DWORD PTR tv70[ebp], 0
$LN8@SetSize:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _bClear$[ebp], ecx

; 215  :         UINT oldNum=num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _oldNum$[ebp], eax

; 216  : 
; 217  :         num = n;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 218  :         array = (T*)ReAllocate(array, sizeof(T)*num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 219  : 
; 220  :         if(bClear)

	cmp	DWORD PTR _bClear$[ebp], 0
	je	SHORT $LN1@SetSize

; 221  :             zero(&array[oldNum], sizeof(T)*(num-oldNum));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, DWORD PTR _oldNum$[ebp]
	shl	eax, 4
	push	eax
	mov	ecx, DWORD PTR _oldNum$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	push	ecx
	call	?zero@@YGXPAXI@Z			; zero
$LN1@SetSize:

; 222  : 
; 223  :         return TRUE;

	mov	eax, 1
$LN5@SetSize:

; 224  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetSize@?$List@UVideoSegment@@@@QAEHI@Z ENDP		; List<VideoSegment>::SetSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Clear@?$List@W4PacketType@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@?$List@W4PacketType@@@@QAEXXZ PROC		; List<enum PacketType>::Clear, COMDAT
; _this$ = ecx

; 334  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 335  :         if(array)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Clear

; 336  :         {
; 337  :             /*if(IsBadWritePtr(array, sizeof(T)*num))
; 338  :                 CrashError(TEXT("what the.."));*/
; 339  :             Free(array);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4

; 340  :             array = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 341  :             num = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$LN2@Clear:

; 342  :         }
; 343  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$List@W4PacketType@@@@QAEXXZ ENDP		; List<enum PacketType>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Add@?$List@PAX@@QAEIABQAX@Z
_TEXT	SEGMENT
tv73 = -8						; size = 4
_this$ = -4						; size = 4
_val$ = 8						; size = 4
?Add@?$List@PAX@@QAEIABQAX@Z PROC			; List<void *>::Add, COMDAT
; _this$ = ecx

; 45   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 46   :         array = (T*)ReAllocate(array, sizeof(T)*++num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	DWORD PTR tv73[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR tv73[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 47   :         mcpy(&array[(num-1)], (void*)&val, sizeof(T));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [edx+eax*4-4], ecx

; 48   :         return num-1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1

; 49   :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?Add@?$List@PAX@@QAEIABQAX@Z ENDP			; List<void *>::Add
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Clear@?$List@PAX@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@?$List@PAX@@QAEXXZ PROC				; List<void *>::Clear, COMDAT
; _this$ = ecx

; 334  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 335  :         if(array)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Clear

; 336  :         {
; 337  :             /*if(IsBadWritePtr(array, sizeof(T)*num))
; 338  :                 CrashError(TEXT("what the.."));*/
; 339  :             Free(array);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4

; 340  :             array = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 341  :             num = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$LN2@Clear:

; 342  :         }
; 343  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$List@PAX@@QAEXXZ ENDP				; List<void *>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ??$make_shared@$$CBV?$vector@EV?$allocator@E@std@@@std@@PAEPAE@std@@YA?AV?$shared_ptr@$$CBV?$vector@EV?$allocator@E@std@@@std@@@0@$$QAPAE0@Z
_TEXT	SEGMENT
__Ret$ = -20						; size = 8
__Rx$ = -12						; size = 4
tv75 = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_<_Args_0>$ = 12					; size = 4
_<_Args_1>$ = 16					; size = 4
??$make_shared@$$CBV?$vector@EV?$allocator@E@std@@@std@@PAEPAE@std@@YA?AV?$shared_ptr@$$CBV?$vector@EV?$allocator@E@std@@@std@@@0@$$QAPAE0@Z PROC ; std::make_shared<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned char *,unsigned char *>, COMDAT

; 1001 : 	{	// make a shared_ptr

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 1002 : 	_Ref_count_obj<_Ty> *_Rx =
; 1003 : 		new _Ref_count_obj<_Ty>(_STD forward<_Types>(_Args)...);

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN3@make_share
	mov	eax, DWORD PTR _<_Args_1>$[ebp]
	push	eax
	call	??$forward@PAE@std@@YA$$QAPAEAAPAE@Z	; std::forward<unsigned char *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@PAE@std@@YA$$QAPAEAAPAE@Z	; std::forward<unsigned char *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR $T1[ebp]
	call	??$?0PAEPAE@?$_Ref_count_obj@$$CBV?$vector@EV?$allocator@E@std@@@std@@@std@@QAE@$$QAPAE0@Z ; std::_Ref_count_obj<std::vector<unsigned char,std::allocator<unsigned char> > const >::_Ref_count_obj<std::vector<unsigned char,std::allocator<unsigned char> > const ><unsigned char *,unsigned char *>
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN4@make_share
$LN3@make_share:
	mov	DWORD PTR tv75[ebp], 0
$LN4@make_share:
	mov	edx, DWORD PTR tv75[ebp]
	mov	DWORD PTR __Rx$[ebp], edx

; 1004 : 
; 1005 : 	shared_ptr<_Ty> _Ret;

	lea	ecx, DWORD PTR __Ret$[ebp]
	call	??0?$shared_ptr@$$CBV?$vector@EV?$allocator@E@std@@@std@@@std@@QAE@XZ ; std::shared_ptr<std::vector<unsigned char,std::allocator<unsigned char> > const >::shared_ptr<std::vector<unsigned char,std::allocator<unsigned char> > const >

; 1006 : 	_Ret._Resetp0(_Rx->_Getptr(), _Rx);

	mov	eax, DWORD PTR __Rx$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Rx$[ebp]
	call	?_Getptr@?$_Ref_count_obj@$$CBV?$vector@EV?$allocator@E@std@@@std@@@std@@QBEPBV?$vector@EV?$allocator@E@std@@@2@XZ ; std::_Ref_count_obj<std::vector<unsigned char,std::allocator<unsigned char> > const >::_Getptr
	push	eax
	lea	ecx, DWORD PTR __Ret$[ebp]
	call	??$_Resetp0@$$CBV?$vector@EV?$allocator@E@std@@@std@@@?$shared_ptr@$$CBV?$vector@EV?$allocator@E@std@@@std@@@std@@QAEXPBV?$vector@EV?$allocator@E@std@@@1@PAV_Ref_count_base@1@@Z ; std::shared_ptr<std::vector<unsigned char,std::allocator<unsigned char> > const >::_Resetp0<std::vector<unsigned char,std::allocator<unsigned char> > const >

; 1007 : 	return (_Ret);

	lea	ecx, DWORD PTR __Ret$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$shared_ptr@$$CBV?$vector@EV?$allocator@E@std@@@std@@@std@@QAE@$$QAV01@@Z ; std::shared_ptr<std::vector<unsigned char,std::allocator<unsigned char> > const >::shared_ptr<std::vector<unsigned char,std::allocator<unsigned char> > const >
	lea	ecx, DWORD PTR __Ret$[ebp]
	call	??1?$shared_ptr@$$CBV?$vector@EV?$allocator@E@std@@@std@@@std@@QAE@XZ ; std::shared_ptr<std::vector<unsigned char,std::allocator<unsigned char> > const >::~shared_ptr<std::vector<unsigned char,std::allocator<unsigned char> > const >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1008 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$make_shared@$$CBV?$vector@EV?$allocator@E@std@@@std@@PAEPAE@std@@YA?AV?$shared_ptr@$$CBV?$vector@EV?$allocator@E@std@@@std@@@0@$$QAPAE0@Z ENDP ; std::make_shared<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned char *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$forward@PAE@std@@YA$$QAPAEAAPAE@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@PAE@std@@YA$$QAPAEAAPAE@Z PROC		; std::forward<unsigned char *>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@PAE@std@@YA$$QAPAEAAPAE@Z ENDP		; std::forward<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ??$?0PAEPAE@?$_Ref_count_obj@$$CBV?$vector@EV?$allocator@E@std@@@std@@@std@@QAE@$$QAPAE0@Z
_TEXT	SEGMENT
tv93 = -12						; size = 4
$T1 = -8						; size = 4
_this$ = -4						; size = 4
_<_Args_0>$ = 8						; size = 4
_<_Args_1>$ = 12					; size = 4
??$?0PAEPAE@?$_Ref_count_obj@$$CBV?$vector@EV?$allocator@E@std@@@std@@@std@@QAE@$$QAPAE0@Z PROC ; std::_Ref_count_obj<std::vector<unsigned char,std::allocator<unsigned char> > const >::_Ref_count_obj<std::vector<unsigned char,std::allocator<unsigned char> > const ><unsigned char *,unsigned char *>, COMDAT
; _this$ = ecx

; 931  : 		{	// construct from argument list

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Ref_count_base@std@@IAE@XZ		; std::_Ref_count_base::_Ref_count_base
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$_Ref_count_obj@$$CBV?$vector@EV?$allocator@E@std@@@std@@@std@@6B@

; 932  : 		::new ((void *)&_Storage) _Ty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	push	12					; 0000000cH
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN3@allocator
	mov	edx, DWORD PTR _<_Args_1>$[ebp]
	push	edx
	call	??$forward@PAE@std@@YA$$QAPAEAAPAE@Z	; std::forward<unsigned char *>
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@PAE@std@@YA$$QAPAEAAPAE@Z	; std::forward<unsigned char *>
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR $T1[ebp]
	call	??$?0PAEX@?$vector@EV?$allocator@E@std@@@std@@QAE@PAE0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> ><unsigned char *,void>
	mov	DWORD PTR tv93[ebp], eax
	jmp	SHORT $LN1@allocator
$LN3@allocator:
	mov	DWORD PTR tv93[ebp], 0
$LN1@allocator:

; 933  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??$?0PAEPAE@?$_Ref_count_obj@$$CBV?$vector@EV?$allocator@E@std@@@std@@@std@@QAE@$$QAPAE0@Z ENDP ; std::_Ref_count_obj<std::vector<unsigned char,std::allocator<unsigned char> > const >::_Ref_count_obj<std::vector<unsigned char,std::allocator<unsigned char> > const ><unsigned char *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ??$?0PAEX@?$vector@EV?$allocator@E@std@@@std@@QAE@PAE0@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$?0PAEX@?$vector@EV?$allocator@E@std@@@std@@QAE@PAE0@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> ><unsigned char *,void>, COMDAT
; _this$ = ecx

; 750  : 		{	// construct from [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@E@std@@QAE@XZ		; std::allocator<unsigned char>::allocator<unsigned char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@ABV?$allocator@E@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Vector_alloc<0,std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >

; 751  : 		_Construct(_First, _Last);

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Construct@PAE@?$vector@EV?$allocator@E@std@@@std@@QAEXPAE0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Construct<unsigned char *>

; 752  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??$?0PAEX@?$vector@EV?$allocator@E@std@@@std@@QAE@PAE0@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> ><unsigned char *,void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ??$_Construct@PAE@?$vector@EV?$allocator@E@std@@@std@@QAEXPAE0@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -2						; size = 1
$T2 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Construct@PAE@?$vector@EV?$allocator@E@std@@@std@@QAEXPAE0@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Construct<unsigned char *>, COMDAT
; _this$ = ecx

; 764  : 		void _Construct(_Iter _First, _Iter _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 765  : 		{	// initialize with [_First, _Last)
; 766  : 		_Construct(_First, _Last, _Iter_cat(_First));

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??$_Iter_cat@PAE@std@@YA?AUrandom_access_iterator_tag@0@ABQAE@Z ; std::_Iter_cat<unsigned char *>
	add	esp, 8
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR $T2[ebp], dl
	movzx	eax, BYTE PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Construct@PAE@?$vector@EV?$allocator@E@std@@@std@@QAEXPAE0Uforward_iterator_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Construct<unsigned char *>

; 767  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$_Construct@PAE@?$vector@EV?$allocator@E@std@@@std@@QAEXPAE0@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Construct<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ??$_Construct@PAE@?$vector@EV?$allocator@E@std@@@std@@QAEXPAE0Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Construct@PAE@?$vector@EV?$allocator@E@std@@@std@@QAEXPAE0Uforward_iterator_tag@1@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Construct<unsigned char *>, COMDAT
; _this$ = ecx

; 784  : 		void _Construct(_Iter _First, _Iter _Last, forward_iterator_tag)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Construct@PAE@?$vector@EV?$allocator@E@std@@@std@@QAEXPAE0Uforward_iterator_tag@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 785  : 		{	// initialize with [_First, _Last), forward iterators
; 786  : 		if (_Buy(_STD distance(_First, _Last)))

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$distance@PAE@std@@YAHPAE0@Z		; std::distance<unsigned char *>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@EV?$allocator@E@std@@@std@@IAE_NI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN4@Construct

; 787  : 			{	// nonzero, fill it
; 788  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 789  : 			this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAE@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAE00@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Ucopy<unsigned char *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN5@Construct
__catch$??$_Construct@PAE@?$vector@EV?$allocator@E@std@@@std@@QAEXPAE0Uforward_iterator_tag@1@@Z$0:

; 790  : 			_CATCH_ALL
; 791  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy

; 792  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 793  : 			_CATCH_END

	mov	eax, $LN8@Construct
	ret	0
$LN5@Construct:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN4@Construct
$LN8@Construct:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN4@Construct:

; 794  : 			}
; 795  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Construct@PAE@?$vector@EV?$allocator@E@std@@@std@@QAEXPAE0Uforward_iterator_tag@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Construct@PAE@?$vector@EV?$allocator@E@std@@@std@@QAEXPAE0Uforward_iterator_tag@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct@PAE@?$vector@EV?$allocator@E@std@@@std@@QAEXPAE0Uforward_iterator_tag@1@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Construct<unsigned char *>
END

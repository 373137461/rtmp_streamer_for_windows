; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

	TITLE	F:\songmm_moon_stone_obs\OBS\Source\BitmapImage.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_R0M@8					; float `RTTI Type Descriptor'
EXTRN	__imp_?GS@@3PAVGraphicsSystem@@A:DWORD
EXTRN	__imp_??0Vect2@@QAE@XZ:PROC
EXTRN	__imp_?Set@Vect2@@QAEAAU1@MM@Z:PROC
EXTRN	__imp_??1XFile@@QAE@XZ:PROC
EXTRN	__imp_?GetPathExtension@@YA?AVString@@PB_W@Z:PROC
EXTRN	__imp_??0XFile@@QAE@XZ:PROC
EXTRN	__imp_?Open@XFile@@QAEHPB_WKK@Z:PROC
EXTRN	__imp_?Read@XFile@@QAEKPAXK@Z:PROC
EXTRN	__imp_?GetFileSize@XFile@@QBE_KXZ:PROC
EXTRN	__imp_?OSMonitorFileStart@@YGPAUOSFileChangeData@@VString@@_N@Z:PROC
EXTRN	__imp_?OSFileHasChanged@@YGHPAUOSFileChangeData@@@Z:PROC
EXTRN	__imp_?OSMonitorFileDestroy@@YGXPAUOSFileChangeData@@@Z:PROC
;	COMDAT ??_R0M@8
data$r	SEGMENT
??_R0M@8 DD	FLAT:??_7type_info@@6B@			; float `RTTI Type Descriptor'
	DD	00H
	DB	'.M', 00H
$SG4294955033 DB 'B', 00H, 'i', 00H, 't', 00H, 'm', 00H, 'a', 00H, 'p', 00H
	DB	'I', 00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, ':', 00H, ':'
	DB	00H, 'I', 00H, 'n', 00H, 'i', 00H, 't', 00H, ':', 00H, ' ', 00H
	DB	'E', 00H, 'm', 00H, 'p', 00H, 't', 00H, 'y', 00H, ' ', 00H, 'p'
	DB	00H, 'a', 00H, 't', 00H, 'h', 00H, 00H, 00H
$SG4294955032 DB 'g', 00H, 'i', 00H, 'f', 00H, 00H, 00H
	ORG $+2
$SG4294955031 DB 'B', 00H, 'i', 00H, 't', 00H, 'm', 00H, 'a', 00H, 'p', 00H
	DB	'I', 00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, ':', 00H, ':'
	DB	00H, 'I', 00H, 'n', 00H, 'i', 00H, 't', 00H, ':', 00H, ' ', 00H
	DB	'c', 00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, ' ', 00H, 'n'
	DB	00H, 'o', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, ' ', 00H, 'g', 00H, 'i', 00H, 'f', 00H, ' ', 00H, 'f'
	DB	00H, 'i', 00H, 'l', 00H, 'e', 00H, ' ', 00H, '''', 00H, '%', 00H
	DB	's', 00H, '''', 00H, 00H, 00H
$SG4294955030 DB 'B', 00H, 'i', 00H, 't', 00H, 'm', 00H, 'a', 00H, 'p', 00H
	DB	'I', 00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, ':', 00H, ' '
	DB	00H, 'W', 00H, 'a', 00H, 'r', 00H, 'n', 00H, 'i', 00H, 'n', 00H
	DB	'g', 00H, ',', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'u', 00H, 'l'
	DB	00H, 'd', 00H, 'n', 00H, '''', 00H, 't', 00H, ' ', 00H, 'i', 00H
	DB	'n', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'a', 00H, 'l', 00H, 'i'
	DB	00H, 's', 00H, 'e', 00H, ' ', 00H, 'g', 00H, 'i', 00H, 'f', 00H
	DB	' ', 00H, '%', 00H, 's', 00H, ',', 00H, ' ', 00H, 'i', 00H, 't'
	DB	00H, ' ', 00H, 'i', 00H, 's', 00H, ' ', 00H, 'l', 00H, 'i', 00H
	DB	'k', 00H, 'e', 00H, 'l', 00H, 'y', 00H, ' ', 00H, 'c', 00H, 'o'
	DB	00H, 'r', 00H, 'r', 00H, 'u', 00H, 'p', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG4294955029 DB 'B', 00H, 'i', 00H, 't', 00H, 'm', 00H, 'a', 00H, 'p', 00H
	DB	'I', 00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, ':', 00H, ' '
	DB	00H, 'W', 00H, 'a', 00H, 'r', 00H, 'n', 00H, 'i', 00H, 'n', 00H
	DB	'g', 00H, ',', 00H, ' ', 00H, 'b', 00H, 'a', 00H, 'd', 00H, ' '
	DB	00H, 't', 00H, 'e', 00H, 'x', 00H, 't', 00H, 'u', 00H, 'r', 00H
	DB	'e', 00H, ' ', 00H, 'd', 00H, 'i', 00H, 'm', 00H, 'e', 00H, 'n'
	DB	00H, 's', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 's', 00H, ' ', 00H
	DB	'%', 00H, 'd', 00H, ' ', 00H, 'x', 00H, ' ', 00H, '%', 00H, 'd'
	DB	00H, ' ', 00H, 'i', 00H, 'n', 00H, ' ', 00H, '%', 00H, 's', 00H
	DB	00H, 00H
	ORG $+2
$SG4294955028 DB 'B', 00H, 'i', 00H, 't', 00H, 'm', 00H, 'a', 00H, 'p', 00H
	DB	'I', 00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, ':', 00H, ' '
	DB	00H, 'W', 00H, 'a', 00H, 'r', 00H, 'n', 00H, 'i', 00H, 'n', 00H
	DB	'g', 00H, ',', 00H, ' ', 00H, 'g', 00H, 'i', 00H, 'f', 00H, ' '
	DB	00H, '%', 00H, 's', 00H, ' ', 00H, 'o', 00H, 'v', 00H, 'e', 00H
	DB	'r', 00H, 'f', 00H, 'l', 00H, 'o', 00H, 'w', 00H, 'e', 00H, 'd'
	DB	00H, ' ', 00H, 'm', 00H, 'a', 00H, 'x', 00H, 'i', 00H, 'm', 00H
	DB	'u', 00H, 'm', 00H, ' ', 00H, 'p', 00H, 'o', 00H, 'i', 00H, 'n'
	DB	00H, 't', 00H, 'e', 00H, 'r', 00H, ' ', 00H, 's', 00H, 'i', 00H
	DB	'z', 00H, 'e', 00H, ' ', 00H, 'a', 00H, 'n', 00H, 'd', 00H, ' '
	DB	00H, 'w', 00H, 'a', 00H, 's', 00H, ' ', 00H, 'n', 00H, 'o', 00H
	DB	't', 00H, ' ', 00H, 'l', 00H, 'o', 00H, 'a', 00H, 'd', 00H, 'e'
	DB	00H, 'd', 00H, ' ', 00H, '(', 00H, '%', 00H, 'l', 00H, 'l', 00H
	DB	'u', 00H, ' ', 00H, '>', 00H, ' ', 00H, '%', 00H, 'u', 00H, ')'
	DB	00H, 00H, 00H
$SG4294955027 DB 'B', 00H, 'i', 00H, 't', 00H, 'm', 00H, 'a', 00H, 'p', 00H
	DB	'I', 00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, ':', 00H, ' '
	DB	00H, 'W', 00H, 'a', 00H, 'r', 00H, 'n', 00H, 'i', 00H, 'n', 00H
	DB	'g', 00H, ',', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'u', 00H, 'l'
	DB	00H, 'd', 00H, 'n', 00H, '''', 00H, 't', 00H, ' ', 00H, 'd', 00H
	DB	'e', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, ' ', 00H, 'f'
	DB	00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H, ' ', 00H, '%', 00H
	DB	'd', 00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, '%', 00H, 's'
	DB	00H, 00H, 00H
$SG4294955026 DB 'B', 00H, 'i', 00H, 't', 00H, 'm', 00H, 'a', 00H, 'p', 00H
	DB	'I', 00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, ':', 00H, ':'
	DB	00H, 'I', 00H, 'n', 00H, 'i', 00H, 't', 00H, ':', 00H, ' ', 00H
	DB	'c', 00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, ' ', 00H, 'n'
	DB	00H, 'o', 00H, 't', 00H, ' ', 00H, 'c', 00H, 'r', 00H, 'e', 00H
	DB	'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, 't', 00H, 'e', 00H, 'x'
	DB	00H, 't', 00H, 'u', 00H, 'r', 00H, 'e', 00H, ' ', 00H, '''', 00H
	DB	'%', 00H, 's', 00H, '''', 00H, 00H, 00H
PUBLIC	?Add@?$List@M@@QAEIABM@Z			; List<float>::Add
PUBLIC	??A?$List@M@@QAEAAMI@Z				; List<float>::operator[]
PUBLIC	??6?$List@M@@QAEAAV0@ABM@Z			; List<float>::operator<<
PUBLIC	?Clear@?$List@M@@QAEXXZ				; List<float>::Clear
PUBLIC	?Num@?$List@M@@QBEIXZ				; List<float>::Num
PUBLIC	??1?$List@M@@QAE@XZ				; List<float>::~List<float>
PUBLIC	??0?$List@M@@QAE@XZ				; List<float>::List<float>
PUBLIC	?Tick@BitmapImage@@QAEXM@Z			; BitmapImage::Tick
PUBLIC	?GetTexture@BitmapImage@@QBEPAVTexture@@XZ	; BitmapImage::GetTexture
PUBLIC	?GetSize@BitmapImage@@QBE?AUVect2@@XZ		; BitmapImage::GetSize
PUBLIC	?Init@BitmapImage@@QAEXXZ			; BitmapImage::Init
PUBLIC	?EnableFileMonitor@BitmapImage@@QAEX_N@Z	; BitmapImage::EnableFileMonitor
PUBLIC	?SetPath@BitmapImage@@QAEXVString@@@Z		; BitmapImage::SetPath
PUBLIC	?CreateErrorTexture@BitmapImage@@AAEXXZ		; BitmapImage::CreateErrorTexture
PUBLIC	??1BitmapImage@@QAE@XZ				; BitmapImage::~BitmapImage
PUBLIC	??0BitmapImage@@QAE@XZ				; BitmapImage::BitmapImage
PUBLIC	?BI_def_bitmap_modified@@YAXPAX@Z		; BI_def_bitmap_modified
PUBLIC	?BI_def_bitmap_destroy@@YAXPAX@Z		; BI_def_bitmap_destroy
PUBLIC	?BI_def_bitmap_get_buffer@@YAPAEPAX@Z		; BI_def_bitmap_get_buffer
PUBLIC	?BI_def_bitmap_test_opaque@@YAHPAX@Z		; BI_def_bitmap_test_opaque
PUBLIC	?BI_def_bitmap_set_opaque@@YAXPAXH@Z		; BI_def_bitmap_set_opaque
PUBLIC	?BI_def_bitmap_create@@YAPAXHH@Z		; BI_def_bitmap_create
PUBLIC	?CreateTexture@@YAPAVTexture@@IIW4GSColorFormat@@PAXHH@Z ; CreateTexture
PUBLIC	?msetd@@YGXPAXKI@Z				; msetd
	ALIGN	4

__Tuple_alloc DB 01H DUP (?)
	ALIGN	4

_ignore	DB	01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
	ALIGN	4

_piecewise_construct DB 01H DUP (?)
_BSS	ENDS
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
_ignore$initializer$ DD FLAT:??__Eignore@std@@YAXXZ
__Tuple_alloc$initializer$ DD FLAT:??__E_Tuple_alloc@std@@YAXXZ
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\inline.h
;	COMDAT ?msetd@@YGXPAXKI@Z
_TEXT	SEGMENT
tv72 = -28						; size = 4
tv68 = -24						; size = 4
_pVal$ = -20						; size = 4
_destB$ = -16						; size = 4
_iLenMod4$ = -12					; size = 4
_iLenDiv4$ = -8						; size = 4
_destDW$ = -4						; size = 4
_pDest$ = 8						; size = 4
_val$ = 12						; size = 4
_iLen$ = 16						; size = 4
?msetd@@YGXPAXKI@Z PROC					; msetd, COMDAT

; 241  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 242  :     assert(pDest);
; 243  : 
; 244  :     register size_t iLenMod4 = iLen&3;

	mov	eax, DWORD PTR _iLen$[ebp]
	and	eax, 3
	mov	DWORD PTR _iLenMod4$[ebp], eax

; 245  :     register size_t iLenDiv4 = iLen>>2;

	mov	ecx, DWORD PTR _iLen$[ebp]
	shr	ecx, 2
	mov	DWORD PTR _iLenDiv4$[ebp], ecx

; 246  : 
; 247  :     register DWORD *destDW = (DWORD*)pDest;

	mov	edx, DWORD PTR _pDest$[ebp]
	mov	DWORD PTR _destDW$[ebp], edx
$LN4@msetd:

; 248  :     while(iLenDiv4--)

	mov	eax, DWORD PTR _iLenDiv4$[ebp]
	mov	DWORD PTR tv68[ebp], eax
	mov	ecx, DWORD PTR _iLenDiv4$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _iLenDiv4$[ebp], ecx
	cmp	DWORD PTR tv68[ebp], 0
	je	SHORT $LN3@msetd

; 249  :         *(destDW++) = val;

	mov	edx, DWORD PTR _destDW$[ebp]
	mov	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _destDW$[ebp]
	add	ecx, 4
	mov	DWORD PTR _destDW$[ebp], ecx
	jmp	SHORT $LN4@msetd
$LN3@msetd:

; 250  : 
; 251  :     register BYTE *destB = (BYTE*)destDW;

	mov	edx, DWORD PTR _destDW$[ebp]
	mov	DWORD PTR _destB$[ebp], edx

; 252  :     register BYTE *pVal = (BYTE*)&val;

	lea	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR _pVal$[ebp], eax
$LN2@msetd:

; 253  :     while(iLenMod4--)

	mov	ecx, DWORD PTR _iLenMod4$[ebp]
	mov	DWORD PTR tv72[ebp], ecx
	mov	edx, DWORD PTR _iLenMod4$[ebp]
	sub	edx, 1
	mov	DWORD PTR _iLenMod4$[ebp], edx
	cmp	DWORD PTR tv72[ebp], 0
	je	SHORT $LN5@msetd

; 254  :         *(destB++) = *(pVal++);

	mov	eax, DWORD PTR _destB$[ebp]
	mov	ecx, DWORD PTR _pVal$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _destB$[ebp]
	add	eax, 1
	mov	DWORD PTR _destB$[ebp], eax
	mov	ecx, DWORD PTR _pVal$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pVal$[ebp], ecx
	jmp	SHORT $LN2@msetd
$LN5@msetd:

; 255  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?msetd@@YGXPAXKI@Z ENDP					; msetd
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 70   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3451 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\tuple
;	COMDAT ??__Eignore@std@@YAXXZ
text$di	SEGMENT
??__Eignore@std@@YAXXZ PROC				; std::`dynamic initializer for 'ignore'', COMDAT

; 59   : const _Ignore ignore;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET _ignore
	call	??0_Ignore@std@@QAE@XZ			; std::_Ignore::_Ignore
	pop	ebp
	ret	0
??__Eignore@std@@YAXXZ ENDP				; std::`dynamic initializer for 'ignore''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\tuple
;	COMDAT ??__E_Tuple_alloc@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__E_Tuple_alloc@std@@YAXXZ PROC			; std::`dynamic initializer for '_Tuple_alloc'', COMDAT

; 66   : const _Tuple_alloc_t _Tuple_alloc = _Tuple_alloc_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__E_Tuple_alloc@std@@YAXXZ ENDP			; std::`dynamic initializer for '_Tuple_alloc''
text$di	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\graphicssystem.h
;	COMDAT ?CreateTexture@@YAPAVTexture@@IIW4GSColorFormat@@PAXHH@Z
_TEXT	SEGMENT
_width$ = 8						; size = 4
_height$ = 12						; size = 4
_colorFormat$ = 16					; size = 4
_lpData$ = 20						; size = 4
_bGenMipMaps$ = 24					; size = 4
_bStatic$ = 28						; size = 4
?CreateTexture@@YAPAVTexture@@IIW4GSColorFormat@@PAXHH@Z PROC ; CreateTexture, COMDAT

; 640  :     {return GS->CreateTexture(width, height, colorFormat, lpData, bGenMipMaps, bStatic);}

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _bStatic$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bGenMipMaps$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpData$[ebp]
	push	edx
	mov	eax, DWORD PTR _colorFormat$[ebp]
	push	eax
	mov	ecx, DWORD PTR _height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _width$[ebp]
	push	edx
	mov	eax, DWORD PTR __imp_?GS@@3PAVGraphicsSystem@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __imp_?GS@@3PAVGraphicsSystem@@A
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+24]
	call	edx
	pop	ebp
	ret	0
?CreateTexture@@YAPAVTexture@@IIW4GSColorFormat@@PAXHH@Z ENDP ; CreateTexture
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\bitmapimage.cpp
;	COMDAT ?BI_def_bitmap_create@@YAPAXHH@Z
_TEXT	SEGMENT
_width$ = 8						; size = 4
_height$ = 12						; size = 4
?BI_def_bitmap_create@@YAPAXHH@Z PROC			; BI_def_bitmap_create, COMDAT

; 3    : void *BI_def_bitmap_create(int width, int height)          {return Allocate(width * height * 4);}

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _width$[ebp]
	imul	eax, DWORD PTR _height$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	pop	ebp
	ret	0
?BI_def_bitmap_create@@YAPAXHH@Z ENDP			; BI_def_bitmap_create
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\bitmapimage.cpp
;	COMDAT ?BI_def_bitmap_set_opaque@@YAXPAXH@Z
_TEXT	SEGMENT
_bitmap$ = 8						; size = 4
_opaque$ = 12						; size = 4
?BI_def_bitmap_set_opaque@@YAXPAXH@Z PROC		; BI_def_bitmap_set_opaque, COMDAT

; 4    : void  BI_def_bitmap_set_opaque(void *bitmap, BOOL opaque)  {}

	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
?BI_def_bitmap_set_opaque@@YAXPAXH@Z ENDP		; BI_def_bitmap_set_opaque
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\bitmapimage.cpp
;	COMDAT ?BI_def_bitmap_test_opaque@@YAHPAX@Z
_TEXT	SEGMENT
_bitmap$ = 8						; size = 4
?BI_def_bitmap_test_opaque@@YAHPAX@Z PROC		; BI_def_bitmap_test_opaque, COMDAT

; 5    : BOOL  BI_def_bitmap_test_opaque(void *bitmap)              {return false;}

	push	ebp
	mov	ebp, esp
	xor	eax, eax
	pop	ebp
	ret	0
?BI_def_bitmap_test_opaque@@YAHPAX@Z ENDP		; BI_def_bitmap_test_opaque
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\bitmapimage.cpp
;	COMDAT ?BI_def_bitmap_get_buffer@@YAPAEPAX@Z
_TEXT	SEGMENT
_bitmap$ = 8						; size = 4
?BI_def_bitmap_get_buffer@@YAPAEPAX@Z PROC		; BI_def_bitmap_get_buffer, COMDAT

; 6    : unsigned char *BI_def_bitmap_get_buffer(void *bitmap)      {return (unsigned char*)bitmap;}

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _bitmap$[ebp]
	pop	ebp
	ret	0
?BI_def_bitmap_get_buffer@@YAPAEPAX@Z ENDP		; BI_def_bitmap_get_buffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\bitmapimage.cpp
;	COMDAT ?BI_def_bitmap_destroy@@YAXPAX@Z
_TEXT	SEGMENT
_bitmap$ = 8						; size = 4
?BI_def_bitmap_destroy@@YAXPAX@Z PROC			; BI_def_bitmap_destroy, COMDAT

; 7    : void BI_def_bitmap_destroy(void *bitmap)                   {Free(bitmap);}

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _bitmap$[ebp]
	push	eax
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4
	pop	ebp
	ret	0
?BI_def_bitmap_destroy@@YAXPAX@Z ENDP			; BI_def_bitmap_destroy
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\bitmapimage.cpp
;	COMDAT ?BI_def_bitmap_modified@@YAXPAX@Z
_TEXT	SEGMENT
_bitmap$ = 8						; size = 4
?BI_def_bitmap_modified@@YAXPAX@Z PROC			; BI_def_bitmap_modified, COMDAT

; 8    : void BI_def_bitmap_modified(void *bitmap)                  {}

	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
?BI_def_bitmap_modified@@YAXPAX@Z ENDP			; BI_def_bitmap_modified
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\bitmapimage.cpp
;	COMDAT ??0BitmapImage@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0BitmapImage@@QAE@XZ PROC				; BitmapImage::BitmapImage, COMDAT
; _this$ = ecx

; 12   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??0Vect2@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 41148				; 0000a0bcH
	call	??0?$List@M@@QAE@XZ			; List<float>::List<float>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 41184				; 0000a0e0H
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 13   :     bitmap_callbacks.bitmap_create = BI_def_bitmap_create;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+41196], OFFSET ?BI_def_bitmap_create@@YAPAXHH@Z ; BI_def_bitmap_create

; 14   :     bitmap_callbacks.bitmap_destroy = BI_def_bitmap_destroy;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+41200], OFFSET ?BI_def_bitmap_destroy@@YAXPAX@Z ; BI_def_bitmap_destroy

; 15   :     bitmap_callbacks.bitmap_get_buffer = BI_def_bitmap_get_buffer;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+41204], OFFSET ?BI_def_bitmap_get_buffer@@YAPAEPAX@Z ; BI_def_bitmap_get_buffer

; 16   :     bitmap_callbacks.bitmap_modified = BI_def_bitmap_modified;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+41216], OFFSET ?BI_def_bitmap_modified@@YAXPAX@Z ; BI_def_bitmap_modified

; 17   :     bitmap_callbacks.bitmap_set_opaque = BI_def_bitmap_set_opaque;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+41208], OFFSET ?BI_def_bitmap_set_opaque@@YAXPAXH@Z ; BI_def_bitmap_set_opaque

; 18   :     bitmap_callbacks.bitmap_test_opaque = BI_def_bitmap_test_opaque;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+41212], OFFSET ?BI_def_bitmap_test_opaque@@YAHPAX@Z ; BI_def_bitmap_test_opaque

; 19   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0BitmapImage@@QAE@XZ ENDP				; BitmapImage::BitmapImage
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\bitmapimage.cpp
;	COMDAT ??1BitmapImage@@QAE@XZ
_TEXT	SEGMENT
tv94 = -16						; size = 4
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
??1BitmapImage@@QAE@XZ PROC				; BitmapImage::~BitmapImage, COMDAT
; _this$ = ecx

; 22   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 23   :     if(bIsAnimatedGif)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+12]
	test	ecx, ecx
	je	SHORT $LN2@BitmapImag

; 24   :     {
; 25   :         gif_finalise(&gif);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 16					; 00000010H
	push	edx
	call	_gif_finalise
	add	esp, 4

; 26   :         Free(animationFrameCache);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+41156]
	push	ecx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4

; 27   :         Free(animationFrameData);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+41160]
	push	eax
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4
$LN2@BitmapImag:

; 28   :     }
; 29   : 
; 30   :     if(lpGifData)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+41144], 0
	je	SHORT $LN1@BitmapImag

; 31   :         Free(lpGifData);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+41144]
	push	eax
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4
$LN1@BitmapImag:

; 32   : 
; 33   :     EnableFileMonitor(false);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EnableFileMonitor@BitmapImage@@QAEX_N@Z ; BitmapImage::EnableFileMonitor

; 34   : 
; 35   :     delete texture;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T2[ebp], eax
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN5@BitmapImag
	push	1
	mov	ecx, DWORD PTR $T2[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T2[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN3@BitmapImag
$LN5@BitmapImag:
	mov	DWORD PTR tv94[ebp], 0
$LN3@BitmapImag:

; 36   : }

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 41184				; 0000a0e0H
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 41148				; 0000a0bcH
	call	??1?$List@M@@QAE@XZ			; List<float>::~List<float>
	mov	esp, ebp
	pop	ebp
	ret	0
??1BitmapImage@@QAE@XZ ENDP				; BitmapImage::~BitmapImage
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\bitmapimage.cpp
;	COMDAT ?CreateErrorTexture@BitmapImage@@AAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_textureData$ = -4					; size = 4
?CreateErrorTexture@BitmapImage@@AAEXXZ PROC		; BitmapImage::CreateErrorTexture, COMDAT
; _this$ = ecx

; 41   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 42   :     LPBYTE textureData = (LPBYTE)Allocate(32*32*4);

	push	4096					; 00001000H
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+4]
	call	edx
	mov	DWORD PTR _textureData$[ebp], eax

; 43   :     msetd(textureData, 0xFF0000FF, 32*32*4);

	push	4096					; 00001000H
	push	-16776961				; ff0000ffH
	mov	eax, DWORD PTR _textureData$[ebp]
	push	eax
	call	?msetd@@YGXPAXKI@Z			; msetd

; 44   : 
; 45   :     texture = CreateTexture(32, 32, GS_RGB, textureData, FALSE);

	push	1
	push	0
	mov	ecx, DWORD PTR _textureData$[ebp]
	push	ecx
	push	3
	push	32					; 00000020H
	push	32					; 00000020H
	call	?CreateTexture@@YAPAVTexture@@IIW4GSColorFormat@@PAXHH@Z ; CreateTexture
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], eax

; 46   :     fullSize.Set(32.0f, 32.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@42000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@42000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_?Set@Vect2@@QAEAAU1@MM@Z

; 47   : 
; 48   :     Free(textureData);

	mov	eax, DWORD PTR _textureData$[ebp]
	push	eax
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4

; 49   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CreateErrorTexture@BitmapImage@@AAEXXZ ENDP		; BitmapImage::CreateErrorTexture
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\bitmapimage.cpp
;	COMDAT ?SetPath@BitmapImage@@QAEXVString@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_path$ = 8						; size = 8
?SetPath@BitmapImage@@QAEXVString@@@Z PROC		; BitmapImage::SetPath, COMDAT
; _this$ = ecx

; 55   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   :     filePath = path;

	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 41184				; 0000a0e0H
	call	DWORD PTR __imp_??4String@@QAEAAV0@ABV0@@Z

; 57   : }

	lea	ecx, DWORD PTR _path$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	8
?SetPath@BitmapImage@@QAEXVString@@@Z ENDP		; BitmapImage::SetPath
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\bitmapimage.cpp
;	COMDAT ?EnableFileMonitor@BitmapImage@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bMonitor$ = 8						; size = 1
?EnableFileMonitor@BitmapImage@@QAEX_N@Z PROC		; BitmapImage::EnableFileMonitor, COMDAT
; _this$ = ecx

; 60   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 61   :     if (changeMonitor)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+41192], 0
	je	SHORT $LN2@EnableFile

; 62   :     {
; 63   :         OSMonitorFileDestroy(changeMonitor);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+41192]
	push	edx
	call	DWORD PTR __imp_?OSMonitorFileDestroy@@YGXPAUOSFileChangeData@@@Z

; 64   :         changeMonitor = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+41192], 0
$LN2@EnableFile:

; 65   :     }
; 66   : 
; 67   :     if (bMonitor)

	movzx	ecx, BYTE PTR _bMonitor$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@EnableFile

; 68   :         changeMonitor = OSMonitorFileStart(filePath);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 41184				; 0000a0e0H
	sub	esp, 8
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0String@@QAE@ABV0@@Z
	call	DWORD PTR __imp_?OSMonitorFileStart@@YGPAUOSFileChangeData@@VString@@_N@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+41192], eax
$LN3@EnableFile:

; 69   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?EnableFileMonitor@BitmapImage@@QAEX_N@Z ENDP		; BitmapImage::EnableFileMonitor
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\bitmapimage.cpp
;	COMDAT ?Init@BitmapImage@@QAEXXZ
_TEXT	SEGMENT
$T1 = -148						; size = 8
tv604 = -140						; size = 8
tv647 = -132						; size = 8
tv593 = -124						; size = 8
tv634 = -116						; size = 8
tv571 = -108						; size = 8
_gifFile$2 = -100					; size = 24
$T3 = -76						; size = 4
tv94 = -72						; size = 4
$T4 = -68						; size = 4
tv512 = -64						; size = 8
tv589 = -56						; size = 4
tv600 = -52						; size = 4
tv567 = -48						; size = 4
tv631 = -44						; size = 4
_max_size$5 = -40					; size = 8
tv644 = -32						; size = 4
_frameTime$6 = -28					; size = 4
$T7 = -24						; size = 4
_fileSize$8 = -20					; size = 4
_result$9 = -16						; size = 4
_i$10 = -12						; size = 4
_lpBitmap$ = -8						; size = 4
_this$ = -4						; size = 4
?Init@BitmapImage@@QAEXXZ PROC				; BitmapImage::Init, COMDAT
; _this$ = ecx

; 72   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 73   :     if(bIsAnimatedGif)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+12]
	test	ecx, ecx
	je	SHORT $LN25@Init

; 74   :     {
; 75   :         bIsAnimatedGif = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+12], 0

; 76   :         gif_finalise(&gif);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	call	_gif_finalise
	add	esp, 4

; 77   : 
; 78   :         Free(animationFrameCache);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+41156]
	push	edx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4

; 79   :         animationFrameCache = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+41156], 0

; 80   :         Free(animationFrameData);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+41160]
	push	edx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4

; 81   :         animationFrameData = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+41160], 0
$LN25@Init:

; 82   :     }
; 83   : 
; 84   :     if(lpGifData)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+41144], 0
	je	SHORT $LN24@Init

; 85   :     {
; 86   :         Free(lpGifData);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+41144]
	push	eax
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4

; 87   :         lpGifData = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+41144], 0
$LN24@Init:

; 88   :     }
; 89   : 
; 90   :     animationTimes.Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 41148				; 0000a0bcH
	call	?Clear@?$List@M@@QAEXXZ			; List<float>::Clear

; 91   : 
; 92   :     delete texture;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T4[ebp], eax
	mov	ecx, DWORD PTR $T4[ebp]
	mov	DWORD PTR $T7[ebp], ecx
	cmp	DWORD PTR $T7[ebp], 0
	je	SHORT $LN28@Init
	push	1
	mov	edx, DWORD PTR $T7[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T7[ebp]
	mov	edx, DWORD PTR [eax]
	call	edx
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN29@Init
$LN28@Init:
	mov	DWORD PTR tv94[ebp], 0
$LN29@Init:

; 93   :     texture = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 94   : 
; 95   :     CTSTR lpBitmap = filePath;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 41184				; 0000a0e0H
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	DWORD PTR _lpBitmap$[ebp], eax

; 96   :     if(!lpBitmap || !*lpBitmap)

	cmp	DWORD PTR _lpBitmap$[ebp], 0
	je	SHORT $LN22@Init
	mov	ecx, DWORD PTR _lpBitmap$[ebp]
	movzx	edx, WORD PTR [ecx]
	test	edx, edx
	jne	SHORT $LN23@Init
$LN22@Init:

; 97   :     {
; 98   :         AppWarning(TEXT("BitmapImage::Init: Empty path"));

	push	OFFSET $SG4294955033
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 4

; 99   :         CreateErrorTexture();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CreateErrorTexture@BitmapImage@@AAEXXZ	; BitmapImage::CreateErrorTexture

; 100  :         return;

	jmp	$LN26@Init
$LN23@Init:

; 101  :     }
; 102  : 
; 103  :     //------------------------------------
; 104  : 
; 105  :     if(GetPathExtension(lpBitmap).CompareI(TEXT("gif")))

	push	OFFSET $SG4294955032
	mov	eax, DWORD PTR _lpBitmap$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	DWORD PTR __imp_?GetPathExtension@@YA?AVString@@PB_W@Z
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	mov	DWORD PTR $T3[ebp], eax
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	cmp	DWORD PTR $T3[ebp], 0
	je	$LN21@Init

; 106  :     {
; 107  :         gif_create(&gif, &bitmap_callbacks);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 41196				; 0000a0ecH
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	call	_gif_create
	add	esp, 8

; 108  : 
; 109  :         XFile gifFile;

	lea	ecx, DWORD PTR _gifFile$2[ebp]
	call	DWORD PTR __imp_??0XFile@@QAE@XZ

; 110  :         if(!gifFile.Open(lpBitmap, XFILE_READ, XFILE_OPENEXISTING))

	push	3
	push	1
	mov	ecx, DWORD PTR _lpBitmap$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _gifFile$2[ebp]
	call	DWORD PTR __imp_?Open@XFile@@QAEHPB_WKK@Z
	test	eax, eax
	jne	SHORT $LN20@Init

; 111  :         {
; 112  :             AppWarning(TEXT("BitmapImage::Init: could not open gif file '%s'"), lpBitmap);

	mov	edx, DWORD PTR _lpBitmap$[ebp]
	push	edx
	push	OFFSET $SG4294955031
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 8

; 113  :             CreateErrorTexture();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CreateErrorTexture@BitmapImage@@AAEXXZ	; BitmapImage::CreateErrorTexture

; 114  :             return;

	lea	ecx, DWORD PTR _gifFile$2[ebp]
	call	DWORD PTR __imp_??1XFile@@QAE@XZ
	jmp	$LN26@Init
$LN20@Init:

; 115  :         }
; 116  : 
; 117  : 
; 118  :         DWORD fileSize = (DWORD)gifFile.GetFileSize();

	lea	ecx, DWORD PTR _gifFile$2[ebp]
	call	DWORD PTR __imp_?GetFileSize@XFile@@QBE_KXZ
	mov	DWORD PTR _fileSize$8[ebp], eax

; 119  :         lpGifData = (LPBYTE)Allocate(fileSize);

	mov	eax, DWORD PTR _fileSize$8[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+41144], eax

; 120  :         gifFile.Read(lpGifData, fileSize);

	mov	edx, DWORD PTR _fileSize$8[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+41144]
	push	ecx
	lea	ecx, DWORD PTR _gifFile$2[ebp]
	call	DWORD PTR __imp_?Read@XFile@@QAEKPAXK@Z
$LN19@Init:

; 121  : 
; 122  :         gif_result result;
; 123  :         do
; 124  :         {
; 125  :             result = gif_initialise(&gif, fileSize, lpGifData);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+41144]
	push	eax
	mov	ecx, DWORD PTR _fileSize$8[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 16					; 00000010H
	push	edx
	call	_gif_initialise
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _result$9[ebp], eax

; 126  :             if(result != GIF_OK && result != GIF_WORKING)

	cmp	DWORD PTR _result$9[ebp], 0
	je	SHORT $LN16@Init
	cmp	DWORD PTR _result$9[ebp], 1
	je	SHORT $LN16@Init

; 127  :             {
; 128  :                 Log(TEXT("BitmapImage: Warning, couldn't initialise gif %s, it is likely corrupt"), lpBitmap);

	mov	eax, DWORD PTR _lpBitmap$[ebp]
	push	eax
	push	OFFSET $SG4294955030
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8

; 129  :                 CreateErrorTexture();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CreateErrorTexture@BitmapImage@@AAEXXZ	; BitmapImage::CreateErrorTexture

; 130  :                 return;

	lea	ecx, DWORD PTR _gifFile$2[ebp]
	call	DWORD PTR __imp_??1XFile@@QAE@XZ
	jmp	$LN26@Init
$LN16@Init:

; 131  :             }
; 132  :         }while(result != GIF_OK);

	cmp	DWORD PTR _result$9[ebp], 0
	jne	SHORT $LN19@Init

; 133  : 
; 134  :         if (gif.width > 4096 || gif.height > 4096)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+44], 4096		; 00001000H
	ja	SHORT $LN14@Init
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+48], 4096		; 00001000H
	jbe	SHORT $LN15@Init
$LN14@Init:

; 135  :         {
; 136  :             Log(TEXT("BitmapImage: Warning, bad texture dimensions %d x %d in %s"), gif.width, gif.height, lpBitmap);

	mov	eax, DWORD PTR _lpBitmap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	push	OFFSET $SG4294955029
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 16					; 00000010H

; 137  :             CreateErrorTexture();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CreateErrorTexture@BitmapImage@@AAEXXZ	; BitmapImage::CreateErrorTexture

; 138  :             return;

	lea	ecx, DWORD PTR _gifFile$2[ebp]
	call	DWORD PTR __imp_??1XFile@@QAE@XZ
	jmp	$LN26@Init
$LN15@Init:

; 139  :         }
; 140  : 
; 141  :         unsigned long long max_size = (unsigned long long)gif.width * (unsigned long long)gif.height * 4LLU * (unsigned long long)gif.frame_count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mul	DWORD PTR [ecx+48]
	push	0
	push	4
	push	edx
	push	eax
	call	__allmul
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	xor	esi, esi
	push	esi
	push	ecx
	push	edx
	push	eax
	call	__allmul
	mov	DWORD PTR _max_size$5[ebp], eax
	mov	DWORD PTR _max_size$5[ebp+4], edx

; 142  :         if (gif.width * gif.height * 4 * gif.frame_count != max_size)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+44]
	imul	ecx, DWORD PTR [eax+48]
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	imul	ecx, DWORD PTR [edx+52]
	xor	eax, eax
	mov	DWORD PTR tv512[ebp], ecx
	mov	DWORD PTR tv512[ebp+4], eax
	mov	ecx, DWORD PTR tv512[ebp]
	cmp	ecx, DWORD PTR _max_size$5[ebp]
	jne	SHORT $LN30@Init
	mov	edx, DWORD PTR tv512[ebp+4]
	cmp	edx, DWORD PTR _max_size$5[ebp+4]
	je	SHORT $LN13@Init
$LN30@Init:

; 143  :         {
; 144  :             Log(TEXT("BitmapImage: Warning, gif %s overflowed maximum pointer size and was not loaded (%llu > %u)"), lpBitmap, max_size, gif.width * gif.height * 4 * gif.frame_count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+44]
	imul	edx, DWORD PTR [ecx+48]
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	imul	edx, DWORD PTR [eax+52]
	push	edx
	mov	ecx, DWORD PTR _max_size$5[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _max_size$5[ebp]
	push	edx
	mov	eax, DWORD PTR _lpBitmap$[ebp]
	push	eax
	push	OFFSET $SG4294955028
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 20					; 00000014H

; 145  :             CreateErrorTexture();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CreateErrorTexture@BitmapImage@@AAEXXZ	; BitmapImage::CreateErrorTexture

; 146  :             return;

	lea	ecx, DWORD PTR _gifFile$2[ebp]
	call	DWORD PTR __imp_??1XFile@@QAE@XZ
	jmp	$LN26@Init
$LN13@Init:

; 147  :         }
; 148  : 
; 149  :         if(gif.frame_count > 1)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+52], 1
	jbe	SHORT $LN11@Init

; 150  :         {
; 151  :             if(result == GIF_OK || result == GIF_WORKING)

	cmp	DWORD PTR _result$9[ebp], 0
	je	SHORT $LN10@Init
	cmp	DWORD PTR _result$9[ebp], 1
	jne	SHORT $LN11@Init
$LN10@Init:

; 152  :                 bIsAnimatedGif = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+12], 1
$LN11@Init:

; 153  :         }
; 154  : 
; 155  :         if(bIsAnimatedGif)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+12]
	test	ecx, ecx
	je	$LN9@Init

; 156  :         {
; 157  :             gif_decode_frame(&gif, 0);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 16					; 00000010H
	push	edx
	call	_gif_decode_frame
	add	esp, 8

; 158  :             texture = CreateTexture(gif.width, gif.height, GS_RGBA, gif.frame_image, FALSE, FALSE);

	push	0
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	push	ecx
	push	4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+48]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?CreateTexture@@YAPAVTexture@@IIW4GSColorFormat@@PAXHH@Z ; CreateTexture
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 159  : 
; 160  :             animationFrameCache = (BYTE **)Allocate(gif.frame_count * sizeof(BYTE *));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+41156], eax

; 161  :             memset(animationFrameCache, 0, gif.frame_count * sizeof(BYTE *));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	shl	eax, 2
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+41156]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 162  : 
; 163  :             animationFrameData = (BYTE *)Allocate(gif.frame_count * gif.width * gif.height * 4);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+52]
	imul	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _this$[ebp]
	imul	edx, DWORD PTR [eax+48]
	shl	edx, 2
	push	edx
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+41160], eax

; 164  :             memset(animationFrameData, 0, gif.frame_count * gif.width * gif.height * 4);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	imul	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _this$[ebp]
	imul	ecx, DWORD PTR [edx+48]
	shl	ecx, 2
	push	ecx
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+41160]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 165  : 
; 166  :             for(UINT i=0; i<gif.frame_count; i++)

	mov	DWORD PTR _i$10[ebp], 0
	jmp	SHORT $LN8@Init
$LN7@Init:
	mov	edx, DWORD PTR _i$10[ebp]
	add	edx, 1
	mov	DWORD PTR _i$10[ebp], edx
$LN8@Init:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$10[ebp]
	cmp	ecx, DWORD PTR [eax+52]
	jae	$LN6@Init

; 167  :             {
; 168  :                 float frameTime = float(gif.frames[i].frame_delay)*0.01f;

	imul	edx, DWORD PTR _i$10[ebp], 52
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	edx, DWORD PTR [ecx+edx+4]
	mov	DWORD PTR tv567[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv567[ebp]
	mov	eax, DWORD PTR tv567[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv571[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv571[ebp]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR _frameTime$6[ebp], xmm0

; 169  :                 if (frameTime == 0.0f)

	movss	xmm0, DWORD PTR _frameTime$6[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@Init

; 170  :                     frameTime = 0.1f;

	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _frameTime$6[ebp], xmm0
$LN5@Init:

; 171  :                 animationTimes << frameTime;

	lea	ecx, DWORD PTR _frameTime$6[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 41148				; 0000a0bcH
	call	??6?$List@M@@QAEAAV0@ABM@Z		; List<float>::operator<<

; 172  : 
; 173  :                 if (gif_decode_frame(&gif, i) != GIF_OK)

	mov	edx, DWORD PTR _i$10[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	call	_gif_decode_frame
	add	esp, 8
	test	eax, eax
	je	SHORT $LN4@Init

; 174  :                     Log (TEXT("BitmapImage: Warning, couldn't decode frame %d of %s"), i, lpBitmap);

	mov	ecx, DWORD PTR _lpBitmap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$10[ebp]
	push	edx
	push	OFFSET $SG4294955027
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 12					; 0000000cH
$LN4@Init:

; 175  :             }

	jmp	$LN7@Init
$LN6@Init:

; 176  : 
; 177  :             gif_decode_frame(&gif, 0);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	call	_gif_decode_frame
	add	esp, 8

; 178  : 
; 179  :             fullSize.x = float(gif.width);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR tv589[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv589[ebp]
	mov	eax, DWORD PTR tv589[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv593[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv593[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+4], xmm0

; 180  :             fullSize.y = float(gif.height);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR tv600[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv600[ebp]
	mov	ecx, DWORD PTR tv600[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv604[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv604[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+8], xmm0

; 181  : 
; 182  :             curTime = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+41176], xmm0

; 183  :             curFrame = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+41164], 0

; 184  :             lastDecodedFrame = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+41172], 0

; 185  :         }
; 186  :         else

	jmp	SHORT $LN3@Init
$LN9@Init:

; 187  :         {
; 188  :             gif_finalise(&gif);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	call	_gif_finalise
	add	esp, 4

; 189  :             Free(lpGifData);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+41144]
	push	edx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4

; 190  :             lpGifData = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+41144], 0
$LN3@Init:

; 191  :         }
; 192  :     }

	lea	ecx, DWORD PTR _gifFile$2[ebp]
	call	DWORD PTR __imp_??1XFile@@QAE@XZ
$LN21@Init:

; 193  : 
; 194  :     if(!bIsAnimatedGif)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+12]
	test	edx, edx
	jne	$LN2@Init

; 195  :     {
; 196  :         texture = GS->CreateTextureFromFile(lpBitmap, TRUE);

	push	1
	mov	eax, DWORD PTR _lpBitmap$[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp_?GS@@3PAVGraphicsSystem@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?GS@@3PAVGraphicsSystem@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+28]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 197  :         if(!texture)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN1@Init

; 198  :         {
; 199  :             AppWarning(TEXT("BitmapImage::Init: could not create texture '%s'"), lpBitmap);

	mov	eax, DWORD PTR _lpBitmap$[ebp]
	push	eax
	push	OFFSET $SG4294955026
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 8

; 200  :             CreateErrorTexture();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CreateErrorTexture@BitmapImage@@AAEXXZ	; BitmapImage::CreateErrorTexture

; 201  :             return;

	jmp	SHORT $LN26@Init
$LN1@Init:

; 202  :         }
; 203  : 
; 204  :         fullSize.x = float(texture->Width());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	mov	DWORD PTR tv631[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv631[ebp]
	mov	ecx, DWORD PTR tv631[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv634[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv634[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+4], xmm0

; 205  :         fullSize.y = float(texture->Height());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+8]
	call	edx
	mov	DWORD PTR tv644[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv644[ebp]
	mov	eax, DWORD PTR tv644[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv647[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv647[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+8], xmm0
$LN2@Init:
$LN26@Init:

; 206  :     }
; 207  : 
; 208  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?Init@BitmapImage@@QAEXXZ ENDP				; BitmapImage::Init
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\bitmapimage.cpp
;	COMDAT ?GetSize@BitmapImage@@QBE?AUVect2@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetSize@BitmapImage@@QBE?AUVect2@@XZ PROC		; BitmapImage::GetSize, COMDAT
; _this$ = ecx

; 211  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 212  :     return fullSize;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0Vect2@@QAE@ABU0@@Z
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 213  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetSize@BitmapImage@@QBE?AUVect2@@XZ ENDP		; BitmapImage::GetSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\bitmapimage.cpp
;	COMDAT ?GetTexture@BitmapImage@@QBEPAVTexture@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTexture@BitmapImage@@QBEPAVTexture@@XZ PROC		; BitmapImage::GetTexture, COMDAT
; _this$ = ecx

; 216  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 217  :     return texture;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 218  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTexture@BitmapImage@@QBEPAVTexture@@XZ ENDP		; BitmapImage::GetTexture
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\bitmapimage.cpp
;	COMDAT ?Tick@BitmapImage@@QAEXM@Z
_TEXT	SEGMENT
_ret$1 = -28						; size = 4
_lastFrame$2 = -24					; size = 4
tv130 = -20						; size = 4
_i$3 = -16						; size = 4
_totalLoops$4 = -12					; size = 4
_newFrame$5 = -8					; size = 4
_this$ = -4						; size = 4
_fSeconds$ = 8						; size = 4
?Tick@BitmapImage@@QAEXM@Z PROC				; BitmapImage::Tick, COMDAT
; _this$ = ecx

; 221  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 222  :     if(bIsAnimatedGif)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+12]
	test	ecx, ecx
	je	$LN13@Tick

; 223  :     {
; 224  :         UINT totalLoops = (UINT)gif.loop_count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	DWORD PTR _totalLoops$4[ebp], eax

; 225  :         if(totalLoops >= 0xFFFF)

	cmp	DWORD PTR _totalLoops$4[ebp], 65535	; 0000ffffH
	jb	SHORT $LN23@Tick

; 226  :             totalLoops = 0;

	mov	DWORD PTR _totalLoops$4[ebp], 0
$LN23@Tick:

; 227  : 
; 228  :         if(!totalLoops || curLoop < totalLoops)

	cmp	DWORD PTR _totalLoops$4[ebp], 0
	je	SHORT $LN21@Tick
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+41168]
	cmp	edx, DWORD PTR _totalLoops$4[ebp]
	jae	$LN13@Tick
$LN21@Tick:

; 229  :         {
; 230  :             UINT newFrame = curFrame;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+41164]
	mov	DWORD PTR _newFrame$5[ebp], ecx

; 231  : 
; 232  :             curTime += fSeconds;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+41176]
	addss	xmm0, DWORD PTR _fSeconds$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+41176], xmm0
$LN20@Tick:

; 233  :             while(curTime > animationTimes[newFrame])

	mov	ecx, DWORD PTR _newFrame$5[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 41148				; 0000a0bcH
	call	??A?$List@M@@QAEAAMI@Z			; List<float>::operator[]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+41176]
	comiss	xmm0, DWORD PTR [eax]
	jbe	$LN19@Tick

; 234  :             {
; 235  :                 curTime -= animationTimes[newFrame];

	mov	eax, DWORD PTR _newFrame$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 41148				; 0000a0bcH
	call	??A?$List@M@@QAEAAMI@Z			; List<float>::operator[]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+41176]
	subss	xmm0, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+41176], xmm0

; 236  :                 if(++newFrame == animationTimes.Num())

	mov	eax, DWORD PTR _newFrame$5[ebp]
	add	eax, 1
	mov	DWORD PTR _newFrame$5[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 41148				; 0000a0bcH
	call	?Num@?$List@M@@QBEIXZ			; List<float>::Num
	cmp	DWORD PTR _newFrame$5[ebp], eax
	jne	SHORT $LN14@Tick

; 237  :                 {
; 238  :                     if(!totalLoops || ++curLoop < totalLoops)

	cmp	DWORD PTR _totalLoops$4[ebp], 0
	je	SHORT $LN16@Tick
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+41168]
	add	edx, 1
	mov	DWORD PTR tv130[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR tv130[ebp]
	mov	DWORD PTR [eax+41168], ecx
	mov	edx, DWORD PTR tv130[ebp]
	cmp	edx, DWORD PTR _totalLoops$4[ebp]
	jae	SHORT $LN17@Tick
$LN16@Tick:

; 239  :                         newFrame = 0;

	mov	DWORD PTR _newFrame$5[ebp], 0
	jmp	SHORT $LN14@Tick
$LN17@Tick:

; 240  :                     else if (curLoop == totalLoops)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+41168]
	cmp	ecx, DWORD PTR _totalLoops$4[ebp]
	jne	SHORT $LN14@Tick

; 241  :                     {
; 242  :                         newFrame--;

	mov	edx, DWORD PTR _newFrame$5[ebp]
	sub	edx, 1
	mov	DWORD PTR _newFrame$5[ebp], edx

; 243  :                         break;

	jmp	SHORT $LN19@Tick
$LN14@Tick:

; 244  :                     }
; 245  :                 }
; 246  :             }

	jmp	$LN20@Tick
$LN19@Tick:

; 247  : 
; 248  :             if(newFrame != curFrame)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newFrame$5[ebp]
	cmp	ecx, DWORD PTR [eax+41164]
	je	$LN13@Tick

; 249  :             {
; 250  :                 UINT lastFrame;
; 251  : 
; 252  :                 if (!animationFrameCache[newFrame])

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+41156]
	mov	ecx, DWORD PTR _newFrame$5[ebp]
	cmp	DWORD PTR [eax+ecx*4], 0
	jne	$LN12@Tick

; 253  :                 {
; 254  :                     //animation might have looped, if so make sure we decode from frame 0
; 255  :                     if (newFrame < lastDecodedFrame)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _newFrame$5[ebp]
	cmp	eax, DWORD PTR [edx+41172]
	jae	SHORT $LN11@Tick

; 256  :                         lastFrame = 0;

	mov	DWORD PTR _lastFrame$2[ebp], 0

; 257  :                     else

	jmp	SHORT $LN10@Tick
$LN11@Tick:

; 258  :                         lastFrame = lastDecodedFrame + 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+41172]
	add	edx, 1
	mov	DWORD PTR _lastFrame$2[ebp], edx
$LN10@Tick:

; 259  : 
; 260  :                     //we need to decode any frames we missed for consistency
; 261  :                     for (UINT i = lastFrame; i < newFrame; i++)

	mov	eax, DWORD PTR _lastFrame$2[ebp]
	mov	DWORD PTR _i$3[ebp], eax
	jmp	SHORT $LN9@Tick
$LN8@Tick:
	mov	ecx, DWORD PTR _i$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$3[ebp], ecx
$LN9@Tick:
	mov	edx, DWORD PTR _i$3[ebp]
	cmp	edx, DWORD PTR _newFrame$5[ebp]
	jae	SHORT $LN7@Tick

; 262  :                     {
; 263  :                         if (gif_decode_frame(&gif, i) != GIF_OK)

	mov	eax, DWORD PTR _i$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	call	_gif_decode_frame
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@Tick

; 264  :                             return;

	jmp	$LN25@Tick
$LN6@Tick:

; 265  :                     }

	jmp	SHORT $LN8@Tick
$LN7@Tick:

; 266  : 
; 267  :                     //now decode and display the actual frame we want
; 268  :                     int ret = gif_decode_frame(&gif, newFrame);

	mov	edx, DWORD PTR _newFrame$5[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	call	_gif_decode_frame
	add	esp, 8
	mov	DWORD PTR _ret$1[ebp], eax

; 269  :                     if (ret == GIF_OK)

	cmp	DWORD PTR _ret$1[ebp], 0
	jne	SHORT $LN5@Tick

; 270  :                     {
; 271  :                         animationFrameCache[newFrame] = animationFrameData + (newFrame * (gif.width * gif.height * 4));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+44]
	imul	eax, DWORD PTR [edx+48]
	shl	eax, 2
	imul	eax, DWORD PTR _newFrame$5[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+41160]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+41156]
	mov	edx, DWORD PTR _newFrame$5[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 272  :                         memcpy(animationFrameCache[newFrame], gif.frame_image, gif.width * gif.height * 4);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+44]
	imul	edx, DWORD PTR [ecx+48]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+41156]
	mov	ecx, DWORD PTR _newFrame$5[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN5@Tick:

; 273  :                     }
; 274  : 
; 275  :                     lastDecodedFrame = newFrame;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newFrame$5[ebp]
	mov	DWORD PTR [eax+41172], ecx
$LN12@Tick:

; 276  :                 }
; 277  : 
; 278  :                 if (animationFrameCache[newFrame])

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+41156]
	mov	ecx, DWORD PTR _newFrame$5[ebp]
	cmp	DWORD PTR [eax+ecx*4], 0
	je	SHORT $LN4@Tick

; 279  :                     texture->SetImage(animationFrameCache[newFrame], GS_IMAGEFORMAT_RGBA, gif.width*4);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	shl	eax, 2
	push	eax
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+41156]
	mov	eax, DWORD PTR _newFrame$5[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN4@Tick:

; 280  : 
; 281  :                 curFrame = newFrame;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _newFrame$5[ebp]
	mov	DWORD PTR [ecx+41164], edx
$LN13@Tick:

; 282  :             }
; 283  :         }
; 284  :     }
; 285  : 
; 286  :     if (updateImageTime)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+41180]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@Tick

; 287  :     {
; 288  :         updateImageTime -= fSeconds;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+41180]
	subss	xmm0, DWORD PTR _fSeconds$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+41180], xmm0

; 289  :         if (updateImageTime <= 0.0f)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [eax+41180]
	jb	SHORT $LN2@Tick

; 290  :         {
; 291  :             updateImageTime = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+41180], xmm0

; 292  :             Init();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Init@BitmapImage@@QAEXXZ		; BitmapImage::Init
$LN2@Tick:

; 293  :         }
; 294  :     }
; 295  : 
; 296  :     if (changeMonitor && OSFileHasChanged(changeMonitor))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+41192], 0
	je	SHORT $LN1@Tick
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+41192]
	push	ecx
	call	DWORD PTR __imp_?OSFileHasChanged@@YGHPAUOSFileChangeData@@@Z
	test	eax, eax
	je	SHORT $LN1@Tick

; 297  :         updateImageTime = 1.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+41180], xmm0
$LN1@Tick:
$LN25@Tick:

; 298  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Tick@BitmapImage@@QAEXM@Z ENDP				; BitmapImage::Tick
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??0?$List@M@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$List@M@@QAE@XZ PROC				; List<float>::List<float>, COMDAT
; _this$ = ecx

; 35   :     inline List() : array(NULL), num(0) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@M@@QAE@XZ ENDP				; List<float>::List<float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??1?$List@M@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$List@M@@QAE@XZ PROC				; List<float>::~List<float>, COMDAT
; _this$ = ecx

; 37   :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 38   :         Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@M@@QAEXXZ			; List<float>::Clear

; 39   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@M@@QAE@XZ ENDP				; List<float>::~List<float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Num@?$List@M@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Num@?$List@M@@QBEIXZ PROC				; List<float>::Num, COMDAT
; _this$ = ecx

; 42   :     inline unsigned int Num() const     {return num;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?Num@?$List@M@@QBEIXZ ENDP				; List<float>::Num
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Clear@?$List@M@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@?$List@M@@QAEXXZ PROC				; List<float>::Clear, COMDAT
; _this$ = ecx

; 334  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 335  :         if(array)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Clear

; 336  :         {
; 337  :             /*if(IsBadWritePtr(array, sizeof(T)*num))
; 338  :                 CrashError(TEXT("what the.."));*/
; 339  :             Free(array);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4

; 340  :             array = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 341  :             num = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$LN2@Clear:

; 342  :         }
; 343  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$List@M@@QAEXXZ ENDP				; List<float>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??6?$List@M@@QAEAAV0@ABM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_val$ = 8						; size = 4
??6?$List@M@@QAEAAV0@ABM@Z PROC				; List<float>::operator<<, COMDAT
; _this$ = ecx

; 366  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 367  :         Add(val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Add@?$List@M@@QAEIABM@Z		; List<float>::Add

; 368  :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 369  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??6?$List@M@@QAEAAV0@ABM@Z ENDP				; List<float>::operator<<
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??A?$List@M@@QAEAAMI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$List@M@@QAEAAMI@Z PROC				; List<float>::operator[], COMDAT
; _this$ = ecx

; 379  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  :         assert(index < num);
; 381  :         if(index >= num) {DumpError(TEXT("Out of range!  List<%S>::operator[](%d)"), typeid(T).name(), index); return array[0];}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN1@operator
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	push	OFFSET ?__type_info_root_node@@3U__type_info_node@@A ; __type_info_root_node
	mov	ecx, OFFSET ??_R0M@8
	call	?name@type_info@@QBEPBDPAU__type_info_node@@@Z ; type_info::name
	push	eax
	push	OFFSET ??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp_?DumpError@@YAXPB_WZZ
	mov	eax, 4
	imul	eax, eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN3@operator
$LN1@operator:

; 382  :         return array[index];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _index$[ebp]
	lea	eax, DWORD PTR [eax+ecx*4]
$LN3@operator:

; 383  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@M@@QAEAAMI@Z ENDP				; List<float>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Add@?$List@M@@QAEIABM@Z
_TEXT	SEGMENT
tv73 = -8						; size = 4
_this$ = -4						; size = 4
_val$ = 8						; size = 4
?Add@?$List@M@@QAEIABM@Z PROC				; List<float>::Add, COMDAT
; _this$ = ecx

; 45   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 46   :         array = (T*)ReAllocate(array, sizeof(T)*++num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	DWORD PTR tv73[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR tv73[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 47   :         mcpy(&array[(num-1)], (void*)&val, sizeof(T));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [edx+eax*4-4], ecx

; 48   :         return num-1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1

; 49   :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?Add@?$List@M@@QAEIABM@Z ENDP				; List<float>::Add
_TEXT	ENDS
END

; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

	TITLE	F:\songmm_moon_stone_obs\OBS\Source\Encoder_x264.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_11LOCGONAA@?$AA?$AA@			; `string'
PUBLIC	??_C@_1CE@BMPFFOPN@?$AAU?$AAs?$AAe?$AAC?$AAu?$AAs?$AAt?$AAo?$AAm?$AAS?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BO@FDMCHPPE@?$AAC?$AAu?$AAs?$AAt?$AAo?$AAm?$AAS?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EC@MHGNNJDA@?$AAU?$AAs?$AAi?$AAn?$AAg?$AA?5?$AAc?$AAu?$AAs?$AAt?$AAo?$AAm?$AA?5?$AAx?$AA2?$AA6?$AA4?$AA?5?$AAs?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AAs?$AA?3?$AA?5?$AA?$CC?$AA?$CF?$AAs?$AA?$CC@ ; `string'
PUBLIC	??_C@_1O@KFCPNKHD@?$AAp?$AAr?$AAe?$AAs?$AAe?$AAt?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CG@DMGFBGHB@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAp?$AAr?$AAe?$AAs?$AAe?$AAt?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_19DJGBEEIE@?$AAt?$AAu?$AAn?$AAe?$AA?$AA@	; `string'
PUBLIC	??_C@_1CC@IEINPIEO@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAt?$AAu?$AAn?$AAe?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BA@PNHGIEJF@?$AAp?$AAr?$AAo?$AAf?$AAi?$AAl?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CI@DIKLJDHA@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAp?$AAr?$AAo?$AAf?$AAi?$AAl?$AAe?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EG@DKNJMDPM@?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAs?$AAe?$AAt?$AA?5?$AAx?$AA2?$AA6?$AA4?$AA?5?$AAd?$AAe?$AAf?$AAa?$AAu?$AAl?$AAt?$AAs?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?1@ ; `string'
PUBLIC	??_C@_1O@OGDCGAII@?$AAP?$AAa?$AAd?$AAC?$AAB?$AAR?$AA?$AA@ ; `string'
PUBLIC	??_C@_17POPBILBJ@?$AAf?$AAp?$AAs?$AA?$AA@	; `string'
PUBLIC	??_C@_1BE@KJGOOJHK@?$AAf?$AAo?$AAr?$AAc?$AAe?$AA?9?$AAc?$AAf?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_1KE@FCEDOHCD@?$AAT?$AAh?$AAe?$AA?5?$AAc?$AAu?$AAs?$AAt?$AAo?$AAm?$AA?5?$AAx?$AA2?$AA6?$AA4?$AA?5?$AAc?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AA?5?$AA?8?$AA?$CF?$AAs?$AA?8?$AA?5?$AAi?$AAs?$AA?5@ ; `string'
PUBLIC	??_C@_1EI@KKIIHNLA@?$AAT?$AAh?$AAe?$AA?5?$AAc?$AAu?$AAs?$AAt?$AAo?$AAm?$AA?5?$AAx?$AA2?$AA6?$AA4?$AA?5?$AAc?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AA?5?$AA?8?$AA?$CF?$AAs?$AA?8?$AA?5?$AAf?$AAa?$AAi@ ; `string'
PUBLIC	??_C@_1DO@JLMBLODN@?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAs?$AAe?$AAt?$AA?5?$AAx?$AA2?$AA6?$AA4?$AA?5?$AAp?$AAr?$AAo?$AAf?$AAi?$AAl?$AAe?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DE@JDBGJCBN@?$AAC?$AAo?$AAu?$AAl?$AAd?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?5?$AAx?$AA2?$AA6?$AA4?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CG@PCBENPOB@?$AAx?$AA2?$AA6?$AA4?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CK@JPDANMPO@?$AAV?$AAi?$AAd?$AAe?$AAo?$AA?5?$AAE?$AAn?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA?3?$AA?5?$AAx?$AA2?$AA6?$AA4?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BO@DHMJEFGL@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAp?$AAr?$AAe?$AAs?$AAe?$AAt?$AA?3?$AA?5?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BO@KNOLPPNN@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAk?$AAe?$AAy?$AAi?$AAn?$AAt?$AA?3?$AA?5?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CA@EAIGMDMJ@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAq?$AAu?$AAa?$AAl?$AAi?$AAt?$AAy?$AA?3?$AA?5?$AA?$AA@ ; `string'
PUBLIC	??_C@_1GE@KMKNGAEG@?$AAC?$AAo?$AAu?$AAl?$AAd?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAe?$AAt?$AA?5?$AAn?$AAe?$AAw?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?5?$AAb?$AAi?$AAt?$AAr?$AAa?$AAt@ ; `string'
PUBLIC	??_C@_1BO@PHOABOJI@?$AAb?$AAi?$AAt?$AAr?$AAa?$AAt?$AAe?$AA?5?$AA?$CF?$AAd?$AA?9?$AA?$DO?$AA?$CF?$AAd?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CK@JNMHHCMH@?$AA?$CF?$AAs?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$CF?$AAd?$AA?9?$AA?$DO?$AA?$CF?$AAd?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BC@NMBCIDFP@?$AAx?$AA2?$AA6?$AA4?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_R1A@?0A@EA@X264Encoder@@8			; X264Encoder::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7X264Encoder@@6B@				; X264Encoder::`vftable'
PUBLIC	??_R0?AVX264Encoder@@@8				; X264Encoder `RTTI Type Descriptor'
PUBLIC	??_R3X264Encoder@@8				; X264Encoder::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4X264Encoder@@6B@				; X264Encoder::`RTTI Complete Object Locator'
PUBLIC	??_R2X264Encoder@@8				; X264Encoder::`RTTI Base Class Array'
EXTRN	__imp_?Remove@StringList@@QAEXI@Z:PROC
EXTRN	__imp__x264_encoder_close:PROC
EXTRN	__imp__x264_encoder_encode:PROC
EXTRN	__imp__x264_encoder_open_146:PROC
EXTRN	__imp_??6String@@QAEAAV0@H@Z:PROC
EXTRN	__imp_?CreateUTF8String@String@@QAEPADXZ:PROC
EXTRN	__imp__x264_encoder_headers:PROC
EXTRN	__imp__x264_param_apply_profile:PROC
EXTRN	__imp_?Logva@@YAXPB_WPAD@Z:PROC
EXTRN	__imp__x264_param_default_preset:PROC
EXTRN	__imp__x264_encoder_reconfig:PROC
EXTRN	__imp__x264_encoder_delayed_frames:PROC
EXTRN	__imp_?OSDebugOutva@@YAXPB_WPAD@Z:PROC
EXTRN	__imp__x264_param_parse:PROC
;	COMDAT ??_R2X264Encoder@@8
rdata$r	SEGMENT
??_R2X264Encoder@@8 DD FLAT:??_R1A@?0A@EA@X264Encoder@@8 ; X264Encoder::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@VideoEncoder@@8
rdata$r	ENDS
;	COMDAT ??_R4X264Encoder@@6B@
rdata$r	SEGMENT
??_R4X264Encoder@@6B@ DD 00H				; X264Encoder::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVX264Encoder@@@8
	DD	FLAT:??_R3X264Encoder@@8
rdata$r	ENDS
;	COMDAT ??_R3X264Encoder@@8
rdata$r	SEGMENT
??_R3X264Encoder@@8 DD 00H				; X264Encoder::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2X264Encoder@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVX264Encoder@@@8
data$r	SEGMENT
??_R0?AVX264Encoder@@@8 DD FLAT:??_7type_info@@6B@	; X264Encoder `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVX264Encoder@@', 00H
data$r	ENDS
;	COMDAT ??_7X264Encoder@@6B@
CONST	SEGMENT
??_7X264Encoder@@6B@ DD FLAT:??_R4X264Encoder@@6B@	; X264Encoder::`vftable'
	DD	FLAT:?Encode@X264Encoder@@UAE_NPAXAAV?$List@UDataPacket@@@@AAV?$List@W4PacketType@@@@KAAK@Z
	DD	FLAT:?RequestBuffers@VideoEncoder@@MAEXPAX@Z
	DD	FLAT:??_EX264Encoder@@UAEPAXI@Z
	DD	FLAT:?GetBitRate@X264Encoder@@UBEHXZ
	DD	FLAT:?DynamicBitrateSupported@X264Encoder@@UBE_NXZ
	DD	FLAT:?SetBitRate@X264Encoder@@UAE_NKK@Z
	DD	FLAT:?GetHeaders@X264Encoder@@UAEXAAUDataPacket@@@Z
	DD	FLAT:?GetSEI@X264Encoder@@UAEXAAUDataPacket@@@Z
	DD	FLAT:?RequestKeyframe@X264Encoder@@UAEXXZ
	DD	FLAT:?GetInfoString@X264Encoder@@UBE?AVString@@XZ
	DD	FLAT:?isQSV@VideoEncoder@@UAE_NXZ
	DD	FLAT:?GetBufferedFrames@X264Encoder@@UAEHXZ
	DD	FLAT:?HasBufferedFrames@X264Encoder@@UAE_NXZ
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@X264Encoder@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@X264Encoder@@8 DD FLAT:??_R0?AVX264Encoder@@@8 ; X264Encoder::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3X264Encoder@@8
rdata$r	ENDS
;	COMDAT ??_C@_1BC@NMBCIDFP@?$AAx?$AA2?$AA6?$AA4?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@NMBCIDFP@?$AAx?$AA2?$AA6?$AA4?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?$AA@ DB 'x'
	DB	00H, '2', 00H, '6', 00H, '4', 00H, ':', 00H, ' ', 00H, '%', 00H
	DB	's', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@JNMHHCMH@?$AA?$CF?$AAs?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$CF?$AAd?$AA?9?$AA?$DO?$AA?$CF?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@JNMHHCMH@?$AA?$CF?$AAs?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$CF?$AAd?$AA?9?$AA?$DO?$AA?$CF?$AAd?$AA?$AA@ DB '%'
	DB	00H, 's', 00H, 'b', 00H, 'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H
	DB	'r', 00H, ' ', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, ' '
	DB	00H, '%', 00H, 'd', 00H, '-', 00H, '>', 00H, '%', 00H, 'd', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@PHOABOJI@?$AAb?$AAi?$AAt?$AAr?$AAa?$AAt?$AAe?$AA?5?$AA?$CF?$AAd?$AA?9?$AA?$DO?$AA?$CF?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@PHOABOJI@?$AAb?$AAi?$AAt?$AAr?$AAa?$AAt?$AAe?$AA?5?$AA?$CF?$AAd?$AA?9?$AA?$DO?$AA?$CF?$AAd?$AA?$AA@ DB 'b'
	DB	00H, 'i', 00H, 't', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'e', 00H
	DB	' ', 00H, '%', 00H, 'd', 00H, '-', 00H, '>', 00H, '%', 00H, 'd'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1GE@KMKNGAEG@?$AAC?$AAo?$AAu?$AAl?$AAd?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAe?$AAt?$AA?5?$AAn?$AAe?$AAw?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?5?$AAb?$AAi?$AAt?$AAr?$AAa?$AAt@
CONST	SEGMENT
??_C@_1GE@KMKNGAEG@?$AAC?$AAo?$AAu?$AAl?$AAd?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAe?$AAt?$AA?5?$AAn?$AAe?$AAw?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?5?$AAb?$AAi?$AAt?$AAr?$AAa?$AAt@ DB 'C'
	DB	00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, ' ', 00H, 'n', 00H
	DB	'o', 00H, 't', 00H, ' ', 00H, 's', 00H, 'e', 00H, 't', 00H, ' '
	DB	00H, 'n', 00H, 'e', 00H, 'w', 00H, ' ', 00H, 'e', 00H, 'n', 00H
	DB	'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H, ' ', 00H, 'b'
	DB	00H, 'i', 00H, 't', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'e', 00H
	DB	',', 00H, ' ', 00H, 'e', 00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r'
	DB	00H, ' ', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'u', 00H, 'e', 00H
	DB	' ', 00H, '%', 00H, 'u', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@EAIGMDMJ@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAq?$AAu?$AAa?$AAl?$AAi?$AAt?$AAy?$AA?3?$AA?5?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@EAIGMDMJ@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAq?$AAu?$AAa?$AAl?$AAi?$AAt?$AAy?$AA?3?$AA?5?$AA?$AA@ DB 0dH
	DB	00H, 0aH, 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'q', 00H
	DB	'u', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 't', 00H, 'y', 00H, ':'
	DB	00H, ' ', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@KNOLPPNN@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAk?$AAe?$AAy?$AAi?$AAn?$AAt?$AA?3?$AA?5?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@KNOLPPNN@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAk?$AAe?$AAy?$AAi?$AAn?$AAt?$AA?3?$AA?5?$AA?$AA@ DB 0dH
	DB	00H, 0aH, 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'k', 00H
	DB	'e', 00H, 'y', 00H, 'i', 00H, 'n', 00H, 't', 00H, ':', 00H, ' '
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@DHMJEFGL@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAp?$AAr?$AAe?$AAs?$AAe?$AAt?$AA?3?$AA?5?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@DHMJEFGL@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAp?$AAr?$AAe?$AAs?$AAe?$AAt?$AA?3?$AA?5?$AA?$AA@ DB 0dH
	DB	00H, 0aH, 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'p', 00H
	DB	'r', 00H, 'e', 00H, 's', 00H, 'e', 00H, 't', 00H, ':', 00H, ' '
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@JPDANMPO@?$AAV?$AAi?$AAd?$AAe?$AAo?$AA?5?$AAE?$AAn?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA?3?$AA?5?$AAx?$AA2?$AA6?$AA4?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@JPDANMPO@?$AAV?$AAi?$AAd?$AAe?$AAo?$AA?5?$AAE?$AAn?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA?3?$AA?5?$AAx?$AA2?$AA6?$AA4?$AA?$AA@ DB 'V'
	DB	00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, ' ', 00H, 'E', 00H
	DB	'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'i', 00H, 'n', 00H, 'g'
	DB	00H, ':', 00H, ' ', 00H, 'x', 00H, '2', 00H, '6', 00H, '4', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@PCBENPOB@?$AAx?$AA2?$AA6?$AA4?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@PCBENPOB@?$AAx?$AA2?$AA6?$AA4?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?$AA@ DB 'x'
	DB	00H, '2', 00H, '6', 00H, '4', 00H, ' ', 00H, 'e', 00H, 'n', 00H
	DB	'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, ' ', 00H, 'f', 00H, 'a'
	DB	00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DE@JDBGJCBN@?$AAC?$AAo?$AAu?$AAl?$AAd?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?5?$AAx?$AA2?$AA6?$AA4?$AA?$AA@
CONST	SEGMENT
??_C@_1DE@JDBGJCBN@?$AAC?$AAo?$AAu?$AAl?$AAd?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?5?$AAx?$AA2?$AA6?$AA4?$AA?$AA@ DB 'C'
	DB	00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, ' ', 00H, 'n', 00H
	DB	'o', 00H, 't', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 'i', 00H, 't'
	DB	00H, 'i', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'z', 00H, 'e', 00H
	DB	' ', 00H, 'x', 00H, '2', 00H, '6', 00H, '4', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DO@JLMBLODN@?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAs?$AAe?$AAt?$AA?5?$AAx?$AA2?$AA6?$AA4?$AA?5?$AAp?$AAr?$AAo?$AAf?$AAi?$AAl?$AAe?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1DO@JLMBLODN@?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAs?$AAe?$AAt?$AA?5?$AAx?$AA2?$AA6?$AA4?$AA?5?$AAp?$AAr?$AAo?$AAf?$AAi?$AAl?$AAe?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?$AA@ DB 'F'
	DB	00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H, ' ', 00H
	DB	't', 00H, 'o', 00H, ' ', 00H, 's', 00H, 'e', 00H, 't', 00H, ' '
	DB	00H, 'x', 00H, '2', 00H, '6', 00H, '4', 00H, ' ', 00H, 'p', 00H
	DB	'r', 00H, 'o', 00H, 'f', 00H, 'i', 00H, 'l', 00H, 'e', 00H, ':'
	DB	00H, ' ', 00H, '%', 00H, 's', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1EI@KKIIHNLA@?$AAT?$AAh?$AAe?$AA?5?$AAc?$AAu?$AAs?$AAt?$AAo?$AAm?$AA?5?$AAx?$AA2?$AA6?$AA4?$AA?5?$AAc?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AA?5?$AA?8?$AA?$CF?$AAs?$AA?8?$AA?5?$AAf?$AAa?$AAi@
CONST	SEGMENT
??_C@_1EI@KKIIHNLA@?$AAT?$AAh?$AAe?$AA?5?$AAc?$AAu?$AAs?$AAt?$AAo?$AAm?$AA?5?$AAx?$AA2?$AA6?$AA4?$AA?5?$AAc?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AA?5?$AA?8?$AA?$CF?$AAs?$AA?8?$AA?5?$AAf?$AAa?$AAi@ DB 'T'
	DB	00H, 'h', 00H, 'e', 00H, ' ', 00H, 'c', 00H, 'u', 00H, 's', 00H
	DB	't', 00H, 'o', 00H, 'm', 00H, ' ', 00H, 'x', 00H, '2', 00H, '6'
	DB	00H, '4', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'm', 00H
	DB	'a', 00H, 'n', 00H, 'd', 00H, ' ', 00H, '''', 00H, '%', 00H, 's'
	DB	00H, '''', 00H, ' ', 00H, 'f', 00H, 'a', 00H, 'i', 00H, 'l', 00H
	DB	'e', 00H, 'd', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1KE@FCEDOHCD@?$AAT?$AAh?$AAe?$AA?5?$AAc?$AAu?$AAs?$AAt?$AAo?$AAm?$AA?5?$AAx?$AA2?$AA6?$AA4?$AA?5?$AAc?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AA?5?$AA?8?$AA?$CF?$AAs?$AA?8?$AA?5?$AAi?$AAs?$AA?5@
CONST	SEGMENT
??_C@_1KE@FCEDOHCD@?$AAT?$AAh?$AAe?$AA?5?$AAc?$AAu?$AAs?$AAt?$AAo?$AAm?$AA?5?$AAx?$AA2?$AA6?$AA4?$AA?5?$AAc?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AA?5?$AA?8?$AA?$CF?$AAs?$AA?8?$AA?5?$AAi?$AAs?$AA?5@ DB 'T'
	DB	00H, 'h', 00H, 'e', 00H, ' ', 00H, 'c', 00H, 'u', 00H, 's', 00H
	DB	't', 00H, 'o', 00H, 'm', 00H, ' ', 00H, 'x', 00H, '2', 00H, '6'
	DB	00H, '4', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'm', 00H
	DB	'a', 00H, 'n', 00H, 'd', 00H, ' ', 00H, '''', 00H, '%', 00H, 's'
	DB	00H, '''', 00H, ' ', 00H, 'i', 00H, 's', 00H, ' ', 00H, 'u', 00H
	DB	'n', 00H, 's', 00H, 'u', 00H, 'p', 00H, 'p', 00H, 'o', 00H, 'r'
	DB	00H, 't', 00H, 'e', 00H, 'd', 00H, ',', 00H, ' ', 00H, 'u', 00H
	DB	's', 00H, 'e', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'e', 00H, ' '
	DB	00H, 'a', 00H, 'p', 00H, 'p', 00H, 'l', 00H, 'i', 00H, 'c', 00H
	DB	'a', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, ' ', 00H, 's'
	DB	00H, 'e', 00H, 't', 00H, 't', 00H, 'i', 00H, 'n', 00H, 'g', 00H
	DB	's', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 's', 00H, 't', 00H, 'e'
	DB	00H, 'a', 00H, 'd', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@KJGOOJHK@?$AAf?$AAo?$AAr?$AAc?$AAe?$AA?9?$AAc?$AAf?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@KJGOOJHK@?$AAf?$AAo?$AAr?$AAc?$AAe?$AA?9?$AAc?$AAf?$AAr?$AA?$AA@ DB 'f'
	DB	00H, 'o', 00H, 'r', 00H, 'c', 00H, 'e', 00H, '-', 00H, 'c', 00H
	DB	'f', 00H, 'r', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_17POPBILBJ@?$AAf?$AAp?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_17POPBILBJ@?$AAf?$AAp?$AAs?$AA?$AA@ DB 'f', 00H, 'p', 00H, 's', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@OGDCGAII@?$AAP?$AAa?$AAd?$AAC?$AAB?$AAR?$AA?$AA@
CONST	SEGMENT
??_C@_1O@OGDCGAII@?$AAP?$AAa?$AAd?$AAC?$AAB?$AAR?$AA?$AA@ DB 'P', 00H, 'a'
	DB	00H, 'd', 00H, 'C', 00H, 'B', 00H, 'R', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EG@DKNJMDPM@?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAs?$AAe?$AAt?$AA?5?$AAx?$AA2?$AA6?$AA4?$AA?5?$AAd?$AAe?$AAf?$AAa?$AAu?$AAl?$AAt?$AAs?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?1@
CONST	SEGMENT
??_C@_1EG@DKNJMDPM@?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAs?$AAe?$AAt?$AA?5?$AAx?$AA2?$AA6?$AA4?$AA?5?$AAd?$AAe?$AAf?$AAa?$AAu?$AAl?$AAt?$AAs?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?1@ DB 'F'
	DB	00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H, ' ', 00H
	DB	't', 00H, 'o', 00H, ' ', 00H, 's', 00H, 'e', 00H, 't', 00H, ' '
	DB	00H, 'x', 00H, '2', 00H, '6', 00H, '4', 00H, ' ', 00H, 'd', 00H
	DB	'e', 00H, 'f', 00H, 'a', 00H, 'u', 00H, 'l', 00H, 't', 00H, 's'
	DB	00H, ':', 00H, ' ', 00H, '%', 00H, 's', 00H, '/', 00H, '%', 00H
	DB	's', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@DIKLJDHA@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAp?$AAr?$AAo?$AAf?$AAi?$AAl?$AAe?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@DIKLJDHA@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAp?$AAr?$AAo?$AAf?$AAi?$AAl?$AAe?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?$AA@ DB 'i'
	DB	00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H
	DB	' ', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, ':', 00H, ' ', 00H, '%', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BA@PNHGIEJF@?$AAp?$AAr?$AAo?$AAf?$AAi?$AAl?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BA@PNHGIEJF@?$AAp?$AAr?$AAo?$AAf?$AAi?$AAl?$AAe?$AA?$AA@ DB 'p', 00H
	DB	'r', 00H, 'o', 00H, 'f', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@IEINPIEO@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAt?$AAu?$AAn?$AAe?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@IEINPIEO@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAt?$AAu?$AAn?$AAe?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?$AA@ DB 'i'
	DB	00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'u', 00H, 'n', 00H, 'e', 00H, ':', 00H, ' '
	DB	00H, '%', 00H, 's', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_19DJGBEEIE@?$AAt?$AAu?$AAn?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_19DJGBEEIE@?$AAt?$AAu?$AAn?$AAe?$AA?$AA@ DB 't', 00H, 'u', 00H, 'n', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@DMGFBGHB@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAp?$AAr?$AAe?$AAs?$AAe?$AAt?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@DMGFBGHB@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAp?$AAr?$AAe?$AAs?$AAe?$AAt?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?$AA@ DB 'i'
	DB	00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H
	DB	' ', 00H, 'p', 00H, 'r', 00H, 'e', 00H, 's', 00H, 'e', 00H, 't'
	DB	00H, ':', 00H, ' ', 00H, '%', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@KFCPNKHD@?$AAp?$AAr?$AAe?$AAs?$AAe?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1O@KFCPNKHD@?$AAp?$AAr?$AAe?$AAs?$AAe?$AAt?$AA?$AA@ DB 'p', 00H, 'r'
	DB	00H, 'e', 00H, 's', 00H, 'e', 00H, 't', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EC@MHGNNJDA@?$AAU?$AAs?$AAi?$AAn?$AAg?$AA?5?$AAc?$AAu?$AAs?$AAt?$AAo?$AAm?$AA?5?$AAx?$AA2?$AA6?$AA4?$AA?5?$AAs?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AAs?$AA?3?$AA?5?$AA?$CC?$AA?$CF?$AAs?$AA?$CC@
CONST	SEGMENT
??_C@_1EC@MHGNNJDA@?$AAU?$AAs?$AAi?$AAn?$AAg?$AA?5?$AAc?$AAu?$AAs?$AAt?$AAo?$AAm?$AA?5?$AAx?$AA2?$AA6?$AA4?$AA?5?$AAs?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AAs?$AA?3?$AA?5?$AA?$CC?$AA?$CF?$AAs?$AA?$CC@ DB 'U'
	DB	00H, 's', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'c', 00H
	DB	'u', 00H, 's', 00H, 't', 00H, 'o', 00H, 'm', 00H, ' ', 00H, 'x'
	DB	00H, '2', 00H, '6', 00H, '4', 00H, ' ', 00H, 's', 00H, 'e', 00H
	DB	't', 00H, 't', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 's', 00H, ':'
	DB	00H, ' ', 00H, '"', 00H, '%', 00H, 's', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@FDMCHPPE@?$AAC?$AAu?$AAs?$AAt?$AAo?$AAm?$AAS?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@FDMCHPPE@?$AAC?$AAu?$AAs?$AAt?$AAo?$AAm?$AAS?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AAs?$AA?$AA@ DB 'C'
	DB	00H, 'u', 00H, 's', 00H, 't', 00H, 'o', 00H, 'm', 00H, 'S', 00H
	DB	'e', 00H, 't', 00H, 't', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 's'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@BMPFFOPN@?$AAU?$AAs?$AAe?$AAC?$AAu?$AAs?$AAt?$AAo?$AAm?$AAS?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@BMPFFOPN@?$AAU?$AAs?$AAe?$AAC?$AAu?$AAs?$AAt?$AAo?$AAm?$AAS?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AAs?$AA?$AA@ DB 'U'
	DB	00H, 's', 00H, 'e', 00H, 'C', 00H, 'u', 00H, 's', 00H, 't', 00H
	DB	'o', 00H, 'm', 00H, 'S', 00H, 'e', 00H, 't', 00H, 't', 00H, 'i'
	DB	00H, 'n', 00H, 'g', 00H, 's', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_11LOCGONAA@?$AA?$AA@
CONST	SEGMENT
??_C@_11LOCGONAA@?$AA?$AA@ DB 00H, 00H			; `string'
$SG4294864381 DB 00H
$SG4294864378 DB 00H
$SG4294864371 DB 00H
$SG4294864368 DB 00H
$SG4294864352 DB 00H
	ORG $+2
$SG4294864402 DB 'temporal', 00H
	ORG $+2
$SG4294864403 DB 'spatial', 00H
$SG4294864400 DB 'dia', 00H
	ORG $+2
$SG4294864398 DB 'umh', 00H
$SG4294864399 DB 'hex', 00H
	ORG $+2
$SG4294864397 DB 'esa', 00H
$SG4294864388 DB 'pal', 00H
	ORG $+2
$SG4294864404 DB 'none', 00H
	ORG $+3
$SG4294864401 DB 'auto', 00H
	ORG $+3
$SG4294864396 DB 'tesa', 00H
	ORG $+3
$SG4294864394 DB 'strict', 00H
	ORG $+1
$SG4294864395 DB 'none', 00H
	ORG $+3
$SG4294864392 DB 'undef', 00H
	ORG $+2
$SG4294864393 DB 'normal', 00H
	ORG $+1
$SG4294864390 DB 'crop', 00H
	ORG $+3
$SG4294864391 DB 'show', 00H
	ORG $+3
$SG4294864389 DB 'component', 00H
	ORG $+2
$SG4294864386 DB 'secam', 00H
	ORG $+2
$SG4294864387 DB 'ntsc', 00H
	ORG $+3
$SG4294864384 DB 'undef', 00H
	ORG $+2
$SG4294864385 DB 'mac', 00H
$SG4294864382 DB 'on', 00H
	ORG $+1
$SG4294864383 DB 'off', 00H
$SG4294864380 DB 'bt709', 00H
	ORG $+2
$SG4294864379 DB 'undef', 00H
	ORG $+2
$SG4294864376 DB 'bt470bg', 00H
$SG4294864377 DB 'bt470m', 00H
	ORG $+1
$SG4294864374 DB 'smpte240m', 00H
	ORG $+2
$SG4294864375 DB 'smpte170m', 00H
	ORG $+2
$SG4294864372 DB 'bt2020', 00H
	ORG $+1
$SG4294864373 DB 'film', 00H
	ORG $+3
$SG4294864370 DB 'bt709', 00H
	ORG $+2
$SG4294864369 DB 'undef', 00H
	ORG $+2
$SG4294864366 DB 'bt470bg', 00H
$SG4294864367 DB 'bt470m', 00H
	ORG $+1
$SG4294864364 DB 'smpte240m', 00H
	ORG $+2
$SG4294864365 DB 'smpte170m', 00H
	ORG $+2
$SG4294864362 DB 'log100', 00H
	ORG $+1
$SG4294864363 DB 'linear', 00H
	ORG $+1
$SG4294864360 DB 'iec61966-2-4', 00H
	ORG $+3
$SG4294864361 DB 'log316', 00H
	ORG $+1
$SG4294864358 DB 'iec61966-2-1', 00H
	ORG $+3
$SG4294864359 DB 'bt1361e', 00H
$SG4294864356 DB 'bt2020-12', 00H
	ORG $+2
$SG4294864357 DB 'bt2020-10', 00H
	ORG $+2
$SG4294864354 DB 'bt709', 00H
	ORG $+2
$SG4294864355 DB 'GBR', 00H
$SG4294864353 DB 'undef', 00H
	ORG $+2
$SG4294864350 DB 'bt470bg', 00H
$SG4294864351 DB 'fcc', 00H
$SG4294864348 DB 'smpte240m', 00H
	ORG $+2
$SG4294864349 DB 'smpte170m', 00H
	ORG $+2
$SG4294864346 DB 'bt2020nc', 00H
	ORG $+3
$SG4294864347 DB 'YCgCo', 00H
	ORG $+2
$SG4294864344 DB 'none', 00H
	ORG $+3
$SG4294864345 DB 'bt2020c', 00H
$SG4294864342 DB 'cbr', 00H
$SG4294864343 DB 'vbr', 00H
$SG4294864340 DB 'superfast', 00H
	ORG $+2
$SG4294864341 DB 'ultrafast', 00H
	ORG $+2
$SG4294864338 DB 'faster', 00H
	ORG $+1
$SG4294864339 DB 'veryfast', 00H
	ORG $+3
$SG4294864336 DB 'medium', 00H
	ORG $+1
$SG4294864337 DB 'fast', 00H
	ORG $+3
$SG4294864334 DB 'slower', 00H
	ORG $+1
$SG4294864335 DB 'slow', 00H
	ORG $+3
$SG4294864332 DB 'placebo', 00H
$SG4294864333 DB 'veryslow', 00H
	ORG $+3
$SG4294864330 DB 'animation', 00H
	ORG $+2
$SG4294864331 DB 'film', 00H
	ORG $+3
$SG4294864328 DB 'stillimage', 00H
	ORG $+1
$SG4294864329 DB 'grain', 00H
	ORG $+2
$SG4294864326 DB 'ssim', 00H
	ORG $+3
$SG4294864327 DB 'psnr', 00H
	ORG $+3
$SG4294864324 DB 'zerolatency', 00H
$SG4294864325 DB 'fastdecode', 00H
	ORG $+1
$SG4294864322 DB 'main', 00H
	ORG $+3
$SG4294864323 DB 'baseline', 00H
	ORG $+3
$SG4294864320 DB 'high10', 00H
	ORG $+1
$SG4294864321 DB 'high', 00H
	ORG $+3
$SG4294864318 DB 'high444', 00H
$SG4294864319 DB 'high422', 00H
$SG4294864316 DB '%', 00H, 'S', 00H, 00H, 00H
	ORG $+2
$SG4294864317 DB 'x', 00H, '2', 00H, '6', 00H, '4', 00H, ':', 00H, ' ', 00H
	DB	00H, 00H
	ORG $+2
$SG4294864314 DB 00H, 00H
	ORG $+2
$SG4294864315 DB '%', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG4294864312 DB 00H, 00H
	ORG $+2
$SG4294864313 DB 0dH, 00H, 00H, 00H
$SG4294864311 DB 0aH, 00H, 00H, 00H
$SG4294864310 DB 'x', 00H, '2', 00H, '6', 00H, '4', 00H, ':', 00H, ' ', 00H
	DB	'O', 00H, 'p', 00H, 'e', 00H, 'n', 00H, 'C', 00H, 'L', 00H, ':'
	DB	00H, ' ', 00H, 'f', 00H, 'a', 00H, 't', 00H, 'a', 00H, 'l', 00H
	DB	' ', 00H, 'e', 00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H, ','
	DB	00H, ' ', 00H, 'a', 00H, 'b', 00H, 'o', 00H, 'r', 00H, 't', 00H
	DB	'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'e', 00H, 'n', 00H, 'c'
	DB	00H, 'o', 00H, 'd', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG4294864308 DB 'A', 00H, 'b', 00H, 'o', 00H, 'r', 00H, 't', 00H, 'i', 00H
	DB	'n', 00H, 'g', 00H, ' ', 00H, 's', 00H, 't', 00H, 'r', 00H, 'e'
	DB	00H, 'a', 00H, 'm', 00H, ' ', 00H, 'd', 00H, 'u', 00H, 'e', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'x', 00H, '2', 00H, '6'
	DB	00H, '4', 00H, ' ', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'n', 00H
	DB	'c', 00H, 'l', 00H, ' ', 00H, 'e', 00H, 'r', 00H, 'r', 00H, 'o'
	DB	00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG4294864309 DB 'x', 00H, '2', 00H, '6', 00H, '4', 00H, ':', 00H, ' ', 00H
	DB	'O', 00H, 'p', 00H, 'e', 00H, 'n', 00H, 'C', 00H, 'L', 00H, ':'
	DB	00H, ' ', 00H, 'I', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H
	DB	'i', 00H, 'd', 00H, ' ', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'u'
	DB	00H, 'e', 00H, '.', 00H, 00H, 00H
	ORG $+2
$SG4294864307 DB 'x', 00H, '2', 00H, '6', 00H, '4', 00H, ' ', 00H, 'O', 00H
	DB	'p', 00H, 'e', 00H, 'n', 00H, 'C', 00H, 'L', 00H, ' ', 00H, 'E'
	DB	00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H, 0dH, 00H, 0aH, 00H
	DB	0dH, 00H, 0aH, 00H, 'x', 00H, '2', 00H, '6', 00H, '4', 00H, ' '
	DB	00H, 'e', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'u', 00H, 'n', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'a'
	DB	00H, 'n', 00H, ' ', 00H, 'e', 00H, 'r', 00H, 'r', 00H, 'o', 00H
	DB	'r', 00H, ' ', 00H, 'a', 00H, 't', 00H, 't', 00H, 'e', 00H, 'm'
	DB	00H, 'p', 00H, 't', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H
	DB	't', 00H, 'o', 00H, ' ', 00H, 'u', 00H, 's', 00H, 'e', 00H, ' '
	DB	00H, 'O', 00H, 'p', 00H, 'e', 00H, 'n', 00H, 'C', 00H, 'L', 00H
	DB	'.', 00H, ' ', 00H, 'T', 00H, 'h', 00H, 'i', 00H, 's', 00H, ' '
	DB	00H, 'm', 00H, 'a', 00H, 'y', 00H, ' ', 00H, 'b', 00H, 'e', 00H
	DB	' ', 00H, 'd', 00H, 'u', 00H, 'e', 00H, ' ', 00H, 't', 00H, 'o'
	DB	00H, ' ', 00H, 'u', 00H, 'n', 00H, 's', 00H, 'u', 00H, 'p', 00H
	DB	'p', 00H, 'o', 00H, 'r', 00H, 't', 00H, 'e', 00H, 'd', 00H, ' '
	DB	00H, 'h', 00H, 'a', 00H, 'r', 00H, 'd', 00H, 'w', 00H, 'a', 00H
	DB	'r', 00H, 'e', 00H, ' ', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'o'
	DB	00H, 'u', 00H, 't', 00H, 'd', 00H, 'a', 00H, 't', 00H, 'e', 00H
	DB	'd', 00H, ' ', 00H, 'd', 00H, 'r', 00H, 'i', 00H, 'v', 00H, 'e'
	DB	00H, 'r', 00H, 's', 00H, '.', 00H, 0dH, 00H, 0aH, 00H, 0dH, 00H
	DB	0aH, 00H, 'I', 00H, 't', 00H, ' ', 00H, 'i', 00H, 's', 00H, ' '
	DB	00H, 'r', 00H, 'e', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'm', 00H
	DB	'e', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 't'
	DB	00H, 'h', 00H, 'a', 00H, 't', 00H, ' ', 00H, 'y', 00H, 'o', 00H
	DB	'u', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'v'
	DB	00H, 'e', 00H, ' ', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'n', 00H
	DB	'c', 00H, 'l', 00H, '=', 00H, 't', 00H, 'r', 00H, 'u', 00H, 'e'
	DB	00H, ' ', 00H, 'f', 00H, 'r', 00H, 'o', 00H, 'm', 00H, ' ', 00H
	DB	'y', 00H, 'o', 00H, 'u', 00H, 'r', 00H, ' ', 00H, 'x', 00H, '2'
	DB	00H, '6', 00H, '4', 00H, ' ', 00H, 'a', 00H, 'd', 00H, 'v', 00H
	DB	'a', 00H, 'n', 00H, 'c', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 's'
	DB	00H, 'e', 00H, 't', 00H, 't', 00H, 'i', 00H, 'n', 00H, 'g', 00H
	DB	's', 00H, '.', 00H, 00H, 00H
	ORG $+2
_baseCRF DD	041b00000r			; 22
_x264_preset_names DD FLAT:$SG4294864341
	DD	FLAT:$SG4294864340
	DD	FLAT:$SG4294864339
	DD	FLAT:$SG4294864338
	DD	FLAT:$SG4294864337
	DD	FLAT:$SG4294864336
	DD	FLAT:$SG4294864335
	DD	FLAT:$SG4294864334
	DD	FLAT:$SG4294864333
	DD	FLAT:$SG4294864332
	DD	00H
_x264_profile_names DD FLAT:$SG4294864323
	DD	FLAT:$SG4294864322
	DD	FLAT:$SG4294864321
	DD	FLAT:$SG4294864320
	DD	FLAT:$SG4294864319
	DD	FLAT:$SG4294864318
	DD	00H
_x264_tune_names DD FLAT:$SG4294864331
	DD	FLAT:$SG4294864330
	DD	FLAT:$SG4294864329
	DD	FLAT:$SG4294864328
	DD	FLAT:$SG4294864327
	DD	FLAT:$SG4294864326
	DD	FLAT:$SG4294864325
	DD	FLAT:$SG4294864324
	DD	00H
PUBLIC	?CreateX264Encoder@@YAPAVVideoEncoder@@HHHHPB_W_NAAUColorDescription@@HH1@Z ; CreateX264Encoder
PUBLIC	??_GX264Encoder@@UAEPAXI@Z			; X264Encoder::`scalar deleting destructor'
PUBLIC	?HasBufferedFrames@X264Encoder@@UAE_NXZ		; X264Encoder::HasBufferedFrames
PUBLIC	?GetBufferedFrames@X264Encoder@@UAEHXZ		; X264Encoder::GetBufferedFrames
PUBLIC	?RequestKeyframe@X264Encoder@@UAEXXZ		; X264Encoder::RequestKeyframe
PUBLIC	?SetBitRate@X264Encoder@@UAE_NKK@Z		; X264Encoder::SetBitRate
PUBLIC	?DynamicBitrateSupported@X264Encoder@@UBE_NXZ	; X264Encoder::DynamicBitrateSupported
PUBLIC	?GetInfoString@X264Encoder@@UBE?AVString@@XZ	; X264Encoder::GetInfoString
PUBLIC	?GetBitRate@X264Encoder@@UBEHXZ			; X264Encoder::GetBitRate
PUBLIC	?GetSEI@X264Encoder@@UAEXAAUDataPacket@@@Z	; X264Encoder::GetSEI
PUBLIC	?GetHeaders@X264Encoder@@UAEXAAUDataPacket@@@Z	; X264Encoder::GetHeaders
PUBLIC	?Encode@X264Encoder@@UAE_NPAXAAV?$List@UDataPacket@@@@AAV?$List@W4PacketType@@@@KAAK@Z ; X264Encoder::Encode
PUBLIC	??1X264Encoder@@UAE@XZ				; X264Encoder::~X264Encoder
PUBLIC	??0X264Encoder@@QAE@HHHHPB_W_NAAUColorDescription@@HH1@Z ; X264Encoder::X264Encoder
PUBLIC	?SetBitRateParams@X264Encoder@@AAEXKK@Z		; X264Encoder::SetBitRateParams
PUBLIC	?ClearPackets@X264Encoder@@AAEXXZ		; X264Encoder::ClearPackets
PUBLIC	?valid_x264_string@@YA_NABVString@@PAPBD@Z	; valid_x264_string
PUBLIC	?get_x264_log@@YAXPAXHPBDPAD@Z			; get_x264_log
EXTRN	??_EX264Encoder@@UAEPAXI@Z:PROC			; X264Encoder::`vector deleting destructor'
	ALIGN	4

__Tuple_alloc DB 01H DUP (?)
	ALIGN	4

_ignore	DB	01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
	ALIGN	4

_piecewise_construct DB 01H DUP (?)
_BSS	ENDS
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
_ignore$initializer$ DD FLAT:??__Eignore@std@@YAXXZ
__Tuple_alloc$initializer$ DD FLAT:??__E_Tuple_alloc@std@@YAXXZ
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 70   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3451 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\tuple
;	COMDAT ??__Eignore@std@@YAXXZ
text$di	SEGMENT
??__Eignore@std@@YAXXZ PROC				; std::`dynamic initializer for 'ignore'', COMDAT

; 59   : const _Ignore ignore;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET _ignore
	call	??0_Ignore@std@@QAE@XZ			; std::_Ignore::_Ignore
	pop	ebp
	ret	0
??__Eignore@std@@YAXXZ ENDP				; std::`dynamic initializer for 'ignore''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\tuple
;	COMDAT ??__E_Tuple_alloc@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__E_Tuple_alloc@std@@YAXXZ PROC			; std::`dynamic initializer for '_Tuple_alloc'', COMDAT

; 66   : const _Tuple_alloc_t _Tuple_alloc = _Tuple_alloc_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__E_Tuple_alloc@std@@YAXXZ ENDP			; std::`dynamic initializer for '_Tuple_alloc''
text$di	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_x264.cpp
;	COMDAT ?get_x264_log@@YAXPAXHPBDPAD@Z
_TEXT	SEGMENT
$T1 = -16						; size = 8
_chi$ = -8						; size = 8
_param$ = 8						; size = 4
_i_level$ = 12						; size = 4
_psz$ = 16						; size = 4
_argptr$ = 20						; size = 4
?get_x264_log@@YAXPAXHPBDPAD@Z PROC			; get_x264_log, COMDAT

; 34   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 35   :     String chi;

	lea	ecx, DWORD PTR _chi$[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 36   : 
; 37   :     chi << TEXT("x264: ") << String(psz);

	mov	eax, DWORD PTR _psz$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PBD@Z
	push	eax
	push	OFFSET $SG4294864317
	lea	ecx, DWORD PTR _chi$[ebp]
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 38   :     chi.FindReplace(TEXT("%s"), TEXT("%S"));

	push	OFFSET $SG4294864316
	push	OFFSET $SG4294864315
	lea	ecx, DWORD PTR _chi$[ebp]
	call	DWORD PTR __imp_?FindReplace@String@@QAEAAV1@PB_W0@Z

; 39   : 
; 40   :     OSDebugOutva(chi, argptr);

	mov	ecx, DWORD PTR _argptr$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _chi$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?OSDebugOutva@@YAXPB_WPAD@Z
	add	esp, 8

; 41   : 
; 42   :     chi.FindReplace(TEXT("\r"), TEXT(""));

	push	OFFSET $SG4294864314
	push	OFFSET $SG4294864313
	lea	ecx, DWORD PTR _chi$[ebp]
	call	DWORD PTR __imp_?FindReplace@String@@QAEAAV1@PB_W0@Z

; 43   :     chi.FindReplace(TEXT("\n"), TEXT(""));

	push	OFFSET $SG4294864312
	push	OFFSET $SG4294864311
	lea	ecx, DWORD PTR _chi$[ebp]
	call	DWORD PTR __imp_?FindReplace@String@@QAEAAV1@PB_W0@Z

; 44   : 
; 45   :     if (chi == TEXT("x264: OpenCL: fatal error, aborting encode") || chi == TEXT("x264: OpenCL: Invalid value."))

	push	OFFSET $SG4294864310
	lea	ecx, DWORD PTR _chi$[ebp]
	call	DWORD PTR __imp_??8String@@QBEHPB_W@Z
	test	eax, eax
	jne	SHORT $LN2@get_x264_l
	push	OFFSET $SG4294864309
	lea	ecx, DWORD PTR _chi$[ebp]
	call	DWORD PTR __imp_??8String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN3@get_x264_l
$LN2@get_x264_l:

; 46   :     {
; 47   :         if (App->IsRunning())

	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?IsRunning@OBS@@QBE_NXZ			; OBS::IsRunning
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@get_x264_l

; 48   :         {
; 49   :             // FIXME: currently due to the way OBS handles the stream report, if reconnect is enabled and this error happens
; 50   :             // outside of the 30 second "no reconnect" window, no error dialog is shown to the user. usually x264 opencl errors
; 51   :             // will happen immediately though.
; 52   :             Log(TEXT("Aborting stream due to x264 opencl error"));

	push	OFFSET $SG4294864308
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 4

; 53   :             App->SetStreamReport(TEXT("x264 OpenCL Error\r\n\r\nx264 encountered an error attempting to use OpenCL. This may be due to unsupported hardware or outdated drivers.\r\n\r\nIt is recommended that you remove opencl=true from your x264 advanced settings."));

	push	OFFSET $SG4294864307
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?SetStreamReport@OBS@@QAEXPB_W@Z	; OBS::SetStreamReport

; 54   :             PostMessage(hwndMain, OBS_REQUESTSTOP, 1, 0);

	push	0
	push	1
	push	1025					; 00000401H
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	call	DWORD PTR __imp__PostMessageW@16
$LN3@get_x264_l:

; 55   :         }
; 56   :     }
; 57   : 
; 58   :     Logva(chi.Array(), argptr);

	mov	ecx, DWORD PTR _argptr$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _chi$[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?Logva@@YAXPB_WPAD@Z
	add	esp, 8

; 59   : }

	lea	ecx, DWORD PTR _chi$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
?get_x264_log@@YAXPAXHPBDPAD@Z ENDP			; get_x264_log
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_x264.cpp
;	COMDAT ?valid_x264_string@@YA_NABVString@@PAPBD@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
$T2 = -4						; size = 4
_str$ = 8						; size = 4
_x264StringList$ = 12					; size = 4
?valid_x264_string@@YA_NABVString@@PAPBD@Z PROC		; valid_x264_string, COMDAT

; 71   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
$LN4@valid_x264:

; 72   :     do
; 73   :     {
; 74   :         if(str.CompareI(String(*x264StringList)))

	mov	eax, DWORD PTR _x264StringList$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PBD@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	mov	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	mov	DWORD PTR $T2[ebp], eax
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN3@valid_x264

; 75   :             return true;

	mov	al, 1
	jmp	SHORT $LN5@valid_x264
$LN3@valid_x264:

; 76   :     } while (*++x264StringList != 0);

	mov	edx, DWORD PTR _x264StringList$[ebp]
	add	edx, 4
	mov	DWORD PTR _x264StringList$[ebp], edx
	mov	eax, DWORD PTR _x264StringList$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN4@valid_x264

; 77   : 
; 78   :     return false;

	xor	al, al
$LN5@valid_x264:

; 79   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?valid_x264_string@@YA_NABVString@@PAPBD@Z ENDP		; valid_x264_string
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_x264.cpp
;	COMDAT ?ClearPackets@X264Encoder@@AAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
?ClearPackets@X264Encoder@@AAEXXZ PROC			; X264Encoder::ClearPackets, COMDAT
; _this$ = ecx

; 112  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 113  :         for(UINT i=0; i<CurrentPackets.Num(); i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN3@ClearPacke
$LN2@ClearPacke:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN3@ClearPacke:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1120				; 00000460H
	call	?Num@?$List@UVideoPacket@@@@QBEIXZ	; List<VideoPacket>::Num
	cmp	DWORD PTR _i$1[ebp], eax
	jae	SHORT $LN1@ClearPacke

; 114  :             CurrentPackets[i].FreeData();

	mov	ecx, DWORD PTR _i$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1120				; 00000460H
	call	??A?$List@UVideoPacket@@@@QAEAAUVideoPacket@@I@Z ; List<VideoPacket>::operator[]
	mov	ecx, eax
	call	?FreeData@VideoPacket@@QAEXXZ		; VideoPacket::FreeData
	jmp	SHORT $LN2@ClearPacke
$LN1@ClearPacke:

; 115  :         CurrentPackets.Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1120				; 00000460H
	call	?Clear@?$List@UVideoPacket@@@@QAEXXZ	; List<VideoPacket>::Clear

; 116  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?ClearPackets@X264Encoder@@AAEXXZ ENDP			; X264Encoder::ClearPackets
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_x264.cpp
;	COMDAT ?SetBitRateParams@X264Encoder@@AAEXKK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_maxBitrate$ = 8					; size = 4
_bufferSize$ = 12					; size = 4
?SetBitRateParams@X264Encoder@@AAEXKK@Z PROC		; X264Encoder::SetBitRateParams, COMDAT
; _this$ = ecx

; 119  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  :         //-1 means ignore so we don't have to know both settings
; 121  : 
; 122  :         if (maxBitrate != -1)

	cmp	DWORD PTR _maxBitrate$[ebp], -1
	je	SHORT $LN3@SetBitRate

; 123  :             paramData.rc.i_vbv_max_bitrate  = maxBitrate; //vbv-maxrate

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _maxBitrate$[ebp]
	mov	DWORD PTR [eax+664], ecx
$LN3@SetBitRate:

; 124  : 
; 125  :         if (bufferSize != -1)

	cmp	DWORD PTR _bufferSize$[ebp], -1
	je	SHORT $LN2@SetBitRate

; 126  :             paramData.rc.i_vbv_buffer_size  = bufferSize; //vbv-bufsize

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _bufferSize$[ebp]
	mov	DWORD PTR [edx+668], eax
$LN2@SetBitRate:

; 127  : 
; 128  :         if(bUseCBR)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+1117]
	test	edx, edx
	je	SHORT $LN4@SetBitRate

; 129  :             paramData.rc.i_bitrate = maxBitrate;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _maxBitrate$[ebp]
	mov	DWORD PTR [eax+648], ecx
$LN4@SetBitRate:

; 130  :     }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetBitRateParams@X264Encoder@@AAEXKK@Z ENDP		; X264Encoder::SetBitRateParams
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_x264.cpp
;	COMDAT ??0X264Encoder@@QAE@HHHHPB_W_NAAUColorDescription@@HH1@Z
_TEXT	SEGMENT
_packet$ = -144						; size = 8
$T1 = -136						; size = 8
$T2 = -128						; size = 8
tv239 = -120						; size = 4
tv259 = -116						; size = 4
_bUseCustomParams$ = -112				; size = 4
_strParamVal$3 = -108					; size = 8
tv279 = -100						; size = 4
_strParamName$4 = -96					; size = 8
_strCustomParams$5 = -88				; size = 8
_lpVal$6 = -80						; size = 4
tv318 = -76						; size = 4
_keyframeInterval$ = -72				; size = 4
_lpPreset$ = -68					; size = 4
_lpParam$7 = -64					; size = 4
tv327 = -60						; size = 4
_strParamName$8 = -56					; size = 8
tv366 = -48						; size = 4
_lpTune$ = -44						; size = 4
_lpProfile$9 = -40					; size = 4
_strParam$10 = -36					; size = 4
_paramList$ = -32					; size = 8
_i$11 = -24						; size = 4
_strParamVal$12 = -20					; size = 8
_strParam$13 = -12					; size = 4
_i$14 = -8						; size = 4
_this$ = -4						; size = 4
_fps$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_quality$ = 20						; size = 4
_preset$ = 24						; size = 4
_bUse444$ = 28						; size = 1
_colorDesc$ = 32					; size = 4
_maxBitrate$ = 36					; size = 4
_bufferSize$ = 40					; size = 4
_bUseCFR$ = 44						; size = 1
??0X264Encoder@@QAE@HHHHPB_W_NAAUColorDescription@@HH1@Z PROC ; X264Encoder::X264Encoder, COMDAT
; _this$ = ecx

; 133  :     X264Encoder(int fps, int width, int height, int quality, CTSTR preset, bool bUse444, ColorDescription &colorDesc, int maxBitrate, int bufferSize, bool bUseCFR)

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0VideoEncoder@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7X264Encoder@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1092				; 00000444H
	call	DWORD PTR __imp_??0String@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1100				; 0000044cH
	call	DWORD PTR __imp_??0String@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1108				; 00000454H
	call	DWORD PTR __imp_??0String@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1120				; 00000460H
	call	??0?$List@UVideoPacket@@@@QAE@XZ	; List<VideoPacket>::List<VideoPacket>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1128				; 00000468H
	call	??0?$List@E@@QAE@XZ			; List<unsigned char>::List<unsigned char>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1136				; 00000470H
	call	??0?$List@E@@QAE@XZ			; List<unsigned char>::List<unsigned char>

; 134  :     {
; 135  :         curPreset = preset;

	mov	ecx, DWORD PTR _preset$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1092				; 00000444H
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z

; 136  : 
; 137  :         fps_ms = 1000/fps;

	mov	eax, 1000				; 000003e8H
	cdq
	idiv	DWORD PTR _fps$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1076], eax

; 138  : 
; 139  :         StringList paramList;

	lea	ecx, DWORD PTR _paramList$[ebp]
	call	DWORD PTR __imp_??0StringList@@QAE@XZ

; 140  : 
; 141  :         curProfile = AppConfig->GetString(TEXT("Video Encoding"), TEXT("X264Profile"), TEXT("high"));

	push	OFFSET ??_C@_19PKICIIJD@?$AAh?$AAi?$AAg?$AAh?$AA?$AA@
	push	OFFSET ??_C@_1BI@CHOFIDHM@?$AAX?$AA2?$AA6?$AA4?$AAP?$AAr?$AAo?$AAf?$AAi?$AAl?$AAe?$AA?$AA@
	push	OFFSET ??_C@_1BO@PCCCHKLK@?$AAV?$AAi?$AAd?$AAe?$AAo?$AA?5?$AAE?$AAn?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA?$AA@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetString@ConfigFile@@QAE?AVString@@PB_W00@Z
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1108				; 00000454H
	call	DWORD PTR __imp_??4String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 142  : 
; 143  :         BOOL bUseCustomParams = AppConfig->GetInt(TEXT("Video Encoding"), TEXT("UseCustomSettings"));

	push	0
	push	OFFSET ??_C@_1CE@BMPFFOPN@?$AAU?$AAs?$AAe?$AAC?$AAu?$AAs?$AAt?$AAo?$AAm?$AAS?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AAs?$AA?$AA@
	push	OFFSET ??_C@_1BO@PCCCHKLK@?$AAV?$AAi?$AAd?$AAe?$AAo?$AA?5?$AAE?$AAn?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA?$AA@
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _bUseCustomParams$[ebp], eax

; 144  :         if(bUseCustomParams)

	cmp	DWORD PTR _bUseCustomParams$[ebp], 0
	je	$LN36@X264Encode

; 145  :         {
; 146  :             String strCustomParams = AppConfig->GetString(TEXT("Video Encoding"), TEXT("CustomSettings"));

	push	0
	push	OFFSET ??_C@_1BO@FDMCHPPE@?$AAC?$AAu?$AAs?$AAt?$AAo?$AAm?$AAS?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AAs?$AA?$AA@
	push	OFFSET ??_C@_1BO@PCCCHKLK@?$AAV?$AAi?$AAd?$AAe?$AAo?$AA?5?$AAE?$AAn?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA?$AA@
	lea	ecx, DWORD PTR _strCustomParams$5[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetString@ConfigFile@@QAE?AVString@@PB_W00@Z

; 147  :             strCustomParams.KillSpaces();

	lea	ecx, DWORD PTR _strCustomParams$5[ebp]
	call	DWORD PTR __imp_?KillSpaces@String@@QAEAAV1@XZ

; 148  : 
; 149  :             if(strCustomParams.IsValid())

	lea	ecx, DWORD PTR _strCustomParams$5[ebp]
	call	DWORD PTR __imp_?IsValid@String@@QBEHXZ
	test	eax, eax
	je	$LN32@X264Encode

; 150  :             {
; 151  :                 Log(TEXT("Using custom x264 settings: \"%s\""), strCustomParams.Array());

	lea	ecx, DWORD PTR _strCustomParams$5[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET ??_C@_1EC@MHGNNJDA@?$AAU?$AAs?$AAi?$AAn?$AAg?$AA?5?$AAc?$AAu?$AAs?$AAt?$AAo?$AAm?$AA?5?$AAx?$AA2?$AA6?$AA4?$AA?5?$AAs?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AAs?$AA?3?$AA?5?$AA?$CC?$AA?$CF?$AAs?$AA?$CC@
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8

; 152  : 
; 153  :                 strCustomParams.GetTokenList(paramList, ' ', FALSE);

	push	0
	push	32					; 00000020H
	lea	edx, DWORD PTR _paramList$[ebp]
	push	edx
	lea	ecx, DWORD PTR _strCustomParams$5[ebp]
	call	DWORD PTR __imp_?GetTokenList@String@@QBEXAAVStringList@@_WH@Z

; 154  :                 for(UINT i=0; i<paramList.Num(); i++)

	mov	DWORD PTR _i$14[ebp], 0
	jmp	SHORT $LN34@X264Encode
$LN33@X264Encode:
	mov	eax, DWORD PTR _i$14[ebp]
	add	eax, 1
	mov	DWORD PTR _i$14[ebp], eax
$LN34@X264Encode:
	lea	ecx, DWORD PTR _paramList$[ebp]
	call	DWORD PTR __imp_?Num@?$List@VString@@@@QBEIXZ
	cmp	DWORD PTR _i$14[ebp], eax
	jae	$LN32@X264Encode

; 155  :                 {
; 156  :                     String &strParam = paramList[i];

	mov	ecx, DWORD PTR _i$14[ebp]
	push	ecx
	lea	ecx, DWORD PTR _paramList$[ebp]
	call	DWORD PTR __imp_??A?$List@VString@@@@QAEAAVString@@I@Z
	mov	DWORD PTR _strParam$10[ebp], eax

; 157  :                     if(!schr(strParam, '='))

	push	61					; 0000003dH
	mov	ecx, DWORD PTR _strParam$10[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?schr@@YGPA_WPB_W_W@Z
	test	eax, eax
	jne	SHORT $LN31@X264Encode

; 158  :                         continue;

	jmp	SHORT $LN33@X264Encode
$LN31@X264Encode:

; 159  : 
; 160  :                     String strParamName = strParam.GetToken(0, '=');

	push	61					; 0000003dH
	push	0
	lea	edx, DWORD PTR _strParamName$4[ebp]
	push	edx
	mov	ecx, DWORD PTR _strParam$10[ebp]
	call	DWORD PTR __imp_?GetToken@String@@QBE?AV1@H_W@Z

; 161  :                     String strParamVal  = strParam.GetTokenOffset(1, '=');

	push	61					; 0000003dH
	push	1
	mov	ecx, DWORD PTR _strParam$10[ebp]
	call	DWORD PTR __imp_?GetTokenOffset@String@@QBEPB_WH_W@Z
	push	eax
	lea	ecx, DWORD PTR _strParamVal$12[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PB_W@Z

; 162  : 
; 163  :                     if(strParamName.CompareI(TEXT("preset")))

	push	OFFSET ??_C@_1O@KFCPNKHD@?$AAp?$AAr?$AAe?$AAs?$AAe?$AAt?$AA?$AA@
	lea	ecx, DWORD PTR _strParamName$4[ebp]
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN30@X264Encode

; 164  :                     {
; 165  :                         if(valid_x264_string(strParamVal, (const char**)x264_preset_names))

	push	OFFSET _x264_preset_names
	lea	eax, DWORD PTR _strParamVal$12[ebp]
	push	eax
	call	?valid_x264_string@@YA_NABVString@@PAPBD@Z ; valid_x264_string
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN29@X264Encode

; 166  :                             curPreset = strParamVal;

	lea	edx, DWORD PTR _strParamVal$12[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1092				; 00000444H
	call	DWORD PTR __imp_??4String@@QAEAAV0@ABV0@@Z

; 167  :                         else

	jmp	SHORT $LN28@X264Encode
$LN29@X264Encode:

; 168  :                             Log(TEXT("invalid preset: %s"), strParamVal.Array());

	lea	ecx, DWORD PTR _strParamVal$12[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET ??_C@_1CG@DMGFBGHB@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAp?$AAr?$AAe?$AAs?$AAe?$AAt?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?$AA@
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8
$LN28@X264Encode:

; 169  : 
; 170  :                         paramList.Remove(i--);

	mov	eax, DWORD PTR _i$14[ebp]
	mov	DWORD PTR tv239[ebp], eax
	mov	ecx, DWORD PTR tv239[ebp]
	push	ecx
	lea	ecx, DWORD PTR _paramList$[ebp]
	call	DWORD PTR __imp_?Remove@StringList@@QAEXI@Z
	mov	edx, DWORD PTR _i$14[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$14[ebp], edx
	jmp	$LN22@X264Encode
$LN30@X264Encode:

; 171  :                     }
; 172  :                     else if(strParamName.CompareI(TEXT("tune")))

	push	OFFSET ??_C@_19DJGBEEIE@?$AAt?$AAu?$AAn?$AAe?$AA?$AA@
	lea	ecx, DWORD PTR _strParamName$4[ebp]
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN26@X264Encode

; 173  :                     {
; 174  :                         if(valid_x264_string(strParamVal, (const char**)x264_tune_names))

	push	OFFSET _x264_tune_names
	lea	eax, DWORD PTR _strParamVal$12[ebp]
	push	eax
	call	?valid_x264_string@@YA_NABVString@@PAPBD@Z ; valid_x264_string
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN25@X264Encode

; 175  :                             curTune = strParamVal;

	lea	edx, DWORD PTR _strParamVal$12[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1100				; 0000044cH
	call	DWORD PTR __imp_??4String@@QAEAAV0@ABV0@@Z

; 176  :                         else

	jmp	SHORT $LN24@X264Encode
$LN25@X264Encode:

; 177  :                             Log(TEXT("invalid tune: %s"), strParamVal.Array());

	lea	ecx, DWORD PTR _strParamVal$12[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET ??_C@_1CC@IEINPIEO@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAt?$AAu?$AAn?$AAe?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?$AA@
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8
$LN24@X264Encode:

; 178  : 
; 179  :                         paramList.Remove(i--);

	mov	eax, DWORD PTR _i$14[ebp]
	mov	DWORD PTR tv259[ebp], eax
	mov	ecx, DWORD PTR tv259[ebp]
	push	ecx
	lea	ecx, DWORD PTR _paramList$[ebp]
	call	DWORD PTR __imp_?Remove@StringList@@QAEXI@Z
	mov	edx, DWORD PTR _i$14[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$14[ebp], edx
	jmp	SHORT $LN22@X264Encode
$LN26@X264Encode:

; 180  :                     }
; 181  :                     else if(strParamName.CompareI(TEXT("profile")))

	push	OFFSET ??_C@_1BA@PNHGIEJF@?$AAp?$AAr?$AAo?$AAf?$AAi?$AAl?$AAe?$AA?$AA@
	lea	ecx, DWORD PTR _strParamName$4[ebp]
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN22@X264Encode

; 182  :                     {
; 183  :                         if(valid_x264_string(strParamVal, (const char **)x264_profile_names))

	push	OFFSET _x264_profile_names
	lea	eax, DWORD PTR _strParamVal$12[ebp]
	push	eax
	call	?valid_x264_string@@YA_NABVString@@PAPBD@Z ; valid_x264_string
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN21@X264Encode

; 184  :                             curProfile = strParamVal;

	lea	edx, DWORD PTR _strParamVal$12[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1108				; 00000454H
	call	DWORD PTR __imp_??4String@@QAEAAV0@ABV0@@Z

; 185  :                         else

	jmp	SHORT $LN20@X264Encode
$LN21@X264Encode:

; 186  :                             Log(TEXT("invalid profile: %s"), strParamVal.Array());

	lea	ecx, DWORD PTR _strParamVal$12[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET ??_C@_1CI@DIKLJDHA@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAp?$AAr?$AAo?$AAf?$AAi?$AAl?$AAe?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?$AA@
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8
$LN20@X264Encode:

; 187  : 
; 188  :                         paramList.Remove(i--);

	mov	eax, DWORD PTR _i$14[ebp]
	mov	DWORD PTR tv279[ebp], eax
	mov	ecx, DWORD PTR tv279[ebp]
	push	ecx
	lea	ecx, DWORD PTR _paramList$[ebp]
	call	DWORD PTR __imp_?Remove@StringList@@QAEXI@Z
	mov	edx, DWORD PTR _i$14[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$14[ebp], edx
$LN22@X264Encode:

; 189  :                     }
; 190  :                 }

	lea	ecx, DWORD PTR _strParamVal$12[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strParamName$4[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	jmp	$LN33@X264Encode
$LN32@X264Encode:

; 191  :             }
; 192  :         }

	lea	ecx, DWORD PTR _strCustomParams$5[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN36@X264Encode:

; 193  : 
; 194  :         zero(&paramData, sizeof(paramData));

	push	860					; 0000035cH
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	call	?zero@@YGXPAXI@Z			; zero

; 195  : 
; 196  :         LPSTR lpPreset = curPreset.CreateUTF8String();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1092				; 00000444H
	call	DWORD PTR __imp_?CreateUTF8String@String@@QAEPADXZ
	mov	DWORD PTR _lpPreset$[ebp], eax

; 197  :         LPSTR lpTune = curTune.CreateUTF8String();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1100				; 0000044cH
	call	DWORD PTR __imp_?CreateUTF8String@String@@QAEPADXZ
	mov	DWORD PTR _lpTune$[ebp], eax

; 198  : 
; 199  :         if (x264_param_default_preset(&paramData, lpPreset, lpTune))

	mov	ecx, DWORD PTR _lpTune$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpPreset$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	call	DWORD PTR __imp__x264_param_default_preset
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN19@X264Encode

; 200  :             Log(TEXT("Failed to set x264 defaults: %s/%s"), curPreset.Array(), curTune.Array());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1100				; 0000044cH
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1092				; 00000444H
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET ??_C@_1EG@DKNJMDPM@?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAs?$AAe?$AAt?$AA?5?$AAx?$AA2?$AA6?$AA4?$AA?5?$AAd?$AAe?$AAf?$AAa?$AAu?$AAl?$AAt?$AAs?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?1@
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 12					; 0000000cH
$LN19@X264Encode:

; 201  : 
; 202  :         Free(lpTune);

	mov	ecx, DWORD PTR _lpTune$[ebp]
	push	ecx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4

; 203  :         Free(lpPreset);

	mov	edx, DWORD PTR _lpPreset$[ebp]
	push	edx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4

; 204  : 
; 205  :         this->width  = width;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _width$[ebp]
	mov	DWORD PTR [eax+1084], ecx

; 206  :         this->height = height;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _height$[ebp]
	mov	DWORD PTR [edx+1088], eax

; 207  : 
; 208  :         paramData.b_deterministic       = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 209  : 
; 210  :         bUseCBR = AppConfig->GetInt(TEXT("Video Encoding"), TEXT("UseCBR"), 1) != 0;

	push	1
	push	OFFSET ??_C@_1O@GNHABGLI@?$AAU?$AAs?$AAe?$AAC?$AAB?$AAR?$AA?$AA@
	push	OFFSET ??_C@_1BO@PCCCHKLK@?$AAV?$AAi?$AAd?$AAe?$AAo?$AA?5?$AAE?$AAn?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA?$AA@
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	test	eax, eax
	je	SHORT $LN39@X264Encode
	mov	DWORD PTR tv318[ebp], 1
	jmp	SHORT $LN40@X264Encode
$LN39@X264Encode:
	mov	DWORD PTR tv318[ebp], 0
$LN40@X264Encode:
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR tv318[ebp]
	mov	BYTE PTR [edx+1117], al

; 211  :         bPadCBR = AppConfig->GetInt(TEXT("Video Encoding"), TEXT("PadCBR"), 1) != 0;

	push	1
	push	OFFSET ??_C@_1O@OGDCGAII@?$AAP?$AAa?$AAd?$AAC?$AAB?$AAR?$AA?$AA@
	push	OFFSET ??_C@_1BO@PCCCHKLK@?$AAV?$AAi?$AAd?$AAe?$AAo?$AA?5?$AAE?$AAn?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA?$AA@
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	test	eax, eax
	je	SHORT $LN41@X264Encode
	mov	DWORD PTR tv327[ebp], 1
	jmp	SHORT $LN42@X264Encode
$LN41@X264Encode:
	mov	DWORD PTR tv327[ebp], 0
$LN42@X264Encode:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR tv327[ebp]
	mov	BYTE PTR [ecx+1119], dl

; 212  :         this->bUseCFR = bUseCFR;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _bUseCFR$[ebp]
	mov	BYTE PTR [eax+1118], cl

; 213  : 
; 214  :         SetBitRateParams(maxBitrate, bufferSize);

	mov	edx, DWORD PTR _bufferSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _maxBitrate$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetBitRateParams@X264Encoder@@AAEXKK@Z	; X264Encoder::SetBitRateParams

; 215  : 
; 216  :         if(bUseCBR)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+1117]
	test	edx, edx
	je	SHORT $LN18@X264Encode

; 217  :         {
; 218  :             if(bPadCBR) paramData.rc.b_filler = 1;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1119]
	test	ecx, ecx
	je	SHORT $LN17@X264Encode
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+684], 1
$LN17@X264Encode:

; 219  :             //if(bPadCBR) paramData.i_nal_hrd = X264_NAL_HRD_CBR;
; 220  :             paramData.rc.i_rc_method    = X264_RC_ABR;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+628], 2

; 221  :             paramData.rc.f_rf_constant  = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+652], xmm0

; 222  :         }
; 223  :         else

	jmp	SHORT $LN16@X264Encode
$LN18@X264Encode:

; 224  :         {
; 225  :             paramData.rc.i_rc_method    = X264_RC_CRF;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+628], 1

; 226  :             paramData.rc.f_rf_constant  = baseCRF+float(10-quality);

	mov	eax, 10					; 0000000aH
	sub	eax, DWORD PTR _quality$[ebp]
	cvtsi2ss xmm0, eax
	addss	xmm0, DWORD PTR _baseCRF
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+652], xmm0
$LN16@X264Encode:

; 227  :         }
; 228  : 
; 229  :         UINT keyframeInterval = AppConfig->GetInt(TEXT("Video Encoding"), TEXT("KeyframeInterval"), 0);

	push	0
	push	OFFSET ??_C@_1CC@INKCNOFG@?$AAK?$AAe?$AAy?$AAf?$AAr?$AAa?$AAm?$AAe?$AAI?$AAn?$AAt?$AAe?$AAr?$AAv?$AAa?$AAl?$AA?$AA@
	push	OFFSET ??_C@_1BO@PCCCHKLK@?$AAV?$AAi?$AAd?$AAe?$AAo?$AA?5?$AAE?$AAn?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA?$AA@
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _keyframeInterval$[ebp], eax

; 230  : 
; 231  :         paramData.b_vfr_input           = !bUseCFR;

	movzx	edx, BYTE PTR _bUseCFR$[ebp]
	test	edx, edx
	jne	SHORT $LN43@X264Encode
	mov	DWORD PTR tv366[ebp], 1
	jmp	SHORT $LN44@X264Encode
$LN43@X264Encode:
	mov	DWORD PTR tv366[ebp], 0
$LN44@X264Encode:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR tv366[ebp]
	mov	DWORD PTR [eax+780], ecx

; 232  :         paramData.i_width               = width;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR [edx+32], eax

; 233  :         paramData.i_height              = height;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _height$[ebp]
	mov	DWORD PTR [ecx+36], edx

; 234  :         paramData.vui.b_fullrange       = colorDesc.fullRange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _colorDesc$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+72], edx

; 235  :         paramData.vui.i_colorprim       = colorDesc.primaries;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _colorDesc$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+76], edx

; 236  :         paramData.vui.i_transfer        = colorDesc.transfer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _colorDesc$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+80], edx

; 237  :         paramData.vui.i_colmatrix       = colorDesc.matrix;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _colorDesc$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+84], edx

; 238  : 
; 239  :         if (keyframeInterval)

	cmp	DWORD PTR _keyframeInterval$[ebp], 0
	je	SHORT $LN15@X264Encode

; 240  :             paramData.i_keyint_max      = fps*keyframeInterval;

	mov	eax, DWORD PTR _fps$[ebp]
	imul	eax, DWORD PTR _keyframeInterval$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+100], eax
$LN15@X264Encode:

; 241  : 
; 242  :         paramData.i_fps_num             = fps;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _fps$[ebp]
	mov	DWORD PTR [edx+788], eax

; 243  :         paramData.i_fps_den             = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+792], 1

; 244  : 
; 245  :         paramData.i_timebase_num        = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+796], 1

; 246  :         paramData.i_timebase_den        = 1000;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+800], 1000		; 000003e8H

; 247  : 
; 248  :         paramData.pf_log                = get_x264_log;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+500], OFFSET ?get_x264_log@@YAXPAXHPBDPAD@Z ; get_x264_log

; 249  :         paramData.i_log_level           = X264_LOG_WARNING;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+508], 1

; 250  : 
; 251  :         if (scmpi(curProfile, L"main") == 0)

	push	OFFSET ??_C@_19NACPGGMO@?$AAm?$AAa?$AAi?$AAn?$AA?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1108				; 00000454H
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?scmpi@@YGHPB_W0@Z
	test	eax, eax
	jne	SHORT $LN14@X264Encode

; 252  :             paramData.i_level_idc = 41; // to ensure compatibility with portable devices

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+44], 41			; 00000029H
$LN14@X264Encode:

; 253  : 
; 254  :         for (UINT i = 0; i<paramList.Num(); i++)

	mov	DWORD PTR _i$11[ebp], 0
	jmp	SHORT $LN13@X264Encode
$LN12@X264Encode:
	mov	ecx, DWORD PTR _i$11[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$11[ebp], ecx
$LN13@X264Encode:
	lea	ecx, DWORD PTR _paramList$[ebp]
	call	DWORD PTR __imp_?Num@?$List@VString@@@@QBEIXZ
	cmp	DWORD PTR _i$11[ebp], eax
	jae	$LN11@X264Encode

; 255  :         {
; 256  :             String &strParam = paramList[i];

	mov	edx, DWORD PTR _i$11[ebp]
	push	edx
	lea	ecx, DWORD PTR _paramList$[ebp]
	call	DWORD PTR __imp_??A?$List@VString@@@@QAEAAVString@@I@Z
	mov	DWORD PTR _strParam$13[ebp], eax

; 257  :             if(!schr(strParam, '='))

	push	61					; 0000003dH
	mov	ecx, DWORD PTR _strParam$13[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?schr@@YGPA_WPB_W_W@Z
	test	eax, eax
	jne	SHORT $LN10@X264Encode

; 258  :                 continue;

	jmp	SHORT $LN12@X264Encode
$LN10@X264Encode:

; 259  : 
; 260  :             String strParamName = strParam.GetToken(0, '=');

	push	61					; 0000003dH
	push	0
	lea	eax, DWORD PTR _strParamName$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _strParam$13[ebp]
	call	DWORD PTR __imp_?GetToken@String@@QBE?AV1@H_W@Z

; 261  :             String strParamVal  = strParam.GetTokenOffset(1, '=');

	push	61					; 0000003dH
	push	1
	mov	ecx, DWORD PTR _strParam$13[ebp]
	call	DWORD PTR __imp_?GetTokenOffset@String@@QBEPB_WH_W@Z
	push	eax
	lea	ecx, DWORD PTR _strParamVal$3[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PB_W@Z

; 262  : 
; 263  :             if( strParamName.CompareI(TEXT("fps")) || 
; 264  :                 strParamName.CompareI(TEXT("force-cfr")))

	push	OFFSET ??_C@_17POPBILBJ@?$AAf?$AAp?$AAs?$AA?$AA@
	lea	ecx, DWORD PTR _strParamName$8[ebp]
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	test	eax, eax
	jne	SHORT $LN8@X264Encode
	push	OFFSET ??_C@_1BE@KJGOOJHK@?$AAf?$AAo?$AAr?$AAc?$AAe?$AA?9?$AAc?$AAf?$AAr?$AA?$AA@
	lea	ecx, DWORD PTR _strParamName$8[ebp]
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN9@X264Encode
$LN8@X264Encode:

; 265  :             {
; 266  :                 Log(TEXT("The custom x264 command '%s' is unsupported, use the application settings instead"), strParam.Array());

	mov	ecx, DWORD PTR _strParam$13[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET ??_C@_1KE@FCEDOHCD@?$AAT?$AAh?$AAe?$AA?5?$AAc?$AAu?$AAs?$AAt?$AAo?$AAm?$AA?5?$AAx?$AA2?$AA6?$AA4?$AA?5?$AAc?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AA?5?$AA?8?$AA?$CF?$AAs?$AA?8?$AA?5?$AAi?$AAs?$AA?5@
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8

; 267  :                 continue;

	lea	ecx, DWORD PTR _strParamVal$3[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strParamName$8[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	jmp	$LN12@X264Encode

; 268  :             }
; 269  :             else

	jmp	SHORT $LN7@X264Encode
$LN9@X264Encode:

; 270  :             {
; 271  :                 LPSTR lpParam = strParamName.CreateUTF8String();

	lea	ecx, DWORD PTR _strParamName$8[ebp]
	call	DWORD PTR __imp_?CreateUTF8String@String@@QAEPADXZ
	mov	DWORD PTR _lpParam$7[ebp], eax

; 272  :                 LPSTR lpVal   = strParamVal.CreateUTF8String();

	lea	ecx, DWORD PTR _strParamVal$3[ebp]
	call	DWORD PTR __imp_?CreateUTF8String@String@@QAEPADXZ
	mov	DWORD PTR _lpVal$6[ebp], eax

; 273  : 
; 274  :                 if(x264_param_parse(&paramData, lpParam, lpVal) != 0)

	mov	ecx, DWORD PTR _lpVal$6[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpParam$7[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	call	DWORD PTR __imp__x264_param_parse
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@X264Encode

; 275  :                     Log(TEXT("The custom x264 command '%s' failed"), strParam.Array());

	mov	ecx, DWORD PTR _strParam$13[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET ??_C@_1EI@KKIIHNLA@?$AAT?$AAh?$AAe?$AA?5?$AAc?$AAu?$AAs?$AAt?$AAo?$AAm?$AA?5?$AAx?$AA2?$AA6?$AA4?$AA?5?$AAc?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AA?5?$AA?8?$AA?$CF?$AAs?$AA?8?$AA?5?$AAf?$AAa?$AAi@
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8
$LN6@X264Encode:

; 276  : 
; 277  :                 Free(lpParam);

	mov	ecx, DWORD PTR _lpParam$7[ebp]
	push	ecx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4

; 278  :                 Free(lpVal);

	mov	edx, DWORD PTR _lpVal$6[ebp]
	push	edx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4
$LN7@X264Encode:

; 279  :             }
; 280  :         }

	lea	ecx, DWORD PTR _strParamVal$3[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strParamName$8[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	jmp	$LN12@X264Encode
$LN11@X264Encode:

; 281  : 
; 282  :         if(bUse444) paramData.i_csp = X264_CSP_I444;

	movzx	eax, BYTE PTR _bUse444$[ebp]
	test	eax, eax
	je	SHORT $LN5@X264Encode
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+40], 8
	jmp	SHORT $LN4@X264Encode
$LN5@X264Encode:

; 283  :         else paramData.i_csp = X264_CSP_I420;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+40], 1
$LN4@X264Encode:

; 284  : 
; 285  :         colorDesc.fullRange = paramData.vui.b_fullrange;

	mov	eax, DWORD PTR _colorDesc$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR [eax], edx

; 286  :         colorDesc.primaries = paramData.vui.i_colorprim;

	mov	eax, DWORD PTR _colorDesc$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR [eax+4], edx

; 287  :         colorDesc.transfer  = paramData.vui.i_transfer;

	mov	eax, DWORD PTR _colorDesc$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	DWORD PTR [eax+8], edx

; 288  :         colorDesc.matrix    = paramData.vui.i_colmatrix;

	mov	eax, DWORD PTR _colorDesc$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR [eax+12], edx

; 289  : 
; 290  :         if (curProfile)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1108				; 00000454H
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	test	eax, eax
	je	SHORT $LN3@X264Encode

; 291  :         {
; 292  :             LPSTR lpProfile = curProfile.CreateUTF8String();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1108				; 00000454H
	call	DWORD PTR __imp_?CreateUTF8String@String@@QAEPADXZ
	mov	DWORD PTR _lpProfile$9[ebp], eax

; 293  : 
; 294  :             if (x264_param_apply_profile (&paramData, lpProfile))

	mov	eax, DWORD PTR _lpProfile$9[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	push	ecx
	call	DWORD PTR __imp__x264_param_apply_profile
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@X264Encode

; 295  :                 Log(TEXT("Failed to set x264 profile: %s"), curProfile.Array());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1108				; 00000454H
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET ??_C@_1DO@JLMBLODN@?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAs?$AAe?$AAt?$AA?5?$AAx?$AA2?$AA6?$AA4?$AA?5?$AAp?$AAr?$AAo?$AAf?$AAi?$AAl?$AAe?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?$AA@
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8
$LN2@X264Encode:

; 296  : 
; 297  :             Free(lpProfile);

	mov	edx, DWORD PTR _lpProfile$9[ebp]
	push	edx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4
$LN3@X264Encode:

; 298  :         }
; 299  : 
; 300  :         x264 = x264_encoder_open(&paramData);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	call	DWORD PTR __imp__x264_encoder_open_146
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+864], eax

; 301  :         if(!x264)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+864], 0
	jne	SHORT $LN1@X264Encode

; 302  :             CrashError(TEXT("Could not initialize x264"));

	push	OFFSET ??_C@_1DE@JDBGJCBN@?$AAC?$AAo?$AAu?$AAl?$AAd?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?5?$AAx?$AA2?$AA6?$AA4?$AA?$AA@
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ
$LN1@X264Encode:

; 303  : 
; 304  :         Log(TEXT("------------------------------------------"));

	push	OFFSET ??_C@_1FG@KNBPKHHL@?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9@
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 4

; 305  :         Log(TEXT("%s"), GetInfoString().Array());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetInfoString@X264Encoder@@UBE?AVString@@XZ ; X264Encoder::GetInfoString
	mov	ecx, eax
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 306  :         Log(TEXT("------------------------------------------"));

	push	OFFSET ??_C@_1FG@KNBPKHHL@?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9@
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 4

; 307  : 
; 308  :         DataPacket packet;
; 309  :         GetHeaders(packet);

	lea	ecx, DWORD PTR _packet$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetHeaders@X264Encoder@@UAEXAAUDataPacket@@@Z ; X264Encoder::GetHeaders

; 310  :     }

	lea	ecx, DWORD PTR _paramList$[ebp]
	call	DWORD PTR __imp_??1StringList@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
$LN38@X264Encode:
	mov	esp, ebp
	pop	ebp
	ret	40					; 00000028H
??0X264Encoder@@QAE@HHHHPB_W_NAAUColorDescription@@HH1@Z ENDP ; X264Encoder::X264Encoder
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_x264.cpp
;	COMDAT ??1X264Encoder@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1X264Encoder@@UAE@XZ PROC				; X264Encoder::~X264Encoder, COMDAT
; _this$ = ecx

; 313  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7X264Encoder@@6B@

; 314  :         ClearPackets();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearPackets@X264Encoder@@AAEXXZ	; X264Encoder::ClearPackets

; 315  :         x264_encoder_close(x264);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+864]
	push	edx
	call	DWORD PTR __imp__x264_encoder_close
	add	esp, 4

; 316  :     }

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1136				; 00000470H
	call	??1?$List@E@@QAE@XZ			; List<unsigned char>::~List<unsigned char>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1128				; 00000468H
	call	??1?$List@E@@QAE@XZ			; List<unsigned char>::~List<unsigned char>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1120				; 00000460H
	call	??1?$List@UVideoPacket@@@@QAE@XZ	; List<VideoPacket>::~List<VideoPacket>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1108				; 00000454H
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1100				; 0000044cH
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1092				; 00000444H
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1VideoEncoder@@UAE@XZ			; VideoEncoder::~VideoEncoder
	mov	esp, ebp
	pop	ebp
	ret	0
??1X264Encoder@@UAE@XZ ENDP				; X264Encoder::~X264Encoder
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_x264.cpp
;	COMDAT ?Encode@X264Encoder@@UAE_NPAXAAV?$List@UDataPacket@@@@AAV?$List@W4PacketType@@@@KAAK@Z
_TEXT	SEGMENT
_ts$ = -176						; size = 8
_packetOut$1 = -168					; size = 12
_packetOut$2 = -156					; size = 12
_packetOut$3 = -144					; size = 12
_packetOut$4 = -132					; size = 12
tv255 = -120						; size = 4
tv219 = -116						; size = 4
tv158 = -112						; size = 4
_timeOffsetAddr$ = -108					; size = 4
_nalOut$ = -104						; size = 4
tv343 = -100						; size = 4
_skipBytes$5 = -96					; size = 4
tv341 = -92						; size = 4
tv268 = -88						; size = 4
tv339 = -84						; size = 4
_newPayloadSize$6 = -80					; size = 4
tv337 = -76						; size = 4
_newPayloadSize$7 = -72					; size = 4
tv335 = -68						; size = 4
_skipBytes$8 = -64					; size = 4
_nalNum$ = -60						; size = 4
_i$9 = -56						; size = 4
_skip$10 = -52						; size = 4
_newPayloadSize$11 = -48				; size = 4
_skip$12 = -44						; size = 4
_skipBytes$13 = -40					; size = 4
_skip$14 = -36						; size = 4
_picIn$ = -32						; size = 4
$T15 = -26						; size = 1
$T16 = -25						; size = 1
_timeOffset$ = -24					; size = 4
_bFoundFrame$ = -17					; size = 1
_newPacket$ = -16					; size = 4
_bestType$ = -12					; size = 4
_nal$17 = -8						; size = 4
_this$ = -4						; size = 4
_picInPtr$ = 8						; size = 4
_packets$ = 12						; size = 4
_packetTypes$ = 16					; size = 4
_outputTimestamp$ = 20					; size = 4
_out_pts$ = 24						; size = 4
?Encode@X264Encoder@@UAE_NPAXAAV?$List@UDataPacket@@@@AAV?$List@W4PacketType@@@@KAAK@Z PROC ; X264Encoder::Encode, COMDAT
; _this$ = ecx

; 319  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 176				; 000000b0H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 320  :         x264_picture_t *picIn = (x264_picture_t*)picInPtr;

	mov	eax, DWORD PTR _picInPtr$[ebp]
	mov	DWORD PTR _picIn$[ebp], eax

; 321  : 
; 322  :         x264_nal_t *nalOut;
; 323  :         int nalNum;
; 324  : 
; 325  :         packets.Clear();

	mov	ecx, DWORD PTR _packets$[ebp]
	call	?Clear@?$List@UDataPacket@@@@QAEXXZ	; List<DataPacket>::Clear

; 326  :         ClearPackets();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearPackets@X264Encoder@@AAEXXZ	; X264Encoder::ClearPackets

; 327  : 
; 328  :         if(bRequestKeyframe && picIn)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+1080]
	test	edx, edx
	je	SHORT $LN34@Encode
	cmp	DWORD PTR _picIn$[ebp], 0
	je	SHORT $LN34@Encode

; 329  :             picIn->i_type = X264_TYPE_IDR;

	mov	eax, DWORD PTR _picIn$[ebp]
	mov	DWORD PTR [eax], 1
$LN34@Encode:

; 330  : 
; 331  :         if(x264_encoder_encode(x264, &nalOut, &nalNum, picIn, &picOut) < 0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 872				; 00000368H
	push	ecx
	mov	edx, DWORD PTR _picIn$[ebp]
	push	edx
	lea	eax, DWORD PTR _nalNum$[ebp]
	push	eax
	lea	ecx, DWORD PTR _nalOut$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+864]
	push	eax
	call	DWORD PTR __imp__x264_encoder_encode
	add	esp, 20					; 00000014H
	test	eax, eax
	jge	SHORT $LN33@Encode

; 332  :         {
; 333  :             AppWarning(TEXT("x264 encode failed"));

	push	OFFSET ??_C@_1CG@PCBENPOB@?$AAx?$AA2?$AA6?$AA4?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?$AA@
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 4

; 334  :             return false;

	xor	al, al
	jmp	$LN35@Encode
$LN33@Encode:

; 335  :         }
; 336  : 
; 337  :         if(bRequestKeyframe && picIn)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+1080]
	test	edx, edx
	je	SHORT $LN32@Encode
	cmp	DWORD PTR _picIn$[ebp], 0
	je	SHORT $LN32@Encode

; 338  :         {
; 339  :             picIn->i_type = X264_TYPE_AUTO;

	mov	eax, DWORD PTR _picIn$[ebp]
	mov	DWORD PTR [eax], 0

; 340  :             bRequestKeyframe = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1080], 0
$LN32@Encode:

; 341  :         }
; 342  : 
; 343  :         if(!bFirstFrameProcessed && nalNum)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+1116]
	test	eax, eax
	jne	SHORT $LN31@Encode
	cmp	DWORD PTR _nalNum$[ebp], 0
	je	SHORT $LN31@Encode

; 344  :         {
; 345  :             delayOffset = -picOut.i_dts;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+896]
	neg	edx
	mov	eax, DWORD PTR [ecx+900]
	adc	eax, 0
	neg	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1144], edx
	mov	DWORD PTR [ecx+1148], eax

; 346  :             bFirstFrameProcessed = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1116], 1
$LN31@Encode:

; 347  :         }
; 348  : 
; 349  :         INT64 ts = INT64(outputTimestamp);

	mov	eax, DWORD PTR _outputTimestamp$[ebp]
	xor	ecx, ecx
	mov	DWORD PTR _ts$[ebp], eax
	mov	DWORD PTR _ts$[ebp+4], ecx

; 350  :         int timeOffset;
; 351  : 
; 352  :         //if frame duplication is being used, the shift will be insignificant, so just don't bother adjusting audio
; 353  :         timeOffset = int(picOut.i_pts-picOut.i_dts);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+888]
	sub	ecx, DWORD PTR [eax+896]
	mov	edx, DWORD PTR [edx+892]
	sbb	edx, DWORD PTR [eax+900]
	mov	DWORD PTR _timeOffset$[ebp], ecx

; 354  :         timeOffset += frameShift;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _timeOffset$[ebp]
	add	ecx, DWORD PTR [eax+1152]
	mov	DWORD PTR _timeOffset$[ebp], ecx

; 355  : 
; 356  :         out_pts = (DWORD)picOut.i_pts;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+888]
	mov	ecx, DWORD PTR _out_pts$[ebp]
	mov	DWORD PTR [ecx], eax

; 357  : 
; 358  :         if(nalNum && timeOffset < 0)

	cmp	DWORD PTR _nalNum$[ebp], 0
	je	SHORT $LN30@Encode
	cmp	DWORD PTR _timeOffset$[ebp], 0
	jge	SHORT $LN30@Encode

; 359  :         {
; 360  :             frameShift -= timeOffset;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1152]
	sub	eax, DWORD PTR _timeOffset$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1152], eax

; 361  :             timeOffset = 0;

	mov	DWORD PTR _timeOffset$[ebp], 0
$LN30@Encode:

; 362  :         }
; 363  : 
; 364  :         //OSDebugOut(TEXT("inpts: %005lld, dts: %005lld, pts: %005lld, timestamp: %005d, offset: %005d, newoffset: %005lld\n"), picIn->i_pts, picOut.i_dts, picOut.i_pts, outputTimestamp, timeOffset, picOut.i_pts-picOut.i_dts);
; 365  : 
; 366  :         timeOffset = htonl(timeOffset);

	mov	edx, DWORD PTR _timeOffset$[ebp]
	push	edx
	call	DWORD PTR __imp__htonl@4
	mov	DWORD PTR _timeOffset$[ebp], eax

; 367  : 
; 368  :         BYTE *timeOffsetAddr = ((BYTE*)&timeOffset)+1;

	lea	eax, DWORD PTR _timeOffset$[ebp+1]
	mov	DWORD PTR _timeOffsetAddr$[ebp], eax

; 369  : 
; 370  :         VideoPacket *newPacket = NULL;

	mov	DWORD PTR _newPacket$[ebp], 0

; 371  : 
; 372  :         PacketType bestType = PacketType_VideoDisposable;

	mov	DWORD PTR _bestType$[ebp], 0

; 373  :         bool bFoundFrame = false;

	mov	BYTE PTR _bFoundFrame$[ebp], 0

; 374  : 
; 375  :         for(int i=0; i<nalNum; i++)

	mov	DWORD PTR _i$9[ebp], 0
	jmp	SHORT $LN29@Encode
$LN28@Encode:
	mov	ecx, DWORD PTR _i$9[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$9[ebp], ecx
$LN29@Encode:
	mov	edx, DWORD PTR _i$9[ebp]
	cmp	edx, DWORD PTR _nalNum$[ebp]
	jge	$LN27@Encode

; 376  :         {
; 377  :             x264_nal_t &nal = nalOut[i];

	mov	eax, DWORD PTR _i$9[ebp]
	shl	eax, 5
	add	eax, DWORD PTR _nalOut$[ebp]
	mov	DWORD PTR _nal$17[ebp], eax

; 378  : 
; 379  :             if(nal.i_type == NAL_SEI)

	mov	ecx, DWORD PTR _nal$17[ebp]
	cmp	DWORD PTR [ecx+4], 6
	jne	$LN26@Encode

; 380  :             {
; 381  :                 BYTE *skip = nal.p_payload;

	mov	edx, DWORD PTR _nal$17[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _skip$14[ebp], eax
$LN25@Encode:

; 382  :                 while(*(skip++) != 0x1);

	mov	ecx, DWORD PTR _skip$14[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR tv158[ebp], edx
	mov	eax, DWORD PTR _skip$14[ebp]
	add	eax, 1
	mov	DWORD PTR _skip$14[ebp], eax
	cmp	DWORD PTR tv158[ebp], 1
	je	SHORT $LN24@Encode
	jmp	SHORT $LN25@Encode
$LN24@Encode:

; 383  :                 int skipBytes = (int)(skip-nal.p_payload);

	mov	ecx, DWORD PTR _nal$17[ebp]
	mov	edx, DWORD PTR _skip$14[ebp]
	sub	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _skipBytes$13[ebp], edx

; 384  : 
; 385  :                 int newPayloadSize = (nal.i_payload-skipBytes);

	mov	eax, DWORD PTR _nal$17[ebp]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR _skipBytes$13[ebp]
	mov	DWORD PTR _newPayloadSize$11[ebp], ecx

; 386  : 
; 387  :                 if (nal.p_payload[skipBytes+1] == 0x5) {

	mov	edx, DWORD PTR _nal$17[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _skipBytes$13[ebp]
	movzx	edx, BYTE PTR [eax+ecx+1]
	cmp	edx, 5
	jne	SHORT $LN23@Encode

; 388  :                     SEIData.Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1136				; 00000470H
	call	?Clear@?$List@E@@QAEXXZ			; List<unsigned char>::Clear

; 389  :                     BufferOutputSerializer packetOut(SEIData);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1136				; 00000470H
	push	eax
	lea	ecx, DWORD PTR _packetOut$4[ebp]
	call	DWORD PTR __imp_??0BufferOutputSerializer@@QAE@AAV?$List@E@@H@Z

; 390  : 
; 391  :                     packetOut.OutputDword(htonl(newPayloadSize));

	mov	ecx, DWORD PTR _newPayloadSize$11[ebp]
	push	ecx
	call	DWORD PTR __imp__htonl@4
	push	eax
	lea	ecx, DWORD PTR _packetOut$4[ebp]
	call	DWORD PTR __imp_?OutputDword@Serializer@@QAEAAV1@K@Z

; 392  :                     packetOut.Serialize(nal.p_payload+skipBytes, newPayloadSize);

	mov	edx, DWORD PTR _newPayloadSize$11[ebp]
	push	edx
	mov	eax, DWORD PTR _nal$17[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, DWORD PTR _skipBytes$13[ebp]
	push	ecx
	lea	ecx, DWORD PTR _packetOut$4[ebp]
	call	DWORD PTR __imp_?Serialize@BufferOutputSerializer@@UAEXPBXK@Z

; 393  :                 } else {

	lea	ecx, DWORD PTR _packetOut$4[ebp]
	call	DWORD PTR __imp_??1BufferOutputSerializer@@UAE@XZ
	jmp	SHORT $LN22@Encode
$LN23@Encode:

; 394  :                     if (!newPacket)

	cmp	DWORD PTR _newPacket$[ebp], 0
	jne	SHORT $LN21@Encode

; 395  :                         newPacket = CurrentPackets.CreateNew();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1120				; 00000460H
	call	?CreateNew@?$List@UVideoPacket@@@@QAEPAUVideoPacket@@XZ ; List<VideoPacket>::CreateNew
	mov	DWORD PTR _newPacket$[ebp], eax
$LN21@Encode:

; 396  : 
; 397  :                     BufferOutputSerializer packetOut(newPacket->Packet);

	push	1
	mov	edx, DWORD PTR _newPacket$[ebp]
	push	edx
	lea	ecx, DWORD PTR _packetOut$3[ebp]
	call	DWORD PTR __imp_??0BufferOutputSerializer@@QAE@AAV?$List@E@@H@Z

; 398  : 
; 399  :                     packetOut.OutputDword(htonl(newPayloadSize));

	mov	eax, DWORD PTR _newPayloadSize$11[ebp]
	push	eax
	call	DWORD PTR __imp__htonl@4
	push	eax
	lea	ecx, DWORD PTR _packetOut$3[ebp]
	call	DWORD PTR __imp_?OutputDword@Serializer@@QAEAAV1@K@Z

; 400  :                     packetOut.Serialize(nal.p_payload+skipBytes, newPayloadSize);

	mov	ecx, DWORD PTR _newPayloadSize$11[ebp]
	push	ecx
	mov	edx, DWORD PTR _nal$17[ebp]
	mov	eax, DWORD PTR [edx+24]
	add	eax, DWORD PTR _skipBytes$13[ebp]
	push	eax
	lea	ecx, DWORD PTR _packetOut$3[ebp]
	call	DWORD PTR __imp_?Serialize@BufferOutputSerializer@@UAEXPBXK@Z

; 401  :                 }

	lea	ecx, DWORD PTR _packetOut$3[ebp]
	call	DWORD PTR __imp_??1BufferOutputSerializer@@UAE@XZ
$LN22@Encode:
	jmp	$LN20@Encode
$LN26@Encode:

; 402  :             }
; 403  :             else if(nal.i_type == NAL_FILLER)

	mov	ecx, DWORD PTR _nal$17[ebp]
	cmp	DWORD PTR [ecx+4], 12			; 0000000cH
	jne	$LN19@Encode

; 404  :             {
; 405  :                 BYTE *skip = nal.p_payload;

	mov	edx, DWORD PTR _nal$17[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _skip$12[ebp], eax
$LN18@Encode:

; 406  :                 while(*(skip++) != 0x1);

	mov	ecx, DWORD PTR _skip$12[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR tv219[ebp], edx
	mov	eax, DWORD PTR _skip$12[ebp]
	add	eax, 1
	mov	DWORD PTR _skip$12[ebp], eax
	cmp	DWORD PTR tv219[ebp], 1
	je	SHORT $LN17@Encode
	jmp	SHORT $LN18@Encode
$LN17@Encode:

; 407  :                 int skipBytes = (int)(skip-nal.p_payload);

	mov	ecx, DWORD PTR _nal$17[ebp]
	mov	edx, DWORD PTR _skip$12[ebp]
	sub	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _skipBytes$8[ebp], edx

; 408  : 
; 409  :                 int newPayloadSize = (nal.i_payload-skipBytes);

	mov	eax, DWORD PTR _nal$17[ebp]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR _skipBytes$8[ebp]
	mov	DWORD PTR _newPayloadSize$7[ebp], ecx

; 410  : 
; 411  :                 if (!newPacket)

	cmp	DWORD PTR _newPacket$[ebp], 0
	jne	SHORT $LN16@Encode

; 412  :                     newPacket = CurrentPackets.CreateNew();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1120				; 00000460H
	call	?CreateNew@?$List@UVideoPacket@@@@QAEPAUVideoPacket@@XZ ; List<VideoPacket>::CreateNew
	mov	DWORD PTR _newPacket$[ebp], eax
$LN16@Encode:

; 413  : 
; 414  :                 BufferOutputSerializer packetOut(newPacket->Packet);

	push	1
	mov	edx, DWORD PTR _newPacket$[ebp]
	push	edx
	lea	ecx, DWORD PTR _packetOut$1[ebp]
	call	DWORD PTR __imp_??0BufferOutputSerializer@@QAE@AAV?$List@E@@H@Z

; 415  : 
; 416  :                 packetOut.OutputDword(htonl(newPayloadSize));

	mov	eax, DWORD PTR _newPayloadSize$7[ebp]
	push	eax
	call	DWORD PTR __imp__htonl@4
	push	eax
	lea	ecx, DWORD PTR _packetOut$1[ebp]
	call	DWORD PTR __imp_?OutputDword@Serializer@@QAEAAV1@K@Z

; 417  :                 packetOut.Serialize(nal.p_payload+skipBytes, newPayloadSize);

	mov	ecx, DWORD PTR _newPayloadSize$7[ebp]
	push	ecx
	mov	edx, DWORD PTR _nal$17[ebp]
	mov	eax, DWORD PTR [edx+24]
	add	eax, DWORD PTR _skipBytes$8[ebp]
	push	eax
	lea	ecx, DWORD PTR _packetOut$1[ebp]
	call	DWORD PTR __imp_?Serialize@BufferOutputSerializer@@UAEXPBXK@Z

; 418  :             }

	lea	ecx, DWORD PTR _packetOut$1[ebp]
	call	DWORD PTR __imp_??1BufferOutputSerializer@@UAE@XZ
	jmp	$LN20@Encode
$LN19@Encode:

; 419  :             else if(nal.i_type == NAL_SLICE_IDR || nal.i_type == NAL_SLICE)

	mov	ecx, DWORD PTR _nal$17[ebp]
	cmp	DWORD PTR [ecx+4], 5
	je	SHORT $LN13@Encode
	mov	edx, DWORD PTR _nal$17[ebp]
	cmp	DWORD PTR [edx+4], 1
	jne	$LN14@Encode
$LN13@Encode:

; 420  :             {
; 421  :                 BYTE *skip = nal.p_payload;

	mov	eax, DWORD PTR _nal$17[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _skip$10[ebp], ecx
$LN12@Encode:

; 422  :                 while(*(skip++) != 0x1);

	mov	edx, DWORD PTR _skip$10[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR tv255[ebp], eax
	mov	ecx, DWORD PTR _skip$10[ebp]
	add	ecx, 1
	mov	DWORD PTR _skip$10[ebp], ecx
	cmp	DWORD PTR tv255[ebp], 1
	je	SHORT $LN11@Encode
	jmp	SHORT $LN12@Encode
$LN11@Encode:

; 423  :                 int skipBytes = (int)(skip-nal.p_payload);

	mov	edx, DWORD PTR _nal$17[ebp]
	mov	eax, DWORD PTR _skip$10[ebp]
	sub	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _skipBytes$5[ebp], eax

; 424  : 
; 425  :                 if (!newPacket)

	cmp	DWORD PTR _newPacket$[ebp], 0
	jne	SHORT $LN10@Encode

; 426  :                     newPacket = CurrentPackets.CreateNew();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1120				; 00000460H
	call	?CreateNew@?$List@UVideoPacket@@@@QAEPAUVideoPacket@@XZ ; List<VideoPacket>::CreateNew
	mov	DWORD PTR _newPacket$[ebp], eax
$LN10@Encode:

; 427  : 
; 428  :                 if (!bFoundFrame)

	movzx	ecx, BYTE PTR _bFoundFrame$[ebp]
	test	ecx, ecx
	jne	SHORT $LN9@Encode

; 429  :                 {
; 430  :                     newPacket->Packet.Insert(0, (nal.i_type == NAL_SLICE_IDR) ? 0x17 : 0x27);

	mov	edx, DWORD PTR _nal$17[ebp]
	cmp	DWORD PTR [edx+4], 5
	jne	SHORT $LN37@Encode
	mov	DWORD PTR tv268[ebp], 23		; 00000017H
	jmp	SHORT $LN38@Encode
$LN37@Encode:
	mov	DWORD PTR tv268[ebp], 39		; 00000027H
$LN38@Encode:
	mov	al, BYTE PTR tv268[ebp]
	mov	BYTE PTR $T16[ebp], al
	lea	ecx, DWORD PTR $T16[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _newPacket$[ebp]
	call	?Insert@?$List@E@@QAEXIABE@Z		; List<unsigned char>::Insert

; 431  :                     newPacket->Packet.Insert(1, 1);

	mov	BYTE PTR $T15[ebp], 1
	lea	edx, DWORD PTR $T15[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _newPacket$[ebp]
	call	?Insert@?$List@E@@QAEXIABE@Z		; List<unsigned char>::Insert

; 432  :                     newPacket->Packet.InsertArray(2, timeOffsetAddr, 3);

	push	3
	mov	eax, DWORD PTR _timeOffsetAddr$[ebp]
	push	eax
	push	2
	mov	ecx, DWORD PTR _newPacket$[ebp]
	call	?InsertArray@?$List@E@@QAEXIPBEI@Z	; List<unsigned char>::InsertArray

; 433  : 
; 434  :                     bFoundFrame = true;

	mov	BYTE PTR _bFoundFrame$[ebp], 1
$LN9@Encode:

; 435  :                 }
; 436  : 
; 437  :                 int newPayloadSize = (nal.i_payload-skipBytes);

	mov	ecx, DWORD PTR _nal$17[ebp]
	mov	edx, DWORD PTR [ecx+20]
	sub	edx, DWORD PTR _skipBytes$5[ebp]
	mov	DWORD PTR _newPayloadSize$6[ebp], edx

; 438  :                 BufferOutputSerializer packetOut(newPacket->Packet);

	push	1
	mov	eax, DWORD PTR _newPacket$[ebp]
	push	eax
	lea	ecx, DWORD PTR _packetOut$2[ebp]
	call	DWORD PTR __imp_??0BufferOutputSerializer@@QAE@AAV?$List@E@@H@Z

; 439  : 
; 440  :                 packetOut.OutputDword(htonl(newPayloadSize));

	mov	ecx, DWORD PTR _newPayloadSize$6[ebp]
	push	ecx
	call	DWORD PTR __imp__htonl@4
	push	eax
	lea	ecx, DWORD PTR _packetOut$2[ebp]
	call	DWORD PTR __imp_?OutputDword@Serializer@@QAEAAV1@K@Z

; 441  :                 packetOut.Serialize(nal.p_payload+skipBytes, newPayloadSize);

	mov	edx, DWORD PTR _newPayloadSize$6[ebp]
	push	edx
	mov	eax, DWORD PTR _nal$17[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, DWORD PTR _skipBytes$5[ebp]
	push	ecx
	lea	ecx, DWORD PTR _packetOut$2[ebp]
	call	DWORD PTR __imp_?Serialize@BufferOutputSerializer@@UAEXPBXK@Z

; 442  : 
; 443  :                 switch(nal.i_ref_idc)

	mov	edx, DWORD PTR _nal$17[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv335[ebp], eax
	cmp	DWORD PTR tv335[ebp], 3
	ja	SHORT $LN7@Encode
	mov	ecx, DWORD PTR tv335[ebp]
	jmp	DWORD PTR $LN47@Encode[ecx*4]
$LN6@Encode:

; 444  :                 {
; 445  :                     case NAL_PRIORITY_DISPOSABLE:   bestType = MAX(bestType, PacketType_VideoDisposable);  break;

	cmp	DWORD PTR _bestType$[ebp], 0
	jle	SHORT $LN39@Encode
	mov	edx, DWORD PTR _bestType$[ebp]
	mov	DWORD PTR tv337[ebp], edx
	jmp	SHORT $LN40@Encode
$LN39@Encode:
	mov	DWORD PTR tv337[ebp], 0
$LN40@Encode:
	mov	eax, DWORD PTR tv337[ebp]
	mov	DWORD PTR _bestType$[ebp], eax
	jmp	SHORT $LN7@Encode
$LN5@Encode:

; 446  :                     case NAL_PRIORITY_LOW:          bestType = MAX(bestType, PacketType_VideoLow);         break;

	cmp	DWORD PTR _bestType$[ebp], 1
	jle	SHORT $LN41@Encode
	mov	ecx, DWORD PTR _bestType$[ebp]
	mov	DWORD PTR tv339[ebp], ecx
	jmp	SHORT $LN42@Encode
$LN41@Encode:
	mov	DWORD PTR tv339[ebp], 1
$LN42@Encode:
	mov	edx, DWORD PTR tv339[ebp]
	mov	DWORD PTR _bestType$[ebp], edx
	jmp	SHORT $LN7@Encode
$LN4@Encode:

; 447  :                     case NAL_PRIORITY_HIGH:         bestType = MAX(bestType, PacketType_VideoHigh);        break;

	cmp	DWORD PTR _bestType$[ebp], 2
	jle	SHORT $LN43@Encode
	mov	eax, DWORD PTR _bestType$[ebp]
	mov	DWORD PTR tv341[ebp], eax
	jmp	SHORT $LN44@Encode
$LN43@Encode:
	mov	DWORD PTR tv341[ebp], 2
$LN44@Encode:
	mov	ecx, DWORD PTR tv341[ebp]
	mov	DWORD PTR _bestType$[ebp], ecx
	jmp	SHORT $LN7@Encode
$LN3@Encode:

; 448  :                     case NAL_PRIORITY_HIGHEST:      bestType = MAX(bestType, PacketType_VideoHighest);     break;

	cmp	DWORD PTR _bestType$[ebp], 3
	jle	SHORT $LN45@Encode
	mov	edx, DWORD PTR _bestType$[ebp]
	mov	DWORD PTR tv343[ebp], edx
	jmp	SHORT $LN46@Encode
$LN45@Encode:
	mov	DWORD PTR tv343[ebp], 3
$LN46@Encode:
	mov	eax, DWORD PTR tv343[ebp]
	mov	DWORD PTR _bestType$[ebp], eax
$LN7@Encode:

; 449  :                 }
; 450  :             }

	lea	ecx, DWORD PTR _packetOut$2[ebp]
	call	DWORD PTR __imp_??1BufferOutputSerializer@@UAE@XZ

; 451  :             /*else if(nal.i_type == NAL_SPS)
; 452  :             {
; 453  :                 VideoPacket *newPacket = CurrentPackets.CreateNew();
; 454  :                 BufferOutputSerializer headerOut(newPacket->Packet);
; 455  : 
; 456  :                 headerOut.OutputByte(0x17);
; 457  :                 headerOut.OutputByte(0);
; 458  :                 headerOut.Serialize(timeOffsetAddr, 3);
; 459  :                 headerOut.OutputByte(1);
; 460  :                 headerOut.Serialize(nal.p_payload+5, 3);
; 461  :                 headerOut.OutputByte(0xff);
; 462  :                 headerOut.OutputByte(0xe1);
; 463  :                 headerOut.OutputWord(htons(nal.i_payload-4));
; 464  :                 headerOut.Serialize(nal.p_payload+4, nal.i_payload-4);
; 465  : 
; 466  :                 x264_nal_t &pps = nalOut[i+1]; //the PPS always comes after the SPS
; 467  : 
; 468  :                 headerOut.OutputByte(1);
; 469  :                 headerOut.OutputWord(htons(pps.i_payload-4));
; 470  :                 headerOut.Serialize(pps.p_payload+4, pps.i_payload-4);
; 471  :             }*/
; 472  :             else

	jmp	SHORT $LN20@Encode
$LN14@Encode:

; 473  :                 continue;

	jmp	$LN28@Encode
$LN20@Encode:

; 474  :         }

	jmp	$LN28@Encode
$LN27@Encode:

; 475  : 
; 476  :         packetTypes << bestType;

	lea	ecx, DWORD PTR _bestType$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _packetTypes$[ebp]
	call	??6?$List@W4PacketType@@@@QAEAAV0@ABW4PacketType@@@Z ; List<enum PacketType>::operator<<

; 477  : 
; 478  : 	if (CurrentPackets.Num()) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1120				; 00000460H
	call	?Num@?$List@UVideoPacket@@@@QBEIXZ	; List<VideoPacket>::Num
	test	eax, eax
	je	SHORT $LN1@Encode

; 479  : 		packets.SetSize(1);

	push	1
	mov	ecx, DWORD PTR _packets$[ebp]
	call	?SetSize@?$List@UDataPacket@@@@QAEHI@Z	; List<DataPacket>::SetSize

; 480  : 		packets[0].lpPacket = CurrentPackets[0].Packet.Array();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1120				; 00000460H
	call	??A?$List@UVideoPacket@@@@QAEAAUVideoPacket@@I@Z ; List<VideoPacket>::operator[]
	mov	ecx, eax
	call	?Array@?$List@E@@QBEPAEXZ		; List<unsigned char>::Array
	mov	esi, eax
	push	0
	mov	ecx, DWORD PTR _packets$[ebp]
	call	??A?$List@UDataPacket@@@@QAEAAUDataPacket@@I@Z ; List<DataPacket>::operator[]
	mov	DWORD PTR [eax], esi

; 481  : 		packets[0].size     = CurrentPackets[0].Packet.Num();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1120				; 00000460H
	call	??A?$List@UVideoPacket@@@@QAEAAUVideoPacket@@I@Z ; List<VideoPacket>::operator[]
	mov	ecx, eax
	call	?Num@?$List@E@@QBEIXZ			; List<unsigned char>::Num
	mov	esi, eax
	push	0
	mov	ecx, DWORD PTR _packets$[ebp]
	call	??A?$List@UDataPacket@@@@QAEAAUDataPacket@@I@Z ; List<DataPacket>::operator[]
	mov	DWORD PTR [eax+4], esi
$LN1@Encode:

; 482  : 	}
; 483  : 
; 484  :         return true;

	mov	al, 1
$LN35@Encode:

; 485  :     }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
	npad	1
$LN47@Encode:
	DD	$LN6@Encode
	DD	$LN5@Encode
	DD	$LN4@Encode
	DD	$LN3@Encode
?Encode@X264Encoder@@UAE_NPAXAAV?$List@UDataPacket@@@@AAV?$List@W4PacketType@@@@KAAK@Z ENDP ; X264Encoder::Encode
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_x264.cpp
;	COMDAT ?GetHeaders@X264Encoder@@UAEXAAUDataPacket@@@Z
_TEXT	SEGMENT
_headerOut$1 = -36					; size = 12
_nalNum$2 = -24						; size = 4
_nalOut$3 = -20						; size = 4
_pps$4 = -16						; size = 4
_this$ = -12						; size = 4
_i$5 = -8						; size = 4
_nal$6 = -4						; size = 4
_packet$ = 8						; size = 4
?GetHeaders@X264Encoder@@UAEXAAUDataPacket@@@Z PROC	; X264Encoder::GetHeaders, COMDAT
; _this$ = ecx

; 488  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 489  :         if(!HeaderPacket.Num())

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1128				; 00000468H
	call	?Num@?$List@E@@QBEIXZ			; List<unsigned char>::Num
	test	eax, eax
	jne	$LN5@GetHeaders

; 490  :         {
; 491  :             x264_nal_t *nalOut;
; 492  :             int nalNum;
; 493  : 
; 494  :             x264_encoder_headers(x264, &nalOut, &nalNum);

	lea	eax, DWORD PTR _nalNum$2[ebp]
	push	eax
	lea	ecx, DWORD PTR _nalOut$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+864]
	push	eax
	call	DWORD PTR __imp__x264_encoder_headers
	add	esp, 12					; 0000000cH

; 495  : 
; 496  :             for(int i=0; i<nalNum; i++)

	mov	DWORD PTR _i$5[ebp], 0
	jmp	SHORT $LN4@GetHeaders
$LN3@GetHeaders:
	mov	ecx, DWORD PTR _i$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$5[ebp], ecx
$LN4@GetHeaders:
	mov	edx, DWORD PTR _i$5[ebp]
	cmp	edx, DWORD PTR _nalNum$2[ebp]
	jge	$LN5@GetHeaders

; 497  :             {
; 498  :                 x264_nal_t &nal = nalOut[i];

	mov	eax, DWORD PTR _i$5[ebp]
	shl	eax, 5
	add	eax, DWORD PTR _nalOut$3[ebp]
	mov	DWORD PTR _nal$6[ebp], eax

; 499  : 
; 500  :                 if(nal.i_type == NAL_SPS)

	mov	ecx, DWORD PTR _nal$6[ebp]
	cmp	DWORD PTR [ecx+4], 7
	jne	$LN1@GetHeaders

; 501  :                 {
; 502  :                     BufferOutputSerializer headerOut(HeaderPacket);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1128				; 00000468H
	push	edx
	lea	ecx, DWORD PTR _headerOut$1[ebp]
	call	DWORD PTR __imp_??0BufferOutputSerializer@@QAE@AAV?$List@E@@H@Z

; 503  : 
; 504  :                     headerOut.OutputByte(0x17);

	push	23					; 00000017H
	lea	ecx, DWORD PTR _headerOut$1[ebp]
	call	DWORD PTR __imp_?OutputByte@Serializer@@QAEAAV1@E@Z

; 505  :                     headerOut.OutputByte(0);

	push	0
	lea	ecx, DWORD PTR _headerOut$1[ebp]
	call	DWORD PTR __imp_?OutputByte@Serializer@@QAEAAV1@E@Z

; 506  :                     headerOut.OutputByte(0);

	push	0
	lea	ecx, DWORD PTR _headerOut$1[ebp]
	call	DWORD PTR __imp_?OutputByte@Serializer@@QAEAAV1@E@Z

; 507  :                     headerOut.OutputByte(0);

	push	0
	lea	ecx, DWORD PTR _headerOut$1[ebp]
	call	DWORD PTR __imp_?OutputByte@Serializer@@QAEAAV1@E@Z

; 508  :                     headerOut.OutputByte(0);

	push	0
	lea	ecx, DWORD PTR _headerOut$1[ebp]
	call	DWORD PTR __imp_?OutputByte@Serializer@@QAEAAV1@E@Z

; 509  :                     headerOut.OutputByte(1);

	push	1
	lea	ecx, DWORD PTR _headerOut$1[ebp]
	call	DWORD PTR __imp_?OutputByte@Serializer@@QAEAAV1@E@Z

; 510  :                     headerOut.Serialize(nal.p_payload+5, 3);

	push	3
	mov	eax, DWORD PTR _nal$6[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, 5
	push	ecx
	lea	ecx, DWORD PTR _headerOut$1[ebp]
	call	DWORD PTR __imp_?Serialize@BufferOutputSerializer@@UAEXPBXK@Z

; 511  :                     headerOut.OutputByte(0xff);

	push	255					; 000000ffH
	lea	ecx, DWORD PTR _headerOut$1[ebp]
	call	DWORD PTR __imp_?OutputByte@Serializer@@QAEAAV1@E@Z

; 512  :                     headerOut.OutputByte(0xe1);

	push	225					; 000000e1H
	lea	ecx, DWORD PTR _headerOut$1[ebp]
	call	DWORD PTR __imp_?OutputByte@Serializer@@QAEAAV1@E@Z

; 513  :                     headerOut.OutputWord(htons(nal.i_payload-4));

	mov	edx, DWORD PTR _nal$6[ebp]
	mov	eax, DWORD PTR [edx+20]
	sub	eax, 4
	push	eax
	call	DWORD PTR __imp__htons@4
	movzx	ecx, ax
	push	ecx
	lea	ecx, DWORD PTR _headerOut$1[ebp]
	call	DWORD PTR __imp_?OutputWord@Serializer@@QAEAAV1@G@Z

; 514  :                     headerOut.Serialize(nal.p_payload+4, nal.i_payload-4);

	mov	edx, DWORD PTR _nal$6[ebp]
	mov	eax, DWORD PTR [edx+20]
	sub	eax, 4
	push	eax
	mov	ecx, DWORD PTR _nal$6[ebp]
	mov	edx, DWORD PTR [ecx+24]
	add	edx, 4
	push	edx
	lea	ecx, DWORD PTR _headerOut$1[ebp]
	call	DWORD PTR __imp_?Serialize@BufferOutputSerializer@@UAEXPBXK@Z

; 515  : 
; 516  :                     x264_nal_t &pps = nalOut[i+1]; //the PPS always comes after the SPS

	mov	eax, DWORD PTR _i$5[ebp]
	add	eax, 1
	shl	eax, 5
	add	eax, DWORD PTR _nalOut$3[ebp]
	mov	DWORD PTR _pps$4[ebp], eax

; 517  : 
; 518  :                     headerOut.OutputByte(1);

	push	1
	lea	ecx, DWORD PTR _headerOut$1[ebp]
	call	DWORD PTR __imp_?OutputByte@Serializer@@QAEAAV1@E@Z

; 519  :                     headerOut.OutputWord(htons(pps.i_payload-4));

	mov	ecx, DWORD PTR _pps$4[ebp]
	mov	edx, DWORD PTR [ecx+20]
	sub	edx, 4
	push	edx
	call	DWORD PTR __imp__htons@4
	movzx	eax, ax
	push	eax
	lea	ecx, DWORD PTR _headerOut$1[ebp]
	call	DWORD PTR __imp_?OutputWord@Serializer@@QAEAAV1@G@Z

; 520  :                     headerOut.Serialize(pps.p_payload+4, pps.i_payload-4);

	mov	ecx, DWORD PTR _pps$4[ebp]
	mov	edx, DWORD PTR [ecx+20]
	sub	edx, 4
	push	edx
	mov	eax, DWORD PTR _pps$4[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, 4
	push	ecx
	lea	ecx, DWORD PTR _headerOut$1[ebp]
	call	DWORD PTR __imp_?Serialize@BufferOutputSerializer@@UAEXPBXK@Z

; 521  :                 }

	lea	ecx, DWORD PTR _headerOut$1[ebp]
	call	DWORD PTR __imp_??1BufferOutputSerializer@@UAE@XZ
$LN1@GetHeaders:

; 522  :             }

	jmp	$LN3@GetHeaders
$LN5@GetHeaders:

; 523  :         }
; 524  : 
; 525  :         packet.lpPacket = HeaderPacket.Array();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1128				; 00000468H
	call	?Array@?$List@E@@QBEPAEXZ		; List<unsigned char>::Array
	mov	edx, DWORD PTR _packet$[ebp]
	mov	DWORD PTR [edx], eax

; 526  :         packet.size     = HeaderPacket.Num();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1128				; 00000468H
	call	?Num@?$List@E@@QBEIXZ			; List<unsigned char>::Num
	mov	ecx, DWORD PTR _packet$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 527  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetHeaders@X264Encoder@@UAEXAAUDataPacket@@@Z ENDP	; X264Encoder::GetHeaders
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_x264.cpp
;	COMDAT ?GetSEI@X264Encoder@@UAEXAAUDataPacket@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_packet$ = 8						; size = 4
?GetSEI@X264Encoder@@UAEXAAUDataPacket@@@Z PROC		; X264Encoder::GetSEI, COMDAT
; _this$ = ecx

; 530  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 531  :         packet.lpPacket = SEIData.Array();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1136				; 00000470H
	call	?Array@?$List@E@@QBEPAEXZ		; List<unsigned char>::Array
	mov	ecx, DWORD PTR _packet$[ebp]
	mov	DWORD PTR [ecx], eax

; 532  :         packet.size     = SEIData.Num();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1136				; 00000470H
	call	?Num@?$List@E@@QBEIXZ			; List<unsigned char>::Num
	mov	edx, DWORD PTR _packet$[ebp]
	mov	DWORD PTR [edx+4], eax

; 533  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetSEI@X264Encoder@@UAEXAAUDataPacket@@@Z ENDP		; X264Encoder::GetSEI
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_x264.cpp
;	COMDAT ?GetBitRate@X264Encoder@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBitRate@X264Encoder@@UBEHXZ PROC			; X264Encoder::GetBitRate, COMDAT
; _this$ = ecx

; 536  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 537  :         if (paramData.rc.i_vbv_max_bitrate)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+664], 0
	je	SHORT $LN2@GetBitRate

; 538  :             return paramData.rc.i_vbv_max_bitrate;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+664]
	jmp	SHORT $LN3@GetBitRate

; 539  :         else

	jmp	SHORT $LN3@GetBitRate
$LN2@GetBitRate:

; 540  :             return paramData.rc.i_bitrate;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+648]
$LN3@GetBitRate:

; 541  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetBitRate@X264Encoder@@UBEHXZ ENDP			; X264Encoder::GetBitRate
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_x264.cpp
;	COMDAT ?GetInfoString@X264Encoder@@UBE?AVString@@XZ
_TEXT	SEGMENT
$T1 = -68						; size = 8
$T2 = -60						; size = 8
$T3 = -52						; size = 8
$T4 = -44						; size = 8
$T5 = -36						; size = 8
$T6 = -28						; size = 8
_strInfo$ = -20						; size = 8
tv172 = -12						; size = 4
tv182 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetInfoString@X264Encoder@@UBE?AVString@@XZ PROC	; X264Encoder::GetInfoString, COMDAT
; _this$ = ecx

; 544  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 545  :         String strInfo;

	lea	ecx, DWORD PTR _strInfo$[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 546  : 
; 547  :         strInfo << TEXT("Video Encoding: x264")  <<
; 548  :                    TEXT("\r\n    fps: ")         << IntString(paramData.i_fps_num) <<
; 549  :                    TEXT("\r\n    width: ")       << IntString(width) << TEXT(", height: ") << IntString(height) <<
; 550  :                    TEXT("\r\n    preset: ")      << curPreset <<
; 551  :                    TEXT("\r\n    profile: ")     << curProfile <<
; 552  :                    TEXT("\r\n    keyint: ")      << paramData.i_keyint_max <<
; 553  :                    TEXT("\r\n    CBR: ")         << CTSTR((bUseCBR) ? TEXT("yes") : TEXT("no")) <<
; 554  :                    TEXT("\r\n    CFR: ")         << CTSTR((bUseCFR) ? TEXT("yes") : TEXT("no")) <<
; 555  :                    TEXT("\r\n    max bitrate: ") << IntString(paramData.rc.i_vbv_max_bitrate) <<
; 556  :                    TEXT("\r\n    buffer size: ") << IntString(paramData.rc.i_vbv_buffer_size);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1118]
	test	ecx, ecx
	je	SHORT $LN6@GetInfoStr
	mov	DWORD PTR tv182[ebp], OFFSET ??_C@_17IHBDLLG@?$AAy?$AAe?$AAs?$AA?$AA@
	jmp	SHORT $LN7@GetInfoStr
$LN6@GetInfoStr:
	mov	DWORD PTR tv182[ebp], OFFSET ??_C@_15BPIGNHCD@?$AAn?$AAo?$AA?$AA@
$LN7@GetInfoStr:
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+1117]
	test	eax, eax
	je	SHORT $LN4@GetInfoStr
	mov	DWORD PTR tv172[ebp], OFFSET ??_C@_17IHBDLLG@?$AAy?$AAe?$AAs?$AA?$AA@
	jmp	SHORT $LN5@GetInfoStr
$LN4@GetInfoStr:
	mov	DWORD PTR tv172[ebp], OFFSET ??_C@_15BPIGNHCD@?$AAn?$AAo?$AA?$AA@
$LN5@GetInfoStr:
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+668]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	DWORD PTR __imp_?IntString@@YA?AVString@@HH@Z
	add	esp, 12					; 0000000cH
	push	eax
	push	OFFSET ??_C@_1CI@EBHCIKPJ@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?3?$AA?5?$AA?$AA@
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+664]
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	DWORD PTR __imp_?IntString@@YA?AVString@@HH@Z
	add	esp, 12					; 0000000cH
	push	eax
	push	OFFSET ??_C@_1CI@MGGEJOEN@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAm?$AAa?$AAx?$AA?5?$AAb?$AAi?$AAt?$AAr?$AAa?$AAt?$AAe?$AA?3?$AA?5?$AA?$AA@
	mov	ecx, DWORD PTR tv182[ebp]
	push	ecx
	push	OFFSET ??_C@_1BI@KKGLJLKO@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAC?$AAF?$AAR?$AA?3?$AA?5?$AA?$AA@
	mov	edx, DWORD PTR tv172[ebp]
	push	edx
	push	OFFSET ??_C@_1BI@KDIADLNE@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAC?$AAB?$AAR?$AA?3?$AA?5?$AA?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	push	ecx
	push	OFFSET ??_C@_1BO@KNOLPPNN@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAk?$AAe?$AAy?$AAi?$AAn?$AAt?$AA?3?$AA?5?$AA?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1108				; 00000454H
	push	edx
	push	OFFSET ??_C@_1CA@CJBHDLKD@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAp?$AAr?$AAo?$AAf?$AAi?$AAl?$AAe?$AA?3?$AA?5?$AA?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1092				; 00000444H
	push	eax
	push	OFFSET ??_C@_1BO@DHMJEFGL@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAp?$AAr?$AAe?$AAs?$AAe?$AAt?$AA?3?$AA?5?$AA?$AA@
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1088]
	push	edx
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	DWORD PTR __imp_?IntString@@YA?AVString@@HH@Z
	add	esp, 12					; 0000000cH
	push	eax
	push	OFFSET ??_C@_1BG@CGNKKOP@?$AA?0?$AA?5?$AAh?$AAe?$AAi?$AAg?$AAh?$AAt?$AA?3?$AA?5?$AA?$AA@
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1084]
	push	edx
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	DWORD PTR __imp_?IntString@@YA?AVString@@HH@Z
	add	esp, 12					; 0000000cH
	push	eax
	push	OFFSET ??_C@_1BM@NGONPCKN@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?3?$AA?5?$AA?$AA@
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+788]
	push	edx
	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	call	DWORD PTR __imp_?IntString@@YA?AVString@@HH@Z
	add	esp, 12					; 0000000cH
	push	eax
	push	OFFSET ??_C@_1BI@HKMIKHPB@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAf?$AAp?$AAs?$AA?3?$AA?5?$AA?$AA@
	push	OFFSET ??_C@_1CK@JPDANMPO@?$AAV?$AAi?$AAd?$AAe?$AAo?$AA?5?$AAE?$AAn?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA?3?$AA?5?$AAx?$AA2?$AA6?$AA4?$AA?$AA@
	lea	ecx, DWORD PTR _strInfo$[ebp]
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@H@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T6[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR $T5[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR $T4[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR $T3[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR $T2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 557  : 
; 558  :         if(!bUseCBR)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+1117]
	test	edx, edx
	jne	SHORT $LN1@GetInfoStr

; 559  :         {
; 560  :             strInfo << TEXT("\r\n    quality: ")     << IntString(10-int(paramData.rc.f_rf_constant-baseCRF));

	push	10					; 0000000aH
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+652]
	subss	xmm0, DWORD PTR _baseCRF
	cvttss2si ecx, xmm0
	mov	edx, 10					; 0000000aH
	sub	edx, ecx
	push	edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	DWORD PTR __imp_?IntString@@YA?AVString@@HH@Z
	add	esp, 12					; 0000000cH
	push	eax
	push	OFFSET ??_C@_1CA@EAIGMDMJ@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAq?$AAu?$AAa?$AAl?$AAi?$AAt?$AAy?$AA?3?$AA?5?$AA?$AA@
	lea	ecx, DWORD PTR _strInfo$[ebp]
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN1@GetInfoStr:

; 561  :         }
; 562  : 
; 563  :         return strInfo;

	lea	ecx, DWORD PTR _strInfo$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0String@@QAE@ABV0@@Z
	lea	ecx, DWORD PTR _strInfo$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 564  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetInfoString@X264Encoder@@UBE?AVString@@XZ ENDP	; X264Encoder::GetInfoString
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_x264.cpp
;	COMDAT ?DynamicBitrateSupported@X264Encoder@@UBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
?DynamicBitrateSupported@X264Encoder@@UBE_NXZ PROC	; X264Encoder::DynamicBitrateSupported, COMDAT
; _this$ = ecx

; 567  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 568  :         return (paramData.i_nal_hrd != X264_NAL_HRD_CBR);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+52], 2
	je	SHORT $LN3@DynamicBit
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@DynamicBit
$LN3@DynamicBit:
	mov	DWORD PTR tv67[ebp], 0
$LN4@DynamicBit:
	mov	al, BYTE PTR tv67[ebp]

; 569  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?DynamicBitrateSupported@X264Encoder@@UBE_NXZ ENDP	; X264Encoder::DynamicBitrateSupported
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_x264.cpp
;	COMDAT ?SetBitRate@X264Encoder@@UAE_NKK@Z
_TEXT	SEGMENT
$T1 = -48						; size = 8
$T2 = -40						; size = 8
_changes$3 = -32					; size = 8
tv149 = -24						; size = 4
tv135 = -20						; size = 4
_old_buffer$ = -16					; size = 4
_old_bitrate$ = -12					; size = 4
_retVal$ = -8						; size = 4
_this$ = -4						; size = 4
_maxBitrate$ = 8					; size = 4
_bufferSize$ = 12					; size = 4
?SetBitRate@X264Encoder@@UAE_NKK@Z PROC			; X264Encoder::SetBitRate, COMDAT
; _this$ = ecx

; 572  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 573  :         DWORD old_bitrate = paramData.rc.i_vbv_max_bitrate;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+664]
	mov	DWORD PTR _old_bitrate$[ebp], ecx

; 574  :         DWORD old_buffer  = paramData.rc.i_vbv_buffer_size;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+668]
	mov	DWORD PTR _old_buffer$[ebp], eax

; 575  : 
; 576  :         SetBitRateParams(maxBitrate, bufferSize);

	mov	ecx, DWORD PTR _bufferSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _maxBitrate$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetBitRateParams@X264Encoder@@AAEXKK@Z	; X264Encoder::SetBitRateParams

; 577  : 
; 578  :         int retVal = x264_encoder_reconfig(x264, &paramData);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+864]
	push	edx
	call	DWORD PTR __imp__x264_encoder_reconfig
	add	esp, 8
	mov	DWORD PTR _retVal$[ebp], eax

; 579  :         if (retVal < 0)

	cmp	DWORD PTR _retVal$[ebp], 0
	jge	SHORT $LN5@SetBitRate

; 580  :             Log(TEXT("Could not set new encoder bitrate, error value %u"), retVal);

	mov	eax, DWORD PTR _retVal$[ebp]
	push	eax
	push	OFFSET ??_C@_1GE@KMKNGAEG@?$AAC?$AAo?$AAu?$AAl?$AAd?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAe?$AAt?$AA?5?$AAn?$AAe?$AAw?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?5?$AAb?$AAi?$AAt?$AAr?$AAa?$AAt@
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8

; 581  :         else

	jmp	$LN4@SetBitRate
$LN5@SetBitRate:

; 582  :         {
; 583  :             String changes;

	lea	ecx, DWORD PTR _changes$3[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 584  :             if (old_bitrate != maxBitrate)

	mov	ecx, DWORD PTR _old_bitrate$[ebp]
	cmp	ecx, DWORD PTR _maxBitrate$[ebp]
	je	SHORT $LN3@SetBitRate

; 585  :                 changes << FormattedString(L"bitrate %d->%d", old_bitrate, maxBitrate);

	mov	edx, DWORD PTR _maxBitrate$[ebp]
	push	edx
	mov	eax, DWORD PTR _old_bitrate$[ebp]
	push	eax
	push	OFFSET ??_C@_1BO@PHOABOJI@?$AAb?$AAi?$AAt?$AAr?$AAa?$AAt?$AAe?$AA?5?$AA?$CF?$AAd?$AA?9?$AA?$DO?$AA?$CF?$AAd?$AA?$AA@
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR _changes$3[ebp]
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN3@SetBitRate:

; 586  :             if (old_buffer != bufferSize)

	mov	edx, DWORD PTR _old_buffer$[ebp]
	cmp	edx, DWORD PTR _bufferSize$[ebp]
	je	SHORT $LN2@SetBitRate

; 587  :                 changes << FormattedString(L"%sbuffer size %d->%d", changes.Length() ? L", " : L"", old_buffer, bufferSize);

	lea	ecx, DWORD PTR _changes$3[ebp]
	call	DWORD PTR __imp_?Length@String@@QBEIXZ
	test	eax, eax
	je	SHORT $LN8@SetBitRate
	mov	DWORD PTR tv135[ebp], OFFSET ??_C@_15JOGBDECP@?$AA?0?$AA?5?$AA?$AA@
	jmp	SHORT $LN9@SetBitRate
$LN8@SetBitRate:
	mov	DWORD PTR tv135[ebp], OFFSET ??_C@_11LOCGONAA@?$AA?$AA@
$LN9@SetBitRate:
	mov	eax, DWORD PTR _bufferSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _old_buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv135[ebp]
	push	edx
	push	OFFSET ??_C@_1CK@JNMHHCMH@?$AA?$CF?$AAs?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$CF?$AAd?$AA?9?$AA?$DO?$AA?$CF?$AAd?$AA?$AA@
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 20					; 00000014H
	push	eax
	lea	ecx, DWORD PTR _changes$3[ebp]
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN2@SetBitRate:

; 588  :             if (changes)

	lea	ecx, DWORD PTR _changes$3[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	test	eax, eax
	je	SHORT $LN1@SetBitRate

; 589  :                 Log(L"x264: %s", changes.Array());

	lea	ecx, DWORD PTR _changes$3[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET ??_C@_1BC@NMBCIDFP@?$AAx?$AA2?$AA6?$AA4?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?$AA@
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8
$LN1@SetBitRate:

; 590  :         }

	lea	ecx, DWORD PTR _changes$3[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN4@SetBitRate:

; 591  : 
; 592  :         return retVal == 0;

	cmp	DWORD PTR _retVal$[ebp], 0
	jne	SHORT $LN10@SetBitRate
	mov	DWORD PTR tv149[ebp], 1
	jmp	SHORT $LN11@SetBitRate
$LN10@SetBitRate:
	mov	DWORD PTR tv149[ebp], 0
$LN11@SetBitRate:
	mov	al, BYTE PTR tv149[ebp]

; 593  :     }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetBitRate@X264Encoder@@UAE_NKK@Z ENDP			; X264Encoder::SetBitRate
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_x264.cpp
;	COMDAT ?RequestKeyframe@X264Encoder@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RequestKeyframe@X264Encoder@@UAEXXZ PROC		; X264Encoder::RequestKeyframe, COMDAT
; _this$ = ecx

; 596  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 597  :         bRequestKeyframe = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1080], 1

; 598  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?RequestKeyframe@X264Encoder@@UAEXXZ ENDP		; X264Encoder::RequestKeyframe
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_x264.cpp
;	COMDAT ?GetBufferedFrames@X264Encoder@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBufferedFrames@X264Encoder@@UAEHXZ PROC		; X264Encoder::GetBufferedFrames, COMDAT
; _this$ = ecx

; 601  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 602  :         return x264_encoder_delayed_frames(x264);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+864]
	push	ecx
	call	DWORD PTR __imp__x264_encoder_delayed_frames
	add	esp, 4

; 603  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetBufferedFrames@X264Encoder@@UAEHXZ ENDP		; X264Encoder::GetBufferedFrames
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_x264.cpp
;	COMDAT ?HasBufferedFrames@X264Encoder@@UAE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
?HasBufferedFrames@X264Encoder@@UAE_NXZ PROC		; X264Encoder::HasBufferedFrames, COMDAT
; _this$ = ecx

; 606  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 607  :         return x264_encoder_delayed_frames(x264) > 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+864]
	push	ecx
	call	DWORD PTR __imp__x264_encoder_delayed_frames
	add	esp, 4
	test	eax, eax
	jle	SHORT $LN3@HasBuffere
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@HasBuffere
$LN3@HasBuffere:
	mov	DWORD PTR tv68[ebp], 0
$LN4@HasBuffere:
	mov	al, BYTE PTR tv68[ebp]

; 608  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?HasBufferedFrames@X264Encoder@@UAE_NXZ ENDP		; X264Encoder::HasBufferedFrames
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GX264Encoder@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GX264Encoder@@UAEPAXI@Z PROC				; X264Encoder::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1X264Encoder@@UAE@XZ			; X264Encoder::~X264Encoder
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GX264Encoder@@UAEPAXI@Z ENDP				; X264Encoder::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_x264.cpp
;	COMDAT ?CreateX264Encoder@@YAPAVVideoEncoder@@HHHHPB_W_NAAUColorDescription@@HH1@Z
_TEXT	SEGMENT
tv82 = -8						; size = 4
$T1 = -4						; size = 4
_fps$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_quality$ = 20						; size = 4
_preset$ = 24						; size = 4
_bUse444$ = 28						; size = 1
_colorDesc$ = 32					; size = 4
_maxBitRate$ = 36					; size = 4
_bufferSize$ = 40					; size = 4
_bUseCFR$ = 44						; size = 1
?CreateX264Encoder@@YAPAVVideoEncoder@@HHHHPB_W_NAAUColorDescription@@HH1@Z PROC ; CreateX264Encoder, COMDAT

; 613  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 614  :     return new X264Encoder(fps, width, height, quality, preset, bUse444, colorDesc, maxBitRate, bufferSize, bUseCFR);

	push	1160					; 00000488H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN3@CreateX264
	movzx	eax, BYTE PTR _bUseCFR$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bufferSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _maxBitRate$[ebp]
	push	edx
	mov	eax, DWORD PTR _colorDesc$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _bUse444$[ebp]
	push	ecx
	mov	edx, DWORD PTR _preset$[ebp]
	push	edx
	mov	eax, DWORD PTR _quality$[ebp]
	push	eax
	mov	ecx, DWORD PTR _height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _width$[ebp]
	push	edx
	mov	eax, DWORD PTR _fps$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T1[ebp]
	call	??0X264Encoder@@QAE@HHHHPB_W_NAAUColorDescription@@HH1@Z ; X264Encoder::X264Encoder
	mov	DWORD PTR tv82[ebp], eax
	jmp	SHORT $LN4@CreateX264
$LN3@CreateX264:
	mov	DWORD PTR tv82[ebp], 0
$LN4@CreateX264:
	mov	eax, DWORD PTR tv82[ebp]

; 615  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CreateX264Encoder@@YAPAVVideoEncoder@@HHHHPB_W_NAAUColorDescription@@HH1@Z ENDP ; CreateX264Encoder
_TEXT	ENDS
END

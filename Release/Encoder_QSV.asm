; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

	TITLE	F:\songmm_moon_stone_obs\OBS\Source\Encoder_QSV.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?emulation_prevention_pattern@?CF@??ProcessEncodedFrame@QSVEncoder@@QAEXAAV?$List@UDataPacket@@@@AAV?$List@W4PacketType@@@@KAAKI@Z@4QBEB ; `QSVEncoder::ProcessEncodedFrame'::`37'::emulation_prevention_pattern
PUBLIC	??_7QSVEncoder@@6B@				; QSVEncoder::`vftable'
PUBLIC	??_R0?AUencode_task@QSVEncoder@@@8		; QSVEncoder::encode_task `RTTI Type Descriptor'
PUBLIC	??_R4QSVEncoder@@6B@				; QSVEncoder::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUmfxFrameData@@@8			; mfxFrameData `RTTI Type Descriptor'
PUBLIC	??_7VideoEncoder@@6B@				; VideoEncoder::`vftable'
PUBLIC	??_R0?AVVideoEncoder@@@8			; VideoEncoder `RTTI Type Descriptor'
PUBLIC	??_R2QSVEncoder@@8				; QSVEncoder::`RTTI Base Class Array'
PUBLIC	?usageStr@?A0x7e09c670@@3PAPB_WA		; `anonymous namespace'::usageStr
PUBLIC	?rate_control_str@?A0x7e09c670@@3PAU<unnamed-type-rate_control_str>@1@A ; `anonymous namespace'::rate_control_str
PUBLIC	?implStr@?A0x7e09c670@@3PAPB_WA			; `anonymous namespace'::implStr
PUBLIC	?start_seq@?8??ProcessEncodedFrame@QSVEncoder@@QAEXAAV?$List@UDataPacket@@@@AAV?$List@W4PacketType@@@@KAAKI@Z@4QBEB ; `QSVEncoder::ProcessEncodedFrame'::`9'::start_seq
PUBLIC	??_R0?AUx264_nal_t@@@8				; x264_nal_t `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@VideoEncoder@@8			; VideoEncoder::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4VideoEncoder@@6B@				; VideoEncoder::`RTTI Complete Object Locator'
PUBLIC	__TI2CPA_W
PUBLIC	??_R0?AUVideoPacket@@@8				; VideoPacket `RTTI Type Descriptor'
PUBLIC	??_R0PA_W@8					; wchar_t * `RTTI Type Descriptor'
PUBLIC	??_R0?AVQSVEncoder@@@8				; QSVEncoder `RTTI Type Descriptor'
PUBLIC	??_R0_J@8					; __int64 `RTTI Type Descriptor'
PUBLIC	??_R3VideoEncoder@@8				; VideoEncoder::`RTTI Class Hierarchy Descriptor'
PUBLIC	__CT??_R0PA_W@84
PUBLIC	??_R2VideoEncoder@@8				; VideoEncoder::`RTTI Base Class Array'
PUBLIC	??_R0?AUDataPacket@@@8				; DataPacket `RTTI Type Descriptor'
PUBLIC	__CTA2PA_W
PUBLIC	??_R1A@?0A@EA@QSVEncoder@@8			; QSVEncoder::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
PUBLIC	?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::npos
PUBLIC	__CT??_R0PAX@84
PUBLIC	??_R3QSVEncoder@@8				; QSVEncoder::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0PAX@8					; void * `RTTI Type Descriptor'
PUBLIC	??_C@_1GA@FFPJBDII@?$AAR?$AAe?$AAc?$AAa?$AAl?$AAc?$AAu?$AAl?$AAa?$AAt?$AAe?$AAd?$AA?5?$AAb?$AAf?$AAr?$AAa?$AAm?$AAe?$AA_?$AAd?$AAe?$AAl?$AAa?$AAy?$AA?3?$AA?5?$AA?$CF?$AAu?$AA?0?$AA?5?$AAi@ ; `string'
PUBLIC	??_C@_1EG@IOAIFOJM@?$AAb?$AAf?$AAr?$AAa?$AAm?$AAe?$AA_?$AAd?$AAe?$AAl?$AAa?$AAy?$AA?$DN?$AA?$CF?$AAu?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAi?$AAn?$AAi?$AAt?$AA_?$AAp?$AAt?$AAs?$AA?4?$AAN?$AAu?$AAm?$AA?$DN@ ; `string'
PUBLIC	??_C@_1O@GNHABGLI@?$AAU?$AAs?$AAe?$AAC?$AAB?$AAR?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BO@PCCCHKLK@?$AAV?$AAi?$AAd?$AAe?$AAo?$AA?5?$AAE?$AAn?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA?$AA@ ; `string'
PUBLIC	??_C@_1GC@LANNAHFH@?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AAu?$AAr?$AAe?$AAd?$AA?5?$AAb?$AAi?$AAt?$AAr?$AAa?$AAt?$AAe?$AA?5?$AA?$CF?$AAd?$AA?5?$AAe?$AAx?$AAc?$AAe?$AAe?$AAd?$AAs?$AA?5?$AAQ?$AAS@ ; `string'
PUBLIC	??_C@_1CC@INKCNOFG@?$AAK?$AAe?$AAy?$AAf?$AAr?$AAa?$AAm?$AAe?$AAI?$AAn?$AAt?$AAe?$AAr?$AAv?$AAa?$AAl?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BE@ODBMCAAO@?$AAQ?$AAS?$AAV?$AAP?$AAr?$AAe?$AAs?$AAe?$AAt?$AA?$AA@ ; `string'
PUBLIC	??_C@_19PKICIIJD@?$AAh?$AAi?$AAg?$AAh?$AA?$AA@	; `string'
PUBLIC	??_C@_1BI@CHOFIDHM@?$AAX?$AA2?$AA6?$AA4?$AAP?$AAr?$AAo?$AAf?$AAi?$AAl?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DG@KLBNDPKC@?$AAQ?$AAS?$AAV?$AAU?$AAs?$AAe?$AAV?$AAi?$AAd?$AAe?$AAo?$AAE?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AAS?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CE@FAHANJKA@?$AAC?$AAu?$AAs?$AAt?$AAo?$AAm?$AAQ?$AAS?$AAV?$AAS?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EI@EDAOEDLO@?$AAU?$AAs?$AAi?$AAn?$AAg?$AA?5?$AAc?$AAu?$AAs?$AAt?$AAo?$AAm?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?5?$AAs?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AAs?$AA?3?$AA?5?$AA?$CC@ ; `string'
PUBLIC	??_C@_06IONMGJI@keyint?$AA@			; `string'
PUBLIC	??_C@_07IBIPAAJI@bframes?$AA@			; `string'
PUBLIC	??_C@_07DKALODOL@qsvimpl?$AA@			; `string'
PUBLIC	??_C@_05GMGJDJAH@d3d11?$AA@			; `string'
PUBLIC	??_C@_04PGKLGAGG@d3d9?$AA@			; `string'
PUBLIC	??_C@_07LNMDFKEJ@profile?$AA@			; `string'
PUBLIC	??_C@_1BC@PBFEDEIE@?$AAb?$AAa?$AAs?$AAe?$AAl?$AAi?$AAn?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_19NACPGGMO@?$AAm?$AAa?$AAi?$AAn?$AA?$AA@	; `string'
PUBLIC	??_C@_1HC@EHFMGPIB@?$AAQ?$AAS?$AAV?$AA?3?$AA?5?$AAU?$AAn?$AAr?$AAe?$AAc?$AAo?$AAg?$AAn?$AAi?$AAz?$AAe?$AAd?$AA?5?$AAp?$AAr?$AAo?$AAf?$AAi?$AAl?$AAe?$AA?5?$AA?8?$AA?$CF?$AAs?$AA?8?$AA?0?$AA?5@ ; `string'
PUBLIC	??_C@_1EI@MGAFFPDA@?$AAE?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?4?$AAQ?$AAS?$AAV?$AA?4?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AAL?$AAa?$AAu?$AAn?$AAc?$AAh?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AAV?$AAi@ ; `string'
PUBLIC	??_C@_1EI@BEBMIADP@?$AAQ?$AAS?$AAV?$AA?5?$AAi?$AAs?$AA?5?$AAn?$AAo?$AA?5?$AAl?$AAo?$AAn?$AAg?$AAe?$AAr?$AA?5?$AAs?$AAu?$AAp?$AAp?$AAo?$AAr?$AAt?$AAe?$AAd?$AA?5?$AAo?$AAn?$AA?5?$AAV?$AAi@ ; `string'
PUBLIC	??_C@_1DO@OPJHFIHF@?$AAE?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?4?$AAQ?$AAS?$AAV?$AA?4?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AAL?$AAa?$AAu?$AAn?$AAc?$AAh?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EG@KGHDNBFC@?$AAC?$AAo?$AAu?$AAl?$AAd?$AAn?$AA?8?$AAt?$AA?5?$AAl?$AAa?$AAu?$AAn?$AAc?$AAh?$AA?5?$AAQ?$AAS?$AAV?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AA?4?$AAe?$AAx?$AAe?$AA?3?$AA?5?$AA?$CF@ ; `string'
PUBLIC	??_C@_1BK@BCABKOOC@?$AAi?$AAn?$AAi?$AAt?$AA_?$AAr?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CA@CDIPFIBO@?$AAU?$AAs?$AAe?$AAC?$AAu?$AAs?$AAt?$AAo?$AAm?$AAP?$AAa?$AAr?$AAa?$AAm?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BO@ENCKOBAL@?$AAQ?$AAS?$AAV?$AA?5?$AA?$CI?$AAA?$AAd?$AAv?$AAa?$AAn?$AAc?$AAe?$AAd?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DK@IPJBHBLN@?$AAQ?$AAS?$AAV?$AA?3?$AA?5?$AAU?$AAs?$AAi?$AAn?$AAg?$AA?5?$AAc?$AAu?$AAs?$AAt?$AAo?$AAm?$AA?5?$AAp?$AAa?$AAr?$AAa?$AAm?$AAe?$AAt?$AAe?$AAr?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CE@IBGNPBIO@?$AAR?$AAa?$AAt?$AAe?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AAM?$AAe?$AAt?$AAh?$AAo?$AAd?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CC@HBKEGJCM@?$AAU?$AAs?$AAe?$AAG?$AAl?$AAo?$AAb?$AAa?$AAl?$AAB?$AAi?$AAt?$AAr?$AAa?$AAt?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CI@KDHOMFIK@?$AAU?$AAs?$AAe?$AAG?$AAl?$AAo?$AAb?$AAa?$AAl?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAS?$AAi?$AAz?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BG@IDKHPHBG@?$AAT?$AAa?$AAr?$AAg?$AAe?$AAt?$AAK?$AAb?$AAp?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BO@CJMDAOPJ@?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAS?$AAi?$AAz?$AAe?$AAI?$AAn?$AAK?$AAB?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BA@IBNIMAHO@?$AAM?$AAa?$AAx?$AAK?$AAb?$AAp?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BC@OHENPEDC@?$AAA?$AAc?$AAc?$AAu?$AAr?$AAa?$AAc?$AAy?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BI@CJLLPJDH@?$AAC?$AAo?$AAn?$AAv?$AAe?$AAr?$AAg?$AAe?$AAn?$AAc?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_17OJMDMMIO@?$AAQ?$AAP?$AAI?$AA?$AA@	; `string'
PUBLIC	??_C@_17MENCNEJL@?$AAQ?$AAP?$AAP?$AA?$AA@	; `string'
PUBLIC	??_C@_17DOMCELIP@?$AAQ?$AAP?$AAB?$AA?$AA@	; `string'
PUBLIC	??_C@_1BG@OLCPADEI@?$AAI?$AAC?$AAQ?$AAQ?$AAu?$AAa?$AAl?$AAi?$AAt?$AAy?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BA@IAHEMFAP@?$AAL?$AAA?$AAD?$AAe?$AAp?$AAt?$AAh?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BM@MFIKDNIH@?$AAi?$AAn?$AAi?$AAt?$AA_?$AAr?$AAe?$AAs?$AAp?$AAo?$AAn?$AAs?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DI@NLPDPCNO@?$AAE?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?4?$AAQ?$AAS?$AAV?$AA?4?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AAE?$AAa?$AAr?$AAl?$AAy?$AAE?$AAx?$AAi?$AAt?$AA?$AA@ ; `string'
PUBLIC	??_C@_1HC@HGAJLDHP@?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAg?$AAe?$AAt?$AA?5?$AAe?$AAx?$AAi?$AAt?$AA?5?$AAc?$AAo?$AAd?$AAe?$AA?5?$AAw?$AAh?$AAi?$AAl?$AAe?$AA?5?$AAi?$AAn@ ; `string'
PUBLIC	??_C@_1DK@KOIAJGOC@?$AAE?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?4?$AAQ?$AAS?$AAV?$AA?4?$AAI?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AAI?$AAm?$AAp?$AAl?$AA?$AA@ ; `string'
PUBLIC	??_C@_1LO@DHEHLBEE@?$AAQ?$AAS?$AAV?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AA?4?$AAe?$AAx?$AAe?$AA?5?$AAh?$AAa?$AAs?$AA?5?$AAe?$AAx?$AAi?$AAt?$AAe?$AAd?$AA?5?$AAb?$AAe?$AAc?$AAa?$AAu?$AAs?$AAe@ ; `string'
PUBLIC	??_C@_1DE@MCCIFHMH@?$AAE?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?4?$AAQ?$AAS?$AAV?$AA?4?$AAN?$AAo?$AAV?$AAa?$AAl?$AAi?$AAd?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AA?$AA@ ; `string'
PUBLIC	??_C@_1IC@JEHGHKKI@?$AAQ?$AAS?$AAV?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AA?4?$AAe?$AAx?$AAe?$AA?5?$AAh?$AAa?$AAs?$AA?5?$AAe?$AAx?$AAi?$AAt?$AAe?$AAd?$AA?5?$AAb?$AAe?$AAc?$AAa?$AAu?$AAs?$AAe@ ; `string'
PUBLIC	??_C@_1GG@IFDPCDFB@?$AAQ?$AAS?$AAV?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AA?4?$AAe?$AAx?$AAe?$AA?5?$AAc?$AAo?$AAu?$AAl?$AAd?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAf?$AAi?$AAn?$AAd?$AA?5?$AAa?$AA?5?$AAv@ ; `string'
PUBLIC	??_C@_1EG@ONGBBGA@?$AAE?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?4?$AAQ?$AAS?$AAV?$AA?4?$AAI?$AAn?$AAi?$AAt?$AAC?$AAu?$AAs?$AAt?$AAo?$AAm?$AAP?$AAa?$AAr?$AAa?$AAm?$AAs?$AAF?$AAa?$AAi?$AAl@ ; `string'
PUBLIC	??_C@_1JC@NLDIMFFD@?$AAE?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAw?$AAi@ ; `string'
PUBLIC	??_C@_1HA@GIELBKIB@?$AAQ?$AAS?$AAV?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AA?4?$AAe?$AAx?$AAe?$AA?5?$AAh?$AAa?$AAs?$AA?5?$AAe?$AAx?$AAi?$AAt?$AAe?$AAd?$AA?5?$AAw?$AAi?$AAt?$AAh?$AA?5?$AAc?$AAo@ ; `string'
PUBLIC	??_C@_1GO@OPENBPNL@?$AAC?$AAo?$AAu?$AAl?$AAd?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?5?$AAQ?$AAS?$AAV?$AA?5?$AAs?$AAe?$AAs?$AAs?$AAi?$AAo?$AAn@ ; `string'
PUBLIC	??_C@_1FI@HNDPAIDH@?$AAQ?$AAS?$AAV?$AA?5?$AAv?$AAe?$AAr?$AAs?$AAi?$AAo?$AAn?$AA?5?$AA?$CF?$AAu?$AA?4?$AA?$CF?$AAu?$AA?5?$AAu?$AAs?$AAi?$AAn?$AAg?$AA?5?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?5?$AA?$CI?$AAa?$AAc@ ; `string'
PUBLIC	??_C@_1BO@LPFGHFJC@?$AAb?$AAi?$AAt?$AAs?$AAt?$AAr?$AAe?$AAa?$AAm?$AA_?$AAb?$AAu?$AAf?$AAf?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BG@ONLLBCFI@?$AAf?$AAr?$AAa?$AAm?$AAe?$AA_?$AAb?$AAu?$AAf?$AAf?$AA?$AA@ ; `string'
PUBLIC	??_C@_1FC@PLEAILN@?$AAU?$AAs?$AAi?$AAn?$AAg?$AA?5?$AA?$CF?$AAu?$AA?5?$AAb?$AAi?$AAt?$AAs?$AAt?$AAr?$AAe?$AAa?$AAm?$AAs?$AA?5?$AAa?$AAn?$AAd?$AA?5?$AA?$CF?$AAu?$AA?5?$AAf?$AAr?$AAa?$AAm?$AAe@ ; `string'
PUBLIC	??_C@_1BI@PNGIAEEE@?$AAf?$AAr?$AAa?$AAm?$AAe?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CE@OKHPDFBP@?$AAf?$AAr?$AAa?$AAm?$AAe?$AA_?$AAb?$AAu?$AAf?$AAf?$AA_?$AAs?$AAt?$AAa?$AAt?$AAu?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BO@BLGPOMJC@?$AAb?$AAi?$AAt?$AAs?$AAt?$AAr?$AAe?$AAa?$AAm?$AA_?$AAi?$AAn?$AAf?$AAo?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CC@CNJHBCEC@?$AAf?$AAi?$AAl?$AAl?$AAe?$AAd?$AA_?$AAb?$AAi?$AAt?$AAs?$AAt?$AAr?$AAe?$AAa?$AAm?$AA?$AA@ ; `string'
PUBLIC	??_C@_19LLIMCLGL@?$AAs?$AAt?$AAo?$AAp?$AA?$AA@	; `string'
PUBLIC	??_C@_1CA@KDLBGFEM@?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA_?$AAf?$AAl?$AAu?$AAs?$AAh?$AAe?$AAd?$AA?$AA@ ; `string'
PUBLIC	??_C@_1FA@PLGDJKOD@?$AAT?$AAe?$AAr?$AAm?$AAi?$AAn?$AAa?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAQ?$AAS?$AAV?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AA?4?$AAe?$AAx?$AAe?$AA?5?$AAa?$AAf?$AAt?$AAe?$AAr?$AA?5@ ; `string'
PUBLIC	??_C@_1CO@CDPCGBKB@?$AAU?$AAn?$AAh?$AAa?$AAn?$AAd?$AAl?$AAe?$AAd?$AA?5?$AAf?$AAr?$AAa?$AAm?$AAe?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$CF?$AAu?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DK@NCJGJBIK@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAa?$AAl?$AAl?$AA?5?$AAf?$AAr?$AAa?$AAm?$AAe?$AAs?$AA?5?$AAa?$AAr?$AAe?$AA?5?$AAi?$AAn?$AA?5?$AAu?$AAs?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CA@JOCIALON@?$AAQ?$AAu?$AAe?$AAu?$AAe?$AAE?$AAn?$AAc?$AAo?$AAd?$AAe?$AAT?$AAa?$AAs?$AAk?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DA@KMEGBFDO@?$AAQ?$AAS?$AAV?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?5?$AAi?$AAs?$AA?5?$AAt?$AAo?$AAo?$AA?5?$AAs?$AAl?$AAo?$AAw?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CM@LDBFCFIL@?$AAQ?$AAS?$AAV?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AA?4?$AAe?$AAx?$AAe?$AA?5?$AAe?$AAx?$AAi?$AAt?$AAe?$AAd?$AA?$CB?$AA?$AA@ ; `string'
PUBLIC	??_C@_1FA@BILEIEBO@?$AAQ?$AAS?$AAV?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AA?4?$AAe?$AAx?$AAe?$AA?5?$AAw?$AAa?$AAs?$AA?5?$AAk?$AAi?$AAl?$AAl?$AAe?$AAd?$AA?0?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe@ ; `string'
PUBLIC	??_C@_1JK@CGJBOKOI@?$AAQ?$AAS?$AAV?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AA?4?$AAe?$AAx?$AAe?$AA?5?$AAh?$AAa?$AAs?$AA?5?$AAe?$AAx?$AAi?$AAt?$AAe?$AAd?$AA?5?$AAb?$AAe?$AAc?$AAa?$AAu?$AAs?$AAe@ ; `string'
PUBLIC	??_C@_1EM@POGNGIIP@?$AAQ?$AAS?$AAV?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AA?4?$AAe?$AAx?$AAe?$AA?5?$AAh?$AAa?$AAs?$AA?5?$AAe?$AAx?$AAi?$AAt?$AAe?$AAd?$AA?5?$AAw?$AAi?$AAt?$AAh?$AA?5?$AAc?$AAo@ ; `string'
PUBLIC	??_C@_1CI@CHNAFGEH@?$AAP?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AAE?$AAn?$AAc?$AAo?$AAd?$AAe?$AAd?$AAF?$AAr?$AAa?$AAm?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BI@JCHINCJN@?$AAs?$AAp?$AAs?$AAp?$AAp?$AAs?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BC@ENMPJGED@?$AAs?$AAp?$AAs?$AA_?$AAb?$AAu?$AAf?$AAf?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BC@KHEJELCB@?$AAp?$AAp?$AAs?$AA_?$AAb?$AAu?$AAf?$AAf?$AA?$AA@ ; `string'
PUBLIC	??_C@_07NFANNNEC@UNKNOWN?$AA@			; `string'
PUBLIC	??_C@_1CI@PIFIBIKK@?$AAV?$AAi?$AAd?$AAe?$AAo?$AA?5?$AAE?$AAn?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA?3?$AA?5?$AAQ?$AAS?$AAV?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BI@HKMIKHPB@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAf?$AAp?$AAs?$AA?3?$AA?5?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BM@NGONPCKN@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?3?$AA?5?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BG@CGNKKOP@?$AA?0?$AA?5?$AAh?$AAe?$AAi?$AAg?$AAh?$AAt?$AA?3?$AA?5?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CK@EKEMKBOE@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAt?$AAa?$AAr?$AAg?$AAe?$AAt?$AA?9?$AAu?$AAs?$AAa?$AAg?$AAe?$AA?3?$AA?5?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CA@CJBHDLKD@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAp?$AAr?$AAo?$AAf?$AAi?$AAl?$AAe?$AA?3?$AA?5?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BI@KDIADLNE@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAC?$AAB?$AAR?$AA?3?$AA?5?$AA?$AA@ ; `string'
PUBLIC	??_C@_17IHBDLLG@?$AAy?$AAe?$AAs?$AA?$AA@	; `string'
PUBLIC	??_C@_15BPIGNHCD@?$AAn?$AAo?$AA?$AA@		; `string'
PUBLIC	??_C@_1BI@KKGLJLKO@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAC?$AAF?$AAR?$AA?3?$AA?5?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CI@MGGEJOEN@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAm?$AAa?$AAx?$AA?5?$AAb?$AAi?$AAt?$AAr?$AAa?$AAt?$AAe?$AA?3?$AA?5?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CI@EBHCIKPJ@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?3?$AA?5?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CK@LENIODAI@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAr?$AAa?$AAt?$AAe?$AA?5?$AAc?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AA?3?$AA?5?$AA?$AA@ ; `string'
PUBLIC	??_C@_1GK@LBKOEOMF@?$AAL?$AAi?$AAs?$AAt?$AA?3?$AA?3?$AAI?$AAn?$AAs?$AAe?$AAr?$AAt?$AAA?$AAr?$AAr?$AAa?$AAy?$AA?3?$AA?5?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?5?$AAw@ ; `string'
PUBLIC	??_C@_1FI@OMPFMOGB@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAC?$AAi?$AAr?$AAc?$AAu?$AAl?$AAa?$AAr?$AAL?$AAi?$AAs?$AAt?$AA?3?$AA?3?$AAo?$AAp?$AAe@ ; `string'
PUBLIC	??_C@_1O@IENHAHCD@?$AAS?$AAi?$AAg?$AAn?$AAa?$AAl?$AA?$AA@ ; `string'
PUBLIC	??_C@_19PDHPMPEG@?$AAL?$AAo?$AAc?$AAk?$AA?$AA@	; `string'
EXTRN	__imp_??0ProfilerNode@@QAE@PB_W_N@Z:PROC
EXTRN	__imp_??1ProfilerNode@@QAE@XZ:PROC
EXTRN	__imp__ReleaseMutex@4:PROC
EXTRN	__imp_?GetToken@String@@QBE?AV1@H_W@Z:PROC
EXTRN	__imp_?GetTokenList@String@@QBEXAAVStringList@@_WH@Z:PROC
EXTRN	__imp__WaitForMultipleObjects@16:PROC
EXTRN	__imp__htonl@4:PROC
EXTRN	__imp__CreateEventW@16:PROC
EXTRN	__imp__CreateFileMappingW@24:PROC
EXTRN	__imp_?OBSGetAppDataPath@@YAPB_WXZ:PROC
EXTRN	__imp__htons@4:PROC
EXTRN	__imp__TerminateProcess@8:PROC
EXTRN	__imp__GetExitCodeProcess@8:PROC
EXTRN	__imp__SetEvent@4:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp_?GetString@ConfigFile@@QAE?AVString@@PB_W00@Z:PROC
EXTRN	__imp__CreateProcessW@40:PROC
EXTRN	__imp__UnmapViewOfFile@4:PROC
EXTRN	__imp__MapViewOfFile@20:PROC
EXTRN	__imp__CreateMutexW@12:PROC
EXTRN	__imp_?OutputByte@Serializer@@QAEAAV1@E@Z:PROC
EXTRN	__imp_?OutputWord@Serializer@@QAEAAV1@G@Z:PROC
EXTRN	__imp_?OutputDword@Serializer@@QAEAAV1@K@Z:PROC
EXTRN	__imp_?Serialize@BufferOutputSerializer@@UAEXPBXK@Z:PROC
EXTRN	__imp_?MakeLower@String@@QAEAAV1@XZ:PROC
;	COMDAT ?warning_logged@?N@??CheckQSVHardwareSupport@@YA_N_NPA_N@Z@4_NA
_BSS	SEGMENT
?warning_logged@?N@??CheckQSVHardwareSupport@@YA_N_NPA_N@Z@4_NA DB 01H DUP (?) ; `CheckQSVHardwareSupport'::`13'::warning_logged
_BSS	ENDS
;	COMDAT ??_C@_19PDHPMPEG@?$AAL?$AAo?$AAc?$AAk?$AA?$AA@
CONST	SEGMENT
??_C@_19PDHPMPEG@?$AAL?$AAo?$AAc?$AAk?$AA?$AA@ DB 'L', 00H, 'o', 00H, 'c', 00H
	DB	'k', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@IENHAHCD@?$AAS?$AAi?$AAg?$AAn?$AAa?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1O@IENHAHCD@?$AAS?$AAi?$AAg?$AAn?$AAa?$AAl?$AA?$AA@ DB 'S', 00H, 'i'
	DB	00H, 'g', 00H, 'n', 00H, 'a', 00H, 'l', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FI@OMPFMOGB@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAC?$AAi?$AAr?$AAc?$AAu?$AAl?$AAa?$AAr?$AAL?$AAi?$AAs?$AAt?$AA?3?$AA?3?$AAo?$AAp?$AAe@
CONST	SEGMENT
??_C@_1FI@OMPFMOGB@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAC?$AAi?$AAr?$AAc?$AAu?$AAl?$AAa?$AAr?$AAL?$AAi?$AAs?$AAt?$AA?3?$AA?3?$AAo?$AAp?$AAe@ DB 'O'
	DB	00H, 'u', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H
	DB	'r', 00H, 'a', 00H, 'n', 00H, 'g', 00H, 'e', 00H, '!', 00H, ' '
	DB	00H, ' ', 00H, 'C', 00H, 'i', 00H, 'r', 00H, 'c', 00H, 'u', 00H
	DB	'l', 00H, 'a', 00H, 'r', 00H, 'L', 00H, 'i', 00H, 's', 00H, 't'
	DB	00H, ':', 00H, ':', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H
	DB	'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '[', 00H, ']', 00H, '('
	DB	00H, '%', 00H, 'd', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1GK@LBKOEOMF@?$AAL?$AAi?$AAs?$AAt?$AA?3?$AA?3?$AAI?$AAn?$AAs?$AAe?$AAr?$AAt?$AAA?$AAr?$AAr?$AAa?$AAy?$AA?3?$AA?5?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?5?$AAw@
CONST	SEGMENT
??_C@_1GK@LBKOEOMF@?$AAL?$AAi?$AAs?$AAt?$AA?3?$AA?3?$AAI?$AAn?$AAs?$AAe?$AAr?$AAt?$AAA?$AAr?$AAr?$AAa?$AAy?$AA?3?$AA?5?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?5?$AAw@ DB 'L'
	DB	00H, 'i', 00H, 's', 00H, 't', 00H, ':', 00H, ':', 00H, 'I', 00H
	DB	'n', 00H, 's', 00H, 'e', 00H, 'r', 00H, 't', 00H, 'A', 00H, 'r'
	DB	00H, 'r', 00H, 'a', 00H, 'y', 00H, ':', 00H, ' ', 00H, ' ', 00H
	DB	'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, ' ', 00H, 'a', 00H, 'r'
	DB	00H, 'r', 00H, 'a', 00H, 'y', 00H, ' ', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'u', 00H, 'n'
	DB	00H, 't', 00H, ' ', 00H, 'a', 00H, 'b', 00H, 'o', 00H, 'v', 00H
	DB	'e', 00H, ' ', 00H, 'z', 00H, 'e', 00H, 'r', 00H, 'o', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@LENIODAI@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAr?$AAa?$AAt?$AAe?$AA?5?$AAc?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AA?3?$AA?5?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@LENIODAI@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAr?$AAa?$AAt?$AAe?$AA?5?$AAc?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AA?3?$AA?5?$AA?$AA@ DB 0dH
	DB	00H, 0aH, 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'r', 00H
	DB	'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'n'
	DB	00H, 't', 00H, 'r', 00H, 'o', 00H, 'l', 00H, ':', 00H, ' ', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@EBHCIKPJ@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?3?$AA?5?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@EBHCIKPJ@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?3?$AA?5?$AA?$AA@ DB 0dH
	DB	00H, 0aH, 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'b', 00H
	DB	'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H, 'r', 00H, ' ', 00H, 's'
	DB	00H, 'i', 00H, 'z', 00H, 'e', 00H, ':', 00H, ' ', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@MGGEJOEN@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAm?$AAa?$AAx?$AA?5?$AAb?$AAi?$AAt?$AAr?$AAa?$AAt?$AAe?$AA?3?$AA?5?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@MGGEJOEN@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAm?$AAa?$AAx?$AA?5?$AAb?$AAi?$AAt?$AAr?$AAa?$AAt?$AAe?$AA?3?$AA?5?$AA?$AA@ DB 0dH
	DB	00H, 0aH, 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'm', 00H
	DB	'a', 00H, 'x', 00H, ' ', 00H, 'b', 00H, 'i', 00H, 't', 00H, 'r'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, ':', 00H, ' ', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@KKGLJLKO@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAC?$AAF?$AAR?$AA?3?$AA?5?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@KKGLJLKO@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAC?$AAF?$AAR?$AA?3?$AA?5?$AA?$AA@ DB 0dH
	DB	00H, 0aH, 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'C', 00H
	DB	'F', 00H, 'R', 00H, ':', 00H, ' ', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15BPIGNHCD@?$AAn?$AAo?$AA?$AA@
CONST	SEGMENT
??_C@_15BPIGNHCD@?$AAn?$AAo?$AA?$AA@ DB 'n', 00H, 'o', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_17IHBDLLG@?$AAy?$AAe?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_17IHBDLLG@?$AAy?$AAe?$AAs?$AA?$AA@ DB 'y', 00H, 'e', 00H, 's', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@KDIADLNE@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAC?$AAB?$AAR?$AA?3?$AA?5?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@KDIADLNE@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAC?$AAB?$AAR?$AA?3?$AA?5?$AA?$AA@ DB 0dH
	DB	00H, 0aH, 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'C', 00H
	DB	'B', 00H, 'R', 00H, ':', 00H, ' ', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@CJBHDLKD@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAp?$AAr?$AAo?$AAf?$AAi?$AAl?$AAe?$AA?3?$AA?5?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@CJBHDLKD@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAp?$AAr?$AAo?$AAf?$AAi?$AAl?$AAe?$AA?3?$AA?5?$AA?$AA@ DB 0dH
	DB	00H, 0aH, 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'p', 00H
	DB	'r', 00H, 'o', 00H, 'f', 00H, 'i', 00H, 'l', 00H, 'e', 00H, ':'
	DB	00H, ' ', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@EKEMKBOE@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAt?$AAa?$AAr?$AAg?$AAe?$AAt?$AA?9?$AAu?$AAs?$AAa?$AAg?$AAe?$AA?3?$AA?5?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@EKEMKBOE@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAt?$AAa?$AAr?$AAg?$AAe?$AAt?$AA?9?$AAu?$AAs?$AAa?$AAg?$AAe?$AA?3?$AA?5?$AA?$AA@ DB 0dH
	DB	00H, 0aH, 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 't', 00H
	DB	'a', 00H, 'r', 00H, 'g', 00H, 'e', 00H, 't', 00H, '-', 00H, 'u'
	DB	00H, 's', 00H, 'a', 00H, 'g', 00H, 'e', 00H, ':', 00H, ' ', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@CGNKKOP@?$AA?0?$AA?5?$AAh?$AAe?$AAi?$AAg?$AAh?$AAt?$AA?3?$AA?5?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@CGNKKOP@?$AA?0?$AA?5?$AAh?$AAe?$AAi?$AAg?$AAh?$AAt?$AA?3?$AA?5?$AA?$AA@ DB ','
	DB	00H, ' ', 00H, 'h', 00H, 'e', 00H, 'i', 00H, 'g', 00H, 'h', 00H
	DB	't', 00H, ':', 00H, ' ', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@NGONPCKN@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?3?$AA?5?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@NGONPCKN@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?3?$AA?5?$AA?$AA@ DB 0dH
	DB	00H, 0aH, 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'w', 00H
	DB	'i', 00H, 'd', 00H, 't', 00H, 'h', 00H, ':', 00H, ' ', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@HKMIKHPB@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAf?$AAp?$AAs?$AA?3?$AA?5?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@HKMIKHPB@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAf?$AAp?$AAs?$AA?3?$AA?5?$AA?$AA@ DB 0dH
	DB	00H, 0aH, 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'f', 00H
	DB	'p', 00H, 's', 00H, ':', 00H, ' ', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@PIFIBIKK@?$AAV?$AAi?$AAd?$AAe?$AAo?$AA?5?$AAE?$AAn?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA?3?$AA?5?$AAQ?$AAS?$AAV?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@PIFIBIKK@?$AAV?$AAi?$AAd?$AAe?$AAo?$AA?5?$AAE?$AAn?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA?3?$AA?5?$AAQ?$AAS?$AAV?$AA?$AA@ DB 'V'
	DB	00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, ' ', 00H, 'E', 00H
	DB	'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'i', 00H, 'n', 00H, 'g'
	DB	00H, ':', 00H, ' ', 00H, 'Q', 00H, 'S', 00H, 'V', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07NFANNNEC@UNKNOWN?$AA@
CONST	SEGMENT
??_C@_07NFANNNEC@UNKNOWN?$AA@ DB 'UNKNOWN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@KHEJELCB@?$AAp?$AAp?$AAs?$AA_?$AAb?$AAu?$AAf?$AAf?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@KHEJELCB@?$AAp?$AAp?$AAs?$AA_?$AAb?$AAu?$AAf?$AAf?$AA?$AA@ DB 'p'
	DB	00H, 'p', 00H, 's', 00H, '_', 00H, 'b', 00H, 'u', 00H, 'f', 00H
	DB	'f', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@ENMPJGED@?$AAs?$AAp?$AAs?$AA_?$AAb?$AAu?$AAf?$AAf?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@ENMPJGED@?$AAs?$AAp?$AAs?$AA_?$AAb?$AAu?$AAf?$AAf?$AA?$AA@ DB 's'
	DB	00H, 'p', 00H, 's', 00H, '_', 00H, 'b', 00H, 'u', 00H, 'f', 00H
	DB	'f', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@JCHINCJN@?$AAs?$AAp?$AAs?$AAp?$AAp?$AAs?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@JCHINCJN@?$AAs?$AAp?$AAs?$AAp?$AAp?$AAs?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ DB 's'
	DB	00H, 'p', 00H, 's', 00H, 'p', 00H, 'p', 00H, 's', 00H, '_', 00H
	DB	's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@CHNAFGEH@?$AAP?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AAE?$AAn?$AAc?$AAo?$AAd?$AAe?$AAd?$AAF?$AAr?$AAa?$AAm?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@CHNAFGEH@?$AAP?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AAE?$AAn?$AAc?$AAo?$AAd?$AAe?$AAd?$AAF?$AAr?$AAa?$AAm?$AAe?$AA?$AA@ DB 'P'
	DB	00H, 'r', 00H, 'o', 00H, 'c', 00H, 'e', 00H, 's', 00H, 's', 00H
	DB	'E', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'd'
	DB	00H, 'F', 00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EM@POGNGIIP@?$AAQ?$AAS?$AAV?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AA?4?$AAe?$AAx?$AAe?$AA?5?$AAh?$AAa?$AAs?$AA?5?$AAe?$AAx?$AAi?$AAt?$AAe?$AAd?$AA?5?$AAw?$AAi?$AAt?$AAh?$AA?5?$AAc?$AAo@
CONST	SEGMENT
??_C@_1EM@POGNGIIP@?$AAQ?$AAS?$AAV?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AA?4?$AAe?$AAx?$AAe?$AA?5?$AAh?$AAa?$AAs?$AA?5?$AAe?$AAx?$AAi?$AAt?$AAe?$AAd?$AA?5?$AAw?$AAi?$AAt?$AAh?$AA?5?$AAc?$AAo@ DB 'Q'
	DB	00H, 'S', 00H, 'V', 00H, 'H', 00H, 'e', 00H, 'l', 00H, 'p', 00H
	DB	'e', 00H, 'r', 00H, '.', 00H, 'e', 00H, 'x', 00H, 'e', 00H, ' '
	DB	00H, 'h', 00H, 'a', 00H, 's', 00H, ' ', 00H, 'e', 00H, 'x', 00H
	DB	'i', 00H, 't', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'w', 00H, 'i'
	DB	00H, 't', 00H, 'h', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, ' ', 00H, '%', 00H, 'i', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1JK@CGJBOKOI@?$AAQ?$AAS?$AAV?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AA?4?$AAe?$AAx?$AAe?$AA?5?$AAh?$AAa?$AAs?$AA?5?$AAe?$AAx?$AAi?$AAt?$AAe?$AAd?$AA?5?$AAb?$AAe?$AAc?$AAa?$AAu?$AAs?$AAe@
CONST	SEGMENT
??_C@_1JK@CGJBOKOI@?$AAQ?$AAS?$AAV?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AA?4?$AAe?$AAx?$AAe?$AA?5?$AAh?$AAa?$AAs?$AA?5?$AAe?$AAx?$AAi?$AAt?$AAe?$AAd?$AA?5?$AAb?$AAe?$AAc?$AAa?$AAu?$AAs?$AAe@ DB 'Q'
	DB	00H, 'S', 00H, 'V', 00H, 'H', 00H, 'e', 00H, 'l', 00H, 'p', 00H
	DB	'e', 00H, 'r', 00H, '.', 00H, 'e', 00H, 'x', 00H, 'e', 00H, ' '
	DB	00H, 'h', 00H, 'a', 00H, 's', 00H, ' ', 00H, 'e', 00H, 'x', 00H
	DB	'i', 00H, 't', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'b', 00H, 'e'
	DB	00H, 'c', 00H, 'a', 00H, 'u', 00H, 's', 00H, 'e', 00H, ' ', 00H
	DB	'o', 00H, 'f', 00H, ' ', 00H, 'a', 00H, 'n', 00H, ' ', 00H, 'i'
	DB	00H, 'n', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'a', 00H
	DB	't', 00H, 'i', 00H, 'b', 00H, 'l', 00H, 'e', 00H, ' ', 00H, 'q'
	DB	00H, 's', 00H, 'v', 00H, 'i', 00H, 'm', 00H, 'p', 00H, 'l', 00H
	DB	' ', 00H, 'c', 00H, 'u', 00H, 's', 00H, 't', 00H, 'o', 00H, 'm'
	DB	00H, ' ', 00H, 'p', 00H, 'a', 00H, 'r', 00H, 'a', 00H, 'm', 00H
	DB	'e', 00H, 't', 00H, 'e', 00H, 'r', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FA@BILEIEBO@?$AAQ?$AAS?$AAV?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AA?4?$AAe?$AAx?$AAe?$AA?5?$AAw?$AAa?$AAs?$AA?5?$AAk?$AAi?$AAl?$AAl?$AAe?$AAd?$AA?0?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe@
CONST	SEGMENT
??_C@_1FA@BILEIEBO@?$AAQ?$AAS?$AAV?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AA?4?$AAe?$AAx?$AAe?$AA?5?$AAw?$AAa?$AAs?$AA?5?$AAk?$AAi?$AAl?$AAl?$AAe?$AAd?$AA?0?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe@ DB 'Q'
	DB	00H, 'S', 00H, 'V', 00H, 'H', 00H, 'e', 00H, 'l', 00H, 'p', 00H
	DB	'e', 00H, 'r', 00H, '.', 00H, 'e', 00H, 'x', 00H, 'e', 00H, ' '
	DB	00H, 'w', 00H, 'a', 00H, 's', 00H, ' ', 00H, 'k', 00H, 'i', 00H
	DB	'l', 00H, 'l', 00H, 'e', 00H, 'd', 00H, ',', 00H, ' ', 00H, 'e'
	DB	00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, ' ', 00H
	DB	'f', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1CM@LDBFCFIL@?$AAQ?$AAS?$AAV?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AA?4?$AAe?$AAx?$AAe?$AA?5?$AAe?$AAx?$AAi?$AAt?$AAe?$AAd?$AA?$CB?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@LDBFCFIL@?$AAQ?$AAS?$AAV?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AA?4?$AAe?$AAx?$AAe?$AA?5?$AAe?$AAx?$AAi?$AAt?$AAe?$AAd?$AA?$CB?$AA?$AA@ DB 'Q'
	DB	00H, 'S', 00H, 'V', 00H, 'H', 00H, 'e', 00H, 'l', 00H, 'p', 00H
	DB	'e', 00H, 'r', 00H, '.', 00H, 'e', 00H, 'x', 00H, 'e', 00H, ' '
	DB	00H, 'e', 00H, 'x', 00H, 'i', 00H, 't', 00H, 'e', 00H, 'd', 00H
	DB	'!', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@KMEGBFDO@?$AAQ?$AAS?$AAV?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?5?$AAi?$AAs?$AA?5?$AAt?$AAo?$AAo?$AA?5?$AAs?$AAl?$AAo?$AAw?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@KMEGBFDO@?$AAQ?$AAS?$AAV?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?5?$AAi?$AAs?$AA?5?$AAt?$AAo?$AAo?$AA?5?$AAs?$AAl?$AAo?$AAw?$AA?$AA@ DB 'Q'
	DB	00H, 'S', 00H, 'V', 00H, ' ', 00H, 'e', 00H, 'n', 00H, 'c', 00H
	DB	'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H, ' ', 00H, 'i', 00H, 's'
	DB	00H, ' ', 00H, 't', 00H, 'o', 00H, 'o', 00H, ' ', 00H, 's', 00H
	DB	'l', 00H, 'o', 00H, 'w', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@JOCIALON@?$AAQ?$AAu?$AAe?$AAu?$AAe?$AAE?$AAn?$AAc?$AAo?$AAd?$AAe?$AAT?$AAa?$AAs?$AAk?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@JOCIALON@?$AAQ?$AAu?$AAe?$AAu?$AAe?$AAE?$AAn?$AAc?$AAo?$AAd?$AAe?$AAT?$AAa?$AAs?$AAk?$AA?$AA@ DB 'Q'
	DB	00H, 'u', 00H, 'e', 00H, 'u', 00H, 'e', 00H, 'E', 00H, 'n', 00H
	DB	'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'T', 00H, 'a', 00H, 's'
	DB	00H, 'k', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@NCJGJBIK@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAa?$AAl?$AAl?$AA?5?$AAf?$AAr?$AAa?$AAm?$AAe?$AAs?$AA?5?$AAa?$AAr?$AAe?$AA?5?$AAi?$AAn?$AA?5?$AAu?$AAs?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1DK@NCJGJBIK@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAa?$AAl?$AAl?$AA?5?$AAf?$AAr?$AAa?$AAm?$AAe?$AAs?$AA?5?$AAa?$AAr?$AAe?$AA?5?$AAi?$AAn?$AA?5?$AAu?$AAs?$AAe?$AA?$AA@ DB 'E'
	DB	00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H, ':', 00H, ' ', 00H
	DB	'a', 00H, 'l', 00H, 'l', 00H, ' ', 00H, 'f', 00H, 'r', 00H, 'a'
	DB	00H, 'm', 00H, 'e', 00H, 's', 00H, ' ', 00H, 'a', 00H, 'r', 00H
	DB	'e', 00H, ' ', 00H, 'i', 00H, 'n', 00H, ' ', 00H, 'u', 00H, 's'
	DB	00H, 'e', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@CDPCGBKB@?$AAU?$AAn?$AAh?$AAa?$AAn?$AAd?$AAl?$AAe?$AAd?$AA?5?$AAf?$AAr?$AAa?$AAm?$AAe?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$CF?$AAu?$AA?$AA@
CONST	SEGMENT
??_C@_1CO@CDPCGBKB@?$AAU?$AAn?$AAh?$AAa?$AAn?$AAd?$AAl?$AAe?$AAd?$AA?5?$AAf?$AAr?$AAa?$AAm?$AAe?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$CF?$AAu?$AA?$AA@ DB 'U'
	DB	00H, 'n', 00H, 'h', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'l', 00H
	DB	'e', 00H, 'd', 00H, ' ', 00H, 'f', 00H, 'r', 00H, 'a', 00H, 'm'
	DB	00H, 'e', 00H, 't', 00H, 'y', 00H, 'p', 00H, 'e', 00H, ' ', 00H
	DB	'%', 00H, 'u', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1FA@PLGDJKOD@?$AAT?$AAe?$AAr?$AAm?$AAi?$AAn?$AAa?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAQ?$AAS?$AAV?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AA?4?$AAe?$AAx?$AAe?$AA?5?$AAa?$AAf?$AAt?$AAe?$AAr?$AA?5@
CONST	SEGMENT
??_C@_1FA@PLGDJKOD@?$AAT?$AAe?$AAr?$AAm?$AAi?$AAn?$AAa?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAQ?$AAS?$AAV?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AA?4?$AAe?$AAx?$AAe?$AA?5?$AAa?$AAf?$AAt?$AAe?$AAr?$AA?5@ DB 'T'
	DB	00H, 'e', 00H, 'r', 00H, 'm', 00H, 'i', 00H, 'n', 00H, 'a', 00H
	DB	't', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'Q', 00H, 'S'
	DB	00H, 'V', 00H, 'H', 00H, 'e', 00H, 'l', 00H, 'p', 00H, 'e', 00H
	DB	'r', 00H, '.', 00H, 'e', 00H, 'x', 00H, 'e', 00H, ' ', 00H, 'a'
	DB	00H, 'f', 00H, 't', 00H, 'e', 00H, 'r', 00H, ' ', 00H, 't', 00H
	DB	'i', 00H, 'm', 00H, 'e', 00H, 'o', 00H, 'u', 00H, 't', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@KDLBGFEM@?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA_?$AAf?$AAl?$AAu?$AAs?$AAh?$AAe?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@KDLBGFEM@?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA_?$AAf?$AAl?$AAu?$AAs?$AAh?$AAe?$AAd?$AA?$AA@ DB 'e'
	DB	00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H
	DB	'_', 00H, 'f', 00H, 'l', 00H, 'u', 00H, 's', 00H, 'h', 00H, 'e'
	DB	00H, 'd', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_19LLIMCLGL@?$AAs?$AAt?$AAo?$AAp?$AA?$AA@
CONST	SEGMENT
??_C@_19LLIMCLGL@?$AAs?$AAt?$AAo?$AAp?$AA?$AA@ DB 's', 00H, 't', 00H, 'o', 00H
	DB	'p', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@CNJHBCEC@?$AAf?$AAi?$AAl?$AAl?$AAe?$AAd?$AA_?$AAb?$AAi?$AAt?$AAs?$AAt?$AAr?$AAe?$AAa?$AAm?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@CNJHBCEC@?$AAf?$AAi?$AAl?$AAl?$AAe?$AAd?$AA_?$AAb?$AAi?$AAt?$AAs?$AAt?$AAr?$AAe?$AAa?$AAm?$AA?$AA@ DB 'f'
	DB	00H, 'i', 00H, 'l', 00H, 'l', 00H, 'e', 00H, 'd', 00H, '_', 00H
	DB	'b', 00H, 'i', 00H, 't', 00H, 's', 00H, 't', 00H, 'r', 00H, 'e'
	DB	00H, 'a', 00H, 'm', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@BLGPOMJC@?$AAb?$AAi?$AAt?$AAs?$AAt?$AAr?$AAe?$AAa?$AAm?$AA_?$AAi?$AAn?$AAf?$AAo?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@BLGPOMJC@?$AAb?$AAi?$AAt?$AAs?$AAt?$AAr?$AAe?$AAa?$AAm?$AA_?$AAi?$AAn?$AAf?$AAo?$AA?$AA@ DB 'b'
	DB	00H, 'i', 00H, 't', 00H, 's', 00H, 't', 00H, 'r', 00H, 'e', 00H
	DB	'a', 00H, 'm', 00H, '_', 00H, 'i', 00H, 'n', 00H, 'f', 00H, 'o'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@OKHPDFBP@?$AAf?$AAr?$AAa?$AAm?$AAe?$AA_?$AAb?$AAu?$AAf?$AAf?$AA_?$AAs?$AAt?$AAa?$AAt?$AAu?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@OKHPDFBP@?$AAf?$AAr?$AAa?$AAm?$AAe?$AA_?$AAb?$AAu?$AAf?$AAf?$AA_?$AAs?$AAt?$AAa?$AAt?$AAu?$AAs?$AA?$AA@ DB 'f'
	DB	00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H, 'b', 00H
	DB	'u', 00H, 'f', 00H, 'f', 00H, '_', 00H, 's', 00H, 't', 00H, 'a'
	DB	00H, 't', 00H, 'u', 00H, 's', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@PNGIAEEE@?$AAf?$AAr?$AAa?$AAm?$AAe?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@PNGIAEEE@?$AAf?$AAr?$AAa?$AAm?$AAe?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe?$AA?$AA@ DB 'f'
	DB	00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H, 'q', 00H
	DB	'u', 00H, 'e', 00H, 'u', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FC@PLEAILN@?$AAU?$AAs?$AAi?$AAn?$AAg?$AA?5?$AA?$CF?$AAu?$AA?5?$AAb?$AAi?$AAt?$AAs?$AAt?$AAr?$AAe?$AAa?$AAm?$AAs?$AA?5?$AAa?$AAn?$AAd?$AA?5?$AA?$CF?$AAu?$AA?5?$AAf?$AAr?$AAa?$AAm?$AAe@
CONST	SEGMENT
??_C@_1FC@PLEAILN@?$AAU?$AAs?$AAi?$AAn?$AAg?$AA?5?$AA?$CF?$AAu?$AA?5?$AAb?$AAi?$AAt?$AAs?$AAt?$AAr?$AAe?$AAa?$AAm?$AAs?$AA?5?$AAa?$AAn?$AAd?$AA?5?$AA?$CF?$AAu?$AA?5?$AAf?$AAr?$AAa?$AAm?$AAe@ DB 'U'
	DB	00H, 's', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, '%', 00H
	DB	'u', 00H, ' ', 00H, 'b', 00H, 'i', 00H, 't', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'e', 00H, 'a', 00H, 'm', 00H, 's', 00H, ' ', 00H
	DB	'a', 00H, 'n', 00H, 'd', 00H, ' ', 00H, '%', 00H, 'u', 00H, ' '
	DB	00H, 'f', 00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H, ' ', 00H
	DB	'b', 00H, 'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H, 'r', 00H, 's'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@ONLLBCFI@?$AAf?$AAr?$AAa?$AAm?$AAe?$AA_?$AAb?$AAu?$AAf?$AAf?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@ONLLBCFI@?$AAf?$AAr?$AAa?$AAm?$AAe?$AA_?$AAb?$AAu?$AAf?$AAf?$AA?$AA@ DB 'f'
	DB	00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H, 'b', 00H
	DB	'u', 00H, 'f', 00H, 'f', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@LPFGHFJC@?$AAb?$AAi?$AAt?$AAs?$AAt?$AAr?$AAe?$AAa?$AAm?$AA_?$AAb?$AAu?$AAf?$AAf?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@LPFGHFJC@?$AAb?$AAi?$AAt?$AAs?$AAt?$AAr?$AAe?$AAa?$AAm?$AA_?$AAb?$AAu?$AAf?$AAf?$AA?$AA@ DB 'b'
	DB	00H, 'i', 00H, 't', 00H, 's', 00H, 't', 00H, 'r', 00H, 'e', 00H
	DB	'a', 00H, 'm', 00H, '_', 00H, 'b', 00H, 'u', 00H, 'f', 00H, 'f'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1FI@HNDPAIDH@?$AAQ?$AAS?$AAV?$AA?5?$AAv?$AAe?$AAr?$AAs?$AAi?$AAo?$AAn?$AA?5?$AA?$CF?$AAu?$AA?4?$AA?$CF?$AAu?$AA?5?$AAu?$AAs?$AAi?$AAn?$AAg?$AA?5?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?5?$AA?$CI?$AAa?$AAc@
CONST	SEGMENT
??_C@_1FI@HNDPAIDH@?$AAQ?$AAS?$AAV?$AA?5?$AAv?$AAe?$AAr?$AAs?$AAi?$AAo?$AAn?$AA?5?$AA?$CF?$AAu?$AA?4?$AA?$CF?$AAu?$AA?5?$AAu?$AAs?$AAi?$AAn?$AAg?$AA?5?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?5?$AA?$CI?$AAa?$AAc@ DB 'Q'
	DB	00H, 'S', 00H, 'V', 00H, ' ', 00H, 'v', 00H, 'e', 00H, 'r', 00H
	DB	's', 00H, 'i', 00H, 'o', 00H, 'n', 00H, ' ', 00H, '%', 00H, 'u'
	DB	00H, '.', 00H, '%', 00H, 'u', 00H, ' ', 00H, 'u', 00H, 's', 00H
	DB	'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, '%', 00H, 's', 00H, '%'
	DB	00H, 's', 00H, ' ', 00H, '(', 00H, 'a', 00H, 'c', 00H, 't', 00H
	DB	'u', 00H, 'a', 00H, 'l', 00H, ':', 00H, ' ', 00H, '%', 00H, 's'
	DB	00H, '%', 00H, 's', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1GO@OPENBPNL@?$AAC?$AAo?$AAu?$AAl?$AAd?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?5?$AAQ?$AAS?$AAV?$AA?5?$AAs?$AAe?$AAs?$AAs?$AAi?$AAo?$AAn@
CONST	SEGMENT
??_C@_1GO@OPENBPNL@?$AAC?$AAo?$AAu?$AAl?$AAd?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?5?$AAQ?$AAS?$AAV?$AA?5?$AAs?$AAe?$AAs?$AAs?$AAi?$AAo?$AAn@ DB 'C'
	DB	00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, ' ', 00H, 'n', 00H
	DB	'o', 00H, 't', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 'i', 00H, 't'
	DB	00H, 'i', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'z', 00H, 'e', 00H
	DB	' ', 00H, 'Q', 00H, 'S', 00H, 'V', 00H, ' ', 00H, 's', 00H, 'e'
	DB	00H, 's', 00H, 's', 00H, 'i', 00H, 'o', 00H, 'n', 00H, ' ', 00H
	DB	'u', 00H, 's', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'c'
	DB	00H, 'u', 00H, 's', 00H, 't', 00H, 'o', 00H, 'm', 00H, ' ', 00H
	DB	's', 00H, 'e', 00H, 't', 00H, 't', 00H, 'i', 00H, 'n', 00H, 'g'
	DB	00H, 's', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1HA@GIELBKIB@?$AAQ?$AAS?$AAV?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AA?4?$AAe?$AAx?$AAe?$AA?5?$AAh?$AAa?$AAs?$AA?5?$AAe?$AAx?$AAi?$AAt?$AAe?$AAd?$AA?5?$AAw?$AAi?$AAt?$AAh?$AA?5?$AAc?$AAo@
CONST	SEGMENT
??_C@_1HA@GIELBKIB@?$AAQ?$AAS?$AAV?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AA?4?$AAe?$AAx?$AAe?$AA?5?$AAh?$AAa?$AAs?$AA?5?$AAe?$AAx?$AAi?$AAt?$AAe?$AAd?$AA?5?$AAw?$AAi?$AAt?$AAh?$AA?5?$AAc?$AAo@ DB 'Q'
	DB	00H, 'S', 00H, 'V', 00H, 'H', 00H, 'e', 00H, 'l', 00H, 'p', 00H
	DB	'e', 00H, 'r', 00H, '.', 00H, 'e', 00H, 'x', 00H, 'e', 00H, ' '
	DB	00H, 'h', 00H, 'a', 00H, 's', 00H, ' ', 00H, 'e', 00H, 'x', 00H
	DB	'i', 00H, 't', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'w', 00H, 'i'
	DB	00H, 't', 00H, 'h', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, ' ', 00H, '%', 00H, 'i', 00H, ' ', 00H, '(', 00H, 'b'
	DB	00H, 'e', 00H, 'f', 00H, 'o', 00H, 'r', 00H, 'e', 00H, ' ', 00H
	DB	'r', 00H, 'e', 00H, 's', 00H, 'p', 00H, 'o', 00H, 'n', 00H, 's'
	DB	00H, 'e', 00H, ')', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1JC@NLDIMFFD@?$AAE?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAw?$AAi@
CONST	SEGMENT
??_C@_1JC@NLDIMFFD@?$AAE?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAw?$AAi@ DB 'E'
	DB	00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H
	DB	' ', 00H, 'i', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'a'
	DB	00H, 'l', 00H, 'i', 00H, 'z', 00H, 'a', 00H, 't', 00H, 'i', 00H
	DB	'o', 00H, 'n', 00H, ' ', 00H, 'f', 00H, 'a', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 'd', 00H, ' ', 00H, 'w', 00H, 'i', 00H, 't', 00H
	DB	'h', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, ' '
	DB	00H, '%', 00H, 'i', 00H, ' ', 00H, 'w', 00H, 'h', 00H, 'i', 00H
	DB	'l', 00H, 'e', 00H, ' ', 00H, 'u', 00H, 's', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, ' ', 00H, 'c', 00H, 'u', 00H, 's', 00H, 't', 00H
	DB	'o', 00H, 'm', 00H, ' ', 00H, 'p', 00H, 'a', 00H, 'r', 00H, 'a'
	DB	00H, 'm', 00H, 'e', 00H, 't', 00H, 'e', 00H, 'r', 00H, 's', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1EG@ONGBBGA@?$AAE?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?4?$AAQ?$AAS?$AAV?$AA?4?$AAI?$AAn?$AAi?$AAt?$AAC?$AAu?$AAs?$AAt?$AAo?$AAm?$AAP?$AAa?$AAr?$AAa?$AAm?$AAs?$AAF?$AAa?$AAi?$AAl@
CONST	SEGMENT
??_C@_1EG@ONGBBGA@?$AAE?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?4?$AAQ?$AAS?$AAV?$AA?4?$AAI?$AAn?$AAi?$AAt?$AAC?$AAu?$AAs?$AAt?$AAo?$AAm?$AAP?$AAa?$AAr?$AAa?$AAm?$AAs?$AAF?$AAa?$AAi?$AAl@ DB 'E'
	DB	00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H
	DB	'.', 00H, 'Q', 00H, 'S', 00H, 'V', 00H, '.', 00H, 'I', 00H, 'n'
	DB	00H, 'i', 00H, 't', 00H, 'C', 00H, 'u', 00H, 's', 00H, 't', 00H
	DB	'o', 00H, 'm', 00H, 'P', 00H, 'a', 00H, 'r', 00H, 'a', 00H, 'm'
	DB	00H, 's', 00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H
	DB	'd', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1GG@IFDPCDFB@?$AAQ?$AAS?$AAV?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AA?4?$AAe?$AAx?$AAe?$AA?5?$AAc?$AAo?$AAu?$AAl?$AAd?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAf?$AAi?$AAn?$AAd?$AA?5?$AAa?$AA?5?$AAv@
CONST	SEGMENT
??_C@_1GG@IFDPCDFB@?$AAQ?$AAS?$AAV?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AA?4?$AAe?$AAx?$AAe?$AA?5?$AAc?$AAo?$AAu?$AAl?$AAd?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAf?$AAi?$AAn?$AAd?$AA?5?$AAa?$AA?5?$AAv@ DB 'Q'
	DB	00H, 'S', 00H, 'V', 00H, 'H', 00H, 'e', 00H, 'l', 00H, 'p', 00H
	DB	'e', 00H, 'r', 00H, '.', 00H, 'e', 00H, 'x', 00H, 'e', 00H, ' '
	DB	00H, 'c', 00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, ' ', 00H
	DB	'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'n'
	DB	00H, 'd', 00H, ' ', 00H, 'a', 00H, ' ', 00H, 'v', 00H, 'a', 00H
	DB	'l', 00H, 'i', 00H, 'd', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'n'
	DB	00H, 'f', 00H, 'i', 00H, 'g', 00H, 'u', 00H, 'r', 00H, 'a', 00H
	DB	't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1IC@JEHGHKKI@?$AAQ?$AAS?$AAV?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AA?4?$AAe?$AAx?$AAe?$AA?5?$AAh?$AAa?$AAs?$AA?5?$AAe?$AAx?$AAi?$AAt?$AAe?$AAd?$AA?5?$AAb?$AAe?$AAc?$AAa?$AAu?$AAs?$AAe@
CONST	SEGMENT
??_C@_1IC@JEHGHKKI@?$AAQ?$AAS?$AAV?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AA?4?$AAe?$AAx?$AAe?$AA?5?$AAh?$AAa?$AAs?$AA?5?$AAe?$AAx?$AAi?$AAt?$AAe?$AAd?$AA?5?$AAb?$AAe?$AAc?$AAa?$AAu?$AAs?$AAe@ DB 'Q'
	DB	00H, 'S', 00H, 'V', 00H, 'H', 00H, 'e', 00H, 'l', 00H, 'p', 00H
	DB	'e', 00H, 'r', 00H, '.', 00H, 'e', 00H, 'x', 00H, 'e', 00H, ' '
	DB	00H, 'h', 00H, 'a', 00H, 's', 00H, ' ', 00H, 'e', 00H, 'x', 00H
	DB	'i', 00H, 't', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'b', 00H, 'e'
	DB	00H, 'c', 00H, 'a', 00H, 'u', 00H, 's', 00H, 'e', 00H, ' ', 00H
	DB	't', 00H, 'h', 00H, 'e', 00H, ' ', 00H, 'e', 00H, 'n', 00H, 'c'
	DB	00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H, ' ', 00H, 'w', 00H
	DB	'a', 00H, 's', 00H, ' ', 00H, 'n', 00H, 'o', 00H, 't', 00H, ' '
	DB	00H, 'i', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'a', 00H
	DB	'l', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 'd', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DE@MCCIFHMH@?$AAE?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?4?$AAQ?$AAS?$AAV?$AA?4?$AAN?$AAo?$AAV?$AAa?$AAl?$AAi?$AAd?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AA?$AA@
CONST	SEGMENT
??_C@_1DE@MCCIFHMH@?$AAE?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?4?$AAQ?$AAS?$AAV?$AA?4?$AAN?$AAo?$AAV?$AAa?$AAl?$AAi?$AAd?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AA?$AA@ DB 'E'
	DB	00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H
	DB	'.', 00H, 'Q', 00H, 'S', 00H, 'V', 00H, '.', 00H, 'N', 00H, 'o'
	DB	00H, 'V', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H, 'C', 00H
	DB	'o', 00H, 'n', 00H, 'f', 00H, 'i', 00H, 'g', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1LO@DHEHLBEE@?$AAQ?$AAS?$AAV?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AA?4?$AAe?$AAx?$AAe?$AA?5?$AAh?$AAa?$AAs?$AA?5?$AAe?$AAx?$AAi?$AAt?$AAe?$AAd?$AA?5?$AAb?$AAe?$AAc?$AAa?$AAu?$AAs?$AAe@
CONST	SEGMENT
??_C@_1LO@DHEHLBEE@?$AAQ?$AAS?$AAV?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AA?4?$AAe?$AAx?$AAe?$AA?5?$AAh?$AAa?$AAs?$AA?5?$AAe?$AAx?$AAi?$AAt?$AAe?$AAd?$AA?5?$AAb?$AAe?$AAc?$AAa?$AAu?$AAs?$AAe@ DB 'Q'
	DB	00H, 'S', 00H, 'V', 00H, 'H', 00H, 'e', 00H, 'l', 00H, 'p', 00H
	DB	'e', 00H, 'r', 00H, '.', 00H, 'e', 00H, 'x', 00H, 'e', 00H, ' '
	DB	00H, 'h', 00H, 'a', 00H, 's', 00H, ' ', 00H, 'e', 00H, 'x', 00H
	DB	'i', 00H, 't', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'b', 00H, 'e'
	DB	00H, 'c', 00H, 'a', 00H, 'u', 00H, 's', 00H, 'e', 00H, ' ', 00H
	DB	'o', 00H, 'f', 00H, ' ', 00H, 'a', 00H, 'n', 00H, ' ', 00H, 'i'
	DB	00H, 'n', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'a', 00H
	DB	't', 00H, 'i', 00H, 'b', 00H, 'l', 00H, 'e', 00H, ' ', 00H, 'q'
	DB	00H, 's', 00H, 'v', 00H, 'i', 00H, 'm', 00H, 'p', 00H, 'l', 00H
	DB	' ', 00H, 'c', 00H, 'u', 00H, 's', 00H, 't', 00H, 'o', 00H, 'm'
	DB	00H, ' ', 00H, 'p', 00H, 'a', 00H, 'r', 00H, 'a', 00H, 'm', 00H
	DB	'e', 00H, 't', 00H, 'e', 00H, 'r', 00H, ' ', 00H, '(', 00H, 'b'
	DB	00H, 'e', 00H, 'f', 00H, 'o', 00H, 'r', 00H, 'e', 00H, ' ', 00H
	DB	'r', 00H, 'e', 00H, 's', 00H, 'p', 00H, 'o', 00H, 'n', 00H, 's'
	DB	00H, 'e', 00H, ')', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@KOIAJGOC@?$AAE?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?4?$AAQ?$AAS?$AAV?$AA?4?$AAI?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AAI?$AAm?$AAp?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1DK@KOIAJGOC@?$AAE?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?4?$AAQ?$AAS?$AAV?$AA?4?$AAI?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AAI?$AAm?$AAp?$AAl?$AA?$AA@ DB 'E'
	DB	00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H
	DB	'.', 00H, 'Q', 00H, 'S', 00H, 'V', 00H, '.', 00H, 'I', 00H, 'n'
	DB	00H, 'c', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'a', 00H, 't', 00H
	DB	'i', 00H, 'b', 00H, 'l', 00H, 'e', 00H, 'I', 00H, 'm', 00H, 'p'
	DB	00H, 'l', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1HC@HGAJLDHP@?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAg?$AAe?$AAt?$AA?5?$AAe?$AAx?$AAi?$AAt?$AA?5?$AAc?$AAo?$AAd?$AAe?$AA?5?$AAw?$AAh?$AAi?$AAl?$AAe?$AA?5?$AAi?$AAn@
CONST	SEGMENT
??_C@_1HC@HGAJLDHP@?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAg?$AAe?$AAt?$AA?5?$AAe?$AAx?$AAi?$AAt?$AA?5?$AAc?$AAo?$AAd?$AAe?$AA?5?$AAw?$AAh?$AAi?$AAl?$AAe?$AA?5?$AAi?$AAn@ DB 'F'
	DB	00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H, ' ', 00H
	DB	't', 00H, 'o', 00H, ' ', 00H, 'g', 00H, 'e', 00H, 't', 00H, ' '
	DB	00H, 'e', 00H, 'x', 00H, 'i', 00H, 't', 00H, ' ', 00H, 'c', 00H
	DB	'o', 00H, 'd', 00H, 'e', 00H, ' ', 00H, 'w', 00H, 'h', 00H, 'i'
	DB	00H, 'l', 00H, 'e', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 'i', 00H
	DB	't', 00H, 'i', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'z', 00H, 'i'
	DB	00H, 'n', 00H, 'g', 00H, ' ', 00H, 'Q', 00H, 'S', 00H, 'V', 00H
	DB	'H', 00H, 'e', 00H, 'l', 00H, 'p', 00H, 'e', 00H, 'r', 00H, '.'
	DB	00H, 'e', 00H, 'x', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DI@NLPDPCNO@?$AAE?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?4?$AAQ?$AAS?$AAV?$AA?4?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AAE?$AAa?$AAr?$AAl?$AAy?$AAE?$AAx?$AAi?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1DI@NLPDPCNO@?$AAE?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?4?$AAQ?$AAS?$AAV?$AA?4?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AAE?$AAa?$AAr?$AAl?$AAy?$AAE?$AAx?$AAi?$AAt?$AA?$AA@ DB 'E'
	DB	00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H
	DB	'.', 00H, 'Q', 00H, 'S', 00H, 'V', 00H, '.', 00H, 'H', 00H, 'e'
	DB	00H, 'l', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 'E', 00H, 'a', 00H
	DB	'r', 00H, 'l', 00H, 'y', 00H, 'E', 00H, 'x', 00H, 'i', 00H, 't'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@MFIKDNIH@?$AAi?$AAn?$AAi?$AAt?$AA_?$AAr?$AAe?$AAs?$AAp?$AAo?$AAn?$AAs?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@MFIKDNIH@?$AAi?$AAn?$AAi?$AAt?$AA_?$AAr?$AAe?$AAs?$AAp?$AAo?$AAn?$AAs?$AAe?$AA?$AA@ DB 'i'
	DB	00H, 'n', 00H, 'i', 00H, 't', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	's', 00H, 'p', 00H, 'o', 00H, 'n', 00H, 's', 00H, 'e', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BA@IAHEMFAP@?$AAL?$AAA?$AAD?$AAe?$AAp?$AAt?$AAh?$AA?$AA@
CONST	SEGMENT
??_C@_1BA@IAHEMFAP@?$AAL?$AAA?$AAD?$AAe?$AAp?$AAt?$AAh?$AA?$AA@ DB 'L', 00H
	DB	'A', 00H, 'D', 00H, 'e', 00H, 'p', 00H, 't', 00H, 'h', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@OLCPADEI@?$AAI?$AAC?$AAQ?$AAQ?$AAu?$AAa?$AAl?$AAi?$AAt?$AAy?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@OLCPADEI@?$AAI?$AAC?$AAQ?$AAQ?$AAu?$AAa?$AAl?$AAi?$AAt?$AAy?$AA?$AA@ DB 'I'
	DB	00H, 'C', 00H, 'Q', 00H, 'Q', 00H, 'u', 00H, 'a', 00H, 'l', 00H
	DB	'i', 00H, 't', 00H, 'y', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_17DOMCELIP@?$AAQ?$AAP?$AAB?$AA?$AA@
CONST	SEGMENT
??_C@_17DOMCELIP@?$AAQ?$AAP?$AAB?$AA?$AA@ DB 'Q', 00H, 'P', 00H, 'B', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_17MENCNEJL@?$AAQ?$AAP?$AAP?$AA?$AA@
CONST	SEGMENT
??_C@_17MENCNEJL@?$AAQ?$AAP?$AAP?$AA?$AA@ DB 'Q', 00H, 'P', 00H, 'P', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_17OJMDMMIO@?$AAQ?$AAP?$AAI?$AA?$AA@
CONST	SEGMENT
??_C@_17OJMDMMIO@?$AAQ?$AAP?$AAI?$AA?$AA@ DB 'Q', 00H, 'P', 00H, 'I', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@CJLLPJDH@?$AAC?$AAo?$AAn?$AAv?$AAe?$AAr?$AAg?$AAe?$AAn?$AAc?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@CJLLPJDH@?$AAC?$AAo?$AAn?$AAv?$AAe?$AAr?$AAg?$AAe?$AAn?$AAc?$AAe?$AA?$AA@ DB 'C'
	DB	00H, 'o', 00H, 'n', 00H, 'v', 00H, 'e', 00H, 'r', 00H, 'g', 00H
	DB	'e', 00H, 'n', 00H, 'c', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@OHENPEDC@?$AAA?$AAc?$AAc?$AAu?$AAr?$AAa?$AAc?$AAy?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@OHENPEDC@?$AAA?$AAc?$AAc?$AAu?$AAr?$AAa?$AAc?$AAy?$AA?$AA@ DB 'A'
	DB	00H, 'c', 00H, 'c', 00H, 'u', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'y', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BA@IBNIMAHO@?$AAM?$AAa?$AAx?$AAK?$AAb?$AAp?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1BA@IBNIMAHO@?$AAM?$AAa?$AAx?$AAK?$AAb?$AAp?$AAs?$AA?$AA@ DB 'M', 00H
	DB	'a', 00H, 'x', 00H, 'K', 00H, 'b', 00H, 'p', 00H, 's', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@CJMDAOPJ@?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAS?$AAi?$AAz?$AAe?$AAI?$AAn?$AAK?$AAB?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@CJMDAOPJ@?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAS?$AAi?$AAz?$AAe?$AAI?$AAn?$AAK?$AAB?$AA?$AA@ DB 'B'
	DB	00H, 'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H, 'r', 00H, 'S', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, 'I', 00H, 'n', 00H, 'K', 00H, 'B'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@IDKHPHBG@?$AAT?$AAa?$AAr?$AAg?$AAe?$AAt?$AAK?$AAb?$AAp?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@IDKHPHBG@?$AAT?$AAa?$AAr?$AAg?$AAe?$AAt?$AAK?$AAb?$AAp?$AAs?$AA?$AA@ DB 'T'
	DB	00H, 'a', 00H, 'r', 00H, 'g', 00H, 'e', 00H, 't', 00H, 'K', 00H
	DB	'b', 00H, 'p', 00H, 's', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@KDHOMFIK@?$AAU?$AAs?$AAe?$AAG?$AAl?$AAo?$AAb?$AAa?$AAl?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAS?$AAi?$AAz?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@KDHOMFIK@?$AAU?$AAs?$AAe?$AAG?$AAl?$AAo?$AAb?$AAa?$AAl?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAS?$AAi?$AAz?$AAe?$AA?$AA@ DB 'U'
	DB	00H, 's', 00H, 'e', 00H, 'G', 00H, 'l', 00H, 'o', 00H, 'b', 00H
	DB	'a', 00H, 'l', 00H, 'B', 00H, 'u', 00H, 'f', 00H, 'f', 00H, 'e'
	DB	00H, 'r', 00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@HBKEGJCM@?$AAU?$AAs?$AAe?$AAG?$AAl?$AAo?$AAb?$AAa?$AAl?$AAB?$AAi?$AAt?$AAr?$AAa?$AAt?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@HBKEGJCM@?$AAU?$AAs?$AAe?$AAG?$AAl?$AAo?$AAb?$AAa?$AAl?$AAB?$AAi?$AAt?$AAr?$AAa?$AAt?$AAe?$AA?$AA@ DB 'U'
	DB	00H, 's', 00H, 'e', 00H, 'G', 00H, 'l', 00H, 'o', 00H, 'b', 00H
	DB	'a', 00H, 'l', 00H, 'B', 00H, 'i', 00H, 't', 00H, 'r', 00H, 'a'
	DB	00H, 't', 00H, 'e', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@IBGNPBIO@?$AAR?$AAa?$AAt?$AAe?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AAM?$AAe?$AAt?$AAh?$AAo?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@IBGNPBIO@?$AAR?$AAa?$AAt?$AAe?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AAM?$AAe?$AAt?$AAh?$AAo?$AAd?$AA?$AA@ DB 'R'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, 'C', 00H, 'o', 00H, 'n', 00H
	DB	't', 00H, 'r', 00H, 'o', 00H, 'l', 00H, 'M', 00H, 'e', 00H, 't'
	DB	00H, 'h', 00H, 'o', 00H, 'd', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@IPJBHBLN@?$AAQ?$AAS?$AAV?$AA?3?$AA?5?$AAU?$AAs?$AAi?$AAn?$AAg?$AA?5?$AAc?$AAu?$AAs?$AAt?$AAo?$AAm?$AA?5?$AAp?$AAa?$AAr?$AAa?$AAm?$AAe?$AAt?$AAe?$AAr?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1DK@IPJBHBLN@?$AAQ?$AAS?$AAV?$AA?3?$AA?5?$AAU?$AAs?$AAi?$AAn?$AAg?$AA?5?$AAc?$AAu?$AAs?$AAt?$AAo?$AAm?$AA?5?$AAp?$AAa?$AAr?$AAa?$AAm?$AAe?$AAt?$AAe?$AAr?$AAs?$AA?$AA@ DB 'Q'
	DB	00H, 'S', 00H, 'V', 00H, ':', 00H, ' ', 00H, 'U', 00H, 's', 00H
	DB	'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'c', 00H, 'u', 00H, 's'
	DB	00H, 't', 00H, 'o', 00H, 'm', 00H, ' ', 00H, 'p', 00H, 'a', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, 's', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@ENCKOBAL@?$AAQ?$AAS?$AAV?$AA?5?$AA?$CI?$AAA?$AAd?$AAv?$AAa?$AAn?$AAc?$AAe?$AAd?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@ENCKOBAL@?$AAQ?$AAS?$AAV?$AA?5?$AA?$CI?$AAA?$AAd?$AAv?$AAa?$AAn?$AAc?$AAe?$AAd?$AA?$CJ?$AA?$AA@ DB 'Q'
	DB	00H, 'S', 00H, 'V', 00H, ' ', 00H, '(', 00H, 'A', 00H, 'd', 00H
	DB	'v', 00H, 'a', 00H, 'n', 00H, 'c', 00H, 'e', 00H, 'd', 00H, ')'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@CDIPFIBO@?$AAU?$AAs?$AAe?$AAC?$AAu?$AAs?$AAt?$AAo?$AAm?$AAP?$AAa?$AAr?$AAa?$AAm?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@CDIPFIBO@?$AAU?$AAs?$AAe?$AAC?$AAu?$AAs?$AAt?$AAo?$AAm?$AAP?$AAa?$AAr?$AAa?$AAm?$AAs?$AA?$AA@ DB 'U'
	DB	00H, 's', 00H, 'e', 00H, 'C', 00H, 'u', 00H, 's', 00H, 't', 00H
	DB	'o', 00H, 'm', 00H, 'P', 00H, 'a', 00H, 'r', 00H, 'a', 00H, 'm'
	DB	00H, 's', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@BCABKOOC@?$AAi?$AAn?$AAi?$AAt?$AA_?$AAr?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@BCABKOOC@?$AAi?$AAn?$AAi?$AAt?$AA_?$AAr?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AA?$AA@ DB 'i'
	DB	00H, 'n', 00H, 'i', 00H, 't', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'q', 00H, 'u', 00H, 'e', 00H, 's', 00H, 't', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EG@KGHDNBFC@?$AAC?$AAo?$AAu?$AAl?$AAd?$AAn?$AA?8?$AAt?$AA?5?$AAl?$AAa?$AAu?$AAn?$AAc?$AAh?$AA?5?$AAQ?$AAS?$AAV?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AA?4?$AAe?$AAx?$AAe?$AA?3?$AA?5?$AA?$CF@
CONST	SEGMENT
??_C@_1EG@KGHDNBFC@?$AAC?$AAo?$AAu?$AAl?$AAd?$AAn?$AA?8?$AAt?$AA?5?$AAl?$AAa?$AAu?$AAn?$AAc?$AAh?$AA?5?$AAQ?$AAS?$AAV?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AA?4?$AAe?$AAx?$AAe?$AA?3?$AA?5?$AA?$CF@ DB 'C'
	DB	00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, 'n', 00H, '''', 00H
	DB	't', 00H, ' ', 00H, 'l', 00H, 'a', 00H, 'u', 00H, 'n', 00H, 'c'
	DB	00H, 'h', 00H, ' ', 00H, 'Q', 00H, 'S', 00H, 'V', 00H, 'H', 00H
	DB	'e', 00H, 'l', 00H, 'p', 00H, 'e', 00H, 'r', 00H, '.', 00H, 'e'
	DB	00H, 'x', 00H, 'e', 00H, ':', 00H, ' ', 00H, '%', 00H, 'u', 00H
	DB	'!', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DO@OPJHFIHF@?$AAE?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?4?$AAQ?$AAS?$AAV?$AA?4?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AAL?$AAa?$AAu?$AAn?$AAc?$AAh?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1DO@OPJHFIHF@?$AAE?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?4?$AAQ?$AAS?$AAV?$AA?4?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AAL?$AAa?$AAu?$AAn?$AAc?$AAh?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?$AA@ DB 'E'
	DB	00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H
	DB	'.', 00H, 'Q', 00H, 'S', 00H, 'V', 00H, '.', 00H, 'H', 00H, 'e'
	DB	00H, 'l', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 'L', 00H, 'a', 00H
	DB	'u', 00H, 'n', 00H, 'c', 00H, 'h', 00H, 'F', 00H, 'a', 00H, 'i'
	DB	00H, 'l', 00H, 'e', 00H, 'd', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1EI@BEBMIADP@?$AAQ?$AAS?$AAV?$AA?5?$AAi?$AAs?$AA?5?$AAn?$AAo?$AA?5?$AAl?$AAo?$AAn?$AAg?$AAe?$AAr?$AA?5?$AAs?$AAu?$AAp?$AAp?$AAo?$AAr?$AAt?$AAe?$AAd?$AA?5?$AAo?$AAn?$AA?5?$AAV?$AAi@
CONST	SEGMENT
??_C@_1EI@BEBMIADP@?$AAQ?$AAS?$AAV?$AA?5?$AAi?$AAs?$AA?5?$AAn?$AAo?$AA?5?$AAl?$AAo?$AAn?$AAg?$AAe?$AAr?$AA?5?$AAs?$AAu?$AAp?$AAp?$AAo?$AAr?$AAt?$AAe?$AAd?$AA?5?$AAo?$AAn?$AA?5?$AAV?$AAi@ DB 'Q'
	DB	00H, 'S', 00H, 'V', 00H, ' ', 00H, 'i', 00H, 's', 00H, ' ', 00H
	DB	'n', 00H, 'o', 00H, ' ', 00H, 'l', 00H, 'o', 00H, 'n', 00H, 'g'
	DB	00H, 'e', 00H, 'r', 00H, ' ', 00H, 's', 00H, 'u', 00H, 'p', 00H
	DB	'p', 00H, 'o', 00H, 'r', 00H, 't', 00H, 'e', 00H, 'd', 00H, ' '
	DB	00H, 'o', 00H, 'n', 00H, ' ', 00H, 'V', 00H, 'i', 00H, 's', 00H
	DB	't', 00H, 'a', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EI@MGAFFPDA@?$AAE?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?4?$AAQ?$AAS?$AAV?$AA?4?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AAL?$AAa?$AAu?$AAn?$AAc?$AAh?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AAV?$AAi@
CONST	SEGMENT
??_C@_1EI@MGAFFPDA@?$AAE?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?4?$AAQ?$AAS?$AAV?$AA?4?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AAL?$AAa?$AAu?$AAn?$AAc?$AAh?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AAV?$AAi@ DB 'E'
	DB	00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H
	DB	'.', 00H, 'Q', 00H, 'S', 00H, 'V', 00H, '.', 00H, 'H', 00H, 'e'
	DB	00H, 'l', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 'L', 00H, 'a', 00H
	DB	'u', 00H, 'n', 00H, 'c', 00H, 'h', 00H, 'F', 00H, 'a', 00H, 'i'
	DB	00H, 'l', 00H, 'e', 00H, 'd', 00H, 'V', 00H, 'i', 00H, 's', 00H
	DB	't', 00H, 'a', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1HC@EHFMGPIB@?$AAQ?$AAS?$AAV?$AA?3?$AA?5?$AAU?$AAn?$AAr?$AAe?$AAc?$AAo?$AAg?$AAn?$AAi?$AAz?$AAe?$AAd?$AA?5?$AAp?$AAr?$AAo?$AAf?$AAi?$AAl?$AAe?$AA?5?$AA?8?$AA?$CF?$AAs?$AA?8?$AA?0?$AA?5@
CONST	SEGMENT
??_C@_1HC@EHFMGPIB@?$AAQ?$AAS?$AAV?$AA?3?$AA?5?$AAU?$AAn?$AAr?$AAe?$AAc?$AAo?$AAg?$AAn?$AAi?$AAz?$AAe?$AAd?$AA?5?$AAp?$AAr?$AAo?$AAf?$AAi?$AAl?$AAe?$AA?5?$AA?8?$AA?$CF?$AAs?$AA?8?$AA?0?$AA?5@ DB 'Q'
	DB	00H, 'S', 00H, 'V', 00H, ':', 00H, ' ', 00H, 'U', 00H, 'n', 00H
	DB	'r', 00H, 'e', 00H, 'c', 00H, 'o', 00H, 'g', 00H, 'n', 00H, 'i'
	DB	00H, 'z', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'p', 00H, 'r', 00H
	DB	'o', 00H, 'f', 00H, 'i', 00H, 'l', 00H, 'e', 00H, ' ', 00H, ''''
	DB	00H, '%', 00H, 's', 00H, '''', 00H, ',', 00H, ' ', 00H, 'p', 00H
	DB	'r', 00H, 'o', 00H, 'f', 00H, 'i', 00H, 'l', 00H, 'e', 00H, ' '
	DB	00H, 'r', 00H, 'e', 00H, 's', 00H, 'e', 00H, 't', 00H, ' ', 00H
	DB	't', 00H, 'o', 00H, ' ', 00H, 'd', 00H, 'e', 00H, 'f', 00H, 'a'
	DB	00H, 'u', 00H, 'l', 00H, 't', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_19NACPGGMO@?$AAm?$AAa?$AAi?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_19NACPGGMO@?$AAm?$AAa?$AAi?$AAn?$AA?$AA@ DB 'm', 00H, 'a', 00H, 'i', 00H
	DB	'n', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@PBFEDEIE@?$AAb?$AAa?$AAs?$AAe?$AAl?$AAi?$AAn?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@PBFEDEIE@?$AAb?$AAa?$AAs?$AAe?$AAl?$AAi?$AAn?$AAe?$AA?$AA@ DB 'b'
	DB	00H, 'a', 00H, 's', 00H, 'e', 00H, 'l', 00H, 'i', 00H, 'n', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07LNMDFKEJ@profile?$AA@
CONST	SEGMENT
??_C@_07LNMDFKEJ@profile?$AA@ DB 'profile', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PGKLGAGG@d3d9?$AA@
CONST	SEGMENT
??_C@_04PGKLGAGG@d3d9?$AA@ DB 'd3d9', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GMGJDJAH@d3d11?$AA@
CONST	SEGMENT
??_C@_05GMGJDJAH@d3d11?$AA@ DB 'd3d11', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DKALODOL@qsvimpl?$AA@
CONST	SEGMENT
??_C@_07DKALODOL@qsvimpl?$AA@ DB 'qsvimpl', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07IBIPAAJI@bframes?$AA@
CONST	SEGMENT
??_C@_07IBIPAAJI@bframes?$AA@ DB 'bframes', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IONMGJI@keyint?$AA@
CONST	SEGMENT
??_C@_06IONMGJI@keyint?$AA@ DB 'keyint', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1EI@EDAOEDLO@?$AAU?$AAs?$AAi?$AAn?$AAg?$AA?5?$AAc?$AAu?$AAs?$AAt?$AAo?$AAm?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?5?$AAs?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AAs?$AA?3?$AA?5?$AA?$CC@
CONST	SEGMENT
??_C@_1EI@EDAOEDLO@?$AAU?$AAs?$AAi?$AAn?$AAg?$AA?5?$AAc?$AAu?$AAs?$AAt?$AAo?$AAm?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?5?$AAs?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AAs?$AA?3?$AA?5?$AA?$CC@ DB 'U'
	DB	00H, 's', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'c', 00H
	DB	'u', 00H, 's', 00H, 't', 00H, 'o', 00H, 'm', 00H, ' ', 00H, 'e'
	DB	00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H
	DB	' ', 00H, 's', 00H, 'e', 00H, 't', 00H, 't', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, 's', 00H, ':', 00H, ' ', 00H, '"', 00H, '%', 00H
	DB	's', 00H, '"', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@FAHANJKA@?$AAC?$AAu?$AAs?$AAt?$AAo?$AAm?$AAQ?$AAS?$AAV?$AAS?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@FAHANJKA@?$AAC?$AAu?$AAs?$AAt?$AAo?$AAm?$AAQ?$AAS?$AAV?$AAS?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AAs?$AA?$AA@ DB 'C'
	DB	00H, 'u', 00H, 's', 00H, 't', 00H, 'o', 00H, 'm', 00H, 'Q', 00H
	DB	'S', 00H, 'V', 00H, 'S', 00H, 'e', 00H, 't', 00H, 't', 00H, 'i'
	DB	00H, 'n', 00H, 'g', 00H, 's', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@KLBNDPKC@?$AAQ?$AAS?$AAV?$AAU?$AAs?$AAe?$AAV?$AAi?$AAd?$AAe?$AAo?$AAE?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AAS?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1DG@KLBNDPKC@?$AAQ?$AAS?$AAV?$AAU?$AAs?$AAe?$AAV?$AAi?$AAd?$AAe?$AAo?$AAE?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AAS?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AAs?$AA?$AA@ DB 'Q'
	DB	00H, 'S', 00H, 'V', 00H, 'U', 00H, 's', 00H, 'e', 00H, 'V', 00H
	DB	'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, 'E', 00H, 'n', 00H, 'c'
	DB	00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 'S', 00H, 'e', 00H
	DB	't', 00H, 't', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 's', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@CHOFIDHM@?$AAX?$AA2?$AA6?$AA4?$AAP?$AAr?$AAo?$AAf?$AAi?$AAl?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@CHOFIDHM@?$AAX?$AA2?$AA6?$AA4?$AAP?$AAr?$AAo?$AAf?$AAi?$AAl?$AAe?$AA?$AA@ DB 'X'
	DB	00H, '2', 00H, '6', 00H, '4', 00H, 'P', 00H, 'r', 00H, 'o', 00H
	DB	'f', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_19PKICIIJD@?$AAh?$AAi?$AAg?$AAh?$AA?$AA@
CONST	SEGMENT
??_C@_19PKICIIJD@?$AAh?$AAi?$AAg?$AAh?$AA?$AA@ DB 'h', 00H, 'i', 00H, 'g', 00H
	DB	'h', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@ODBMCAAO@?$AAQ?$AAS?$AAV?$AAP?$AAr?$AAe?$AAs?$AAe?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@ODBMCAAO@?$AAQ?$AAS?$AAV?$AAP?$AAr?$AAe?$AAs?$AAe?$AAt?$AA?$AA@ DB 'Q'
	DB	00H, 'S', 00H, 'V', 00H, 'P', 00H, 'r', 00H, 'e', 00H, 's', 00H
	DB	'e', 00H, 't', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@INKCNOFG@?$AAK?$AAe?$AAy?$AAf?$AAr?$AAa?$AAm?$AAe?$AAI?$AAn?$AAt?$AAe?$AAr?$AAv?$AAa?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@INKCNOFG@?$AAK?$AAe?$AAy?$AAf?$AAr?$AAa?$AAm?$AAe?$AAI?$AAn?$AAt?$AAe?$AAr?$AAv?$AAa?$AAl?$AA?$AA@ DB 'K'
	DB	00H, 'e', 00H, 'y', 00H, 'f', 00H, 'r', 00H, 'a', 00H, 'm', 00H
	DB	'e', 00H, 'I', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'v'
	DB	00H, 'a', 00H, 'l', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1GC@LANNAHFH@?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AAu?$AAr?$AAe?$AAd?$AA?5?$AAb?$AAi?$AAt?$AAr?$AAa?$AAt?$AAe?$AA?5?$AA?$CF?$AAd?$AA?5?$AAe?$AAx?$AAc?$AAe?$AAe?$AAd?$AAs?$AA?5?$AAQ?$AAS@
CONST	SEGMENT
??_C@_1GC@LANNAHFH@?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AAu?$AAr?$AAe?$AAd?$AA?5?$AAb?$AAi?$AAt?$AAr?$AAa?$AAt?$AAe?$AA?5?$AA?$CF?$AAd?$AA?5?$AAe?$AAx?$AAc?$AAe?$AAe?$AAd?$AAs?$AA?5?$AAQ?$AAS@ DB 'C'
	DB	00H, 'o', 00H, 'n', 00H, 'f', 00H, 'i', 00H, 'g', 00H, 'u', 00H
	DB	'r', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'b', 00H, 'i', 00H, 't'
	DB	00H, 'r', 00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, '%', 00H
	DB	'd', 00H, ' ', 00H, 'e', 00H, 'x', 00H, 'c', 00H, 'e', 00H, 'e'
	DB	00H, 'd', 00H, 's', 00H, ' ', 00H, 'Q', 00H, 'S', 00H, 'V', 00H
	DB	' ', 00H, 'm', 00H, 'a', 00H, 'x', 00H, 'i', 00H, 'm', 00H, 'u'
	DB	00H, 'm', 00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, '%', 00H
	DB	'u', 00H, '!', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@PCCCHKLK@?$AAV?$AAi?$AAd?$AAe?$AAo?$AA?5?$AAE?$AAn?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@PCCCHKLK@?$AAV?$AAi?$AAd?$AAe?$AAo?$AA?5?$AAE?$AAn?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA?$AA@ DB 'V'
	DB	00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, ' ', 00H, 'E', 00H
	DB	'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'i', 00H, 'n', 00H, 'g'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@GNHABGLI@?$AAU?$AAs?$AAe?$AAC?$AAB?$AAR?$AA?$AA@
CONST	SEGMENT
??_C@_1O@GNHABGLI@?$AAU?$AAs?$AAe?$AAC?$AAB?$AAR?$AA?$AA@ DB 'U', 00H, 's'
	DB	00H, 'e', 00H, 'C', 00H, 'B', 00H, 'R', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EG@IOAIFOJM@?$AAb?$AAf?$AAr?$AAa?$AAm?$AAe?$AA_?$AAd?$AAe?$AAl?$AAa?$AAy?$AA?$DN?$AA?$CF?$AAu?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAi?$AAn?$AAi?$AAt?$AA_?$AAp?$AAt?$AAs?$AA?4?$AAN?$AAu?$AAm?$AA?$DN@
CONST	SEGMENT
??_C@_1EG@IOAIFOJM@?$AAb?$AAf?$AAr?$AAa?$AAm?$AAe?$AA_?$AAd?$AAe?$AAl?$AAa?$AAy?$AA?$DN?$AA?$CF?$AAu?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAi?$AAn?$AAi?$AAt?$AA_?$AAp?$AAt?$AAs?$AA?4?$AAN?$AAu?$AAm?$AA?$DN@ DB 'b'
	DB	00H, 'f', 00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	'd', 00H, 'e', 00H, 'l', 00H, 'a', 00H, 'y', 00H, '=', 00H, '%'
	DB	00H, 'u', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, 'i', 00H
	DB	'n', 00H, 'i', 00H, 't', 00H, '_', 00H, 'p', 00H, 't', 00H, 's'
	DB	00H, '.', 00H, 'N', 00H, 'u', 00H, 'm', 00H, '=', 00H, '%', 00H
	DB	'u', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1GA@FFPJBDII@?$AAR?$AAe?$AAc?$AAa?$AAl?$AAc?$AAu?$AAl?$AAa?$AAt?$AAe?$AAd?$AA?5?$AAb?$AAf?$AAr?$AAa?$AAm?$AAe?$AA_?$AAd?$AAe?$AAl?$AAa?$AAy?$AA?3?$AA?5?$AA?$CF?$AAu?$AA?0?$AA?5?$AAi@
CONST	SEGMENT
??_C@_1GA@FFPJBDII@?$AAR?$AAe?$AAc?$AAa?$AAl?$AAc?$AAu?$AAl?$AAa?$AAt?$AAe?$AAd?$AA?5?$AAb?$AAf?$AAr?$AAa?$AAm?$AAe?$AA_?$AAd?$AAe?$AAl?$AAa?$AAy?$AA?3?$AA?5?$AA?$CF?$AAu?$AA?0?$AA?5?$AAi@ DB 'R'
	DB	00H, 'e', 00H, 'c', 00H, 'a', 00H, 'l', 00H, 'c', 00H, 'u', 00H
	DB	'l', 00H, 'a', 00H, 't', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'b'
	DB	00H, 'f', 00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	'd', 00H, 'e', 00H, 'l', 00H, 'a', 00H, 'y', 00H, ':', 00H, ' '
	DB	00H, '%', 00H, 'u', 00H, ',', 00H, ' ', 00H, 'i', 00H, 'n', 00H
	DB	'i', 00H, 't', 00H, '_', 00H, 'p', 00H, 't', 00H, 's', 00H, '.'
	DB	00H, 'N', 00H, 'u', 00H, 'm', 00H, ':', 00H, ' ', 00H, '%', 00H
	DB	'u', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_R0PAX@8
data$r	SEGMENT
??_R0PAX@8 DD	FLAT:??_7type_info@@6B@			; void * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAX', 00H
data$r	ENDS
;	COMDAT ??_R3QSVEncoder@@8
rdata$r	SEGMENT
??_R3QSVEncoder@@8 DD 00H				; QSVEncoder::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2QSVEncoder@@8
rdata$r	ENDS
;	COMDAT __CT??_R0PAX@84
xdata$x	SEGMENT
__CT??_R0PAX@84 DD 01H
	DD	FLAT:??_R0PAX@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB
CONST	SEGMENT
?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB DD 0ffffffffH ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::npos
CONST	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
CONST	SEGMENT
?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB DD 0ffffffffH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@QSVEncoder@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@QSVEncoder@@8 DD FLAT:??_R0?AVQSVEncoder@@@8 ; QSVEncoder::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3QSVEncoder@@8
rdata$r	ENDS
;	COMDAT __CTA2PA_W
xdata$x	SEGMENT
__CTA2PA_W DD	02H
	DD	FLAT:__CT??_R0PA_W@84
	DD	FLAT:__CT??_R0PAX@84
xdata$x	ENDS
;	COMDAT ??_R0?AUDataPacket@@@8
data$r	SEGMENT
??_R0?AUDataPacket@@@8 DD FLAT:??_7type_info@@6B@	; DataPacket `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUDataPacket@@', 00H
data$r	ENDS
;	COMDAT ??_R2VideoEncoder@@8
rdata$r	SEGMENT
??_R2VideoEncoder@@8 DD FLAT:??_R1A@?0A@EA@VideoEncoder@@8 ; VideoEncoder::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT __CT??_R0PA_W@84
xdata$x	SEGMENT
__CT??_R0PA_W@84 DD 01H
	DD	FLAT:??_R0PA_W@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R3VideoEncoder@@8
rdata$r	SEGMENT
??_R3VideoEncoder@@8 DD 00H				; VideoEncoder::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2VideoEncoder@@8
rdata$r	ENDS
;	COMDAT ??_R0_J@8
data$r	SEGMENT
??_R0_J@8 DD	FLAT:??_7type_info@@6B@			; __int64 `RTTI Type Descriptor'
	DD	00H
	DB	'._J', 00H
data$r	ENDS
;	COMDAT ??_R0?AVQSVEncoder@@@8
data$r	SEGMENT
??_R0?AVQSVEncoder@@@8 DD FLAT:??_7type_info@@6B@	; QSVEncoder `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVQSVEncoder@@', 00H
data$r	ENDS
;	COMDAT ??_R0PA_W@8
data$r	SEGMENT
??_R0PA_W@8 DD	FLAT:??_7type_info@@6B@			; wchar_t * `RTTI Type Descriptor'
	DD	00H
	DB	'.PA_W', 00H
data$r	ENDS
;	COMDAT ??_R0?AUVideoPacket@@@8
data$r	SEGMENT
??_R0?AUVideoPacket@@@8 DD FLAT:??_7type_info@@6B@	; VideoPacket `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUVideoPacket@@', 00H
data$r	ENDS
;	COMDAT __TI2CPA_W
xdata$x	SEGMENT
__TI2CPA_W DD	01H
	DD	00H
	DD	00H
	DD	FLAT:__CTA2PA_W
xdata$x	ENDS
;	COMDAT ??_R4VideoEncoder@@6B@
rdata$r	SEGMENT
??_R4VideoEncoder@@6B@ DD 00H				; VideoEncoder::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVVideoEncoder@@@8
	DD	FLAT:??_R3VideoEncoder@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@VideoEncoder@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@VideoEncoder@@8 DD FLAT:??_R0?AVVideoEncoder@@@8 ; VideoEncoder::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3VideoEncoder@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUx264_nal_t@@@8
data$r	SEGMENT
??_R0?AUx264_nal_t@@@8 DD FLAT:??_7type_info@@6B@	; x264_nal_t `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUx264_nal_t@@', 00H
data$r	ENDS
;	COMDAT ?start_seq@?8??ProcessEncodedFrame@QSVEncoder@@QAEXAAV?$List@UDataPacket@@@@AAV?$List@W4PacketType@@@@KAAKI@Z@4QBEB
CONST	SEGMENT
?start_seq@?8??ProcessEncodedFrame@QSVEncoder@@QAEXAAV?$List@UDataPacket@@@@AAV?$List@W4PacketType@@@@KAAKI@Z@4QBEB DB 00H ; `QSVEncoder::ProcessEncodedFrame'::`9'::start_seq
	DB	00H
	DB	01H
CONST	ENDS
;	COMDAT ??_R2QSVEncoder@@8
rdata$r	SEGMENT
??_R2QSVEncoder@@8 DD FLAT:??_R1A@?0A@EA@QSVEncoder@@8	; QSVEncoder::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@VideoEncoder@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVVideoEncoder@@@8
data$r	SEGMENT
??_R0?AVVideoEncoder@@@8 DD FLAT:??_7type_info@@6B@	; VideoEncoder `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVVideoEncoder@@', 00H
data$r	ENDS
;	COMDAT ??_7VideoEncoder@@6B@
CONST	SEGMENT
??_7VideoEncoder@@6B@ DD FLAT:??_R4VideoEncoder@@6B@	; VideoEncoder::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:?RequestBuffers@VideoEncoder@@MAEXPAX@Z
	DD	FLAT:??_EVideoEncoder@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?GetSEI@VideoEncoder@@UAEXAAUDataPacket@@@Z
	DD	FLAT:?RequestKeyframe@VideoEncoder@@UAEXXZ
	DD	FLAT:__purecall
	DD	FLAT:?isQSV@VideoEncoder@@UAE_NXZ
	DD	FLAT:?GetBufferedFrames@VideoEncoder@@UAEHXZ
	DD	FLAT:?HasBufferedFrames@VideoEncoder@@UAE_NXZ
CONST	ENDS
;	COMDAT ??_R0?AUmfxFrameData@@@8
data$r	SEGMENT
??_R0?AUmfxFrameData@@@8 DD FLAT:??_7type_info@@6B@	; mfxFrameData `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUmfxFrameData@@', 00H
data$r	ENDS
;	COMDAT ??_R4QSVEncoder@@6B@
rdata$r	SEGMENT
??_R4QSVEncoder@@6B@ DD 00H				; QSVEncoder::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVQSVEncoder@@@8
	DD	FLAT:??_R3QSVEncoder@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUencode_task@QSVEncoder@@@8
data$r	SEGMENT
??_R0?AUencode_task@QSVEncoder@@@8 DD FLAT:??_7type_info@@6B@ ; QSVEncoder::encode_task `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUencode_task@QSVEncoder@@', 00H
data$r	ENDS
;	COMDAT ??_7QSVEncoder@@6B@
CONST	SEGMENT
??_7QSVEncoder@@6B@ DD FLAT:??_R4QSVEncoder@@6B@	; QSVEncoder::`vftable'
	DD	FLAT:?Encode@QSVEncoder@@UAE_NPAXAAV?$List@UDataPacket@@@@AAV?$List@W4PacketType@@@@KAAK@Z
	DD	FLAT:?RequestBuffers@QSVEncoder@@UAEXPAX@Z
	DD	FLAT:??_EQSVEncoder@@UAEPAXI@Z
	DD	FLAT:?GetBitRate@QSVEncoder@@UBEHXZ
	DD	FLAT:?DynamicBitrateSupported@QSVEncoder@@UBE_NXZ
	DD	FLAT:?SetBitRate@QSVEncoder@@UAE_NKK@Z
	DD	FLAT:?GetHeaders@QSVEncoder@@UAEXAAUDataPacket@@@Z
	DD	FLAT:?GetSEI@QSVEncoder@@UAEXAAUDataPacket@@@Z
	DD	FLAT:?RequestKeyframe@QSVEncoder@@UAEXXZ
	DD	FLAT:?GetInfoString@QSVEncoder@@UBE?AVString@@XZ
	DD	FLAT:?isQSV@QSVEncoder@@UAE_NXZ
	DD	FLAT:?GetBufferedFrames@VideoEncoder@@UAEHXZ
	DD	FLAT:?HasBufferedFrames@QSVEncoder@@UAE_NXZ
CONST	ENDS
;	COMDAT ?emulation_prevention_pattern@?CF@??ProcessEncodedFrame@QSVEncoder@@QAEXAAV?$List@UDataPacket@@@@AAV?$List@W4PacketType@@@@KAAKI@Z@4QBEB
CONST	SEGMENT
?emulation_prevention_pattern@?CF@??ProcessEncodedFrame@QSVEncoder@@QAEXAAV?$List@UDataPacket@@@@AAV?$List@W4PacketType@@@@KAAKI@Z@4QBEB DB 00H ; `QSVEncoder::ProcessEncodedFrame'::`37'::emulation_prevention_pattern
	DB	00H
	DB	03H
?usageStr@?A0x7e09c670@@3PAPB_WA DD FLAT:$SG4294870656	; `anonymous namespace'::usageStr
	DD	FLAT:$SG4294870655
	DD	FLAT:$SG4294870654
	DD	FLAT:$SG4294870653
	DD	FLAT:$SG4294870652
	DD	FLAT:$SG4294870651
	DD	FLAT:$SG4294870650
	DD	FLAT:$SG4294870649
?rate_control_str@?A0x7e09c670@@3PAU<unnamed-type-rate_control_str>@1@A DW 01H ; `anonymous namespace'::rate_control_str
	ORG $+2
	DD	FLAT:$SG4294870648
	DB	00H
	ORG $+3
	DW	02H
	ORG $+2
	DD	FLAT:$SG4294870647
	DB	00H
	ORG $+3
	DW	03H
	ORG $+2
	DD	FLAT:$SG4294870646
	DB	01H
	ORG $+3
	DW	04H
	ORG $+2
	DD	FLAT:$SG4294870645
	DB	00H
	ORG $+3
	DW	08H
	ORG $+2
	DD	FLAT:$SG4294870644
	DB	00H
	ORG $+3
	DW	09H
	ORG $+2
	DD	FLAT:$SG4294870643
	DB	01H
	ORG $+3
	DW	0aH
	ORG $+2
	DD	FLAT:$SG4294870642
	DB	00H
	ORG $+3
	DW	0bH
	ORG $+2
	DD	FLAT:$SG4294870641
	DB	01H
	ORG $+3
?implStr@?A0x7e09c670@@3PAPB_WA DD FLAT:$SG4294870665	; `anonymous namespace'::implStr
	DD	FLAT:$SG4294870664
	DD	FLAT:$SG4294870663
	DD	FLAT:$SG4294870662
	DD	FLAT:$SG4294870661
	DD	FLAT:$SG4294870660
	DD	FLAT:$SG4294870659
	DD	FLAT:$SG4294870658
	DD	FLAT:$SG4294870657
$SG4294870729 DB 00H
$SG4294870726 DB 00H
$SG4294870719 DB 00H
$SG4294870716 DB 00H
$SG4294870700 DB 00H
$SG4294870752 DB 'none', 00H
	ORG $+3
$SG4294870750 DB 'temporal', 00H
	ORG $+3
$SG4294870751 DB 'spatial', 00H
$SG4294870748 DB 'dia', 00H
$SG4294870749 DB 'auto', 00H
	ORG $+3
$SG4294870746 DB 'umh', 00H
$SG4294870747 DB 'hex', 00H
$SG4294870744 DB 'tesa', 00H
	ORG $+3
$SG4294870745 DB 'esa', 00H
$SG4294870742 DB 'strict', 00H
	ORG $+1
$SG4294870743 DB 'none', 00H
	ORG $+3
$SG4294870740 DB 'undef', 00H
	ORG $+2
$SG4294870741 DB 'normal', 00H
	ORG $+1
$SG4294870738 DB 'crop', 00H
	ORG $+3
$SG4294870739 DB 'show', 00H
	ORG $+3
$SG4294870736 DB 'pal', 00H
$SG4294870737 DB 'component', 00H
	ORG $+2
$SG4294870734 DB 'secam', 00H
	ORG $+2
$SG4294870735 DB 'ntsc', 00H
	ORG $+3
$SG4294870732 DB 'undef', 00H
	ORG $+2
$SG4294870733 DB 'mac', 00H
$SG4294870730 DB 'on', 00H
	ORG $+1
$SG4294870731 DB 'off', 00H
$SG4294870728 DB 'bt709', 00H
	ORG $+2
$SG4294870727 DB 'undef', 00H
	ORG $+2
$SG4294870724 DB 'bt470bg', 00H
$SG4294870725 DB 'bt470m', 00H
	ORG $+1
$SG4294870722 DB 'smpte240m', 00H
	ORG $+2
$SG4294870723 DB 'smpte170m', 00H
	ORG $+2
$SG4294870720 DB 'bt2020', 00H
	ORG $+1
$SG4294870721 DB 'film', 00H
	ORG $+3
$SG4294870718 DB 'bt709', 00H
	ORG $+2
$SG4294870717 DB 'undef', 00H
	ORG $+2
$SG4294870714 DB 'bt470bg', 00H
$SG4294870715 DB 'bt470m', 00H
	ORG $+1
$SG4294870712 DB 'smpte240m', 00H
	ORG $+2
$SG4294870713 DB 'smpte170m', 00H
	ORG $+2
$SG4294870710 DB 'log100', 00H
	ORG $+1
$SG4294870711 DB 'linear', 00H
	ORG $+1
$SG4294870708 DB 'iec61966-2-4', 00H
	ORG $+3
$SG4294870709 DB 'log316', 00H
	ORG $+1
$SG4294870706 DB 'iec61966-2-1', 00H
	ORG $+3
$SG4294870707 DB 'bt1361e', 00H
$SG4294870704 DB 'bt2020-12', 00H
	ORG $+2
$SG4294870705 DB 'bt2020-10', 00H
	ORG $+2
$SG4294870702 DB 'bt709', 00H
	ORG $+2
$SG4294870703 DB 'GBR', 00H
$SG4294870701 DB 'undef', 00H
	ORG $+2
$SG4294870698 DB 'bt470bg', 00H
$SG4294870699 DB 'fcc', 00H
$SG4294870696 DB 'smpte240m', 00H
	ORG $+2
$SG4294870697 DB 'smpte170m', 00H
	ORG $+2
$SG4294870694 DB 'bt2020nc', 00H
	ORG $+3
$SG4294870695 DB 'YCgCo', 00H
	ORG $+2
$SG4294870692 DB 'none', 00H
	ORG $+3
$SG4294870693 DB 'bt2020c', 00H
$SG4294870690 DB 'cbr', 00H
$SG4294870691 DB 'vbr', 00H
$SG4294870688 DB 'superfast', 00H
	ORG $+2
$SG4294870689 DB 'ultrafast', 00H
	ORG $+2
$SG4294870686 DB 'faster', 00H
	ORG $+1
$SG4294870687 DB 'veryfast', 00H
	ORG $+3
$SG4294870684 DB 'medium', 00H
	ORG $+1
$SG4294870685 DB 'fast', 00H
	ORG $+3
$SG4294870682 DB 'slower', 00H
	ORG $+1
$SG4294870683 DB 'slow', 00H
	ORG $+3
$SG4294870680 DB 'placebo', 00H
$SG4294870681 DB 'veryslow', 00H
	ORG $+3
$SG4294870678 DB 'animation', 00H
	ORG $+2
$SG4294870679 DB 'film', 00H
	ORG $+3
$SG4294870676 DB 'stillimage', 00H
	ORG $+1
$SG4294870677 DB 'grain', 00H
	ORG $+2
$SG4294870674 DB 'ssim', 00H
	ORG $+3
$SG4294870675 DB 'psnr', 00H
	ORG $+3
$SG4294870672 DB 'zerolatency', 00H
$SG4294870673 DB 'fastdecode', 00H
	ORG $+1
$SG4294870670 DB 'main', 00H
	ORG $+3
$SG4294870671 DB 'baseline', 00H
	ORG $+3
$SG4294870668 DB 'high10', 00H
	ORG $+1
$SG4294870669 DB 'high', 00H
	ORG $+3
$SG4294870666 DB 'high444', 00H
$SG4294870667 DB 'high422', 00H
$SG4294870664 DB 'M', 00H, 'F', 00H, 'X', 00H, '_', 00H, 'I', 00H, 'M', 00H
	DB	'P', 00H, 'L', 00H, '_', 00H, 'S', 00H, 'O', 00H, 'F', 00H, 'T'
	DB	00H, 'W', 00H, 'A', 00H, 'R', 00H, 'E', 00H, 00H, 00H
$SG4294870665 DB 'M', 00H, 'F', 00H, 'X', 00H, '_', 00H, 'I', 00H, 'M', 00H
	DB	'P', 00H, 'L', 00H, '_', 00H, 'A', 00H, 'U', 00H, 'T', 00H, 'O'
	DB	00H, 00H, 00H
$SG4294870662 DB 'M', 00H, 'F', 00H, 'X', 00H, '_', 00H, 'I', 00H, 'M', 00H
	DB	'P', 00H, 'L', 00H, '_', 00H, 'A', 00H, 'U', 00H, 'T', 00H, 'O'
	DB	00H, '_', 00H, 'A', 00H, 'N', 00H, 'Y', 00H, 00H, 00H
$SG4294870663 DB 'M', 00H, 'F', 00H, 'X', 00H, '_', 00H, 'I', 00H, 'M', 00H
	DB	'P', 00H, 'L', 00H, '_', 00H, 'H', 00H, 'A', 00H, 'R', 00H, 'D'
	DB	00H, 'W', 00H, 'A', 00H, 'R', 00H, 'E', 00H, 00H, 00H
$SG4294870660 DB 'M', 00H, 'F', 00H, 'X', 00H, '_', 00H, 'I', 00H, 'M', 00H
	DB	'P', 00H, 'L', 00H, '_', 00H, 'H', 00H, 'A', 00H, 'R', 00H, 'D'
	DB	00H, 'W', 00H, 'A', 00H, 'R', 00H, 'E', 00H, '2', 00H, 00H, 00H
	ORG $+2
$SG4294870661 DB 'M', 00H, 'F', 00H, 'X', 00H, '_', 00H, 'I', 00H, 'M', 00H
	DB	'P', 00H, 'L', 00H, '_', 00H, 'H', 00H, 'A', 00H, 'R', 00H, 'D'
	DB	00H, 'W', 00H, 'A', 00H, 'R', 00H, 'E', 00H, '_', 00H, 'A', 00H
	DB	'N', 00H, 'Y', 00H, 00H, 00H
$SG4294870658 DB 'M', 00H, 'F', 00H, 'X', 00H, '_', 00H, 'I', 00H, 'M', 00H
	DB	'P', 00H, 'L', 00H, '_', 00H, 'H', 00H, 'A', 00H, 'R', 00H, 'D'
	DB	00H, 'W', 00H, 'A', 00H, 'R', 00H, 'E', 00H, '4', 00H, 00H, 00H
	ORG $+2
$SG4294870659 DB 'M', 00H, 'F', 00H, 'X', 00H, '_', 00H, 'I', 00H, 'M', 00H
	DB	'P', 00H, 'L', 00H, '_', 00H, 'H', 00H, 'A', 00H, 'R', 00H, 'D'
	DB	00H, 'W', 00H, 'A', 00H, 'R', 00H, 'E', 00H, '3', 00H, 00H, 00H
	ORG $+2
$SG4294870656 DB 'M', 00H, 'F', 00H, 'X', 00H, '_', 00H, 'T', 00H, 'A', 00H
	DB	'R', 00H, 'G', 00H, 'E', 00H, 'T', 00H, 'U', 00H, 'S', 00H, 'A'
	DB	00H, 'G', 00H, 'E', 00H, '_', 00H, 'U', 00H, 'N', 00H, 'K', 00H
	DB	'N', 00H, 'O', 00H, 'W', 00H, 'N', 00H, 00H, 00H
$SG4294870657 DB 'M', 00H, 'F', 00H, 'X', 00H, '_', 00H, 'I', 00H, 'M', 00H
	DB	'P', 00H, 'L', 00H, '_', 00H, 'U', 00H, 'N', 00H, 'K', 00H, 'N'
	DB	00H, 'O', 00H, 'W', 00H, 'N', 00H, 00H, 00H
	ORG $+2
$SG4294870654 DB 'M', 00H, 'F', 00H, 'X', 00H, '_', 00H, 'T', 00H, 'A', 00H
	DB	'R', 00H, 'G', 00H, 'E', 00H, 'T', 00H, 'U', 00H, 'S', 00H, 'A'
	DB	00H, 'G', 00H, 'E', 00H, '_', 00H, '2', 00H, 00H, 00H
$SG4294870655 DB 'M', 00H, 'F', 00H, 'X', 00H, '_', 00H, 'T', 00H, 'A', 00H
	DB	'R', 00H, 'G', 00H, 'E', 00H, 'T', 00H, 'U', 00H, 'S', 00H, 'A'
	DB	00H, 'G', 00H, 'E', 00H, '_', 00H, '1', 00H, '_', 00H, 'B', 00H
	DB	'E', 00H, 'S', 00H, 'T', 00H, '_', 00H, 'Q', 00H, 'U', 00H, 'A'
	DB	00H, 'L', 00H, 'I', 00H, 'T', 00H, 'Y', 00H, 00H, 00H
	ORG $+2
$SG4294870652 DB 'M', 00H, 'F', 00H, 'X', 00H, '_', 00H, 'T', 00H, 'A', 00H
	DB	'R', 00H, 'G', 00H, 'E', 00H, 'T', 00H, 'U', 00H, 'S', 00H, 'A'
	DB	00H, 'G', 00H, 'E', 00H, '_', 00H, '4', 00H, '_', 00H, 'B', 00H
	DB	'A', 00H, 'L', 00H, 'A', 00H, 'N', 00H, 'C', 00H, 'E', 00H, 'D'
	DB	00H, 00H, 00H
	ORG $+2
$SG4294870653 DB 'M', 00H, 'F', 00H, 'X', 00H, '_', 00H, 'T', 00H, 'A', 00H
	DB	'R', 00H, 'G', 00H, 'E', 00H, 'T', 00H, 'U', 00H, 'S', 00H, 'A'
	DB	00H, 'G', 00H, 'E', 00H, '_', 00H, '3', 00H, 00H, 00H
$SG4294870650 DB 'M', 00H, 'F', 00H, 'X', 00H, '_', 00H, 'T', 00H, 'A', 00H
	DB	'R', 00H, 'G', 00H, 'E', 00H, 'T', 00H, 'U', 00H, 'S', 00H, 'A'
	DB	00H, 'G', 00H, 'E', 00H, '_', 00H, '6', 00H, 00H, 00H
$SG4294870651 DB 'M', 00H, 'F', 00H, 'X', 00H, '_', 00H, 'T', 00H, 'A', 00H
	DB	'R', 00H, 'G', 00H, 'E', 00H, 'T', 00H, 'U', 00H, 'S', 00H, 'A'
	DB	00H, 'G', 00H, 'E', 00H, '_', 00H, '5', 00H, 00H, 00H
$SG4294870648 DB 'CBR', 00H
$SG4294870649 DB 'M', 00H, 'F', 00H, 'X', 00H, '_', 00H, 'T', 00H, 'A', 00H
	DB	'R', 00H, 'G', 00H, 'E', 00H, 'T', 00H, 'U', 00H, 'S', 00H, 'A'
	DB	00H, 'G', 00H, 'E', 00H, '_', 00H, '7', 00H, '_', 00H, 'B', 00H
	DB	'E', 00H, 'S', 00H, 'T', 00H, '_', 00H, 'S', 00H, 'P', 00H, 'E'
	DB	00H, 'E', 00H, 'D', 00H, 00H, 00H
	ORG $+2
$SG4294870646 DB 'CQP', 00H
$SG4294870647 DB 'VBR', 00H
$SG4294870644 DB 'LA', 00H
	ORG $+1
$SG4294870645 DB 'AVBR', 00H
	ORG $+3
$SG4294870642 DB 'VCM', 00H
$SG4294870643 DB 'ICQ', 00H
$SG4294870640 DB ' ', 00H, '|', 00H, ' ', 00H, 'M', 00H, 'F', 00H, 'X', 00H
	DB	'_', 00H, 'I', 00H, 'M', 00H, 'P', 00H, 'L', 00H, '_', 00H, 'V'
	DB	00H, 'I', 00H, 'A', 00H, '_', 00H, 'A', 00H, 'N', 00H, 'Y', 00H
	DB	00H, 00H
$SG4294870641 DB 'LA_ICQ', 00H
	ORG $+1
$SG4294870638 DB ' ', 00H, '|', 00H, ' ', 00H, 'M', 00H, 'F', 00H, 'X', 00H
	DB	'_', 00H, 'I', 00H, 'M', 00H, 'P', 00H, 'L', 00H, '_', 00H, 'V'
	DB	00H, 'I', 00H, 'A', 00H, '_', 00H, 'D', 00H, '3', 00H, 'D', 00H
	DB	'1', 00H, '1', 00H, 00H, 00H
$SG4294870639 DB ' ', 00H, '|', 00H, ' ', 00H, 'M', 00H, 'F', 00H, 'X', 00H
	DB	'_', 00H, 'I', 00H, 'M', 00H, 'P', 00H, 'L', 00H, '_', 00H, 'V'
	DB	00H, 'I', 00H, 'A', 00H, '_', 00H, 'D', 00H, '3', 00H, 'D', 00H
	DB	'9', 00H, 00H, 00H
	ORG $+2
$SG4294870636 DB 'M', 00H, 'F', 00H, 'X', 00H, '_', 00H, 'P', 00H, 'R', 00H
	DB	'O', 00H, 'F', 00H, 'I', 00H, 'L', 00H, 'E', 00H, '_', 00H, 'U'
	DB	00H, 'N', 00H, 'K', 00H, 'N', 00H, 'O', 00H, 'W', 00H, 'N', 00H
	DB	00H, 00H
$SG4294870637 DB 00H, 00H
	ORG $+2
$SG4294870634 DB 'M', 00H, 'F', 00H, 'X', 00H, '_', 00H, 'P', 00H, 'R', 00H
	DB	'O', 00H, 'F', 00H, 'I', 00H, 'L', 00H, 'E', 00H, '_', 00H, 'A'
	DB	00H, 'V', 00H, 'C', 00H, '_', 00H, 'C', 00H, 'O', 00H, 'N', 00H
	DB	'S', 00H, 'T', 00H, 'R', 00H, 'A', 00H, 'I', 00H, 'N', 00H, 'T'
	DB	00H, '_', 00H, 'S', 00H, 'E', 00H, 'T', 00H, '1', 00H, 00H, 00H
$SG4294870635 DB 'M', 00H, 'F', 00H, 'X', 00H, '_', 00H, 'P', 00H, 'R', 00H
	DB	'O', 00H, 'F', 00H, 'I', 00H, 'L', 00H, 'E', 00H, '_', 00H, 'A'
	DB	00H, 'V', 00H, 'C', 00H, '_', 00H, 'C', 00H, 'O', 00H, 'N', 00H
	DB	'S', 00H, 'T', 00H, 'R', 00H, 'A', 00H, 'I', 00H, 'N', 00H, 'T'
	DB	00H, '_', 00H, 'S', 00H, 'E', 00H, 'T', 00H, '0', 00H, 00H, 00H
$SG4294870632 DB 'M', 00H, 'F', 00H, 'X', 00H, '_', 00H, 'P', 00H, 'R', 00H
	DB	'O', 00H, 'F', 00H, 'I', 00H, 'L', 00H, 'E', 00H, '_', 00H, 'A'
	DB	00H, 'V', 00H, 'C', 00H, '_', 00H, 'C', 00H, 'O', 00H, 'N', 00H
	DB	'S', 00H, 'T', 00H, 'R', 00H, 'A', 00H, 'I', 00H, 'N', 00H, 'T'
	DB	00H, '_', 00H, 'S', 00H, 'E', 00H, 'T', 00H, '3', 00H, 00H, 00H
$SG4294870633 DB 'M', 00H, 'F', 00H, 'X', 00H, '_', 00H, 'P', 00H, 'R', 00H
	DB	'O', 00H, 'F', 00H, 'I', 00H, 'L', 00H, 'E', 00H, '_', 00H, 'A'
	DB	00H, 'V', 00H, 'C', 00H, '_', 00H, 'C', 00H, 'O', 00H, 'N', 00H
	DB	'S', 00H, 'T', 00H, 'R', 00H, 'A', 00H, 'I', 00H, 'N', 00H, 'T'
	DB	00H, '_', 00H, 'S', 00H, 'E', 00H, 'T', 00H, '2', 00H, 00H, 00H
$SG4294870630 DB 'M', 00H, 'F', 00H, 'X', 00H, '_', 00H, 'P', 00H, 'R', 00H
	DB	'O', 00H, 'F', 00H, 'I', 00H, 'L', 00H, 'E', 00H, '_', 00H, 'A'
	DB	00H, 'V', 00H, 'C', 00H, '_', 00H, 'C', 00H, 'O', 00H, 'N', 00H
	DB	'S', 00H, 'T', 00H, 'R', 00H, 'A', 00H, 'I', 00H, 'N', 00H, 'T'
	DB	00H, '_', 00H, 'S', 00H, 'E', 00H, 'T', 00H, '5', 00H, 00H, 00H
$SG4294870631 DB 'M', 00H, 'F', 00H, 'X', 00H, '_', 00H, 'P', 00H, 'R', 00H
	DB	'O', 00H, 'F', 00H, 'I', 00H, 'L', 00H, 'E', 00H, '_', 00H, 'A'
	DB	00H, 'V', 00H, 'C', 00H, '_', 00H, 'C', 00H, 'O', 00H, 'N', 00H
	DB	'S', 00H, 'T', 00H, 'R', 00H, 'A', 00H, 'I', 00H, 'N', 00H, 'T'
	DB	00H, '_', 00H, 'S', 00H, 'E', 00H, 'T', 00H, '4', 00H, 00H, 00H
$SG4294870628 DB 'M', 00H, 'F', 00H, 'X', 00H, '_', 00H, 'P', 00H, 'R', 00H
	DB	'O', 00H, 'F', 00H, 'I', 00H, 'L', 00H, 'E', 00H, '_', 00H, 'A'
	DB	00H, 'V', 00H, 'C', 00H, '_', 00H, 'M', 00H, 'A', 00H, 'I', 00H
	DB	'N', 00H, 00H, 00H
	ORG $+2
$SG4294870629 DB 'M', 00H, 'F', 00H, 'X', 00H, '_', 00H, 'P', 00H, 'R', 00H
	DB	'O', 00H, 'F', 00H, 'I', 00H, 'L', 00H, 'E', 00H, '_', 00H, 'A'
	DB	00H, 'V', 00H, 'C', 00H, '_', 00H, 'B', 00H, 'A', 00H, 'S', 00H
	DB	'E', 00H, 'L', 00H, 'I', 00H, 'N', 00H, 'E', 00H, 00H, 00H
	ORG $+2
$SG4294870626 DB 'M', 00H, 'F', 00H, 'X', 00H, '_', 00H, 'P', 00H, 'R', 00H
	DB	'O', 00H, 'F', 00H, 'I', 00H, 'L', 00H, 'E', 00H, '_', 00H, 'A'
	DB	00H, 'V', 00H, 'C', 00H, '_', 00H, 'H', 00H, 'I', 00H, 'G', 00H
	DB	'H', 00H, 00H, 00H
	ORG $+2
$SG4294870627 DB 'M', 00H, 'F', 00H, 'X', 00H, '_', 00H, 'P', 00H, 'R', 00H
	DB	'O', 00H, 'F', 00H, 'I', 00H, 'L', 00H, 'E', 00H, '_', 00H, 'A'
	DB	00H, 'V', 00H, 'C', 00H, '_', 00H, 'E', 00H, 'X', 00H, 'T', 00H
	DB	'E', 00H, 'N', 00H, 'D', 00H, 'E', 00H, 'D', 00H, 00H, 00H
	ORG $+2
$SG4294870624 DB 'M', 00H, 'F', 00H, 'X', 00H, '_', 00H, 'P', 00H, 'R', 00H
	DB	'O', 00H, 'F', 00H, 'I', 00H, 'L', 00H, 'E', 00H, '_', 00H, 'A'
	DB	00H, 'V', 00H, 'C', 00H, '_', 00H, 'C', 00H, 'O', 00H, 'N', 00H
	DB	'S', 00H, 'T', 00H, 'R', 00H, 'A', 00H, 'I', 00H, 'N', 00H, 'E'
	DB	00H, 'D', 00H, '_', 00H, 'H', 00H, 'I', 00H, 'G', 00H, 'H', 00H
	DB	00H, 00H
	ORG $+2
$SG4294870622 DB 'U', 00H, 'N', 00H, 'K', 00H, 'N', 00H, 'O', 00H, 'W', 00H
	DB	'N', 00H, 00H, 00H
$SG4294870621 DB '/', 00H
	ORG $+2
$SG4294870625 DB 'M', 00H, 'F', 00H, 'X', 00H, '_', 00H, 'P', 00H, 'R', 00H
	DB	'O', 00H, 'F', 00H, 'I', 00H, 'L', 00H, 'E', 00H, '_', 00H, 'A'
	DB	00H, 'V', 00H, 'C', 00H, '_', 00H, 'C', 00H, 'O', 00H, 'N', 00H
	DB	'S', 00H, 'T', 00H, 'R', 00H, 'A', 00H, 'I', 00H, 'N', 00H, 'E'
	DB	00H, 'D', 00H, '_', 00H, 'B', 00H, 'A', 00H, 'S', 00H, 'E', 00H
	DB	'L', 00H, 'I', 00H, 'N', 00H, 'E', 00H, 00H, 00H
	ORG $+2
$SG4294870618 DB '%', 00H, 's', 00H, '%', 00H, 'u', 00H, 00H, 00H
	ORG $+2
$SG4294870623 DB 'M', 00H, 'F', 00H, 'X', 00H, '_', 00H, 'P', 00H, 'R', 00H
	DB	'O', 00H, 'F', 00H, 'I', 00H, 'L', 00H, 'E', 00H, '_', 00H, 'A'
	DB	00H, 'V', 00H, 'C', 00H, '_', 00H, 'P', 00H, 'R', 00H, 'O', 00H
	DB	'G', 00H, 'R', 00H, 'E', 00H, 'S', 00H, 'S', 00H, 'I', 00H, 'V'
	DB	00H, 'E', 00H, '_', 00H, 'H', 00H, 'I', 00H, 'G', 00H, 'H', 00H
	DB	00H, 00H
	ORG $+2
$SG4294870620 DB 'QSVHelper.exe', 00H
	ORG $+2
$SG4294870619 DB ' ', 00H
	ORG $+2
$SG4294870617 DB 'GenuineIntel', 00H
	ORG $+3
$SG4294870612 DB 'i', 00H, 'n', 00H, 'i', 00H, 't', 00H, '_', 00H, 'r', 00H
	DB	'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, 's', 00H, 't', 00H, 00H
	DB	00H
	ORG $+2
$SG4294870424 DB 'E', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H
	DB	'r', 00H, '.', 00H, 'Q', 00H, 'S', 00H, 'V', 00H, '.', 00H, 'I'
	DB	00H, 'P', 00H, 'C', 00H, 'I', 00H, 'n', 00H, 'i', 00H, 't', 00H
	DB	00H, 00H
$SG4294870423 DB 'E', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H
	DB	'r', 00H, '.', 00H, 'Q', 00H, 'S', 00H, 'V', 00H, '.', 00H, 'N'
	DB	00H, 'o', 00H, 'H', 00H, 'a', 00H, 'r', 00H, 'd', 00H, 'w', 00H
	DB	'a', 00H, 'r', 00H, 'e', 00H, 'S', 00H, 'u', 00H, 'p', 00H, 'p'
	DB	00H, 'o', 00H, 'r', 00H, 't', 00H, 00H, 00H
$SG4294870610 DB 'N', 00H, 'o', 00H, ' ', 00H, 'I', 00H, 'n', 00H, 't', 00H
	DB	'e', 00H, 'l', 00H, ' ', 00H, 'g', 00H, 'r', 00H, 'a', 00H, 'p'
	DB	00H, 'h', 00H, 'i', 00H, 'c', 00H, 's', 00H, ' ', 00H, 'a', 00H
	DB	'd', 00H, 'a', 00H, 'p', 00H, 't', 00H, 'e', 00H, 'r', 00H, ' '
	DB	00H, 'v', 00H, 'i', 00H, 's', 00H, 'i', 00H, 'b', 00H, 'l', 00H
	DB	'e', 00H, ' ', 00H, 'i', 00H, 'n', 00H, ' ', 00H, 'Q', 00H, 'S'
	DB	00H, 'V', 00H, 'H', 00H, 'e', 00H, 'l', 00H, 'p', 00H, 'e', 00H
	DB	'r', 00H, '.', 00H, 'e', 00H, 'x', 00H, 'e', 00H, ',', 00H, ' '
	DB	00H, 'O', 00H, 'p', 00H, 't', 00H, 'i', 00H, 'm', 00H, 'u', 00H
	DB	's', 00H, ' ', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'b', 00H, 'l'
	DB	00H, 'e', 00H, 'm', 00H, '?', 00H, 00H, 00H
	ORG $+2
$SG4294870611 DB 'F', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 'd', 00H, ' ', 00H
	DB	'Q', 00H, 'S', 00H, 'V', 00H, ' ', 00H, 'h', 00H, 'a', 00H, 'r'
	DB	00H, 'd', 00H, 'w', 00H, 'a', 00H, 'r', 00H, 'e', 00H, ' ', 00H
	DB	's', 00H, 'u', 00H, 'p', 00H, 'p', 00H, 'o', 00H, 'r', 00H, 't'
	DB	00H, 00H, 00H
	ORG $+3
$SG4294870609 DB 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 'i'
	DB	00H, 't', 00H, 'i', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'z', 00H
	DB	'e', 00H, ' ', 00H, 'Q', 00H, 'S', 00H, 'V', 00H, ' ', 00H, 'h'
	DB	00H, 'a', 00H, 'r', 00H, 'd', 00H, 'w', 00H, 'a', 00H, 'r', 00H
	DB	'e', 00H, ' ', 00H, 's', 00H, 'e', 00H, 's', 00H, 's', 00H, 'i'
	DB	00H, 'o', 00H, 'n', 00H, 00H, 00H
$SG4294870430 DB 'Q', 00H, 'S', 00H, 'V', 00H, ' ', 00H, '(', 00H, 'A', 00H
	DB	'd', 00H, 'v', 00H, 'a', 00H, 'n', 00H, 'c', 00H, 'e', 00H, 'd'
	DB	00H, ')', 00H, 00H, 00H
	ORG $+2
$SG4294870428 DB 'Q', 00H, 'S', 00H, 'V', 00H, ' ', 00H, '(', 00H, 'A', 00H
	DB	'd', 00H, 'v', 00H, 'a', 00H, 'n', 00H, 'c', 00H, 'e', 00H, 'd'
	DB	00H, ')', 00H, 00H, 00H
	ORG $+2
$SG4294870429 DB 'Q', 00H, 'S', 00H, 'V', 00H, ' ', 00H, '(', 00H, 'A', 00H
	DB	'd', 00H, 'v', 00H, 'a', 00H, 'n', 00H, 'c', 00H, 'e', 00H, 'd'
	DB	00H, ')', 00H, 00H, 00H
	ORG $+2
$SG4294870426 DB 'Q', 00H, 'S', 00H, 'V', 00H, ' ', 00H, '(', 00H, 'A', 00H
	DB	'd', 00H, 'v', 00H, 'a', 00H, 'n', 00H, 'c', 00H, 'e', 00H, 'd'
	DB	00H, ')', 00H, 00H, 00H
	ORG $+2
$SG4294870427 DB 'Q', 00H, 'S', 00H, 'V', 00H, ' ', 00H, '(', 00H, 'A', 00H
	DB	'd', 00H, 'v', 00H, 'a', 00H, 'n', 00H, 'c', 00H, 'e', 00H, 'd'
	DB	00H, ')', 00H, 00H, 00H
$SG4294870425 DB 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 'i'
	DB	00H, 't', 00H, 'i', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'z', 00H
	DB	'e', 00H, ' ', 00H, 'Q', 00H, 'S', 00H, 'V', 00H, ' ', 00H, 'I'
	DB	00H, 'P', 00H, 'C', 00H, ' ', 00H, '''', 00H, '%', 00H, 's', 00H
	DB	'''', 00H, ' ', 00H, '(', 00H, 'f', 00H, 'u', 00H, 'l', 00H, 'l'
	DB	00H, ' ', 00H, 'n', 00H, 'a', 00H, 'm', 00H, 'e', 00H, ':', 00H
	DB	' ', 00H, '''', 00H, '%', 00H, 's', 00H, '''', 00H, ')', 00H, ' '
	DB	00H, '(', 00H, '%', 00H, 'u', 00H, ')', 00H, 00H, 00H
$SG4294870422 DB 'Q', 00H, 'S', 00H, 'V', 00H, ':', 00H, ' ', 00H, 'O', 00H
	DB	'u', 00H, 't', 00H, 'p', 00H, 'u', 00H, 't', 00H, ' ', 00H, 'r'
	DB	00H, 'e', 00H, 's', 00H, 'o', 00H, 'l', 00H, 'u', 00H, 't', 00H
	DB	'i', 00H, 'o', 00H, 'n', 00H, ' ', 00H, 'o', 00H, 'f', 00H, ' '
	DB	00H, '%', 00H, 'u', 00H, 'x', 00H, '%', 00H, 'u', 00H, ' ', 00H
	DB	'e', 00H, 'x', 00H, 'c', 00H, 'e', 00H, 'e', 00H, 'd', 00H, 's'
	DB	00H, ' ', 00H, 't', 00H, 'h', 00H, 'e', 00H, ' ', 00H, 'm', 00H
	DB	'a', 00H, 'x', 00H, 'i', 00H, 'm', 00H, 'u', 00H, 'm', 00H, ' '
	DB	00H, 'o', 00H, 'f', 00H, ' ', 00H, '1', 00H, '9', 00H, '2', 00H
	DB	'0', 00H, 'x', 00H, '1', 00H, '2', 00H, '0', 00H, '0', 00H, ' '
	DB	00H, 's', 00H, 'u', 00H, 'p', 00H, 'p', 00H, 'o', 00H, 'r', 00H
	DB	't', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'b', 00H, 'y', 00H, ' '
	DB	00H, 'Q', 00H, 'u', 00H, 'i', 00H, 'c', 00H, 'k', 00H, 'S', 00H
	DB	'y', 00H, 'n', 00H, 'c', 00H, ' ', 00H, 'o', 00H, 'n', 00H, ' '
	DB	00H, 'S', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'y', 00H, ' ', 00H
	DB	'B', 00H, 'r', 00H, 'i', 00H, 'd', 00H, 'g', 00H, 'e', 00H, ' '
	DB	00H, 'a', 00H, 'n', 00H, 'd', 00H, ' ', 00H, 'I', 00H, 'v', 00H
	DB	'y', 00H, ' ', 00H, 'B', 00H, 'r', 00H, 'i', 00H, 'd', 00H, 'g'
	DB	00H, 'e', 00H, ' ', 00H, 'b', 00H, 'a', 00H, 's', 00H, 'e', 00H
	DB	'd', 00H, ' ', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'c', 00H, 'e'
	DB	00H, 's', 00H, 's', 00H, 'o', 00H, 'r', 00H, 's', 00H, 00H, 00H
$SG4294870420 DB 'Q', 00H, 'S', 00H, 'V', 00H, ':', 00H, ' ', 00H, 'O', 00H
	DB	'u', 00H, 't', 00H, 'p', 00H, 'u', 00H, 't', 00H, ' ', 00H, 'r'
	DB	00H, 'e', 00H, 's', 00H, 'o', 00H, 'l', 00H, 'u', 00H, 't', 00H
	DB	'i', 00H, 'o', 00H, 'n', 00H, ' ', 00H, 'w', 00H, 'i', 00H, 'd'
	DB	00H, 't', 00H, 'h', 00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H
	DB	'%', 00H, 'u', 00H, ' ', 00H, 'e', 00H, 'x', 00H, 'c', 00H, 'e'
	DB	00H, 'e', 00H, 'd', 00H, 's', 00H, ' ', 00H, 't', 00H, 'h', 00H
	DB	'e', 00H, ' ', 00H, 'm', 00H, 'a', 00H, 'x', 00H, 'i', 00H, 'm'
	DB	00H, 'u', 00H, 'm', 00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H
	DB	'1', 00H, '9', 00H, '2', 00H, '0', 00H, ' ', 00H, 's', 00H, 'u'
	DB	00H, 'p', 00H, 'p', 00H, 'o', 00H, 'r', 00H, 't', 00H, 'e', 00H
	DB	'd', 00H, ' ', 00H, 'b', 00H, 'y', 00H, ' ', 00H, 'Q', 00H, 'u'
	DB	00H, 'i', 00H, 'c', 00H, 'k', 00H, 'S', 00H, 'y', 00H, 'n', 00H
	DB	'c', 00H, ' ', 00H, 'o', 00H, 'n', 00H, ' ', 00H, 'S', 00H, 'a'
	DB	00H, 'n', 00H, 'd', 00H, 'y', 00H, ' ', 00H, 'B', 00H, 'r', 00H
	DB	'i', 00H, 'd', 00H, 'g', 00H, 'e', 00H, ' ', 00H, 'a', 00H, 'n'
	DB	00H, 'd', 00H, ' ', 00H, 'I', 00H, 'v', 00H, 'y', 00H, ' ', 00H
	DB	'B', 00H, 'r', 00H, 'i', 00H, 'd', 00H, 'g', 00H, 'e', 00H, ' '
	DB	00H, 'b', 00H, 'a', 00H, 's', 00H, 'e', 00H, 'd', 00H, ' ', 00H
	DB	'p', 00H, 'r', 00H, 'o', 00H, 'c', 00H, 'e', 00H, 's', 00H, 's'
	DB	00H, 'o', 00H, 'r', 00H, 's', 00H, 00H, 00H
$SG4294870421 DB 'E', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H
	DB	'r', 00H, '.', 00H, 'Q', 00H, 'S', 00H, 'V', 00H, '.', 00H, 'S'
	DB	00H, 'N', 00H, 'B', 00H, 'I', 00H, 'V', 00H, 'B', 00H, 'M', 00H
	DB	'a', 00H, 'x', 00H, 'i', 00H, 'm', 00H, 'u', 00H, 'm', 00H, 'R'
	DB	00H, 'e', 00H, 's', 00H, 'o', 00H, 'l', 00H, 'u', 00H, 't', 00H
	DB	'i', 00H, 'o', 00H, 'n', 00H, 'W', 00H, 'i', 00H, 'd', 00H, 't'
	DB	00H, 'h', 00H, 'H', 00H, 'e', 00H, 'i', 00H, 'g', 00H, 'h', 00H
	DB	't', 00H, 'E', 00H, 'x', 00H, 'c', 00H, 'e', 00H, 'e', 00H, 'd'
	DB	00H, 'e', 00H, 'd', 00H, 00H, 00H
	ORG $+2
$SG4294870418 DB 'Q', 00H, 'S', 00H, 'V', 00H, ':', 00H, ' ', 00H, 'O', 00H
	DB	'u', 00H, 't', 00H, 'p', 00H, 'u', 00H, 't', 00H, ' ', 00H, 'r'
	DB	00H, 'e', 00H, 's', 00H, 'o', 00H, 'l', 00H, 'u', 00H, 't', 00H
	DB	'i', 00H, 'o', 00H, 'n', 00H, ' ', 00H, 'h', 00H, 'e', 00H, 'i'
	DB	00H, 'g', 00H, 'h', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'f', 00H
	DB	' ', 00H, '%', 00H, 'u', 00H, ' ', 00H, 'e', 00H, 'x', 00H, 'c'
	DB	00H, 'e', 00H, 'e', 00H, 'd', 00H, 's', 00H, ' ', 00H, 't', 00H
	DB	'h', 00H, 'e', 00H, ' ', 00H, 'm', 00H, 'a', 00H, 'x', 00H, 'i'
	DB	00H, 'm', 00H, 'u', 00H, 'm', 00H, ' ', 00H, 'o', 00H, 'f', 00H
	DB	' ', 00H, '1', 00H, '2', 00H, '0', 00H, '0', 00H, ' ', 00H, 's'
	DB	00H, 'u', 00H, 'p', 00H, 'p', 00H, 'o', 00H, 'r', 00H, 't', 00H
	DB	'e', 00H, 'd', 00H, ' ', 00H, 'b', 00H, 'y', 00H, ' ', 00H, 'Q'
	DB	00H, 'u', 00H, 'i', 00H, 'c', 00H, 'k', 00H, 'S', 00H, 'y', 00H
	DB	'n', 00H, 'c', 00H, ' ', 00H, 'o', 00H, 'n', 00H, ' ', 00H, 'S'
	DB	00H, 'a', 00H, 'n', 00H, 'd', 00H, 'y', 00H, ' ', 00H, 'B', 00H
	DB	'r', 00H, 'i', 00H, 'd', 00H, 'g', 00H, 'e', 00H, ' ', 00H, 'a'
	DB	00H, 'n', 00H, 'd', 00H, ' ', 00H, 'I', 00H, 'v', 00H, 'y', 00H
	DB	' ', 00H, 'B', 00H, 'r', 00H, 'i', 00H, 'd', 00H, 'g', 00H, 'e'
	DB	00H, ' ', 00H, 'b', 00H, 'a', 00H, 's', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'c', 00H, 'e', 00H, 's'
	DB	00H, 's', 00H, 'o', 00H, 'r', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG4294870419 DB 'E', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H
	DB	'r', 00H, '.', 00H, 'Q', 00H, 'S', 00H, 'V', 00H, '.', 00H, 'S'
	DB	00H, 'N', 00H, 'B', 00H, 'I', 00H, 'V', 00H, 'B', 00H, 'M', 00H
	DB	'a', 00H, 'x', 00H, 'i', 00H, 'm', 00H, 'u', 00H, 'm', 00H, 'R'
	DB	00H, 'e', 00H, 's', 00H, 'o', 00H, 'l', 00H, 'u', 00H, 't', 00H
	DB	'i', 00H, 'o', 00H, 'n', 00H, 'W', 00H, 'i', 00H, 'd', 00H, 't'
	DB	00H, 'h', 00H, 'E', 00H, 'x', 00H, 'c', 00H, 'e', 00H, 'e', 00H
	DB	'd', 00H, 'e', 00H, 'd', 00H, 00H, 00H
	ORG $+2
$SG4294870416 DB 'C', 00H, 'a', 00H, 'u', 00H, 'g', 00H, 'h', 00H, 't', 00H
	DB	' ', 00H, 'u', 00H, 'n', 00H, 'h', 00H, 'a', 00H, 'n', 00H, 'd'
	DB	00H, 'l', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'e', 00H, 'x', 00H
	DB	'c', 00H, 'e', 00H, 'p', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n'
	DB	00H, 00H, 00H
$SG4294870417 DB 'E', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H
	DB	'r', 00H, '.', 00H, 'Q', 00H, 'S', 00H, 'V', 00H, '.', 00H, 'S'
	DB	00H, 'N', 00H, 'B', 00H, 'I', 00H, 'V', 00H, 'B', 00H, 'M', 00H
	DB	'a', 00H, 'x', 00H, 'i', 00H, 'm', 00H, 'u', 00H, 'm', 00H, 'R'
	DB	00H, 'e', 00H, 's', 00H, 'o', 00H, 'l', 00H, 'u', 00H, 't', 00H
	DB	'i', 00H, 'o', 00H, 'n', 00H, 'H', 00H, 'e', 00H, 'i', 00H, 'g'
	DB	00H, 'h', 00H, 't', 00H, 'E', 00H, 'x', 00H, 'c', 00H, 'e', 00H
	DB	'e', 00H, 'd', 00H, 'e', 00H, 'd', 00H, 00H, 00H
$SG4294870415 DB 'E', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H
	DB	'r', 00H, '.', 00H, 'Q', 00H, 'S', 00H, 'V', 00H, '.', 00H, 'E'
	DB	00H, 'x', 00H, 'c', 00H, 'e', 00H, 'e', 00H, 'd', 00H, 'e', 00H
	DB	'd', 00H, 'R', 00H, 'e', 00H, 's', 00H, 'o', 00H, 'l', 00H, 'u'
	DB	00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 'H', 00H, 'e', 00H
	DB	'l', 00H, 'p', 00H, 00H, 00H
PUBLIC	??$_Distance2@PBEH@std@@YAXPBE0AAHUrandom_access_iterator_tag@0@@Z ; std::_Distance2<unsigned char const *,int>
PUBLIC	??$_Iter_cat@PBE@std@@YA?AUrandom_access_iterator_tag@0@ABQBE@Z ; std::_Iter_cat<unsigned char const *>
PUBLIC	??$_Distance2@PAEH@std@@YAXPAE0AAHUrandom_access_iterator_tag@0@@Z ; std::_Distance2<unsigned char *,int>
PUBLIC	??$_Iter_cat@PAE@std@@YA?AUrandom_access_iterator_tag@0@ABQAE@Z ; std::_Iter_cat<unsigned char *>
PUBLIC	??$_Uninit_move@PAXPAXPAX@std@@YAPAPAXPAPAX00AAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<void *,void *,void *>
PUBLIC	??$_Val_type@PAPAX@std@@YAPAPAXPAPAX@Z		; std::_Val_type<void * *>
PUBLIC	??$_Uninit_copy@PAXPAX@std@@YAPAPAXPAPAX00AAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<void *,void *>
PUBLIC	??$_Uninit_copy@QAXPAX@std@@YAPAPAXPBQAX0PAPAXAAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<void * const,void *>
PUBLIC	??$_Ptr_cat@PAXPAX@std@@YA?AU_Scalar_ptr_iterator_tag@0@PBQAXPAPAX@Z ; std::_Ptr_cat<void *,void *>
PUBLIC	??$?RAAEABE@?$equal_to@X@std@@QBE_NAAEABE@Z	; std::equal_to<void>::operator()<unsigned char &,unsigned char const &>
PUBLIC	??$_Distance@PBEH@std@@YAXPBE0AAH@Z		; std::_Distance<unsigned char const *,int>
PUBLIC	??$_Distance@PAEH@std@@YAXPAE0AAH@Z		; std::_Distance<unsigned char *,int>
PUBLIC	?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@std@@QBEPBQAXXZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<void *> > >::_Unchecked
PUBLIC	??$_Uninit_move@PAPAXPAPAXU?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@@std@@YAPAPAXPAPAX00AAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@@Z ; std::_Uninit_move<void * *,void * *,std::_Wrap_alloc<std::allocator<void *> > >
PUBLIC	??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z ; std::allocator<wchar_t>::destroy<wchar_t *>
PUBLIC	??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>
PUBLIC	??$construct@PAXAAPAX@?$allocator@PAX@std@@QAEXPAPAXAAPAX@Z ; std::allocator<void *>::construct<void *,void * &>
PUBLIC	??$_Uninit_copy@PAPAXPAPAXU?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@@std@@YAPAPAXPAPAX00AAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@@Z ; std::_Uninit_copy<void * *,void * *,std::_Wrap_alloc<std::allocator<void *> > >
PUBLIC	??$?8PAXPAX@std@@YA_NABV?$allocator@PAX@0@0@Z	; std::operator==<void *,void *>
PUBLIC	??$_Rechecked@PAPAXPAPAX@std@@YAAAPAPAXAAPAPAXPAPAX@Z ; std::_Rechecked<void * *,void * *>
PUBLIC	??$_Uninit_copy@PBQAXPAPAXU?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@@std@@YAPAPAXPBQAX0PAPAXAAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@@Z ; std::_Uninit_copy<void * const *,void * *,std::_Wrap_alloc<std::allocator<void *> > >
PUBLIC	??$_Unchecked@PAPAX@std@@YAPAPAXPAPAX@Z		; std::_Unchecked<void * *>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@std@@YAPBQAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<void *> > >
PUBLIC	??$_Search@PAEPBEHHU?$equal_to@X@std@@@std@@YAPAEPAE0PBE1U?$equal_to@X@0@PAH3@Z ; std::_Search<unsigned char *,unsigned char const *,int,int,std::equal_to<void> >
PUBLIC	??$_Dist_type@PBE@std@@YAPAHPBE@Z		; std::_Dist_type<unsigned char const *>
PUBLIC	??$_Dist_type@PAE@std@@YAPAHPAE@Z		; std::_Dist_type<unsigned char *>
PUBLIC	??$_Unchecked@PBE@std@@YAPBEPBE@Z		; std::_Unchecked<unsigned char const *>
PUBLIC	?construct@?$allocator@PAX@std@@QAEXPAPAXABQAX@Z ; std::allocator<void *>::construct
PUBLIC	??$_Uninitialized_move@PAPAXPAPAXU?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@@std@@YAPAPAXPAPAX00AAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@@Z ; std::_Uninitialized_move<void * *,void * *,std::_Wrap_alloc<std::allocator<void *> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@@std@@YAXPAPAX0AAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<void *> > >
PUBLIC	??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t> >::destroy<wchar_t *>
PUBLIC	??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>
PUBLIC	??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z		; std::forward<wchar_t * &>
PUBLIC	??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z	; std::operator==<wchar_t,wchar_t>
PUBLIC	??$construct@PAXABQAX@?$allocator_traits@V?$allocator@PAX@std@@@std@@SAXAAV?$allocator@PAX@1@PAPAXABQAX@Z ; std::allocator_traits<std::allocator<void *> >::construct<void *,void * const &>
PUBLIC	??$forward@ABQAX@std@@YAABQAXABQAX@Z		; std::forward<void * const &>
PUBLIC	??$construct@PAXAAPAX@?$allocator_traits@V?$allocator@PAX@std@@@std@@SAXAAV?$allocator@PAX@1@PAPAXAAPAX@Z ; std::allocator_traits<std::allocator<void *> >::construct<void *,void * &>
PUBLIC	??$forward@AAPAX@std@@YAAAPAXAAPAX@Z		; std::forward<void * &>
PUBLIC	??$_Uninitialized_copy@PAPAXPAPAXU?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@@std@@YAPAPAXPAPAX00AAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@@Z ; std::_Uninitialized_copy<void * *,void * *,std::_Wrap_alloc<std::allocator<void *> > >
PUBLIC	??$_Copy_impl@PAPAXPAPAX@std@@YAPAPAXPAPAX00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_impl<void * *,void * *>
PUBLIC	??$_Ptr_cat@PAXPAX@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAX0@Z ; std::_Ptr_cat<void *,void *>
PUBLIC	??$?8V?$allocator@PAX@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@0@Z ; std::operator==<std::allocator<void *>,std::allocator<void *> >
PUBLIC	??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@std@@PAPAXU?$_Wrap_alloc@V?$allocator@PAX@std@@@2@@std@@YAPAPAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@0@0PAPAXAAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@@Z ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<void *> > >,void * *,std::_Wrap_alloc<std::allocator<void *> > >
PUBLIC	??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ; std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$_Rechecked@PAEPAE@std@@YAAAPAEAAPAEPAE@Z	; std::_Rechecked<unsigned char *,unsigned char *>
PUBLIC	??$_Find_if_not@PAEV<lambda_4f23e6955dca7f806ec2428e9267999f>@@@std@@YAPAEPAE0V<lambda_4f23e6955dca7f806ec2428e9267999f>@@@Z ; std::_Find_if_not<unsigned char *,<lambda_4f23e6955dca7f806ec2428e9267999f> >
PUBLIC	??$_Unchecked@PAE@std@@YAPAEPAE@Z		; std::_Unchecked<unsigned char *>
PUBLIC	??$search@PAEPBEU?$equal_to@X@std@@@std@@YAPAEPAE0PBE1U?$equal_to@X@0@@Z ; std::search<unsigned char *,unsigned char const *,std::equal_to<void> >
PUBLIC	??$_Distance2@PAPB_WH@std@@YAXPAPB_W0AAHUrandom_access_iterator_tag@0@@Z ; std::_Distance2<wchar_t const * *,int>
PUBLIC	??$_Iter_cat@PAPB_W@std@@YA?AUrandom_access_iterator_tag@0@ABQAPB_W@Z ; std::_Iter_cat<wchar_t const * *>
PUBLIC	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
PUBLIC	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
PUBLIC	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
PUBLIC	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
PUBLIC	??0?$IPCMutexLock@U?$IPCLockedSignalledArray@Uqueued_frame@@@@@@QAE@AAU?$IPCLockedSignalledArray@Uqueued_frame@@@@@Z ; IPCMutexLock<IPCLockedSignalledArray<queued_frame> >::IPCMutexLock<IPCLockedSignalledArray<queued_frame> >
PUBLIC	??0?$IPCMutexLock@U?$IPCLockedSignalledArray@I@@@@QAE@AAU?$IPCLockedSignalledArray@I@@@Z ; IPCMutexLock<IPCLockedSignalledArray<unsigned int> >::IPCMutexLock<IPCLockedSignalledArray<unsigned int> >
PUBLIC	??0?$IPCMutexLock@U?$IPCLockedSignalledType@H@@@@QAE@AAU?$IPCLockedSignalledType@H@@@Z ; IPCMutexLock<IPCLockedSignalledType<int> >::IPCMutexLock<IPCLockedSignalledType<int> >
PUBLIC	?reserve@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::reserve
PUBLIC	??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator+=
PUBLIC	??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator+=
PUBLIC	??$_Allocate@_W@std@@YAPA_WIPA_W@Z		; std::_Allocate<wchar_t>
PUBLIC	??$_Allocate@PAX@std@@YAPAPAXIPAPAX@Z		; std::_Allocate<void *>
PUBLIC	??$_Umove@PAPAX@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEPAPAXPAPAX00@Z ; std::vector<void *,std::allocator<void *> >::_Umove<void * *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@@std@@YAXPAPAX0AAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<void *> > >
PUBLIC	??$addressof@_W@std@@YAPA_WAA_W@Z		; std::addressof<wchar_t>
PUBLIC	??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::destroy<wchar_t *>
PUBLIC	??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>
PUBLIC	??$as@Uspspps_size@@@NamedSharedMemory@@QAEAAUspspps_size@@XZ ; NamedSharedMemory::as<spspps_size>
PUBLIC	??$as@Uinit_response@@@NamedSharedMemory@@QAEAAUinit_response@@XZ ; NamedSharedMemory::as<init_response>
PUBLIC	??$as@H@NamedSharedMemory@@QAEAAHXZ		; NamedSharedMemory::as<int>
PUBLIC	??$move@AAUNamedSharedMemory@@@std@@YA$$QAUNamedSharedMemory@@AAU1@@Z ; std::move<NamedSharedMemory &>
PUBLIC	??$as@Uinit_request@@@NamedSharedMemory@@QAEAAUinit_request@@XZ ; NamedSharedMemory::as<init_request>
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$construct@PAXABQAX@?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QAEXPAPAXABQAX@Z ; std::_Wrap_alloc<std::allocator<void *> >::construct<void *,void * const &>
PUBLIC	??$construct@PAXAAPAX@?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QAEXPAPAXAAPAX@Z ; std::_Wrap_alloc<std::allocator<void *> >::construct<void *,void * &>
PUBLIC	??$addressof@QAX@std@@YAPBQAXABQAX@Z		; std::addressof<void * const>
PUBLIC	??$_Ucopy@PAPAX@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEPAPAXPAPAX00@Z ; std::vector<void *,std::allocator<void *> >::_Ucopy<void * *>
PUBLIC	??$_Copy_impl@PAPAXPAPAX@std@@YAPAPAXPAPAX00@Z	; std::_Copy_impl<void * *,void * *>
PUBLIC	??$?9V?$allocator@PAX@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@0@Z ; std::operator!=<std::allocator<void *>,std::allocator<void *> >
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@std@@@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEPAPAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@1@0PAPAX@Z ; std::vector<void *,std::allocator<void *> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<void *> > > >
PUBLIC	??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ; std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
PUBLIC	??$timestampFromMS@_K@?A0x7e09c670@@YA_K_K@Z	; `anonymous namespace'::timestampFromMS<unsigned __int64>
PUBLIC	??$timestampFromMS@K@?A0x7e09c670@@YAKK@Z	; `anonymous namespace'::timestampFromMS<unsigned long>
PUBLIC	??$lock_mutex@U?$IPCLockedSignalledArray@Uqueued_frame@@@@@@YA?AU?$IPCMutexLock@U?$IPCLockedSignalledArray@Uqueued_frame@@@@@@AAU?$IPCLockedSignalledArray@Uqueued_frame@@@@@Z ; lock_mutex<IPCLockedSignalledArray<queued_frame> >
PUBLIC	??$lock_mutex@U?$IPCLockedSignalledArray@I@@@@YA?AU?$IPCMutexLock@U?$IPCLockedSignalledArray@I@@@@AAU?$IPCLockedSignalledArray@I@@@Z ; lock_mutex<IPCLockedSignalledArray<unsigned int> >
PUBLIC	??$find_if_not@PAEV<lambda_4f23e6955dca7f806ec2428e9267999f>@@@std@@YAPAEPAE0V<lambda_4f23e6955dca7f806ec2428e9267999f>@@@Z ; std::find_if_not<unsigned char *,<lambda_4f23e6955dca7f806ec2428e9267999f> >
PUBLIC	??$msFromTimestamp@_K@?A0x7e09c670@@YA_K_K@Z	; `anonymous namespace'::msFromTimestamp<unsigned __int64>
PUBLIC	??$msFromTimestamp@_J@?A0x7e09c670@@YA_J_J@Z	; `anonymous namespace'::msFromTimestamp<__int64>
PUBLIC	??$search@PAEPBE@std@@YAPAEPAE0PBE1@Z		; std::search<unsigned char *,unsigned char const *>
PUBLIC	??$lock_mutex@U?$IPCLockedSignalledType@H@@@@YA?AU?$IPCMutexLock@U?$IPCLockedSignalledType@H@@@@AAU?$IPCLockedSignalledType@H@@@Z ; lock_mutex<IPCLockedSignalledType<int> >
PUBLIC	??$distance@PAPB_W@std@@YAHPAPB_W0@Z		; std::distance<wchar_t const * *>
PUBLIC	??$end@PB_W$08@std@@YAPAPB_WAAY08PB_W@Z		; std::end<wchar_t const *,9>
PUBLIC	??$begin@PB_W$08@std@@YAPAPB_WAAY08PB_W@Z	; std::begin<wchar_t const *,9>
PUBLIC	??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$move@AAUsafe_handle@@@std@@YA$$QAUsafe_handle@@AAU1@@Z ; std::move<safe_handle &>
PUBLIC	?max_size@?$allocator@_W@std@@QBEIXZ		; std::allocator<wchar_t>::max_size
PUBLIC	?max_size@?$allocator@PAX@std@@QBEIXZ		; std::allocator<void *>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z ; std::allocator_traits<std::allocator<wchar_t> >::max_size
PUBLIC	?allocate@?$allocator@_W@std@@QAEPA_WI@Z	; std::allocator<wchar_t>::allocate
PUBLIC	?max_size@?$allocator_traits@V?$allocator@PAX@std@@@std@@SAIABV?$allocator@PAX@2@@Z ; std::allocator_traits<std::allocator<void *> >::max_size
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<wchar_t> >::max_size
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::allocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<void *> >::max_size
PUBLIC	?allocate@?$allocator@PAX@std@@QAEPAPAXI@Z	; std::allocator<void *>::allocate
PUBLIC	??0?$allocator@PAX@std@@QAE@ABV01@@Z		; std::allocator<void *>::allocator<void *>
PUBLIC	?select_on_container_copy_construction@?$allocator@PAX@std@@QBE?AV12@XZ ; std::allocator<void *>::select_on_container_copy_construction
PUBLIC	?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z	; std::allocator<wchar_t>::deallocate
PUBLIC	??0?$allocator@_W@std@@QAE@ABV01@@Z		; std::allocator<wchar_t>::allocator<wchar_t>
PUBLIC	?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ ; std::allocator<wchar_t>::select_on_container_copy_construction
PUBLIC	?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen
PUBLIC	?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Inside
PUBLIC	?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
PUBLIC	?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@std@@QAE@PAPAXPBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<void *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<void *> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@std@@QBEABQAXXZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<void *> > >::operator*
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@std@@QAE@PAPAXPBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<void *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<void *> > >
PUBLIC	??0?$IPCType@H@@QAE@XZ				; IPCType<int>::IPCType<int>
PUBLIC	??0?$IPCType@H@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; IPCType<int>::IPCType<int>
PUBLIC	??0?$IPCArray@I@@QAE@XZ				; IPCArray<unsigned int>::IPCArray<unsigned int>
PUBLIC	??0?$IPCArray@I@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z ; IPCArray<unsigned int>::IPCArray<unsigned int>
PUBLIC	??0?$IPCArray@Uqueued_frame@@@@QAE@XZ		; IPCArray<queued_frame>::IPCArray<queued_frame>
PUBLIC	??0?$IPCArray@Uqueued_frame@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z ; IPCArray<queued_frame>::IPCArray<queued_frame>
PUBLIC	??0?$IPCSignal@$0A@@@QAE@XZ			; IPCSignal<0>::IPCSignal<0>
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<void *> >::_Vector_val<std::_Simple_types<void *> >
PUBLIC	?select_on_container_copy_construction@?$allocator_traits@V?$allocator@PAX@std@@@std@@SA?AV?$allocator@PAX@2@ABV32@@Z ; std::allocator_traits<std::allocator<void *> >::select_on_container_copy_construction
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QAEPAPAXI@Z ; std::_Wrap_alloc<std::allocator<void *> >::allocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QAE@ABV?$allocator@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<void *> >::_Wrap_alloc<std::allocator<void *> >
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<void *> >::_Wrap_alloc<std::allocator<void *> >
PUBLIC	?deallocate@?$allocator@PAX@std@@QAEXPAPAXI@Z	; std::allocator<void *>::deallocate
PUBLIC	?_Xlen@?$vector@PAXV?$allocator@PAX@std@@@std@@IBEXXZ ; std::vector<void *,std::allocator<void *> >::_Xlen
PUBLIC	?_Reallocate@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXI@Z ; std::vector<void *,std::allocator<void *> >::_Reallocate
PUBLIC	?_Grow_to@?$vector@PAXV?$allocator@PAX@std@@@std@@IBEII@Z ; std::vector<void *,std::allocator<void *> >::_Grow_to
PUBLIC	?max_size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::max_size
PUBLIC	?_Unused_capacity@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::_Unused_capacity
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
PUBLIC	??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
PUBLIC	?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z ; std::allocator_traits<std::allocator<wchar_t> >::select_on_container_copy_construction
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >
PUBLIC	??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >
PUBLIC	?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran
PUBLIC	?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow
PUBLIC	?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos
PUBLIC	?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
PUBLIC	?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@std@@QBEAAPAXXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<void *> > >::operator*
PUBLIC	??0?$IPCArray@E@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z ; IPCArray<unsigned char>::IPCArray<unsigned char>
PUBLIC	??0?$IPCType@Uspspps_size@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; IPCType<spspps_size>::IPCType<spspps_size>
PUBLIC	?Add@?$List@W4PacketType@@@@QAEIABW4PacketType@@@Z ; List<enum PacketType>::Add
PUBLIC	?Clear@?$List@Ux264_nal_t@@@@QAEXXZ		; List<x264_nal_t>::Clear
PUBLIC	?Add@?$List@Ux264_nal_t@@@@QAEIABUx264_nal_t@@@Z ; List<x264_nal_t>::Add
PUBLIC	??0?$IPCType@Uinit_response@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; IPCType<init_response>::IPCType<init_response>
PUBLIC	?SetSize@?$List@UVideoPacket@@@@QAEHI@Z		; List<VideoPacket>::SetSize
PUBLIC	?Clear@?$List@UmfxFrameData@@@@QAEXXZ		; List<mfxFrameData>::Clear
PUBLIC	??0?$IPCSignalledType@H@@QAE@XZ			; IPCSignalledType<int>::IPCSignalledType<int>
PUBLIC	??0?$IPCSignalledType@H@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; IPCSignalledType<int>::IPCSignalledType<int>
PUBLIC	??0?$IPCSignalledArray@I@@QAE@XZ		; IPCSignalledArray<unsigned int>::IPCSignalledArray<unsigned int>
PUBLIC	??0?$IPCSignalledArray@I@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z ; IPCSignalledArray<unsigned int>::IPCSignalledArray<unsigned int>
PUBLIC	??0?$IPCSignalledArray@Uqueued_frame@@@@QAE@XZ	; IPCSignalledArray<queued_frame>::IPCSignalledArray<queued_frame>
PUBLIC	??0?$IPCSignalledArray@Uqueued_frame@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z ; IPCSignalledArray<queued_frame>::IPCSignalledArray<queued_frame>
PUBLIC	?Clear@?$List@Uencode_task@QSVEncoder@@@@QAEXXZ	; List<QSVEncoder::encode_task>::Clear
PUBLIC	??0?$IPCType@Uinit_request@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; IPCType<init_request>::IPCType<init_request>
PUBLIC	?Add@?$List@_J@@QAEIAB_J@Z			; List<__int64>::Add
PUBLIC	??0?$IPCSignal@$0A@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; IPCSignal<0>::IPCSignal<0>
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QAEXPAPAXI@Z ; std::_Wrap_alloc<std::allocator<void *> >::deallocate
PUBLIC	?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<void *> >::select_on_container_copy_construction
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAX@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<void *,std::allocator<void *> > >::_Getal
PUBLIC	?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@PAX@std@@@2@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<void *,std::allocator<void *> > >::_Change_alloc
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QAE@ABV?$allocator@PAX@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<void *,std::allocator<void *> > >::_Vector_alloc<0,std::_Vec_base_types<void *,std::allocator<void *> > >
PUBLIC	??0?$allocator@PAX@std@@QAE@XZ			; std::allocator<void *>::allocator<void *>
PUBLIC	?_Orphan_range@?$vector@PAXV?$allocator@PAX@std@@@std@@IBEXPAPAX0@Z ; std::vector<void *,std::allocator<void *> >::_Orphan_range
PUBLIC	?_Tidy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXXZ ; std::vector<void *,std::allocator<void *> >::_Tidy
PUBLIC	?_Reserve@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXI@Z ; std::vector<void *,std::allocator<void *> >::_Reserve
PUBLIC	?_Inside@?$vector@PAXV?$allocator@PAX@std@@@std@@IBE_NPBQAX@Z ; std::vector<void *,std::allocator<void *> >::_Inside
PUBLIC	?_Destroy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXPAPAX0@Z ; std::vector<void *,std::allocator<void *> >::_Destroy
PUBLIC	?_Buy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAE_NI@Z ; std::vector<void *,std::allocator<void *> >::_Buy
PUBLIC	?clear@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEXXZ ; std::vector<void *,std::allocator<void *> >::clear
PUBLIC	?empty@?$vector@PAXV?$allocator@PAX@std@@@std@@QBE_NXZ ; std::vector<void *,std::allocator<void *> >::empty
PUBLIC	?end@?$vector@PAXV?$allocator@PAX@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@2@XZ ; std::vector<void *,std::allocator<void *> >::end
PUBLIC	?begin@?$vector@PAXV?$allocator@PAX@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@2@XZ ; std::vector<void *,std::allocator<void *> >::begin
PUBLIC	?begin@?$vector@PAXV?$allocator@PAX@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@2@XZ ; std::vector<void *,std::allocator<void *> >::begin
PUBLIC	?capacity@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::capacity
PUBLIC	?Add@?$CircularList@I@@QAEIABI@Z		; CircularList<unsigned int>::Add
PUBLIC	?GetRealIndex@?$CircularList@I@@AAEII@Z		; CircularList<unsigned int>::GetRealIndex
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
PUBLIC	?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<wchar_t> >::select_on_container_copy_construction
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
PUBLIC	?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Change_alloc
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t> > >
PUBLIC	??0?$allocator@_W@std@@QAE@XZ			; std::allocator<wchar_t>::allocator<wchar_t>
PUBLIC	?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy
PUBLIC	?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
PUBLIC	?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
PUBLIC	?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?Add@?$List@E@@QAEIABE@Z			; List<unsigned char>::Add
PUBLIC	??B?$IPCArray@E@@QAEPAEXZ			; IPCArray<unsigned char>::operator unsigned char *
PUBLIC	??0?$IPCSignalledArray@E@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z ; IPCSignalledArray<unsigned char>::IPCSignalledArray<unsigned char>
PUBLIC	??C?$IPCType@Uspspps_size@@@@QAEPAUspspps_size@@XZ ; IPCType<spspps_size>::operator->
PUBLIC	??0?$IPCSignalledType@Uspspps_size@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; IPCSignalledType<spspps_size>::IPCSignalledType<spspps_size>
PUBLIC	??1?$IPCMutexLock@U?$IPCLockedSignalledArray@Uqueued_frame@@@@@@QAE@XZ ; IPCMutexLock<IPCLockedSignalledArray<queued_frame> >::~IPCMutexLock<IPCLockedSignalledArray<queued_frame> >
PUBLIC	??1?$IPCMutexLock@U?$IPCLockedSignalledArray@I@@@@QAE@XZ ; IPCMutexLock<IPCLockedSignalledArray<unsigned int> >::~IPCMutexLock<IPCLockedSignalledArray<unsigned int> >
PUBLIC	??6?$List@W4PacketType@@@@QAEAAV0@ABW4PacketType@@@Z ; List<enum PacketType>::operator<<
PUBLIC	??A?$List@UDataPacket@@@@QAEAAUDataPacket@@I@Z	; List<DataPacket>::operator[]
PUBLIC	?Clear@?$List@UDataPacket@@@@QAEXXZ		; List<DataPacket>::Clear
PUBLIC	?SetSize@?$List@UDataPacket@@@@QAEHI@Z		; List<DataPacket>::SetSize
PUBLIC	?Num@?$List@UDataPacket@@@@QBEIXZ		; List<DataPacket>::Num
PUBLIC	??A?$List@Ux264_nal_t@@@@QAEAAUx264_nal_t@@I@Z	; List<x264_nal_t>::operator[]
PUBLIC	??6?$List@Ux264_nal_t@@@@QAEAAV0@ABUx264_nal_t@@@Z ; List<x264_nal_t>::operator<<
PUBLIC	?Num@?$List@Ux264_nal_t@@@@QBEIXZ		; List<x264_nal_t>::Num
PUBLIC	??1?$List@Ux264_nal_t@@@@QAE@XZ			; List<x264_nal_t>::~List<x264_nal_t>
PUBLIC	??0?$List@Ux264_nal_t@@@@QAE@XZ			; List<x264_nal_t>::List<x264_nal_t>
PUBLIC	??1?$IPCMutexLock@U?$IPCLockedSignalledType@H@@@@QAE@XZ ; IPCMutexLock<IPCLockedSignalledType<int> >::~IPCMutexLock<IPCLockedSignalledType<int> >
PUBLIC	??C?$IPCType@Uinit_response@@@@QAEPAUinit_response@@XZ ; IPCType<init_response>::operator->
PUBLIC	??0?$IPCSignalledType@Uinit_response@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; IPCSignalledType<init_response>::IPCSignalledType<init_response>
PUBLIC	??A?$List@UVideoPacket@@@@QAEAAUVideoPacket@@I@Z ; List<VideoPacket>::operator[]
PUBLIC	?CreateNew@?$List@UVideoPacket@@@@QAEPAUVideoPacket@@XZ ; List<VideoPacket>::CreateNew
PUBLIC	?Clear@?$List@UVideoPacket@@@@QAEXXZ		; List<VideoPacket>::Clear
PUBLIC	?Num@?$List@UVideoPacket@@@@QBEIXZ		; List<VideoPacket>::Num
PUBLIC	??1?$List@UVideoPacket@@@@QAE@XZ		; List<VideoPacket>::~List<VideoPacket>
PUBLIC	??0?$List@UVideoPacket@@@@QAE@XZ		; List<VideoPacket>::List<VideoPacket>
PUBLIC	??A?$List@UmfxFrameData@@@@QAEAAUmfxFrameData@@I@Z ; List<mfxFrameData>::operator[]
PUBLIC	?SetSize@?$List@UmfxFrameData@@@@QAEHI@Z	; List<mfxFrameData>::SetSize
PUBLIC	?Num@?$List@UmfxFrameData@@@@QBEIXZ		; List<mfxFrameData>::Num
PUBLIC	??1?$List@UmfxFrameData@@@@QAE@XZ		; List<mfxFrameData>::~List<mfxFrameData>
PUBLIC	??0?$List@UmfxFrameData@@@@QAE@XZ		; List<mfxFrameData>::List<mfxFrameData>
PUBLIC	??D?$IPCType@H@@QAEAAHXZ			; IPCType<int>::operator*
PUBLIC	??0?$IPCLockedSignalledType@H@@QAE@XZ		; IPCLockedSignalledType<int>::IPCLockedSignalledType<int>
PUBLIC	??0?$IPCLockedSignalledType@H@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; IPCLockedSignalledType<int>::IPCLockedSignalledType<int>
PUBLIC	??4?$IPCLockedSignalledType@H@@QAEAAU0@$$QAU0@@Z ; IPCLockedSignalledType<int>::operator=
PUBLIC	??7?$IPCLockedSignalledType@H@@QBE_NXZ		; IPCLockedSignalledType<int>::operator!
PUBLIC	??B?$IPCArray@I@@QAEPAIXZ			; IPCArray<unsigned int>::operator unsigned int *
PUBLIC	??0?$IPCLockedSignalledArray@I@@QAE@XZ		; IPCLockedSignalledArray<unsigned int>::IPCLockedSignalledArray<unsigned int>
PUBLIC	??0?$IPCLockedSignalledArray@I@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z ; IPCLockedSignalledArray<unsigned int>::IPCLockedSignalledArray<unsigned int>
PUBLIC	??4?$IPCLockedSignalledArray@I@@QAEAAU0@$$QAU0@@Z ; IPCLockedSignalledArray<unsigned int>::operator=
PUBLIC	??7?$IPCLockedSignalledArray@I@@QAE_NXZ		; IPCLockedSignalledArray<unsigned int>::operator!
PUBLIC	??B?$IPCArray@Uqueued_frame@@@@QAEPAUqueued_frame@@XZ ; IPCArray<queued_frame>::operator queued_frame *
PUBLIC	??0?$IPCLockedSignalledArray@Uqueued_frame@@@@QAE@XZ ; IPCLockedSignalledArray<queued_frame>::IPCLockedSignalledArray<queued_frame>
PUBLIC	??0?$IPCLockedSignalledArray@Uqueued_frame@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z ; IPCLockedSignalledArray<queued_frame>::IPCLockedSignalledArray<queued_frame>
PUBLIC	??4?$IPCLockedSignalledArray@Uqueued_frame@@@@QAEAAU0@$$QAU0@@Z ; IPCLockedSignalledArray<queued_frame>::operator=
PUBLIC	??7?$IPCLockedSignalledArray@Uqueued_frame@@@@QAE_NXZ ; IPCLockedSignalledArray<queued_frame>::operator!
PUBLIC	??A?$List@Uencode_task@QSVEncoder@@@@QBEAAUencode_task@QSVEncoder@@I@Z ; List<QSVEncoder::encode_task>::operator[]
PUBLIC	??A?$List@Uencode_task@QSVEncoder@@@@QAEAAUencode_task@QSVEncoder@@I@Z ; List<QSVEncoder::encode_task>::operator[]
PUBLIC	?SetSize@?$List@Uencode_task@QSVEncoder@@@@QAEHI@Z ; List<QSVEncoder::encode_task>::SetSize
PUBLIC	?Num@?$List@Uencode_task@QSVEncoder@@@@QBEIXZ	; List<QSVEncoder::encode_task>::Num
PUBLIC	??1?$List@Uencode_task@QSVEncoder@@@@QAE@XZ	; List<QSVEncoder::encode_task>::~List<QSVEncoder::encode_task>
PUBLIC	??0?$List@Uencode_task@QSVEncoder@@@@QAE@XZ	; List<QSVEncoder::encode_task>::List<QSVEncoder::encode_task>
PUBLIC	??0?$IPCArray@Ubitstream_info@@@@QAE@XZ		; IPCArray<bitstream_info>::IPCArray<bitstream_info>
PUBLIC	??0?$IPCArray@Ubitstream_info@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z ; IPCArray<bitstream_info>::IPCArray<bitstream_info>
PUBLIC	??4?$IPCArray@Ubitstream_info@@@@QAEAAU0@$$QAU0@@Z ; IPCArray<bitstream_info>::operator=
PUBLIC	??B?$IPCArray@Ubitstream_info@@@@QAEPAUbitstream_info@@XZ ; IPCArray<bitstream_info>::operator bitstream_info *
PUBLIC	??7?$IPCArray@Ubitstream_info@@@@QBE_NXZ	; IPCArray<bitstream_info>::operator!
PUBLIC	??C?$IPCType@Uinit_request@@@@QAEPAUinit_request@@XZ ; IPCType<init_request>::operator->
PUBLIC	??0?$IPCSignalledType@Uinit_request@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; IPCSignalledType<init_request>::IPCSignalledType<init_request>
PUBLIC	??0?$IPCSignal@$00@@QAE@XZ			; IPCSignal<1>::IPCSignal<1>
PUBLIC	??0?$IPCSignal@$00@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; IPCSignal<1>::IPCSignal<1>
PUBLIC	??4?$IPCSignal@$00@@QAEAAU0@$$QAU0@@Z		; IPCSignal<1>::operator=
PUBLIC	??7?$IPCSignal@$00@@QBE_NXZ			; IPCSignal<1>::operator!
PUBLIC	?signal@?$IPCSignal@$00@@QAEXXZ			; IPCSignal<1>::signal
PUBLIC	?is_signalled@?$IPCSignal@$00@@QAE_NK@Z		; IPCSignal<1>::is_signalled
PUBLIC	?FindValueIndex@?$List@_J@@QBEIAB_J@Z		; List<__int64>::FindValueIndex
PUBLIC	??A?$List@_J@@QAEAA_JI@Z			; List<__int64>::operator[]
PUBLIC	??6?$List@_J@@QAEAAV0@AB_J@Z			; List<__int64>::operator<<
PUBLIC	?Clear@?$List@_J@@QAEXXZ			; List<__int64>::Clear
PUBLIC	?Remove@?$List@_J@@QAEXI@Z			; List<__int64>::Remove
PUBLIC	?Num@?$List@_J@@QBEIXZ				; List<__int64>::Num
PUBLIC	??1?$List@_J@@QAE@XZ				; List<__int64>::~List<__int64>
PUBLIC	??0?$List@_J@@QAE@XZ				; List<__int64>::List<__int64>
PUBLIC	?signal@?$IPCSignal@$0A@@@QAEXXZ		; IPCSignal<0>::signal
PUBLIC	?push_back@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEXABQAX@Z ; std::vector<void *,std::allocator<void *> >::push_back
PUBLIC	?front@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAPAXXZ ; std::vector<void *,std::allocator<void *> >::front
PUBLIC	??A?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAPAXI@Z ; std::vector<void *,std::allocator<void *> >::operator[]
PUBLIC	?size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::size
PUBLIC	??4?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<void *,std::allocator<void *> >::operator=
PUBLIC	??1?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@XZ ; std::vector<void *,std::allocator<void *> >::~vector<void *,std::allocator<void *> >
PUBLIC	??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@ABV01@@Z ; std::vector<void *,std::allocator<void *> >::vector<void *,std::allocator<void *> >
PUBLIC	??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@XZ ; std::vector<void *,std::allocator<void *> >::vector<void *,std::allocator<void *> >
PUBLIC	??A?$CircularList@I@@QAEAAII@Z			; CircularList<unsigned int>::operator[]
PUBLIC	??6?$CircularList@I@@QAEAAV0@ABI@Z		; CircularList<unsigned int>::operator<<
PUBLIC	?Num@?$CircularList@I@@QBEIXZ			; CircularList<unsigned int>::Num
PUBLIC	?Remove@?$CircularList@I@@QAEXI@Z		; CircularList<unsigned int>::Remove
PUBLIC	??0?$CircularList@I@@QAE@XZ			; CircularList<unsigned int>::CircularList<unsigned int>
PUBLIC	?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
PUBLIC	??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
PUBLIC	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?InsertArray@?$List@E@@QAEXIPBEI@Z		; List<unsigned char>::InsertArray
PUBLIC	?Insert@?$List@E@@QAEXIABE@Z			; List<unsigned char>::Insert
PUBLIC	?CreateQSVEncoder@@YAPAVVideoEncoder@@HHHHPB_W_NAAUColorDescription@@HH1AAVString@@@Z ; CreateQSVEncoder
PUBLIC	??1?$IPCType@H@@QAE@XZ				; IPCType<int>::~IPCType<int>
PUBLIC	??1?$IPCArray@I@@QAE@XZ				; IPCArray<unsigned int>::~IPCArray<unsigned int>
PUBLIC	??1?$IPCArray@Uqueued_frame@@@@QAE@XZ		; IPCArray<queued_frame>::~IPCArray<queued_frame>
PUBLIC	??1?$IPCArray@E@@QAE@XZ				; IPCArray<unsigned char>::~IPCArray<unsigned char>
PUBLIC	??1?$IPCType@Uspspps_size@@@@QAE@XZ		; IPCType<spspps_size>::~IPCType<spspps_size>
PUBLIC	??1?$IPCType@Uinit_response@@@@QAE@XZ		; IPCType<init_response>::~IPCType<init_response>
PUBLIC	??1?$IPCSignalledType@H@@QAE@XZ			; IPCSignalledType<int>::~IPCSignalledType<int>
PUBLIC	??1?$IPCSignalledArray@I@@QAE@XZ		; IPCSignalledArray<unsigned int>::~IPCSignalledArray<unsigned int>
PUBLIC	??1IPCMutex@@QAE@XZ				; IPCMutex::~IPCMutex
PUBLIC	??1?$IPCSignalledArray@Uqueued_frame@@@@QAE@XZ	; IPCSignalledArray<queued_frame>::~IPCSignalledArray<queued_frame>
PUBLIC	??1?$IPCSignalledArray@E@@QAE@XZ		; IPCSignalledArray<unsigned char>::~IPCSignalledArray<unsigned char>
PUBLIC	??1?$IPCSignalledType@Uspspps_size@@@@QAE@XZ	; IPCSignalledType<spspps_size>::~IPCSignalledType<spspps_size>
PUBLIC	??4IPCWaiter@@QAEAAU0@ABU0@@Z			; IPCWaiter::operator=
PUBLIC	??0IPCWaiter@@QAE@ABU0@@Z			; IPCWaiter::IPCWaiter
PUBLIC	??1?$IPCSignalledType@Uinit_response@@@@QAE@XZ	; IPCSignalledType<init_response>::~IPCSignalledType<init_response>
PUBLIC	??1DTSGenerator@?A0x7e09c670@@QAE@XZ		; `anonymous namespace'::DTSGenerator::~DTSGenerator
PUBLIC	??1?$IPCLockedSignalledType@H@@QAE@XZ		; IPCLockedSignalledType<int>::~IPCLockedSignalledType<int>
PUBLIC	??1?$IPCLockedSignalledArray@I@@QAE@XZ		; IPCLockedSignalledArray<unsigned int>::~IPCLockedSignalledArray<unsigned int>
PUBLIC	??1?$IPCLockedSignalledArray@Uqueued_frame@@@@QAE@XZ ; IPCLockedSignalledArray<queued_frame>::~IPCLockedSignalledArray<queued_frame>
PUBLIC	??1?$CircularList@I@@QAE@XZ			; CircularList<unsigned int>::~CircularList<unsigned int>
PUBLIC	??1?$IPCArray@Ubitstream_info@@@@QAE@XZ		; IPCArray<bitstream_info>::~IPCArray<bitstream_info>
PUBLIC	??1?$IPCSignal@$00@@QAE@XZ			; IPCSignal<1>::~IPCSignal<1>
PUBLIC	??0VideoEncoder@@QAE@XZ				; VideoEncoder::VideoEncoder
PUBLIC	??_GQSVEncoder@@UAEPAXI@Z			; QSVEncoder::`scalar deleting destructor'
PUBLIC	?HasBufferedFrames@QSVEncoder@@UAE_NXZ		; QSVEncoder::HasBufferedFrames
PUBLIC	?isQSV@QSVEncoder@@UAE_NXZ			; QSVEncoder::isQSV
PUBLIC	?RequestKeyframe@QSVEncoder@@UAEXXZ		; QSVEncoder::RequestKeyframe
PUBLIC	?SetBitRate@QSVEncoder@@UAE_NKK@Z		; QSVEncoder::SetBitRate
PUBLIC	?DynamicBitrateSupported@QSVEncoder@@UBE_NXZ	; QSVEncoder::DynamicBitrateSupported
PUBLIC	?GetInfoString@QSVEncoder@@UBE?AVString@@XZ	; QSVEncoder::GetInfoString
PUBLIC	?GetBitRate@QSVEncoder@@UBEHXZ			; QSVEncoder::GetBitRate
PUBLIC	?GetSEI@QSVEncoder@@UAEXAAUDataPacket@@@Z	; QSVEncoder::GetSEI
PUBLIC	?GetHeaders@QSVEncoder@@UAEXAAUDataPacket@@@Z	; QSVEncoder::GetHeaders
PUBLIC	?Encode@QSVEncoder@@UAE_NPAXAAV?$List@UDataPacket@@@@AAV?$List@W4PacketType@@@@KAAK@Z ; QSVEncoder::Encode
PUBLIC	?QueueEncodeTask@QSVEncoder@@QAEXPAUmfxFrameSurface1@@K@Z ; QSVEncoder::QueueEncodeTask
PUBLIC	?RequestBuffers@QSVEncoder@@UAEXPAX@Z		; QSVEncoder::RequestBuffers
PUBLIC	?ProcessEncodedFrame@QSVEncoder@@QAEXAAV?$List@UDataPacket@@@@AAV?$List@W4PacketType@@@@KAAKI@Z ; QSVEncoder::ProcessEncodedFrame
PUBLIC	??1QSVEncoder@@UAE@XZ				; QSVEncoder::~QSVEncoder
PUBLIC	??0QSVEncoder@@QAE@HHHHPB_W_NAAUColorDescription@@HH1@Z ; QSVEncoder::QSVEncoder
PUBLIC	?ClearPackets@QSVEncoder@@AAEXXZ		; QSVEncoder::ClearPackets
PUBLIC	?FreeData@VideoPacket@@QAEXXZ			; VideoPacket::FreeData
PUBLIC	?QSVMethodAvailable@@YA_NG@Z			; QSVMethodAvailable
PUBLIC	?IsKnownQSVCPUPlatform@@YA_NXZ			; IsKnownQSVCPUPlatform
PUBLIC	??1?$IPCSignal@$0A@@@QAE@XZ			; IPCSignal<0>::~IPCSignal<0>
PUBLIC	??1?$IPCType@Uinit_request@@@@QAE@XZ		; IPCType<init_request>::~IPCType<init_request>
PUBLIC	??1?$IPCSignalledType@Uinit_request@@@@QAE@XZ	; IPCSignalledType<init_request>::~IPCSignalledType<init_request>
PUBLIC	??1IPCWaiter@@QAE@XZ				; IPCWaiter::~IPCWaiter
PUBLIC	??0IPCWaiter@@QAE@XZ				; IPCWaiter::IPCWaiter
PUBLIC	?CheckQSVHardwareSupport@@YA_N_NPA_N@Z		; CheckQSVHardwareSupport
PUBLIC	?StopHelper@?A0x7e09c670@@YAXAAU?$IPCSignal@$00@@AAUIPCWaiter@@AAUsafe_handle@@@Z ; `anonymous namespace'::StopHelper
PUBLIC	??RDTSGenerator@?A0x7e09c670@@QAE_J_K_J@Z	; `anonymous namespace'::DTSGenerator::operator()
PUBLIC	?add@DTSGenerator@?A0x7e09c670@@QAEX_K@Z	; `anonymous namespace'::DTSGenerator::add
PUBLIC	?Init@DTSGenerator@?A0x7e09c670@@QAEXIAATmfxVersion@@_N_K@Z ; `anonymous namespace'::DTSGenerator::Init
PUBLIC	??0DTSGenerator@?A0x7e09c670@@QAE@XZ		; `anonymous namespace'::DTSGenerator::DTSGenerator
PUBLIC	?qsv_get_cpu_platform@?A0x7e09c670@@YA?AW4qsv_cpu_platform@1@XZ ; `anonymous namespace'::qsv_get_cpu_platform
PUBLIC	?spawn_helper@?A0x7e09c670@@YA_NAAVString@@AAUsafe_handle@@1AAUIPCWaiter@@@Z ; `anonymous namespace'::spawn_helper
PUBLIC	?qsv_profile_str@?A0x7e09c670@@YAPB_WG@Z	; `anonymous namespace'::qsv_profile_str
PUBLIC	?qsv_intf_str@?A0x7e09c670@@YAPB_WI@Z		; `anonymous namespace'::qsv_intf_str
PUBLIC	??0IPCMutex@@QAE@XZ				; IPCMutex::IPCMutex
PUBLIC	??0IPCMutex@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; IPCMutex::IPCMutex
PUBLIC	?unlock@IPCMutex@@QAEXXZ			; IPCMutex::unlock
PUBLIC	?lock@IPCMutex@@QAEXXZ				; IPCMutex::lock
PUBLIC	?wait_for_multiple_objects@IPCWaiter@@AAEKK@Z	; IPCWaiter::wait_for_multiple_objects
PUBLIC	?wait_timeout@IPCWaiter@@QAE_NK@Z		; IPCWaiter::wait_timeout
PUBLIC	?wait_for_two@IPCWaiter@@QAE_NKKK@Z		; IPCWaiter::wait_for_two
PUBLIC	?wait_for@IPCWaiter@@QAE_NKK@Z			; IPCWaiter::wait_for
PUBLIC	?wait@IPCWaiter@@QAE_NK@Z			; IPCWaiter::wait
PUBLIC	?push_back@IPCWaiter@@QAEXABQAX@Z		; IPCWaiter::push_back
PUBLIC	?InitMemory@NamedSharedMemory@@AAEXXZ		; NamedSharedMemory::InitMemory
PUBLIC	?FreeMemory@NamedSharedMemory@@AAEXXZ		; NamedSharedMemory::FreeMemory
PUBLIC	??0NamedSharedMemory@@QAE@XZ			; NamedSharedMemory::NamedSharedMemory
PUBLIC	??0NamedSharedMemory@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_K@Z ; NamedSharedMemory::NamedSharedMemory
PUBLIC	??1NamedSharedMemory@@QAE@XZ			; NamedSharedMemory::~NamedSharedMemory
PUBLIC	??4NamedSharedMemory@@QAEAAU0@$$QAU0@@Z		; NamedSharedMemory::operator=
PUBLIC	??INamedSharedMemory@@QAEPAXXZ			; NamedSharedMemory::operator&
PUBLIC	??7NamedSharedMemory@@QBE_NXZ			; NamedSharedMemory::operator!
PUBLIC	??1safe_handle@@QAE@XZ				; safe_handle::~safe_handle
PUBLIC	??0safe_handle@@QAE@PAX@Z			; safe_handle::safe_handle
PUBLIC	??4safe_handle@@QAEAAU0@$$QAU0@@Z		; safe_handle::operator=
PUBLIC	??7safe_handle@@QBE_NXZ				; safe_handle::operator!
PUBLIC	?reset@safe_handle@@QAEXPAX@Z			; safe_handle::reset
PUBLIC	??Bsafe_handle@@QAEPAXXZ			; safe_handle::operator void *
PUBLIC	??_GVideoEncoder@@UAEPAXI@Z			; VideoEncoder::`scalar deleting destructor'
PUBLIC	?HasBufferedFrames@VideoEncoder@@UAE_NXZ	; VideoEncoder::HasBufferedFrames
PUBLIC	?GetBufferedFrames@VideoEncoder@@UAEHXZ		; VideoEncoder::GetBufferedFrames
PUBLIC	?isQSV@VideoEncoder@@UAE_NXZ			; VideoEncoder::isQSV
PUBLIC	?RequestKeyframe@VideoEncoder@@UAEXXZ		; VideoEncoder::RequestKeyframe
PUBLIC	?GetSEI@VideoEncoder@@UAEXAAUDataPacket@@@Z	; VideoEncoder::GetSEI
PUBLIC	??1VideoEncoder@@UAE@XZ				; VideoEncoder::~VideoEncoder
PUBLIC	?RequestBuffers@VideoEncoder@@MAEXPAX@Z		; VideoEncoder::RequestBuffers
PUBLIC	?compare@?$char_traits@D@std@@SAHPBD0I@Z	; std::char_traits<char>::compare
PUBLIC	?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z	; std::char_traits<wchar_t>::assign
PUBLIC	?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z	; std::char_traits<wchar_t>::move
PUBLIC	?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z	; std::char_traits<wchar_t>::copy
PUBLIC	?length@?$char_traits@_W@std@@SAIPB_W@Z		; std::char_traits<wchar_t>::length
PUBLIC	?max@?$numeric_limits@G@std@@SAGXZ		; std::numeric_limits<unsigned short>::max
PUBLIC	?min@?$numeric_limits@G@std@@SAGXZ		; std::numeric_limits<unsigned short>::min
PUBLIC	_wmemmove
PUBLIC	_wmemcpy
PUBLIC	?mcpyrev@@YGXPAXPBXI@Z				; mcpyrev
EXTRN	??_EVideoEncoder@@UAEPAXI@Z:PROC		; VideoEncoder::`vector deleting destructor'
EXTRN	??_EQSVEncoder@@UAEPAXI@Z:PROC			; QSVEncoder::`vector deleting destructor'
;	COMDAT ?plat@?1??IsKnownQSVCPUPlatform@@YA_NXZ@4W4qsv_cpu_platform@?A0x7e09c670@@A
_BSS	SEGMENT
?plat@?1??IsKnownQSVCPUPlatform@@YA_NXZ@4W4qsv_cpu_platform@?A0x7e09c670@@A DD 01H DUP (?) ; `IsKnownQSVCPUPlatform'::`2'::plat
_BSS	ENDS
;	COMDAT ?plat@?1??QSVMethodAvailable@@YA_NG@Z@4W4qsv_cpu_platform@?A0x7e09c670@@A
_BSS	SEGMENT
?plat@?1??QSVMethodAvailable@@YA_NG@Z@4W4qsv_cpu_platform@?A0x7e09c670@@A DD 01H DUP (?) ; `QSVMethodAvailable'::`2'::plat
	ALIGN	4

__Tuple_alloc DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?$S2@?1??QSVMethodAvailable@@YA_NG@Z@4IA
_BSS	SEGMENT
?$S2@?1??QSVMethodAvailable@@YA_NG@Z@4IA DD 01H DUP (?)	; S2<`template-parameter-2',bool [ ?? ],unsigned short>
	ALIGN	4

_ignore	DB	01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?$S1@?1??IsKnownQSVCPUPlatform@@YA_NXZ@4IA
_BSS	SEGMENT
?$S1@?1??IsKnownQSVCPUPlatform@@YA_NXZ@4IA DD 01H DUP (?) ; S1<`template-parameter-2',KnownQSVCPUPlatform,unsigned int, ?? &>
	ALIGN	4

_piecewise_construct DB 01H DUP (?)
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?CreateQSVEncoder@@YAPAVVideoEncoder@@HHHHPB_W_NAAUColorDescription@@HH1AAVString@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?CreateQSVEncoder@@YAPAVVideoEncoder@@HHHHPB_W_NAAUColorDescription@@HH1AAVString@@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?CreateQSVEncoder@@YAPAVVideoEncoder@@HHHHPB_W_NAAUColorDescription@@HH1AAVString@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?CreateQSVEncoder@@YAPAVVideoEncoder@@HHHHPB_W_NAAUColorDescription@@HH1AAVString@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?CreateQSVEncoder@@YAPAVVideoEncoder@@HHHHPB_W_NAAUColorDescription@@HH1AAVString@@@Z DD 00H
	DD	00H
	DD	01H
	DD	02H
	DD	FLAT:__catchsym$?CreateQSVEncoder@@YAPAVVideoEncoder@@HHHHPB_W_NAAUColorDescription@@HH1AAVString@@@Z$3
__catchsym$?CreateQSVEncoder@@YAPAVVideoEncoder@@HHHHPB_W_NAAUColorDescription@@HH1AAVString@@@Z$3 DD 01H
	DD	FLAT:??_R0PA_W@8
	DD	0ffffffdcH
	DD	FLAT:__catch$?CreateQSVEncoder@@YAPAVVideoEncoder@@HHHHPB_W_NAAUColorDescription@@HH1AAVString@@@Z$0
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?CreateQSVEncoder@@YAPAVVideoEncoder@@HHHHPB_W_NAAUColorDescription@@HH1AAVString@@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@ABV01@@Z$2
__catchsym$??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@ABV01@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@ABV01@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??4?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAV01@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??4?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAV01@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??4?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAV01@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??4?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAV01@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??4?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAV01@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??4?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAV01@ABV01@@Z$2
__catchsym$??4?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAV01@ABV01@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??4?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAV01@ABV01@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Reallocate@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?_Reallocate@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXI@Z$2
__catchsym$?_Reallocate@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXI@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXI@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$5
__catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1
__catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
_ignore$initializer$ DD FLAT:??__Eignore@std@@YAXXZ
__Tuple_alloc$initializer$ DD FLAT:??__E_Tuple_alloc@std@@YAXXZ
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\inline.h
;	COMDAT ?mcpyrev@@YGXPAXPBXI@Z
_TEXT	SEGMENT
tv75 = -32						; size = 4
tv70 = -28						; size = 4
_iLenMod4$ = -24					; size = 4
_iLenDiv4$ = -20					; size = 4
_destDW$ = -16						; size = 4
_srcDW$ = -12						; size = 4
_srcB$ = -8						; size = 4
_destB$ = -4						; size = 4
_pDest$ = 8						; size = 4
_pSrc$ = 12						; size = 4
_iLen$ = 16						; size = 4
?mcpyrev@@YGXPAXPBXI@Z PROC				; mcpyrev, COMDAT

; 283  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 284  :     assert(pDest);
; 285  :     assert(pSrc);
; 286  : 
; 287  :     register size_t iLenMod4 = iLen&3;

	mov	eax, DWORD PTR _iLen$[ebp]
	and	eax, 3
	mov	DWORD PTR _iLenMod4$[ebp], eax

; 288  :     register size_t iLenDiv4 = iLen>>2;

	mov	ecx, DWORD PTR _iLen$[ebp]
	shr	ecx, 2
	mov	DWORD PTR _iLenDiv4$[ebp], ecx

; 289  : 
; 290  :     register BYTE *srcB = (BYTE*)pSrc, *destB = (BYTE*)pDest;

	mov	edx, DWORD PTR _pSrc$[ebp]
	mov	DWORD PTR _srcB$[ebp], edx
	mov	eax, DWORD PTR _pDest$[ebp]
	mov	DWORD PTR _destB$[ebp], eax

; 291  :     register DWORD *srcDW = (DWORD*)(srcB+iLen), *destDW = (DWORD*)(destB+iLen);

	mov	ecx, DWORD PTR _srcB$[ebp]
	add	ecx, DWORD PTR _iLen$[ebp]
	mov	DWORD PTR _srcDW$[ebp], ecx
	mov	edx, DWORD PTR _destB$[ebp]
	add	edx, DWORD PTR _iLen$[ebp]
	mov	DWORD PTR _destDW$[ebp], edx
$LN4@mcpyrev:

; 292  :     while(iLenDiv4--)

	mov	eax, DWORD PTR _iLenDiv4$[ebp]
	mov	DWORD PTR tv70[ebp], eax
	mov	ecx, DWORD PTR _iLenDiv4$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _iLenDiv4$[ebp], ecx
	cmp	DWORD PTR tv70[ebp], 0
	je	SHORT $LN3@mcpyrev

; 293  :         *(--destDW) = *(--srcDW);

	mov	edx, DWORD PTR _srcDW$[ebp]
	sub	edx, 4
	mov	DWORD PTR _srcDW$[ebp], edx
	mov	eax, DWORD PTR _destDW$[ebp]
	sub	eax, 4
	mov	DWORD PTR _destDW$[ebp], eax
	mov	ecx, DWORD PTR _destDW$[ebp]
	mov	edx, DWORD PTR _srcDW$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN4@mcpyrev
$LN3@mcpyrev:

; 294  : 
; 295  :     srcB = (BYTE*)srcDW;

	mov	ecx, DWORD PTR _srcDW$[ebp]
	mov	DWORD PTR _srcB$[ebp], ecx

; 296  :     destB = (BYTE*)destDW;

	mov	edx, DWORD PTR _destDW$[ebp]
	mov	DWORD PTR _destB$[ebp], edx
$LN2@mcpyrev:

; 297  :     while(iLenMod4--)

	mov	eax, DWORD PTR _iLenMod4$[ebp]
	mov	DWORD PTR tv75[ebp], eax
	mov	ecx, DWORD PTR _iLenMod4$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _iLenMod4$[ebp], ecx
	cmp	DWORD PTR tv75[ebp], 0
	je	SHORT $LN5@mcpyrev

; 298  :         *(--destB) = *(--srcB);

	mov	edx, DWORD PTR _srcB$[ebp]
	sub	edx, 1
	mov	DWORD PTR _srcB$[ebp], edx
	mov	eax, DWORD PTR _destB$[ebp]
	sub	eax, 1
	mov	DWORD PTR _destB$[ebp], eax
	mov	ecx, DWORD PTR _destB$[ebp]
	mov	edx, DWORD PTR _srcB$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	jmp	SHORT $LN2@mcpyrev
$LN5@mcpyrev:

; 299  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?mcpyrev@@YGXPAXPBXI@Z ENDP				; mcpyrev
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\wchar.h
;	COMDAT _wmemcpy
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__S2$ = 12						; size = 4
__N$ = 16						; size = 4
_wmemcpy PROC						; COMDAT

; 1271 :         {

	push	ebp
	mov	ebp, esp

; 1272 : #pragma warning( push )
; 1273 : #pragma warning( disable : 4996 6386 )
; 1274 :             return (wchar_t *)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	mov	eax, DWORD PTR __N$[ebp]
	shl	eax, 1
	push	eax
	mov	ecx, DWORD PTR __S2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __S1$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1275 : #pragma warning( pop )
; 1276 :         }

	pop	ebp
	ret	0
_wmemcpy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\wchar.h
;	COMDAT _wmemmove
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__S2$ = 12						; size = 4
__N$ = 16						; size = 4
_wmemmove PROC						; COMDAT

; 1279 :         {

	push	ebp
	mov	ebp, esp

; 1280 : #pragma warning( push )
; 1281 : #pragma warning( disable : 4996 6386 )
; 1282 : #pragma warning( disable : 6387)
; 1283 :                         /* prefast noise VSW 493303 */
; 1284 :             return (wchar_t *)memmove(_S1, _S2, _N*sizeof(wchar_t));

	mov	eax, DWORD PTR __N$[ebp]
	shl	eax, 1
	push	eax
	mov	ecx, DWORD PTR __S2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __S1$[ebp]
	push	edx
	call	_memmove
	add	esp, 12					; 0000000cH

; 1285 : #pragma warning( pop )
; 1286 :         }

	pop	ebp
	ret	0
_wmemmove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\limits
;	COMDAT ?min@?$numeric_limits@G@std@@SAGXZ
_TEXT	SEGMENT
?min@?$numeric_limits@G@std@@SAGXZ PROC			; std::numeric_limits<unsigned short>::min, COMDAT

; 536  : 	static _Ty (min)() _THROW0()

	push	ebp
	mov	ebp, esp

; 537  : 		{	// return minimum value
; 538  : 		return (0);

	xor	eax, eax

; 539  : 		}

	pop	ebp
	ret	0
?min@?$numeric_limits@G@std@@SAGXZ ENDP			; std::numeric_limits<unsigned short>::min
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\limits
;	COMDAT ?max@?$numeric_limits@G@std@@SAGXZ
_TEXT	SEGMENT
?max@?$numeric_limits@G@std@@SAGXZ PROC			; std::numeric_limits<unsigned short>::max, COMDAT

; 541  : 	static _Ty (max)() _THROW0()

	push	ebp
	mov	ebp, esp

; 542  : 		{	// return maximum value
; 543  : 		return (USHRT_MAX);

	mov	eax, 65535				; 0000ffffH

; 544  : 		}

	pop	ebp
	ret	0
?max@?$numeric_limits@G@std@@SAGXZ ENDP			; std::numeric_limits<unsigned short>::max
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@_W@std@@SAIPB_W@Z
_TEXT	SEGMENT
tv68 = -20						; size = 4
tv75 = -16						; size = 4
tv69 = -12						; size = 4
tv72 = -8						; size = 4
tv78 = -2						; size = 2
__First$ = 8						; size = 4
?length@?$char_traits@_W@std@@SAIPB_W@Z PROC		; std::char_traits<wchar_t>::length, COMDAT

; 304  : 		{	// find length of null-terminated sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 305  : 		return (*_First == 0 ? 0
; 306  : 			: _CSTD wcslen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movzx	ecx, WORD PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv69[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR tv72[ebp], edx
	mov	eax, DWORD PTR tv72[ebp]
	add	eax, 2
	mov	DWORD PTR tv75[ebp], eax
$LL5@length:
	mov	ecx, DWORD PTR tv72[ebp]
	mov	dx, WORD PTR [ecx]
	mov	WORD PTR tv78[ebp], dx
	add	DWORD PTR tv72[ebp], 2
	cmp	WORD PTR tv78[ebp], 0
	jne	SHORT $LL5@length
	mov	eax, DWORD PTR tv72[ebp]
	sub	eax, DWORD PTR tv75[ebp]
	sar	eax, 1
	mov	DWORD PTR tv68[ebp], eax
	mov	ecx, DWORD PTR tv68[ebp]
	mov	DWORD PTR tv69[ebp], ecx
$LN4@length:
	mov	eax, DWORD PTR tv69[ebp]

; 307  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@_W@std@@SAIPB_W@Z ENDP		; std::char_traits<wchar_t>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z PROC	; std::char_traits<wchar_t>::copy, COMDAT

; 311  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 312  : 		return (_Count == 0 ? _First1
; 313  : 			: (_Elem *)_CSTD wmemcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_wmemcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 314  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ENDP	; std::char_traits<wchar_t>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z PROC	; std::char_traits<wchar_t>::move, COMDAT

; 334  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 335  : 		return (_Count == 0 ? _First1
; 336  : 			: (_Elem *)_CSTD wmemmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_wmemmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 337  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ENDP	; std::char_traits<wchar_t>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z PROC	; std::char_traits<wchar_t>::assign, COMDAT

; 346  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 347  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dx, WORD PTR [ecx]
	mov	WORD PTR [eax], dx

; 348  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z ENDP	; std::char_traits<wchar_t>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\iosfwd
;	COMDAT ?compare@?$char_traits@D@std@@SAHPBD0I@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
tv70 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?compare@?$char_traits@D@std@@SAHPBD0I@Z PROC		; std::char_traits<char>::compare, COMDAT

; 515  : 		{	// compare [_First1, _First1 + _Count) with [_First2, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 516  : 		return (_Count == 0 ? 0
; 517  : 			: _CSTD memcmp(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@compare
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@compare
$LN3@compare:
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	call	_memcmp
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
	mov	eax, DWORD PTR tv69[ebp]
	mov	DWORD PTR tv70[ebp], eax
$LN4@compare:
	mov	eax, DWORD PTR tv70[ebp]

; 518  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?compare@?$char_traits@D@std@@SAHPBD0I@Z ENDP		; std::char_traits<char>::compare
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 70   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3451 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\tuple
;	COMDAT ??__Eignore@std@@YAXXZ
text$di	SEGMENT
??__Eignore@std@@YAXXZ PROC				; std::`dynamic initializer for 'ignore'', COMDAT

; 59   : const _Ignore ignore;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET _ignore
	call	??0_Ignore@std@@QAE@XZ			; std::_Ignore::_Ignore
	pop	ebp
	ret	0
??__Eignore@std@@YAXXZ ENDP				; std::`dynamic initializer for 'ignore''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\tuple
;	COMDAT ??__E_Tuple_alloc@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__E_Tuple_alloc@std@@YAXXZ PROC			; std::`dynamic initializer for '_Tuple_alloc'', COMDAT

; 66   : const _Tuple_alloc_t _Tuple_alloc = _Tuple_alloc_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__E_Tuple_alloc@std@@YAXXZ ENDP			; std::`dynamic initializer for '_Tuple_alloc''
text$di	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ?RequestBuffers@VideoEncoder@@MAEXPAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_buffers$ = 8						; size = 4
?RequestBuffers@VideoEncoder@@MAEXPAX@Z PROC		; VideoEncoder::RequestBuffers, COMDAT
; _this$ = ecx

; 182  :     virtual void RequestBuffers(LPVOID buffers) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?RequestBuffers@VideoEncoder@@MAEXPAX@Z ENDP		; VideoEncoder::RequestBuffers
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ??1VideoEncoder@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1VideoEncoder@@UAE@XZ PROC				; VideoEncoder::~VideoEncoder, COMDAT
; _this$ = ecx

; 185  :     virtual ~VideoEncoder() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7VideoEncoder@@6B@
	mov	esp, ebp
	pop	ebp
	ret	0
??1VideoEncoder@@UAE@XZ ENDP				; VideoEncoder::~VideoEncoder
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ?GetSEI@VideoEncoder@@UAEXAAUDataPacket@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_packet$ = 8						; size = 4
?GetSEI@VideoEncoder@@UAEXAAUDataPacket@@@Z PROC	; VideoEncoder::GetSEI, COMDAT
; _this$ = ecx

; 192  :     virtual void GetSEI(DataPacket &packet) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetSEI@VideoEncoder@@UAEXAAUDataPacket@@@Z ENDP	; VideoEncoder::GetSEI
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ?RequestKeyframe@VideoEncoder@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RequestKeyframe@VideoEncoder@@UAEXXZ PROC		; VideoEncoder::RequestKeyframe, COMDAT
; _this$ = ecx

; 194  :     virtual void RequestKeyframe() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?RequestKeyframe@VideoEncoder@@UAEXXZ ENDP		; VideoEncoder::RequestKeyframe
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ?isQSV@VideoEncoder@@UAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isQSV@VideoEncoder@@UAE_NXZ PROC			; VideoEncoder::isQSV, COMDAT
; _this$ = ecx

; 198  :     virtual bool isQSV() { return false; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	al, al
	mov	esp, ebp
	pop	ebp
	ret	0
?isQSV@VideoEncoder@@UAE_NXZ ENDP			; VideoEncoder::isQSV
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ?GetBufferedFrames@VideoEncoder@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBufferedFrames@VideoEncoder@@UAEHXZ PROC		; VideoEncoder::GetBufferedFrames, COMDAT
; _this$ = ecx

; 200  :     virtual int GetBufferedFrames() { if(HasBufferedFrames()) return -1; return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+48]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@GetBuffere
	or	eax, -1
	jmp	SHORT $LN2@GetBuffere
$LN1@GetBuffere:
	xor	eax, eax
$LN2@GetBuffere:
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBufferedFrames@VideoEncoder@@UAEHXZ ENDP		; VideoEncoder::GetBufferedFrames
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ?HasBufferedFrames@VideoEncoder@@UAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?HasBufferedFrames@VideoEncoder@@UAE_NXZ PROC		; VideoEncoder::HasBufferedFrames, COMDAT
; _this$ = ecx

; 201  :     virtual bool HasBufferedFrames() { return false; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	al, al
	mov	esp, ebp
	pop	ebp
	ret	0
?HasBufferedFrames@VideoEncoder@@UAE_NXZ ENDP		; VideoEncoder::HasBufferedFrames
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GVideoEncoder@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GVideoEncoder@@UAEPAXI@Z PROC			; VideoEncoder::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1VideoEncoder@@UAE@XZ			; VideoEncoder::~VideoEncoder
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GVideoEncoder@@UAEPAXI@Z ENDP			; VideoEncoder::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??Bsafe_handle@@QAEPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Bsafe_handle@@QAEPAXXZ PROC				; safe_handle::operator void *, COMDAT
; _this$ = ecx

; 36   :     operator HANDLE() { return h; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	esp, ebp
	pop	ebp
	ret	0
??Bsafe_handle@@QAEPAXXZ ENDP				; safe_handle::operator void *
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ?reset@safe_handle@@QAEXPAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_h_$ = 8						; size = 4
?reset@safe_handle@@QAEXPAX@Z PROC			; safe_handle::reset, COMDAT
; _this$ = ecx

; 38   :     void reset(HANDLE h_=nullptr) { if(h) CloseHandle(h); h = h_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@reset
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR __imp__CloseHandle@4
$LN1@reset:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _h_$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?reset@safe_handle@@QAEXPAX@Z ENDP			; safe_handle::reset
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??7safe_handle@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
??7safe_handle@@QBE_NXZ PROC				; safe_handle::operator!, COMDAT
; _this$ = ecx

; 40   :     bool operator!() const { return !h; }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv66[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv66[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??7safe_handle@@QBE_NXZ ENDP				; safe_handle::operator!
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??4safe_handle@@QAEAAU0@$$QAU0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
??4safe_handle@@QAEAAU0@$$QAU0@@Z PROC			; safe_handle::operator=, COMDAT
; _this$ = ecx

; 42   :     safe_handle &operator=(safe_handle &&other) { reset(other.h); other.h = nullptr; return *this; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _other$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?reset@safe_handle@@QAEXPAX@Z		; safe_handle::reset
	mov	edx, DWORD PTR _other$[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4safe_handle@@QAEAAU0@$$QAU0@@Z ENDP			; safe_handle::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??0safe_handle@@QAE@PAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_h$ = 8							; size = 4
??0safe_handle@@QAE@PAX@Z PROC				; safe_handle::safe_handle, COMDAT
; _this$ = ecx

; 44   :     safe_handle(HANDLE h=nullptr) : h(h) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _h$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0safe_handle@@QAE@PAX@Z ENDP				; safe_handle::safe_handle
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??1safe_handle@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1safe_handle@@QAE@XZ PROC				; safe_handle::~safe_handle, COMDAT
; _this$ = ecx

; 45   :     ~safe_handle() { if(h) CloseHandle(h); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@safe_handl
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR __imp__CloseHandle@4
$LN2@safe_handl:
	mov	esp, ebp
	pop	ebp
	ret	0
??1safe_handle@@QAE@XZ ENDP				; safe_handle::~safe_handle
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??7NamedSharedMemory@@QBE_NXZ
_TEXT	SEGMENT
tv71 = -8						; size = 4
_this$ = -4						; size = 4
??7NamedSharedMemory@@QBE_NXZ PROC			; NamedSharedMemory::operator!, COMDAT
; _this$ = ecx

; 58   :     bool operator!() const { return !memory || !file; }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??7safe_handle@@QBE_NXZ			; safe_handle::operator!
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv71[ebp], 0
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv71[ebp], 1
$LN4@operator:
	mov	al, BYTE PTR tv71[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??7NamedSharedMemory@@QBE_NXZ ENDP			; NamedSharedMemory::operator!
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??INamedSharedMemory@@QAEPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??INamedSharedMemory@@QAEPAXXZ PROC			; NamedSharedMemory::operator&, COMDAT
; _this$ = ecx

; 59   :     void *operator&() { return memory; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+32]
	mov	esp, ebp
	pop	ebp
	ret	0
??INamedSharedMemory@@QAEPAXXZ ENDP			; NamedSharedMemory::operator&
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??4NamedSharedMemory@@QAEAAU0@$$QAU0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
??4NamedSharedMemory@@QAEAAU0@$$QAU0@@Z PROC		; NamedSharedMemory::operator=, COMDAT
; _this$ = ecx

; 65   :     { FreeMemory(); name = other.name; size = other.size; memory = other.memory; other.memory = nullptr; file = std::move(other.file); return *this; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeMemory@NamedSharedMemory@@AAEXXZ	; NamedSharedMemory::FreeMemory
	mov	eax, DWORD PTR _other$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _other$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+24], eax
	mov	edx, DWORD PTR [edx+28]
	mov	DWORD PTR [ecx+28], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _other$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+32], edx
	mov	eax, DWORD PTR _other$[ebp]
	mov	DWORD PTR [eax+32], 0
	mov	ecx, DWORD PTR _other$[ebp]
	add	ecx, 36					; 00000024H
	push	ecx
	call	??$move@AAUsafe_handle@@@std@@YA$$QAUsafe_handle@@AAU1@@Z ; std::move<safe_handle &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??4safe_handle@@QAEAAU0@$$QAU0@@Z	; safe_handle::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4NamedSharedMemory@@QAEAAU0@$$QAU0@@Z ENDP		; NamedSharedMemory::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??1NamedSharedMemory@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1NamedSharedMemory@@QAE@XZ PROC			; NamedSharedMemory::~NamedSharedMemory, COMDAT
; _this$ = ecx

; 70   :     ~NamedSharedMemory() { FreeMemory(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeMemory@NamedSharedMemory@@AAEXXZ	; NamedSharedMemory::FreeMemory
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??1safe_handle@@QAE@XZ			; safe_handle::~safe_handle
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	esp, ebp
	pop	ebp
	ret	0
??1NamedSharedMemory@@QAE@XZ ENDP			; NamedSharedMemory::~NamedSharedMemory
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??0NamedSharedMemory@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_K@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_name$ = 8						; size = 24
_size$ = 32						; size = 8
??0NamedSharedMemory@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_K@Z PROC ; NamedSharedMemory::NamedSharedMemory, COMDAT
; _this$ = ecx

; 71   :     NamedSharedMemory(std::wstring name, uint64_t size=1) : name(name), size(size), memory(nullptr) { InitMemory(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [ecx+24], edx
	mov	eax, DWORD PTR _size$[ebp+4]
	mov	DWORD PTR [ecx+28], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32], 0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0safe_handle@@QAE@PAX@Z		; safe_handle::safe_handle
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitMemory@NamedSharedMemory@@AAEXXZ	; NamedSharedMemory::InitMemory
	lea	ecx, DWORD PTR _name$[ebp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
??0NamedSharedMemory@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_K@Z ENDP ; NamedSharedMemory::NamedSharedMemory
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??0NamedSharedMemory@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0NamedSharedMemory@@QAE@XZ PROC			; NamedSharedMemory::NamedSharedMemory, COMDAT
; _this$ = ecx

; 72   :     NamedSharedMemory() : memory(nullptr) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32], 0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0safe_handle@@QAE@PAX@Z		; safe_handle::safe_handle
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0NamedSharedMemory@@QAE@XZ ENDP			; NamedSharedMemory::NamedSharedMemory
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ?FreeMemory@NamedSharedMemory@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?FreeMemory@NamedSharedMemory@@AAEXXZ PROC		; NamedSharedMemory::FreeMemory, COMDAT
; _this$ = ecx

; 75   :     void FreeMemory() { if(memory) UnmapViewOfFile(memory); memory = nullptr; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN1@FreeMemory
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	DWORD PTR __imp__UnmapViewOfFile@4
$LN1@FreeMemory:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32], 0
	mov	esp, ebp
	pop	ebp
	ret	0
?FreeMemory@NamedSharedMemory@@AAEXXZ ENDP		; NamedSharedMemory::FreeMemory
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ?InitMemory@NamedSharedMemory@@AAEXXZ
_TEXT	SEGMENT
tv133 = -8						; size = 4
_this$ = -4						; size = 4
?InitMemory@NamedSharedMemory@@AAEXXZ PROC		; NamedSharedMemory::InitMemory, COMDAT
; _this$ = ecx

; 77   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 78   :         if(!size)

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv133[ebp], eax
	mov	ecx, DWORD PTR tv133[ebp]
	mov	edx, DWORD PTR tv133[ebp]
	mov	eax, DWORD PTR [ecx+24]
	or	eax, DWORD PTR [edx+28]
	jne	SHORT $LN2@InitMemory

; 79   :             size = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 1
	mov	DWORD PTR [ecx+28], 0
$LN2@InitMemory:

; 80   :         file.reset(CreateFileMapping(INVALID_HANDLE_VALUE, nullptr, PAGE_READWRITE, size>>32, size & 0xffffffff, name.c_str()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR [edx+28]
	and	ecx, 0
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	edx, DWORD PTR [edx+28]
	mov	cl, 32					; 00000020H
	call	__aullshr
	push	eax
	push	4
	push	0
	push	-1
	call	DWORD PTR __imp__CreateFileMappingW@24
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?reset@safe_handle@@QAEXPAX@Z		; safe_handle::reset

; 81   :         if(file)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??Bsafe_handle@@QAEPAXXZ		; safe_handle::operator void *
	test	eax, eax
	je	SHORT $LN3@InitMemory

; 82   :             memory = MapViewOfFile(file, FILE_MAP_ALL_ACCESS, 0, 0, 0);

	push	0
	push	0
	push	0
	push	983071					; 000f001fH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??Bsafe_handle@@QAEPAXXZ		; safe_handle::operator void *
	push	eax
	call	DWORD PTR __imp__MapViewOfFile@20
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32], eax
$LN3@InitMemory:

; 83   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?InitMemory@NamedSharedMemory@@AAEXXZ ENDP		; NamedSharedMemory::InitMemory
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ?push_back@IPCWaiter@@QAEXABQAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_h$ = 8							; size = 4
?push_back@IPCWaiter@@QAEXABQAX@Z PROC			; IPCWaiter::push_back, COMDAT
; _this$ = ecx

; 106  :     void push_back(const HANDLE &h) { list.push_back(h); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _h$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push_back@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEXABQAX@Z ; std::vector<void *,std::allocator<void *> >::push_back
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@IPCWaiter@@QAEXABQAX@Z ENDP			; IPCWaiter::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ?wait@IPCWaiter@@QAE_NK@Z
_TEXT	SEGMENT
tv76 = -12						; size = 4
_res$ = -8						; size = 4
_this$ = -4						; size = 4
_timeout$ = 8						; size = 4
?wait@IPCWaiter@@QAE_NK@Z PROC				; IPCWaiter::wait, COMDAT
; _this$ = ecx

; 107  :     bool wait(DWORD timeout=0) { if(!list.size()) return false; auto res = wait_for_multiple_objects(timeout); return WAIT_OBJECT_0 <= res && res < (WAIT_OBJECT_0+list.size()); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::size
	test	eax, eax
	jne	SHORT $LN1@wait
	xor	al, al
	jmp	SHORT $LN2@wait
$LN1@wait:
	mov	eax, DWORD PTR _timeout$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?wait_for_multiple_objects@IPCWaiter@@AAEKK@Z ; IPCWaiter::wait_for_multiple_objects
	mov	DWORD PTR _res$[ebp], eax
	cmp	DWORD PTR _res$[ebp], 0
	jb	SHORT $LN4@wait
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::size
	cmp	DWORD PTR _res$[ebp], eax
	jae	SHORT $LN4@wait
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN5@wait
$LN4@wait:
	mov	DWORD PTR tv76[ebp], 0
$LN5@wait:
	mov	al, BYTE PTR tv76[ebp]
$LN2@wait:
	mov	esp, ebp
	pop	ebp
	ret	4
?wait@IPCWaiter@@QAE_NK@Z ENDP				; IPCWaiter::wait
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ?wait_for@IPCWaiter@@QAE_NKK@Z
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
_object$ = 8						; size = 4
_timeout$ = 12						; size = 4
?wait_for@IPCWaiter@@QAE_NKK@Z PROC			; IPCWaiter::wait_for, COMDAT
; _this$ = ecx

; 108  :     bool wait_for(DWORD object, DWORD timeout=0) { if(!list.size()) return false; return wait_for_multiple_objects(timeout) == (WAIT_OBJECT_0 + object); }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::size
	test	eax, eax
	jne	SHORT $LN1@wait_for
	xor	al, al
	jmp	SHORT $LN2@wait_for
$LN1@wait_for:
	mov	eax, DWORD PTR _timeout$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?wait_for_multiple_objects@IPCWaiter@@AAEKK@Z ; IPCWaiter::wait_for_multiple_objects
	cmp	eax, DWORD PTR _object$[ebp]
	jne	SHORT $LN4@wait_for
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN5@wait_for
$LN4@wait_for:
	mov	DWORD PTR tv72[ebp], 0
$LN5@wait_for:
	mov	al, BYTE PTR tv72[ebp]
$LN2@wait_for:
	mov	esp, ebp
	pop	ebp
	ret	8
?wait_for@IPCWaiter@@QAE_NKK@Z ENDP			; IPCWaiter::wait_for
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ?wait_for_two@IPCWaiter@@QAE_NKKK@Z
_TEXT	SEGMENT
tv73 = -12						; size = 4
_res$ = -8						; size = 4
_this$ = -4						; size = 4
_first$ = 8						; size = 4
_second$ = 12						; size = 4
_timeout$ = 16						; size = 4
?wait_for_two@IPCWaiter@@QAE_NKKK@Z PROC		; IPCWaiter::wait_for_two, COMDAT
; _this$ = ecx

; 109  :     bool wait_for_two(DWORD first, DWORD second, DWORD timeout=0) { if(!list.size()) return false; auto res = wait_for_multiple_objects(timeout); return res == (WAIT_OBJECT_0 + first) || res == (WAIT_OBJECT_0 + second); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::size
	test	eax, eax
	jne	SHORT $LN1@wait_for_t
	xor	al, al
	jmp	SHORT $LN2@wait_for_t
$LN1@wait_for_t:
	mov	eax, DWORD PTR _timeout$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?wait_for_multiple_objects@IPCWaiter@@AAEKK@Z ; IPCWaiter::wait_for_multiple_objects
	mov	DWORD PTR _res$[ebp], eax
	mov	ecx, DWORD PTR _res$[ebp]
	cmp	ecx, DWORD PTR _first$[ebp]
	je	SHORT $LN4@wait_for_t
	mov	edx, DWORD PTR _res$[ebp]
	cmp	edx, DWORD PTR _second$[ebp]
	je	SHORT $LN4@wait_for_t
	mov	DWORD PTR tv73[ebp], 0
	jmp	SHORT $LN5@wait_for_t
$LN4@wait_for_t:
	mov	DWORD PTR tv73[ebp], 1
$LN5@wait_for_t:
	mov	al, BYTE PTR tv73[ebp]
$LN2@wait_for_t:
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?wait_for_two@IPCWaiter@@QAE_NKKK@Z ENDP		; IPCWaiter::wait_for_two
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ?wait_timeout@IPCWaiter@@QAE_NK@Z
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
_timeout$ = 8						; size = 4
?wait_timeout@IPCWaiter@@QAE_NK@Z PROC			; IPCWaiter::wait_timeout, COMDAT
; _this$ = ecx

; 110  :     bool wait_timeout(DWORD timeout=0) { if(!list.size()) return false; return wait_for_multiple_objects(timeout) == WAIT_TIMEOUT; }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::size
	test	eax, eax
	jne	SHORT $LN1@wait_timeo
	xor	al, al
	jmp	SHORT $LN2@wait_timeo
$LN1@wait_timeo:
	mov	eax, DWORD PTR _timeout$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?wait_for_multiple_objects@IPCWaiter@@AAEKK@Z ; IPCWaiter::wait_for_multiple_objects
	cmp	eax, 258				; 00000102H
	jne	SHORT $LN4@wait_timeo
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN5@wait_timeo
$LN4@wait_timeo:
	mov	DWORD PTR tv72[ebp], 0
$LN5@wait_timeo:
	mov	al, BYTE PTR tv72[ebp]
$LN2@wait_timeo:
	mov	esp, ebp
	pop	ebp
	ret	4
?wait_timeout@IPCWaiter@@QAE_NK@Z ENDP			; IPCWaiter::wait_timeout
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ?wait_for_multiple_objects@IPCWaiter@@AAEKK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_timeout$ = 8						; size = 4
?wait_for_multiple_objects@IPCWaiter@@AAEKK@Z PROC	; IPCWaiter::wait_for_multiple_objects, COMDAT
; _this$ = ecx

; 113  :     DWORD wait_for_multiple_objects(DWORD timeout) { return WaitForMultipleObjects(static_cast<DWORD>(list.size()), &list.front(), false, timeout); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _timeout$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?front@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAPAXXZ ; std::vector<void *,std::allocator<void *> >::front
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::size
	push	eax
	call	DWORD PTR __imp__WaitForMultipleObjects@16
	mov	esp, ebp
	pop	ebp
	ret	4
?wait_for_multiple_objects@IPCWaiter@@AAEKK@Z ENDP	; IPCWaiter::wait_for_multiple_objects
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ?lock@IPCMutex@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?lock@IPCMutex@@QAEXXZ PROC				; IPCMutex::lock, COMDAT
; _this$ = ecx

; 120  :     void lock() { if(mutex_) WaitForSingleObject(mutex_, INFINITE); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Bsafe_handle@@QAEPAXXZ		; safe_handle::operator void *
	test	eax, eax
	je	SHORT $LN2@lock
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Bsafe_handle@@QAEPAXXZ		; safe_handle::operator void *
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN2@lock:
	mov	esp, ebp
	pop	ebp
	ret	0
?lock@IPCMutex@@QAEXXZ ENDP				; IPCMutex::lock
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ?unlock@IPCMutex@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?unlock@IPCMutex@@QAEXXZ PROC				; IPCMutex::unlock, COMDAT
; _this$ = ecx

; 121  :     void unlock() { if(mutex_) ReleaseMutex(mutex_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Bsafe_handle@@QAEPAXXZ		; safe_handle::operator void *
	test	eax, eax
	je	SHORT $LN2@unlock
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Bsafe_handle@@QAEPAXXZ		; safe_handle::operator void *
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
$LN2@unlock:
	mov	esp, ebp
	pop	ebp
	ret	0
?unlock@IPCMutex@@QAEXXZ ENDP				; IPCMutex::unlock
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??0IPCMutex@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_name$ = 8						; size = 24
??0IPCMutex@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z PROC ; IPCMutex::IPCMutex, COMDAT
; _this$ = ecx

; 127  :     IPCMutex(std::wstring name) { mutex_.reset(CreateMutex(nullptr, false, name.c_str())); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0safe_handle@@QAE@PAX@Z		; safe_handle::safe_handle
	lea	ecx, DWORD PTR _name$[ebp]
	call	?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
	push	eax
	push	0
	push	0
	call	DWORD PTR __imp__CreateMutexW@12
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?reset@safe_handle@@QAEXPAX@Z		; safe_handle::reset
	lea	ecx, DWORD PTR _name$[ebp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
??0IPCMutex@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ENDP ; IPCMutex::IPCMutex
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??0IPCMutex@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0IPCMutex@@QAE@XZ PROC				; IPCMutex::IPCMutex, COMDAT
; _this$ = ecx

; 128  :     IPCMutex() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0safe_handle@@QAE@PAX@Z		; safe_handle::safe_handle
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0IPCMutex@@QAE@XZ ENDP				; IPCMutex::IPCMutex
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\utilities.h
;	COMDAT ?valid_method@@YA_NG@Z
_TEXT	SEGMENT
tv65 = -4						; size = 4
_method$ = 8						; size = 2
?valid_method@@YA_NG@Z PROC				; valid_method, COMDAT

; 66   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 67   :     switch (method)

	movzx	eax, WORD PTR _method$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	mov	ecx, DWORD PTR tv65[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 10			; 0000000aH
	ja	SHORT $LN2@valid_meth
	mov	edx, DWORD PTR tv65[ebp]
	movzx	eax, BYTE PTR $LN6@valid_meth[edx]
	jmp	DWORD PTR $LN7@valid_meth[eax*4]
$LN1@valid_meth:

; 68   :     {
; 69   :     case MFX_RATECONTROL_CBR:
; 70   :     case MFX_RATECONTROL_VBR:
; 71   :     case MFX_RATECONTROL_CQP:
; 72   :     case MFX_RATECONTROL_AVBR:
; 73   :     case MFX_RATECONTROL_LA:
; 74   :     case MFX_RATECONTROL_ICQ:
; 75   :     case MFX_RATECONTROL_VCM:
; 76   :     case MFX_RATECONTROL_LA_ICQ:
; 77   :         return true;

	mov	al, 1
	jmp	SHORT $LN4@valid_meth
$LN2@valid_meth:

; 78   :     }
; 79   :     return false;

	xor	al, al
$LN4@valid_meth:

; 80   : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN7@valid_meth:
	DD	$LN1@valid_meth
	DD	$LN2@valid_meth
$LN6@valid_meth:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
	DB	0
	DB	0
?valid_method@@YA_NG@Z ENDP				; valid_method
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ?qsv_intf_str@?A0x7e09c670@@YAPB_WI@Z
_TEXT	SEGMENT
tv65 = -4						; size = 4
_impl$ = 8						; size = 4
?qsv_intf_str@?A0x7e09c670@@YAPB_WI@Z PROC		; `anonymous namespace'::qsv_intf_str, COMDAT

; 96   :     {

	push	ebp
	mov	ebp, esp
	push	ecx

; 97   :         switch(impl & (-MFX_IMPL_VIA_ANY))

	mov	eax, DWORD PTR _impl$[ebp]
	and	eax, -256				; ffffff00H
	mov	DWORD PTR tv65[ebp], eax
	cmp	DWORD PTR tv65[ebp], 256		; 00000100H
	je	SHORT $LN4@qsv_intf_s
	cmp	DWORD PTR tv65[ebp], 512		; 00000200H
	je	SHORT $LN3@qsv_intf_s
	cmp	DWORD PTR tv65[ebp], 768		; 00000300H
	je	SHORT $LN2@qsv_intf_s
	jmp	SHORT $LN1@qsv_intf_s
$LN4@qsv_intf_s:

; 98   :         {
; 99   : #define VIA_STR(x) case MFX_IMPL_VIA_##x: return TEXT(" | ") TO_STR(MFX_IMPL_VIA_##x)
; 100  :             VIA_STR(ANY);

	mov	eax, OFFSET $SG4294870640
	jmp	SHORT $LN7@qsv_intf_s
$LN3@qsv_intf_s:

; 101  :             VIA_STR(D3D9);

	mov	eax, OFFSET $SG4294870639
	jmp	SHORT $LN7@qsv_intf_s
$LN2@qsv_intf_s:

; 102  :             VIA_STR(D3D11);

	mov	eax, OFFSET $SG4294870638
	jmp	SHORT $LN7@qsv_intf_s
$LN1@qsv_intf_s:

; 103  : #undef VIA_STR
; 104  :         default: return TEXT("");

	mov	eax, OFFSET $SG4294870637
$LN7@qsv_intf_s:

; 105  :         }
; 106  :     };

	mov	esp, ebp
	pop	ebp
	ret	0
?qsv_intf_str@?A0x7e09c670@@YAPB_WI@Z ENDP		; `anonymous namespace'::qsv_intf_str
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ?qsv_profile_str@?A0x7e09c670@@YAPB_WG@Z
_TEXT	SEGMENT
tv65 = -4						; size = 4
_profile$ = 8						; size = 2
?qsv_profile_str@?A0x7e09c670@@YAPB_WG@Z PROC		; `anonymous namespace'::qsv_profile_str, COMDAT

; 109  :     {

	push	ebp
	mov	ebp, esp
	push	ecx

; 110  :         switch (profile)

	movzx	eax, WORD PTR _profile$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	cmp	DWORD PTR tv65[ebp], 578		; 00000242H
	jg	SHORT $LN19@qsv_profil
	cmp	DWORD PTR tv65[ebp], 578		; 00000242H
	je	$LN3@qsv_profil
	cmp	DWORD PTR tv65[ebp], 88			; 00000058H
	jg	SHORT $LN20@qsv_profil
	cmp	DWORD PTR tv65[ebp], 88			; 00000058H
	je	$LN5@qsv_profil
	cmp	DWORD PTR tv65[ebp], 0
	je	$LN14@qsv_profil
	cmp	DWORD PTR tv65[ebp], 66			; 00000042H
	je	$LN7@qsv_profil
	cmp	DWORD PTR tv65[ebp], 77			; 0000004dH
	je	$LN6@qsv_profil
	jmp	$LN15@qsv_profil
$LN20@qsv_profil:
	cmp	DWORD PTR tv65[ebp], 100		; 00000064H
	je	$LN4@qsv_profil
	cmp	DWORD PTR tv65[ebp], 256		; 00000100H
	je	SHORT $LN13@qsv_profil
	cmp	DWORD PTR tv65[ebp], 512		; 00000200H
	je	SHORT $LN12@qsv_profil
	jmp	$LN15@qsv_profil
$LN19@qsv_profil:
	cmp	DWORD PTR tv65[ebp], 4196		; 00001064H
	jg	SHORT $LN21@qsv_profil
	cmp	DWORD PTR tv65[ebp], 4196		; 00001064H
	je	$LN1@qsv_profil
	cmp	DWORD PTR tv65[ebp], 1024		; 00000400H
	je	SHORT $LN11@qsv_profil
	cmp	DWORD PTR tv65[ebp], 2048		; 00000800H
	je	SHORT $LN10@qsv_profil
	cmp	DWORD PTR tv65[ebp], 4096		; 00001000H
	je	SHORT $LN9@qsv_profil
	jmp	SHORT $LN15@qsv_profil
$LN21@qsv_profil:
	cmp	DWORD PTR tv65[ebp], 8192		; 00002000H
	je	SHORT $LN8@qsv_profil
	cmp	DWORD PTR tv65[ebp], 12388		; 00003064H
	je	SHORT $LN2@qsv_profil
	jmp	SHORT $LN15@qsv_profil
$LN14@qsv_profil:

; 111  :         {
; 112  : #define P_STR(x) case x: return TO_STR(x)
; 113  :             P_STR(MFX_PROFILE_UNKNOWN);

	mov	eax, OFFSET $SG4294870636
	jmp	SHORT $LN17@qsv_profil
$LN13@qsv_profil:

; 114  :             P_STR(MFX_PROFILE_AVC_CONSTRAINT_SET0);

	mov	eax, OFFSET $SG4294870635
	jmp	SHORT $LN17@qsv_profil
$LN12@qsv_profil:

; 115  :             P_STR(MFX_PROFILE_AVC_CONSTRAINT_SET1);

	mov	eax, OFFSET $SG4294870634
	jmp	SHORT $LN17@qsv_profil
$LN11@qsv_profil:

; 116  :             P_STR(MFX_PROFILE_AVC_CONSTRAINT_SET2);

	mov	eax, OFFSET $SG4294870633
	jmp	SHORT $LN17@qsv_profil
$LN10@qsv_profil:

; 117  :             P_STR(MFX_PROFILE_AVC_CONSTRAINT_SET3);

	mov	eax, OFFSET $SG4294870632
	jmp	SHORT $LN17@qsv_profil
$LN9@qsv_profil:

; 118  :             P_STR(MFX_PROFILE_AVC_CONSTRAINT_SET4);

	mov	eax, OFFSET $SG4294870631
	jmp	SHORT $LN17@qsv_profil
$LN8@qsv_profil:

; 119  :             P_STR(MFX_PROFILE_AVC_CONSTRAINT_SET5);

	mov	eax, OFFSET $SG4294870630
	jmp	SHORT $LN17@qsv_profil
$LN7@qsv_profil:

; 120  :             P_STR(MFX_PROFILE_AVC_BASELINE);

	mov	eax, OFFSET $SG4294870629
	jmp	SHORT $LN17@qsv_profil
$LN6@qsv_profil:

; 121  :             P_STR(MFX_PROFILE_AVC_MAIN);

	mov	eax, OFFSET $SG4294870628
	jmp	SHORT $LN17@qsv_profil
$LN5@qsv_profil:

; 122  :             P_STR(MFX_PROFILE_AVC_EXTENDED);

	mov	eax, OFFSET $SG4294870627
	jmp	SHORT $LN17@qsv_profil
$LN4@qsv_profil:

; 123  :             P_STR(MFX_PROFILE_AVC_HIGH);

	mov	eax, OFFSET $SG4294870626
	jmp	SHORT $LN17@qsv_profil
$LN3@qsv_profil:

; 124  :             P_STR(MFX_PROFILE_AVC_CONSTRAINED_BASELINE);

	mov	eax, OFFSET $SG4294870625
	jmp	SHORT $LN17@qsv_profil
$LN2@qsv_profil:

; 125  :             P_STR(MFX_PROFILE_AVC_CONSTRAINED_HIGH);

	mov	eax, OFFSET $SG4294870624
	jmp	SHORT $LN17@qsv_profil
$LN1@qsv_profil:

; 126  :             P_STR(MFX_PROFILE_AVC_PROGRESSIVE_HIGH);

	mov	eax, OFFSET $SG4294870623
	jmp	SHORT $LN17@qsv_profil
$LN15@qsv_profil:

; 127  : #undef P_STR
; 128  :         }
; 129  :         return L"UNKNOWN";

	mov	eax, OFFSET $SG4294870622
$LN17@qsv_profil:

; 130  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?qsv_profile_str@?A0x7e09c670@@YAPB_WG@Z ENDP		; `anonymous namespace'::qsv_profile_str
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ?spawn_helper@?A0x7e09c670@@YA_NAAVString@@AAUsafe_handle@@1AAUIPCWaiter@@@Z
_TEXT	SEGMENT
_si$ = -160						; size = 68
$T1 = -92						; size = 8
$T2 = -84						; size = 8
$T3 = -76						; size = 8
$T4 = -68						; size = 8
$T5 = -60						; size = 8
_pi$ = -52						; size = 16
_helper$ = -36						; size = 8
_helper_name$ = -28					; size = 8
tv165 = -20						; size = 4
_dir_size$ = -16					; size = 4
_helper_path$ = -12					; size = 8
$T6 = -3						; size = 1
$T7 = -2						; size = 1
$T8 = -1						; size = 1
_event_prefix$ = 8					; size = 4
_qsvhelper_process$ = 12				; size = 4
_qsvhelper_thread$ = 16					; size = 4
_process_waiter$ = 20					; size = 4
?spawn_helper@?A0x7e09c670@@YA_NAAVString@@AAUsafe_handle@@1AAUIPCWaiter@@@Z PROC ; `anonymous namespace'::spawn_helper, COMDAT

; 147  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 160				; 000000a0H

; 148  :         if (OSGetVersion() < 7) return false;

	call	DWORD PTR __imp_?OSGetVersion@@YGHXZ
	cmp	eax, 7
	jge	SHORT $LN2@spawn_help
	xor	al, al
	jmp	$LN3@spawn_help
$LN2@spawn_help:

; 149  : 
; 150  :         String helper_path;

	lea	ecx, DWORD PTR _helper_path$[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 151  :         auto dir_size = GetCurrentDirectory(0, NULL);

	push	0
	push	0
	call	DWORD PTR __imp__GetCurrentDirectoryW@8
	mov	DWORD PTR _dir_size$[ebp], eax

; 152  :         helper_path.SetLength(dir_size);

	mov	eax, DWORD PTR _dir_size$[ebp]
	push	eax
	lea	ecx, DWORD PTR _helper_path$[ebp]
	call	DWORD PTR __imp_?SetLength@String@@QAEAAV1@I@Z

; 153  :         GetCurrentDirectory(dir_size, helper_path);

	lea	ecx, DWORD PTR _helper_path$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	mov	ecx, DWORD PTR _dir_size$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetCurrentDirectoryW@8

; 154  : 
; 155  :         helper_path << "/";

	push	OFFSET $SG4294870621
	lea	ecx, DWORD PTR $T4[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PBD@Z
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	lea	ecx, DWORD PTR _helper_path$[ebp]
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T4[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 156  : 
; 157  :         String helper = helper_path;

	lea	eax, DWORD PTR _helper_path$[ebp]
	push	eax
	lea	ecx, DWORD PTR _helper$[ebp]
	call	DWORD PTR __imp_??0String@@QAE@ABV0@@Z

; 158  :         String helper_name = "QSVHelper.exe";

	push	OFFSET $SG4294870620
	lea	ecx, DWORD PTR _helper_name$[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PBD@Z

; 159  :         helper << helper_name;

	lea	ecx, DWORD PTR _helper_name$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _helper$[ebp]
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z

; 160  :         
; 161  :         PROCESS_INFORMATION pi;
; 162  :         STARTUPINFO si;
; 163  : 
; 164  :         zero(pi);

	push	16					; 00000010H
	lea	edx, DWORD PTR _pi$[ebp]
	push	edx
	call	??$zero@U_PROCESS_INFORMATION@@@@YAXAAU_PROCESS_INFORMATION@@I@Z ; zero<_PROCESS_INFORMATION>
	add	esp, 8

; 165  :         zero(si);

	push	68					; 00000044H
	lea	eax, DWORD PTR _si$[ebp]
	push	eax
	call	??$zero@U_STARTUPINFOW@@@@YAXAAU_STARTUPINFOW@@I@Z ; zero<_STARTUPINFOW>
	add	esp, 8

; 166  :         si.cb = sizeof(si);

	mov	DWORD PTR _si$[ebp], 68			; 00000044H

; 167  : 
; 168  :         if(!CreateProcess(helper, helper_name+" "+OBSGetAppDataPath(), nullptr, nullptr, false, 0, nullptr, helper_path, &si, &pi))

	push	OFFSET $SG4294870619
	lea	ecx, DWORD PTR $T5[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PBD@Z
	lea	ecx, DWORD PTR _pi$[ebp]
	push	ecx
	lea	edx, DWORD PTR _si$[ebp]
	push	edx
	lea	ecx, DWORD PTR _helper_path$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	push	0
	push	0
	push	0
	push	0
	push	0
	call	DWORD PTR __imp_?OBSGetAppDataPath@@YAPB_WXZ
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR $T5[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	lea	ecx, DWORD PTR _helper_name$[ebp]
	call	DWORD PTR __imp_??HString@@QBE?AV0@ABV0@@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??HString@@QBE?AV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	lea	ecx, DWORD PTR _helper$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp__CreateProcessW@40
	test	eax, eax
	jne	SHORT $LN5@spawn_help
	mov	DWORD PTR tv165[ebp], 1
	jmp	SHORT $LN6@spawn_help
$LN5@spawn_help:
	mov	DWORD PTR tv165[ebp], 0
$LN6@spawn_help:
	mov	al, BYTE PTR tv165[ebp]
	mov	BYTE PTR $T6[ebp], al
	lea	ecx, DWORD PTR $T2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR $T3[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR $T5[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	movzx	ecx, BYTE PTR $T6[ebp]
	test	ecx, ecx
	je	SHORT $LN1@spawn_help

; 169  :             return false;

	mov	BYTE PTR $T8[ebp], 0
	lea	ecx, DWORD PTR _helper_name$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _helper$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _helper_path$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	al, BYTE PTR $T8[ebp]
	jmp	$LN3@spawn_help
$LN1@spawn_help:

; 170  : 
; 171  :         qsvhelper_process.reset(pi.hProcess);

	mov	edx, DWORD PTR _pi$[ebp]
	push	edx
	mov	ecx, DWORD PTR _qsvhelper_process$[ebp]
	call	?reset@safe_handle@@QAEXPAX@Z		; safe_handle::reset

; 172  :         qsvhelper_thread.reset(pi.hThread);

	mov	eax, DWORD PTR _pi$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _qsvhelper_thread$[ebp]
	call	?reset@safe_handle@@QAEXPAX@Z		; safe_handle::reset

; 173  :         process_waiter.push_back(pi.hProcess);

	lea	ecx, DWORD PTR _pi$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _process_waiter$[ebp]
	call	?push_back@IPCWaiter@@QAEXABQAX@Z	; IPCWaiter::push_back

; 174  :         process_waiter.push_back(pi.hThread);

	lea	edx, DWORD PTR _pi$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _process_waiter$[ebp]
	call	?push_back@IPCWaiter@@QAEXABQAX@Z	; IPCWaiter::push_back

; 175  : 
; 176  :         event_prefix = FormattedString(TEXT("%s%u"), helper_name.Array(), pi.dwProcessId);

	mov	eax, DWORD PTR _pi$[ebp+8]
	push	eax
	lea	ecx, DWORD PTR _helper_name$[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET $SG4294870618
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR _event_prefix$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 177  : 
; 178  :         return true;

	mov	BYTE PTR $T7[ebp], 1
	lea	ecx, DWORD PTR _helper_name$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _helper$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _helper_path$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	al, BYTE PTR $T7[ebp]
$LN3@spawn_help:

; 179  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?spawn_helper@?A0x7e09c670@@YA_NAAVString@@AAUsafe_handle@@1AAUIPCWaiter@@@Z ENDP ; `anonymous namespace'::spawn_helper
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ?qsv_get_cpu_platform@?A0x7e09c670@@YA?AW4qsv_cpu_platform@1@XZ
_TEXT	SEGMENT
$T1 = -160						; size = 4
$T2 = -156						; size = 4
$T3 = -152						; size = 4
$T4 = -148						; size = 4
$T5 = -144						; size = 4
$T6 = -140						; size = 4
$T7 = -136						; size = 4
$T8 = -132						; size = 4
$T9 = -128						; size = 4
tv161 = -124						; size = 4
_model$ = -118						; size = 1
_family$ = -117						; size = 1
$T10 = -116						; size = 24
$T11 = -92						; size = 24
$T12 = -68						; size = 24
_vendor$ = -44						; size = 24
_cpuInfo$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
?qsv_get_cpu_platform@?A0x7e09c670@@YA?AW4qsv_cpu_platform@1@XZ PROC ; `anonymous namespace'::qsv_get_cpu_platform, COMDAT

; 194  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 160				; 000000a0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi

; 195  :         using std::string;
; 196  : 
; 197  :         int cpuInfo[4];
; 198  :         __cpuid(cpuInfo, 0);

	lea	esi, DWORD PTR _cpuInfo$[ebp]
	xor	eax, eax
	xor	ecx, ecx
	cpuid
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+8], ecx
	mov	DWORD PTR [esi+12], edx

; 199  : 
; 200  :         string vendor;

	lea	ecx, DWORD PTR _vendor$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 201  :         vendor += string((char*)&cpuInfo[1], 4);

	push	4
	mov	eax, 4
	shl	eax, 0
	lea	ecx, DWORD PTR _cpuInfo$[ebp+eax]
	push	ecx
	lea	ecx, DWORD PTR $T10[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	push	eax
	lea	ecx, DWORD PTR _vendor$[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
	lea	ecx, DWORD PTR $T10[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 202  :         vendor += string((char*)&cpuInfo[3], 4);

	push	4
	mov	edx, 4
	imul	eax, edx, 3
	lea	ecx, DWORD PTR _cpuInfo$[ebp+eax]
	push	ecx
	lea	ecx, DWORD PTR $T12[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	push	eax
	lea	ecx, DWORD PTR _vendor$[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
	lea	ecx, DWORD PTR $T12[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 203  :         vendor += string((char*)&cpuInfo[2], 4);

	push	4
	mov	edx, 4
	shl	edx, 1
	lea	eax, DWORD PTR _cpuInfo$[ebp+edx]
	push	eax
	lea	ecx, DWORD PTR $T11[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	push	eax
	lea	ecx, DWORD PTR _vendor$[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
	lea	ecx, DWORD PTR $T11[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 204  : 
; 205  :         if (vendor != "GenuineIntel")

	push	OFFSET $SG4294870617
	lea	ecx, DWORD PTR _vendor$[ebp]
	push	ecx
	call	??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN10@qsv_get_cp

; 206  :             return QSV_CPU_PLATFORM_UNKNOWN;

	mov	DWORD PTR $T1[ebp], 0
	lea	ecx, DWORD PTR _vendor$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	jmp	$LN11@qsv_get_cp
$LN10@qsv_get_cp:

; 207  : 
; 208  :         __cpuid(cpuInfo, 1);

	lea	esi, DWORD PTR _cpuInfo$[ebp]
	mov	eax, 1
	xor	ecx, ecx
	cpuid
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+8], ecx
	mov	DWORD PTR [esi+12], edx

; 209  :         BYTE model = ((cpuInfo[0] >> 4) & 0xF) + ((cpuInfo[0] >> 12) & 0xF0);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cpuInfo$[ebp+ecx]
	sar	edx, 4
	and	edx, 15					; 0000000fH
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _cpuInfo$[ebp+ecx]
	sar	eax, 12					; 0000000cH
	and	eax, 240				; 000000f0H
	add	edx, eax
	mov	BYTE PTR _model$[ebp], dl

; 210  :         BYTE family = ((cpuInfo[0] >> 8) & 0xF) + ((cpuInfo[0] >> 20) & 0xFF);

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cpuInfo$[ebp+edx]
	sar	eax, 8
	and	eax, 15					; 0000000fH
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _cpuInfo$[ebp+edx]
	sar	ecx, 20					; 00000014H
	and	ecx, 255				; 000000ffH
	add	eax, ecx
	mov	BYTE PTR _family$[ebp], al

; 211  : 
; 212  :         // See Intel 64 and IA-32 Architectures Software Developer's Manual, Vol 3C Table 35-1
; 213  :         if (family != 6)

	movzx	edx, BYTE PTR _family$[ebp]
	cmp	edx, 6
	je	SHORT $LN9@qsv_get_cp

; 214  :             return QSV_CPU_PLATFORM_UNKNOWN;

	mov	DWORD PTR $T8[ebp], 0
	lea	ecx, DWORD PTR _vendor$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T8[ebp]
	jmp	$LN11@qsv_get_cp
$LN9@qsv_get_cp:

; 215  : 
; 216  :         switch (model)

	movzx	eax, BYTE PTR _model$[ebp]
	mov	DWORD PTR tv161[ebp], eax
	mov	ecx, DWORD PTR tv161[ebp]
	sub	ecx, 28					; 0000001cH
	mov	DWORD PTR tv161[ebp], ecx
	cmp	DWORD PTR tv161[ebp], 65		; 00000041H
	ja	$LN7@qsv_get_cp
	mov	edx, DWORD PTR tv161[ebp]
	movzx	eax, BYTE PTR $LN13@qsv_get_cp[edx]
	jmp	DWORD PTR $LN14@qsv_get_cp[eax*4]
$LN6@qsv_get_cp:

; 217  :         {
; 218  :         case 0x1C:
; 219  :         case 0x26:
; 220  :         case 0x27:
; 221  :         case 0x35:
; 222  :         case 0x36:
; 223  :             return QSV_CPU_PLATFORM_BNL;

	mov	DWORD PTR $T7[ebp], 1
	lea	ecx, DWORD PTR _vendor$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T7[ebp]
	jmp	$LN11@qsv_get_cp
$LN5@qsv_get_cp:

; 224  : 
; 225  :         case 0x2a:
; 226  :         case 0x2d:
; 227  :             return QSV_CPU_PLATFORM_SNB;

	mov	DWORD PTR $T5[ebp], 2
	lea	ecx, DWORD PTR _vendor$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T5[ebp]
	jmp	SHORT $LN11@qsv_get_cp
$LN4@qsv_get_cp:

; 228  : 
; 229  :         case 0x3a:
; 230  :         case 0x3e:
; 231  :             return QSV_CPU_PLATFORM_IVB;

	mov	DWORD PTR $T3[ebp], 3
	lea	ecx, DWORD PTR _vendor$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T3[ebp]
	jmp	SHORT $LN11@qsv_get_cp
$LN3@qsv_get_cp:

; 232  : 
; 233  :         case 0x37:
; 234  :         case 0x4A:
; 235  :         case 0x4D:
; 236  :         case 0x5A:
; 237  :         case 0x5D:
; 238  :             return QSV_CPU_PLATFORM_SLM;

	mov	DWORD PTR $T9[ebp], 4
	lea	ecx, DWORD PTR _vendor$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T9[ebp]
	jmp	SHORT $LN11@qsv_get_cp
$LN2@qsv_get_cp:

; 239  : 
; 240  :         case 0x4C:
; 241  :             return QSV_CPU_PLATFORM_CHT;

	mov	DWORD PTR $T4[ebp], 5
	lea	ecx, DWORD PTR _vendor$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T4[ebp]
	jmp	SHORT $LN11@qsv_get_cp
$LN1@qsv_get_cp:

; 242  : 
; 243  :         case 0x3c:
; 244  :         case 0x3f:
; 245  :         case 0x45:
; 246  :         case 0x46:
; 247  :             return QSV_CPU_PLATFORM_HSW;

	mov	DWORD PTR $T6[ebp], 6
	lea	ecx, DWORD PTR _vendor$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T6[ebp]
	jmp	SHORT $LN11@qsv_get_cp
$LN7@qsv_get_cp:

; 248  :         }
; 249  : 
; 250  :         return QSV_CPU_PLATFORM_INTEL; //assume newer revisions are at least as capable as haswell

	mov	DWORD PTR $T2[ebp], 7
	lea	ecx, DWORD PTR _vendor$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T2[ebp]
$LN11@qsv_get_cp:

; 251  :     }

	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN14@qsv_get_cp:
	DD	$LN6@qsv_get_cp
	DD	$LN5@qsv_get_cp
	DD	$LN3@qsv_get_cp
	DD	$LN4@qsv_get_cp
	DD	$LN1@qsv_get_cp
	DD	$LN2@qsv_get_cp
	DD	$LN7@qsv_get_cp
$LN13@qsv_get_cp:
	DB	0
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	0
	DB	0
	DB	6
	DB	6
	DB	1
	DB	6
	DB	6
	DB	1
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	0
	DB	0
	DB	2
	DB	6
	DB	6
	DB	3
	DB	6
	DB	4
	DB	6
	DB	3
	DB	4
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	4
	DB	4
	DB	6
	DB	6
	DB	6
	DB	2
	DB	6
	DB	5
	DB	2
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	2
	DB	6
	DB	6
	DB	2
?qsv_get_cpu_platform@?A0x7e09c670@@YA?AW4qsv_cpu_platform@1@XZ ENDP ; `anonymous namespace'::qsv_get_cpu_platform
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ??0DTSGenerator@?A0x7e09c670@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0DTSGenerator@?A0x7e09c670@@QAE@XZ PROC		; `anonymous namespace'::DTSGenerator::DTSGenerator, COMDAT
; _this$ = ecx

; 268  :         DTSGenerator() : ver_1_6(false), bframes_pyramid(false), bframe_delay(0), use_bs_dts(false) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??0?$List@_J@@QAE@XZ			; List<__int64>::List<__int64>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	??0?$List@_J@@QAE@XZ			; List<__int64>::List<__int64>
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0DTSGenerator@?A0x7e09c670@@QAE@XZ ENDP		; `anonymous namespace'::DTSGenerator::DTSGenerator
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ?Init@DTSGenerator@?A0x7e09c670@@QAEXIAATmfxVersion@@_N_K@Z
_TEXT	SEGMENT
tv85 = -16						; size = 4
tv77 = -12						; size = 4
tv72 = -8						; size = 4
_this$ = -4						; size = 4
_bframe_delay_$ = 8					; size = 4
_ver$ = 12						; size = 4
_use_cfr$ = 16						; size = 1
_frame_ticks_$ = 20					; size = 8
?Init@DTSGenerator@?A0x7e09c670@@QAEXIAATmfxVersion@@_N_K@Z PROC ; `anonymous namespace'::DTSGenerator::Init, COMDAT
; _this$ = ecx

; 271  :         {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 272  :             bframe_delay = bframe_delay_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _bframe_delay_$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 273  :             ver_1_6 = (ver.Major >= 1 && ver.Minor >= 6);

	mov	edx, DWORD PTR _ver$[ebp]
	movzx	eax, WORD PTR [edx+2]
	cmp	eax, 1
	jl	SHORT $LN3@Init
	mov	ecx, DWORD PTR _ver$[ebp]
	movzx	edx, WORD PTR [ecx]
	cmp	edx, 6
	jl	SHORT $LN3@Init
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN4@Init
$LN3@Init:
	mov	DWORD PTR tv72[ebp], 0
$LN4@Init:
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR tv72[ebp]
	mov	BYTE PTR [eax], cl

; 274  :             bframes_pyramid = qsv_get_cpu_platform() >= QSV_CPU_PLATFORM_HSW;

	call	?qsv_get_cpu_platform@?A0x7e09c670@@YA?AW4qsv_cpu_platform@1@XZ ; `anonymous namespace'::qsv_get_cpu_platform
	cmp	eax, 6
	jl	SHORT $LN5@Init
	mov	DWORD PTR tv77[ebp], 1
	jmp	SHORT $LN6@Init
$LN5@Init:
	mov	DWORD PTR tv77[ebp], 0
$LN6@Init:
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR tv77[ebp]
	mov	BYTE PTR [edx+1], al

; 275  :             use_bs_dts = ver_1_6 && use_cfr;

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN7@Init
	movzx	eax, BYTE PTR _use_cfr$[ebp]
	test	eax, eax
	je	SHORT $LN7@Init
	mov	DWORD PTR tv85[ebp], 1
	jmp	SHORT $LN8@Init
$LN7@Init:
	mov	DWORD PTR tv85[ebp], 0
$LN8@Init:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR tv85[ebp]
	mov	BYTE PTR [ecx+8], dl

; 276  :             frame_ticks = frame_ticks_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _frame_ticks_$[ebp]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR _frame_ticks_$[ebp+4]
	mov	DWORD PTR [eax+20], edx

; 277  :         }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?Init@DTSGenerator@?A0x7e09c670@@QAEXIAATmfxVersion@@_N_K@Z ENDP ; `anonymous namespace'::DTSGenerator::Init
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ?add@DTSGenerator@?A0x7e09c670@@QAEX_K@Z
_TEXT	SEGMENT
$T1 = -32						; size = 8
$T2 = -24						; size = 8
$T3 = -16						; size = 8
tv92 = -8						; size = 4
_this$ = -4						; size = 4
_ts$ = 8						; size = 8
?add@DTSGenerator@?A0x7e09c670@@QAEX_K@Z PROC		; `anonymous namespace'::DTSGenerator::add, COMDAT
; _this$ = ecx

; 280  :         {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 281  :             if (use_bs_dts)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN5@add

; 282  :                 return;

	jmp	$LN6@add
$LN5@add:

; 283  : 
; 284  :             if (init_pts.Num() || frames_out == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	?Num@?$List@_J@@QBEIXZ			; List<__int64>::Num
	test	eax, eax
	jne	SHORT $LN3@add
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv92[ebp], edx
	mov	eax, DWORD PTR tv92[ebp]
	mov	ecx, DWORD PTR tv92[ebp]
	mov	edx, DWORD PTR [eax+24]
	or	edx, DWORD PTR [ecx+28]
	jne	SHORT $LN4@add
$LN3@add:

; 285  :                 init_pts << ts;

	mov	eax, DWORD PTR _ts$[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	ecx, DWORD PTR _ts$[ebp+4]
	mov	DWORD PTR $T3[ebp+4], ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	??6?$List@_J@@QAEAAV0@AB_J@Z		; List<__int64>::operator<<
$LN4@add:

; 286  :             
; 287  :             if (!dts.Num() || dts.FindValueIndex(ts) == INVALID)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	?Num@?$List@_J@@QBEIXZ			; List<__int64>::Num
	test	eax, eax
	je	SHORT $LN1@add
	mov	eax, DWORD PTR _ts$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR _ts$[ebp+4]
	mov	DWORD PTR $T2[ebp+4], ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	?FindValueIndex@?$List@_J@@QBEIAB_J@Z	; List<__int64>::FindValueIndex
	cmp	eax, -1
	jne	SHORT $LN6@add
$LN1@add:

; 288  :                 dts << ts;

	mov	eax, DWORD PTR _ts$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR _ts$[ebp+4]
	mov	DWORD PTR $T1[ebp+4], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??6?$List@_J@@QAEAAV0@AB_J@Z		; List<__int64>::operator<<
$LN6@add:

; 289  :         }

	mov	esp, ebp
	pop	ebp
	ret	8
?add@DTSGenerator@?A0x7e09c670@@QAEX_K@Z ENDP		; `anonymous namespace'::DTSGenerator::add
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ??RDTSGenerator@?A0x7e09c670@@QAE_J_K_J@Z
_TEXT	SEGMENT
tv231 = -32						; size = 8
_result$ = -24						; size = 8
tv230 = -16						; size = 4
_delay$1 = -12						; size = 4
tv174 = -8						; size = 4
_this$ = -4						; size = 4
_bs_pts$ = 8						; size = 8
_bs_dts$ = 16						; size = 8
??RDTSGenerator@?A0x7e09c670@@QAE_J_K_J@Z PROC		; `anonymous namespace'::DTSGenerator::operator(), COMDAT
; _this$ = ecx

; 292  :         {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 293  :             if (use_bs_dts)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN6@operator

; 294  :                 return bs_dts;

	mov	eax, DWORD PTR _bs_dts$[ebp]
	mov	edx, DWORD PTR _bs_dts$[ebp+4]
	jmp	$LN7@operator
$LN6@operator:

; 295  : 
; 296  :             int64_t result = bs_dts;

	mov	edx, DWORD PTR _bs_dts$[ebp]
	mov	DWORD PTR _result$[ebp], edx
	mov	eax, DWORD PTR _bs_dts$[ebp+4]
	mov	DWORD PTR _result$[ebp+4], eax

; 297  : 
; 298  :             if (frames_out == 0 && ver_1_6 && bframes_pyramid)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv174[ebp], ecx
	mov	edx, DWORD PTR tv174[ebp]
	mov	eax, DWORD PTR tv174[ebp]
	mov	ecx, DWORD PTR [edx+24]
	or	ecx, DWORD PTR [eax+28]
	jne	SHORT $LN5@operator
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN5@operator
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	test	edx, edx
	je	SHORT $LN5@operator

; 299  :             {
; 300  :                 int delay = (int)((bs_pts - bs_dts + frame_ticks / 2) / frame_ticks);

	mov	esi, DWORD PTR _bs_pts$[ebp]
	sub	esi, DWORD PTR _bs_dts$[ebp]
	mov	edi, DWORD PTR _bs_pts$[ebp+4]
	sbb	edi, DWORD PTR _bs_dts$[ebp+4]
	mov	eax, DWORD PTR _this$[ebp]
	push	0
	push	2
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR [eax+16]
	push	edx
	call	__aulldiv
	add	esi, eax
	adc	edi, edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR [eax+16]
	push	edx
	push	edi
	push	esi
	call	__aulldiv
	mov	DWORD PTR _delay$1[ebp], eax

; 301  :                 if (delay > 0)

	cmp	DWORD PTR _delay$1[ebp], 0
	jle	SHORT $LN4@operator

; 302  :                     bframe_delay = delay;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _delay$1[ebp]
	mov	DWORD PTR [eax+4], ecx
$LN4@operator:

; 303  :                 Log(L"Recalculated bframe_delay: %u, init_pts.Num: %u", bframe_delay, init_pts.Num());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	?Num@?$List@_J@@QBEIXZ			; List<__int64>::Num
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	OFFSET ??_C@_1GA@FFPJBDII@?$AAR?$AAe?$AAc?$AAa?$AAl?$AAc?$AAu?$AAl?$AAa?$AAt?$AAe?$AAd?$AA?5?$AAb?$AAf?$AAr?$AAa?$AAm?$AAe?$AA_?$AAd?$AAe?$AAl?$AAa?$AAy?$AA?3?$AA?5?$AA?$CF?$AAu?$AA?0?$AA?5?$AAi@
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 12					; 0000000cH
$LN5@operator:

; 304  :             }
; 305  : 
; 306  :             if (frames_out <= bframe_delay)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv230[ebp], ecx
	mov	DWORD PTR tv231[ebp], edx
	mov	DWORD PTR tv231[ebp+4], eax
	mov	edx, DWORD PTR tv230[ebp]
	mov	eax, DWORD PTR [edx+28]
	cmp	eax, DWORD PTR tv231[ebp+4]
	ja	$LN3@operator
	jb	SHORT $LN9@operator
	mov	ecx, DWORD PTR tv230[ebp]
	mov	edx, DWORD PTR [ecx+24]
	cmp	edx, DWORD PTR tv231[ebp]
	ja	$LN3@operator
$LN9@operator:

; 307  :             {
; 308  :                 if (bframe_delay >= init_pts.Num())

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	?Num@?$List@_J@@QBEIXZ			; List<__int64>::Num
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], eax
	jb	SHORT $LN2@operator

; 309  :                 {
; 310  :                     AppWarning(L"bframe_delay=%u >= init_pts.Num=%u", bframe_delay, init_pts.Num());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	?Num@?$List@_J@@QBEIXZ			; List<__int64>::Num
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	OFFSET ??_C@_1EG@IOAIFOJM@?$AAb?$AAf?$AAr?$AAa?$AAm?$AAe?$AA_?$AAd?$AAe?$AAl?$AAa?$AAy?$AA?$DN?$AA?$CF?$AAu?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAi?$AAn?$AAi?$AAt?$AA_?$AAp?$AAt?$AAs?$AA?4?$AAN?$AAu?$AAm?$AA?$DN@
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 12					; 0000000cH

; 311  :                     bframe_delay = init_pts.Num() - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	?Num@?$List@_J@@QBEIXZ			; List<__int64>::Num
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax
$LN2@operator:

; 312  :                 }
; 313  :                 result = init_pts[(unsigned)frames_out] - init_pts[bframe_delay];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	??A?$List@_J@@QAEAA_JI@Z		; List<__int64>::operator[]
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	??A?$List@_J@@QAEAA_JI@Z		; List<__int64>::operator[]
	mov	ecx, DWORD PTR [esi]
	sub	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [esi+4]
	sbb	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _result$[ebp], ecx
	mov	DWORD PTR _result$[ebp+4], edx

; 314  :             }
; 315  :             else

	jmp	SHORT $LN1@operator
$LN3@operator:

; 316  :             {
; 317  :                 init_pts.Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	?Clear@?$List@_J@@QAEXXZ		; List<__int64>::Clear

; 318  :                 result = dts[0];

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??A?$List@_J@@QAEAA_JI@Z		; List<__int64>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _result$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _result$[ebp+4], edx

; 319  :                 dts.Remove(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	?Remove@?$List@_J@@QAEXI@Z		; List<__int64>::Remove
$LN1@operator:

; 320  :             }
; 321  :             //Log(L"bs_dts=%u dts.Num=%u frames_out=%u bframe_delay=%u result=%lli bs_pts=%llu bs_dts=%lli", use_bs_dts, dts.Num(), frames_out, bframe_delay, result, bs_pts, bs_dts);
; 322  : 
; 323  :             frames_out += 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, 1
	mov	edx, DWORD PTR [eax+28]
	adc	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+28], edx

; 324  :             return result;

	mov	eax, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _result$[ebp+4]
$LN7@operator:

; 325  :         }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??RDTSGenerator@?A0x7e09c670@@QAE_J_K_J@Z ENDP		; `anonymous namespace'::DTSGenerator::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ?StopHelper@?A0x7e09c670@@YAXAAU?$IPCSignal@$00@@AAUIPCWaiter@@AAUsafe_handle@@@Z
_TEXT	SEGMENT
_stop$ = 8						; size = 4
_waiter$ = 12						; size = 4
_h$ = 16						; size = 4
?StopHelper@?A0x7e09c670@@YAXAAU?$IPCSignal@$00@@AAUIPCWaiter@@AAUsafe_handle@@@Z PROC ; `anonymous namespace'::StopHelper, COMDAT

; 336  :     {

	push	ebp
	mov	ebp, esp

; 337  :         stop.signal();

	mov	ecx, DWORD PTR _stop$[ebp]
	call	?signal@?$IPCSignal@$00@@QAEXXZ		; IPCSignal<1>::signal

; 338  :         if (waiter.wait_timeout(500))

	push	500					; 000001f4H
	mov	ecx, DWORD PTR _waiter$[ebp]
	call	?wait_timeout@IPCWaiter@@QAE_NK@Z	; IPCWaiter::wait_timeout
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@StopHelper

; 339  :             TerminateProcess(h, (UINT)-2);

	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _h$[ebp]
	call	??Bsafe_handle@@QAEPAXXZ		; safe_handle::operator void *
	push	eax
	call	DWORD PTR __imp__TerminateProcess@8
$LN2@StopHelper:

; 340  :     }

	pop	ebp
	ret	0
?StopHelper@?A0x7e09c670@@YAXAAU?$IPCSignal@$00@@AAUIPCWaiter@@AAUsafe_handle@@@Z ENDP ; `anonymous namespace'::StopHelper
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ?CheckQSVHardwareSupport@@YA_N_NPA_N@Z
_TEXT	SEGMENT
$T1 = -104						; size = 8
_waiter$ = -96						; size = 12
tv180 = -84						; size = 4
_event_prefix$ = -80					; size = 8
_code$ = -72						; size = 4
_helper_thread$ = -68					; size = 4
$T2 = -62						; size = 1
$T3 = -61						; size = 1
_helper_process$ = -60					; size = 4
$T4 = -55						; size = 1
$T5 = -54						; size = 1
$T6 = -53						; size = 1
_req$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_log$ = 8						; size = 1
_configurationWarning$ = 12				; size = 4
?CheckQSVHardwareSupport@@YA_N_NPA_N@Z PROC		; CheckQSVHardwareSupport, COMDAT

; 344  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 345  :     safe_handle helper_process, helper_thread;

	push	0
	lea	ecx, DWORD PTR _helper_process$[ebp]
	call	??0safe_handle@@QAE@PAX@Z		; safe_handle::safe_handle
	push	0
	lea	ecx, DWORD PTR _helper_thread$[ebp]
	call	??0safe_handle@@QAE@PAX@Z		; safe_handle::safe_handle

; 346  :     IPCWaiter waiter;

	lea	ecx, DWORD PTR _waiter$[ebp]
	call	??0IPCWaiter@@QAE@XZ

; 347  :     String event_prefix;

	lea	ecx, DWORD PTR _event_prefix$[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 348  :     if(!spawn_helper(event_prefix, helper_process, helper_thread, waiter))

	lea	eax, DWORD PTR _waiter$[ebp]
	push	eax
	lea	ecx, DWORD PTR _helper_thread$[ebp]
	push	ecx
	lea	edx, DWORD PTR _helper_process$[ebp]
	push	edx
	lea	eax, DWORD PTR _event_prefix$[ebp]
	push	eax
	call	?spawn_helper@?A0x7e09c670@@YA_NAAVString@@AAUsafe_handle@@1AAUIPCWaiter@@@Z ; `anonymous namespace'::spawn_helper
	add	esp, 16					; 00000010H
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN9@CheckQSVHa

; 349  :         return false;

	mov	BYTE PTR $T2[ebp], 0
	lea	ecx, DWORD PTR _event_prefix$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _waiter$[ebp]
	call	??1IPCWaiter@@QAE@XZ
	lea	ecx, DWORD PTR _helper_thread$[ebp]
	call	??1safe_handle@@QAE@XZ			; safe_handle::~safe_handle
	lea	ecx, DWORD PTR _helper_process$[ebp]
	call	??1safe_handle@@QAE@XZ			; safe_handle::~safe_handle
	mov	al, BYTE PTR $T2[ebp]
	jmp	$LN10@CheckQSVHa
$LN9@CheckQSVHa:

; 350  : 
; 351  :     ipc_init_request req((event_prefix + INIT_REQUEST).Array());

	push	OFFSET $SG4294870612
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	lea	ecx, DWORD PTR _event_prefix$[ebp]
	call	DWORD PTR __imp_??HString@@QBE?AV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	push	eax
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	lea	ecx, DWORD PTR _req$[ebp]
	call	??0?$IPCSignalledType@Uinit_request@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; IPCSignalledType<init_request>::IPCSignalledType<init_request>
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 352  :     req->mode = req->MODE_QUERY;

	lea	ecx, DWORD PTR _req$[ebp]
	call	??C?$IPCType@Uinit_request@@@@QAEPAUinit_request@@XZ ; IPCType<init_request>::operator->
	lea	ecx, DWORD PTR _req$[ebp]
	call	??C?$IPCType@Uinit_request@@@@QAEPAUinit_request@@XZ ; IPCType<init_request>::operator->
	mov	DWORD PTR [eax], 0

; 353  :     req.signal();

	lea	ecx, DWORD PTR _req$[ebp+40]
	call	?signal@?$IPCSignal@$0A@@@QAEXXZ	; IPCSignal<0>::signal

; 354  : 
; 355  :     if(!waiter.wait(INFINITE))

	push	-1
	lea	ecx, DWORD PTR _waiter$[ebp]
	call	?wait@IPCWaiter@@QAE_NK@Z		; IPCWaiter::wait
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN8@CheckQSVHa

; 356  :         return false;

	mov	BYTE PTR $T3[ebp], 0
	lea	ecx, DWORD PTR _req$[ebp]
	call	??1?$IPCSignalledType@Uinit_request@@@@QAE@XZ
	lea	ecx, DWORD PTR _event_prefix$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _waiter$[ebp]
	call	??1IPCWaiter@@QAE@XZ
	lea	ecx, DWORD PTR _helper_thread$[ebp]
	call	??1safe_handle@@QAE@XZ			; safe_handle::~safe_handle
	lea	ecx, DWORD PTR _helper_process$[ebp]
	call	??1safe_handle@@QAE@XZ			; safe_handle::~safe_handle
	mov	al, BYTE PTR $T3[ebp]
	jmp	$LN10@CheckQSVHa
$LN8@CheckQSVHa:

; 357  : 
; 358  :     DWORD code = 0;

	mov	DWORD PTR _code$[ebp], 0

; 359  :     if(!GetExitCodeProcess(helper_process.h, &code))

	lea	ecx, DWORD PTR _code$[ebp]
	push	ecx
	mov	edx, DWORD PTR _helper_process$[ebp]
	push	edx
	call	DWORD PTR __imp__GetExitCodeProcess@8
	test	eax, eax
	jne	SHORT $LN7@CheckQSVHa

; 360  :         return false;

	mov	BYTE PTR $T4[ebp], 0
	lea	ecx, DWORD PTR _req$[ebp]
	call	??1?$IPCSignalledType@Uinit_request@@@@QAE@XZ
	lea	ecx, DWORD PTR _event_prefix$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _waiter$[ebp]
	call	??1IPCWaiter@@QAE@XZ
	lea	ecx, DWORD PTR _helper_thread$[ebp]
	call	??1safe_handle@@QAE@XZ			; safe_handle::~safe_handle
	lea	ecx, DWORD PTR _helper_process$[ebp]
	call	??1safe_handle@@QAE@XZ			; safe_handle::~safe_handle
	mov	al, BYTE PTR $T4[ebp]
	jmp	$LN10@CheckQSVHa
$LN7@CheckQSVHa:

; 361  : 
; 362  :     if(code == 0)

	cmp	DWORD PTR _code$[ebp], 0
	jne	SHORT $LN6@CheckQSVHa

; 363  :     {
; 364  :         if(log)

	movzx	eax, BYTE PTR _log$[ebp]
	test	eax, eax
	je	SHORT $LN5@CheckQSVHa

; 365  :             Log(TEXT("Found QSV hardware support"));

	push	OFFSET $SG4294870611
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 4
$LN5@CheckQSVHa:

; 366  :         return true;

	mov	BYTE PTR $T6[ebp], 1
	lea	ecx, DWORD PTR _req$[ebp]
	call	??1?$IPCSignalledType@Uinit_request@@@@QAE@XZ
	lea	ecx, DWORD PTR _event_prefix$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _waiter$[ebp]
	call	??1IPCWaiter@@QAE@XZ
	lea	ecx, DWORD PTR _helper_thread$[ebp]
	call	??1safe_handle@@QAE@XZ			; safe_handle::~safe_handle
	lea	ecx, DWORD PTR _helper_process$[ebp]
	call	??1safe_handle@@QAE@XZ			; safe_handle::~safe_handle
	mov	al, BYTE PTR $T6[ebp]
	jmp	$LN10@CheckQSVHa
$LN6@CheckQSVHa:

; 367  :     }
; 368  : 
; 369  :     static bool warning_logged = false;
; 370  :     if (code == EXIT_NO_INTEL_GRAPHICS && (!warning_logged || log))

	cmp	DWORD PTR _code$[ebp], 2
	jne	SHORT $LN4@CheckQSVHa
	movzx	ecx, BYTE PTR ?warning_logged@?N@??CheckQSVHardwareSupport@@YA_N_NPA_N@Z@4_NA
	test	ecx, ecx
	je	SHORT $LN3@CheckQSVHa
	movzx	edx, BYTE PTR _log$[ebp]
	test	edx, edx
	je	SHORT $LN4@CheckQSVHa
$LN3@CheckQSVHa:

; 371  :     {
; 372  :         Log(L"No Intel graphics adapter visible in QSVHelper.exe, Optimus problem?");

	push	OFFSET $SG4294870610
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 4

; 373  :         warning_logged = true;

	mov	BYTE PTR ?warning_logged@?N@??CheckQSVHardwareSupport@@YA_N_NPA_N@Z@4_NA, 1
$LN4@CheckQSVHa:

; 374  :     }
; 375  : 
; 376  :     if (configurationWarning)

	cmp	DWORD PTR _configurationWarning$[ebp], 0
	je	SHORT $LN2@CheckQSVHa

; 377  :         *configurationWarning = code == EXIT_NO_INTEL_GRAPHICS && qsv_get_cpu_platform() != QSV_CPU_PLATFORM_UNKNOWN;

	cmp	DWORD PTR _code$[ebp], 2
	jne	SHORT $LN12@CheckQSVHa
	call	?qsv_get_cpu_platform@?A0x7e09c670@@YA?AW4qsv_cpu_platform@1@XZ ; `anonymous namespace'::qsv_get_cpu_platform
	test	eax, eax
	je	SHORT $LN12@CheckQSVHa
	mov	DWORD PTR tv180[ebp], 1
	jmp	SHORT $LN13@CheckQSVHa
$LN12@CheckQSVHa:
	mov	DWORD PTR tv180[ebp], 0
$LN13@CheckQSVHa:
	mov	eax, DWORD PTR _configurationWarning$[ebp]
	mov	cl, BYTE PTR tv180[ebp]
	mov	BYTE PTR [eax], cl
$LN2@CheckQSVHa:

; 378  : 
; 379  :     if(log)

	movzx	edx, BYTE PTR _log$[ebp]
	test	edx, edx
	je	SHORT $LN1@CheckQSVHa

; 380  :         Log(TEXT("Failed to initialize QSV hardware session"));

	push	OFFSET $SG4294870609
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 4
$LN1@CheckQSVHa:

; 381  :     return false;

	mov	BYTE PTR $T5[ebp], 0
	lea	ecx, DWORD PTR _req$[ebp]
	call	??1?$IPCSignalledType@Uinit_request@@@@QAE@XZ
	lea	ecx, DWORD PTR _event_prefix$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _waiter$[ebp]
	call	??1IPCWaiter@@QAE@XZ
	lea	ecx, DWORD PTR _helper_thread$[ebp]
	call	??1safe_handle@@QAE@XZ			; safe_handle::~safe_handle
	lea	ecx, DWORD PTR _helper_process$[ebp]
	call	??1safe_handle@@QAE@XZ			; safe_handle::~safe_handle
	mov	al, BYTE PTR $T5[ebp]
$LN10@CheckQSVHa:

; 382  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?CheckQSVHardwareSupport@@YA_N_NPA_N@Z ENDP		; CheckQSVHardwareSupport
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0IPCWaiter@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0IPCWaiter@@QAE@XZ PROC				; IPCWaiter::IPCWaiter, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@XZ ; std::vector<void *,std::allocator<void *> >::vector<void *,std::allocator<void *> >
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0IPCWaiter@@QAE@XZ ENDP				; IPCWaiter::IPCWaiter
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1IPCWaiter@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1IPCWaiter@@QAE@XZ PROC				; IPCWaiter::~IPCWaiter, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@XZ ; std::vector<void *,std::allocator<void *> >::~vector<void *,std::allocator<void *> >
	mov	esp, ebp
	pop	ebp
	ret	0
??1IPCWaiter@@QAE@XZ ENDP				; IPCWaiter::~IPCWaiter
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$IPCSignalledType@Uinit_request@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$IPCSignalledType@Uinit_request@@@@QAE@XZ PROC	; IPCSignalledType<init_request>::~IPCSignalledType<init_request>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	??1?$IPCSignal@$0A@@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$IPCType@Uinit_request@@@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$IPCSignalledType@Uinit_request@@@@QAE@XZ ENDP	; IPCSignalledType<init_request>::~IPCSignalledType<init_request>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$IPCType@Uinit_request@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$IPCType@Uinit_request@@@@QAE@XZ PROC		; IPCType<init_request>::~IPCType<init_request>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1NamedSharedMemory@@QAE@XZ		; NamedSharedMemory::~NamedSharedMemory
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$IPCType@Uinit_request@@@@QAE@XZ ENDP		; IPCType<init_request>::~IPCType<init_request>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$IPCSignal@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$IPCSignal@$0A@@@QAE@XZ PROC			; IPCSignal<0>::~IPCSignal<0>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1safe_handle@@QAE@XZ			; safe_handle::~safe_handle
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$IPCSignal@$0A@@@QAE@XZ ENDP			; IPCSignal<0>::~IPCSignal<0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ?IsKnownQSVCPUPlatform@@YA_NXZ
_TEXT	SEGMENT
tv68 = -4						; size = 4
?IsKnownQSVCPUPlatform@@YA_NXZ PROC			; IsKnownQSVCPUPlatform, COMDAT

; 385  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 386  :     static qsv_cpu_platform plat = qsv_get_cpu_platform();

	mov	eax, DWORD PTR ?$S1@?1??IsKnownQSVCPUPlatform@@YA_NXZ@4IA
	and	eax, 1
	jne	SHORT $LN4@IsKnownQSV
	mov	ecx, DWORD PTR ?$S1@?1??IsKnownQSVCPUPlatform@@YA_NXZ@4IA
	or	ecx, 1
	mov	DWORD PTR ?$S1@?1??IsKnownQSVCPUPlatform@@YA_NXZ@4IA, ecx
	call	?qsv_get_cpu_platform@?A0x7e09c670@@YA?AW4qsv_cpu_platform@1@XZ ; `anonymous namespace'::qsv_get_cpu_platform
	mov	DWORD PTR ?plat@?1??IsKnownQSVCPUPlatform@@YA_NXZ@4W4qsv_cpu_platform@?A0x7e09c670@@A, eax
$LN4@IsKnownQSV:

; 387  :     switch (plat)

	mov	edx, DWORD PTR ?plat@?1??IsKnownQSVCPUPlatform@@YA_NXZ@4W4qsv_cpu_platform@?A0x7e09c670@@A
	mov	DWORD PTR tv68[ebp], edx
	cmp	DWORD PTR tv68[ebp], 0
	jle	SHORT $LN2@IsKnownQSV
	cmp	DWORD PTR tv68[ebp], 6
	jle	SHORT $LN1@IsKnownQSV
	jmp	SHORT $LN2@IsKnownQSV
$LN1@IsKnownQSV:

; 388  :     {
; 389  :     case QSV_CPU_PLATFORM_BNL:
; 390  :     case QSV_CPU_PLATFORM_SNB:
; 391  :     case QSV_CPU_PLATFORM_IVB:
; 392  :     case QSV_CPU_PLATFORM_SLM:
; 393  :     case QSV_CPU_PLATFORM_CHT:
; 394  :     case QSV_CPU_PLATFORM_HSW:
; 395  :         return true;

	mov	al, 1
	jmp	SHORT $LN5@IsKnownQSV
$LN2@IsKnownQSV:

; 396  :     }
; 397  :     return false;

	xor	al, al
$LN5@IsKnownQSV:

; 398  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsKnownQSVCPUPlatform@@YA_NXZ ENDP			; IsKnownQSVCPUPlatform
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ?QSVMethodAvailable@@YA_NG@Z
_TEXT	SEGMENT
tv74 = -12						; size = 4
tv71 = -8						; size = 4
tv69 = -4						; size = 4
_method$ = 8						; size = 2
?QSVMethodAvailable@@YA_NG@Z PROC			; QSVMethodAvailable, COMDAT

; 401  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 402  :     static qsv_cpu_platform plat = qsv_get_cpu_platform();

	mov	eax, DWORD PTR ?$S2@?1??QSVMethodAvailable@@YA_NG@Z@4IA
	and	eax, 1
	jne	SHORT $LN5@QSVMethodA
	mov	ecx, DWORD PTR ?$S2@?1??QSVMethodAvailable@@YA_NG@Z@4IA
	or	ecx, 1
	mov	DWORD PTR ?$S2@?1??QSVMethodAvailable@@YA_NG@Z@4IA, ecx
	call	?qsv_get_cpu_platform@?A0x7e09c670@@YA?AW4qsv_cpu_platform@1@XZ ; `anonymous namespace'::qsv_get_cpu_platform
	mov	DWORD PTR ?plat@?1??QSVMethodAvailable@@YA_NG@Z@4W4qsv_cpu_platform@?A0x7e09c670@@A, eax
$LN5@QSVMethodA:

; 403  :     switch (method)

	movzx	edx, WORD PTR _method$[ebp]
	mov	DWORD PTR tv69[ebp], edx
	mov	eax, DWORD PTR tv69[ebp]
	sub	eax, 1
	mov	DWORD PTR tv69[ebp], eax
	cmp	DWORD PTR tv69[ebp], 10			; 0000000aH
	ja	SHORT $LN3@QSVMethodA
	mov	ecx, DWORD PTR tv69[ebp]
	movzx	edx, BYTE PTR $LN12@QSVMethodA[ecx]
	jmp	DWORD PTR $LN13@QSVMethodA[edx*4]
$LN2@QSVMethodA:

; 404  :     {
; 405  :     case MFX_RATECONTROL_CBR:
; 406  :     case MFX_RATECONTROL_VBR:
; 407  :     case MFX_RATECONTROL_AVBR:
; 408  :     case MFX_RATECONTROL_CQP:
; 409  :         return plat != QSV_CPU_PLATFORM_UNKNOWN;

	cmp	DWORD PTR ?plat@?1??QSVMethodAvailable@@YA_NG@Z@4W4qsv_cpu_platform@?A0x7e09c670@@A, 0
	je	SHORT $LN8@QSVMethodA
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN9@QSVMethodA
$LN8@QSVMethodA:
	mov	DWORD PTR tv71[ebp], 0
$LN9@QSVMethodA:
	mov	al, BYTE PTR tv71[ebp]
	jmp	SHORT $LN6@QSVMethodA
$LN1@QSVMethodA:

; 410  : 
; 411  :     case MFX_RATECONTROL_VCM:
; 412  :     case MFX_RATECONTROL_LA:
; 413  :     case MFX_RATECONTROL_ICQ:
; 414  :     case MFX_RATECONTROL_LA_ICQ:
; 415  :         return plat >= QSV_CPU_PLATFORM_HSW;

	cmp	DWORD PTR ?plat@?1??QSVMethodAvailable@@YA_NG@Z@4W4qsv_cpu_platform@?A0x7e09c670@@A, 6
	jl	SHORT $LN10@QSVMethodA
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN11@QSVMethodA
$LN10@QSVMethodA:
	mov	DWORD PTR tv74[ebp], 0
$LN11@QSVMethodA:
	mov	al, BYTE PTR tv74[ebp]
	jmp	SHORT $LN6@QSVMethodA
$LN3@QSVMethodA:

; 416  :     }
; 417  :     return false;

	xor	al, al
$LN6@QSVMethodA:

; 418  : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN13@QSVMethodA:
	DD	$LN2@QSVMethodA
	DD	$LN1@QSVMethodA
	DD	$LN3@QSVMethodA
$LN12@QSVMethodA:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	2
	DB	2
	DB	2
	DB	1
	DB	1
	DB	1
	DB	1
?QSVMethodAvailable@@YA_NG@Z ENDP			; QSVMethodAvailable
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ?FreeData@VideoPacket@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?FreeData@VideoPacket@@QAEXXZ PROC			; VideoPacket::FreeData, COMDAT
; _this$ = ecx

; 423  :     inline void FreeData() {Packet.Clear();}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@E@@QAEXXZ			; List<unsigned char>::Clear
	mov	esp, ebp
	pop	ebp
	ret	0
?FreeData@VideoPacket@@QAEXXZ ENDP			; VideoPacket::FreeData
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ?ClearPackets@QSVEncoder@@AAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
?ClearPackets@QSVEncoder@@AAEXXZ PROC			; QSVEncoder::ClearPackets, COMDAT
; _this$ = ecx

; 488  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 489  :         for(UINT i=0; i<CurrentPackets.Num(); i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN3@ClearPacke
$LN2@ClearPacke:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN3@ClearPacke:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 516				; 00000204H
	call	?Num@?$List@UVideoPacket@@@@QBEIXZ	; List<VideoPacket>::Num
	cmp	DWORD PTR _i$1[ebp], eax
	jae	SHORT $LN1@ClearPacke

; 490  :             CurrentPackets[i].FreeData();

	mov	ecx, DWORD PTR _i$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 516				; 00000204H
	call	??A?$List@UVideoPacket@@@@QAEAAUVideoPacket@@I@Z ; List<VideoPacket>::operator[]
	mov	ecx, eax
	call	?FreeData@VideoPacket@@QAEXXZ		; VideoPacket::FreeData
	jmp	SHORT $LN2@ClearPacke
$LN1@ClearPacke:

; 491  :         CurrentPackets.Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 516				; 00000204H
	call	?Clear@?$List@UVideoPacket@@@@QAEXXZ	; List<VideoPacket>::Clear

; 492  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?ClearPackets@QSVEncoder@@AAEXXZ ENDP			; QSVEncoder::ClearPackets
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ??0QSVEncoder@@QAE@HHHHPB_W_NAAUColorDescription@@HH1@Z
_TEXT	SEGMENT
_packet$ = -816						; size = 8
$T1 = -808						; size = 8
$T2 = -800						; size = 8
$T3 = -792						; size = 8
$T4 = -784						; size = 8
$T5 = -776						; size = 8
$T6 = -768						; size = 8
$T7 = -760						; size = 8
$T8 = -752						; size = 8
$T9 = -744						; size = 8
$T10 = -736						; size = 8
$T11 = -728						; size = 8
$T12 = -720						; size = 8
_response_waiter$ = -712				; size = 12
$T13 = -700						; size = 8
$T14 = -692						; size = 8
$T15 = -684						; size = 8
$T16 = -676						; size = 8
$T17 = -668						; size = 8
$T18 = -660						; size = 8
$T19 = -652						; size = 4
$T20 = -648						; size = 4
$T21 = -644						; size = 4
$T22 = -640						; size = 4
$T23 = -636						; size = 4
$T24 = -632						; size = 4
_bs_start$ = -628					; size = 4
_intf_str$ = -624					; size = 4
_keyframeInterval$ = -620				; size = 4
_actual_intf_str$ = -616				; size = 4
$T25 = -612						; size = 4
$T26 = -608						; size = 4
$T27 = -604						; size = 4
_paramList$28 = -600					; size = 8
_bframes$ = -592					; size = 4
tv234 = -588						; size = 4
_keyint$ = -584						; size = 4
tv282 = -580						; size = 4
tv677 = -576						; size = 4
_bframes_$29 = -572					; size = 4
tv635 = -568						; size = 4
_strCustomParams$30 = -564				; size = 8
tv626 = -556						; size = 4
_intf$31 = -552						; size = 4
tv619 = -548						; size = 4
_keyint_$32 = -544					; size = 4
tv479 = -540						; size = 4
tv1063 = -536						; size = 4
_length$ = -532						; size = 4
tv477 = -528						; size = 4
_version$33 = -524					; size = 8
_bs$34 = -516						; size = 4
_impl$ = -512						; size = 4
_frame_start$ = -508					; size = 4
_strParam$35 = -504					; size = 4
_bits$36 = -500						; size = 8
_qsv_preset$ = -492					; size = 4
_i$37 = -488						; size = 4
tv681 = -484						; size = 4
_strParamName$38 = -480					; size = 8
$T39 = -472						; size = 4
_code$40 = -468						; size = 4
_strParamVal$41 = -464					; size = 8
_frame$42 = -456					; size = 4
_use_global_bitrate$43 = -451				; size = 1
_use_global_buffer$44 = -450				; size = 1
_useCustomParams$ = -449				; size = 1
_i$45 = -448						; size = 4
_i$46 = -444						; size = 4
_ipc_fail$ = -440					; size = 4
_mfx$47 = -436						; size = 4
_load_int$48 = -429					; size = 1
_this$ = -428						; size = 4
$T49 = -424						; size = 64
$T50 = -360						; size = 64
$T51 = -296						; size = 56
$T52 = -240						; size = 48
$T53 = -192						; size = 40
$T54 = -152						; size = 40
_response$ = -112					; size = 48
_request$ = -64						; size = 48
_custom$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_fps$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_quality$ = 20						; size = 4
_preset$ = 24						; size = 4
_bUse444$ = 28						; size = 1
_colorDesc$ = 32					; size = 4
_maxBitrate$ = 36					; size = 4
_bufferSize$ = 40					; size = 4
_bUseCFR_$ = 44						; size = 1
??0QSVEncoder@@QAE@HHHHPB_W_NAAUColorDescription@@HH1@Z PROC ; QSVEncoder::QSVEncoder, COMDAT
; _this$ = ecx

; 498  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 816				; 00000330H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T39[ebp], 0
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0VideoEncoder@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7QSVEncoder@@6B@
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0safe_handle@@QAE@PAX@Z		; safe_handle::safe_handle
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??0safe_handle@@QAE@PAX@Z		; safe_handle::safe_handle
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0?$IPCSignal@$00@@QAE@XZ		; IPCSignal<1>::IPCSignal<1>

; 434  :     bool helper_killed = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+24], 0

; 498  :     {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	??0?$IPCSignal@$00@@QAE@XZ		; IPCSignal<1>::IPCSignal<1>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??0NamedSharedMemory@@QAE@XZ		; NamedSharedMemory::NamedSharedMemory
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	call	??0?$IPCArray@Ubitstream_info@@@@QAE@XZ	; IPCArray<bitstream_info>::IPCArray<bitstream_info>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	call	??0?$List@Uencode_task@QSVEncoder@@@@QAE@XZ ; List<QSVEncoder::encode_task>::List<QSVEncoder::encode_task>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 128				; 00000080H
	call	??0?$CircularList@I@@QAE@XZ		; CircularList<unsigned int>::CircularList<unsigned int>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??0?$CircularList@I@@QAE@XZ		; CircularList<unsigned int>::CircularList<unsigned int>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 168				; 000000a8H
	call	??0?$IPCLockedSignalledArray@Uqueued_frame@@@@QAE@XZ ; IPCLockedSignalledArray<queued_frame>::IPCLockedSignalledArray<queued_frame>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 232				; 000000e8H
	call	??0NamedSharedMemory@@QAE@XZ		; NamedSharedMemory::NamedSharedMemory
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 272				; 00000110H
	call	??0?$IPCLockedSignalledArray@I@@QAE@XZ	; IPCLockedSignalledArray<unsigned int>::IPCLockedSignalledArray<unsigned int>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 336				; 00000150H
	call	??0?$IPCLockedSignalledType@H@@QAE@XZ	; IPCLockedSignalledType<int>::IPCLockedSignalledType<int>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	??0IPCWaiter@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 404				; 00000194H
	call	??0IPCWaiter@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 416				; 000001a0H
	call	??0?$List@UmfxFrameData@@@@QAE@XZ	; List<mfxFrameData>::List<mfxFrameData>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 432				; 000001b0H
	call	??0DTSGenerator@?A0x7e09c670@@QAE@XZ	; `anonymous namespace'::DTSGenerator::DTSGenerator
	mov	edx, DWORD PTR _maxBitrate$[ebp]
	push	edx
	call	??$saturate@GH@@YAGH@Z			; saturate<unsigned short,int>
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+484], ax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 488				; 000001e8H
	call	DWORD PTR __imp_??0String@@QAE@XZ
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _fps$[ebp]
	mov	DWORD PTR [edx+496], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+501], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR [edx+504], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _height$[ebp]
	mov	DWORD PTR [ecx+508], edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 516				; 00000204H
	call	??0?$List@UVideoPacket@@@@QAE@XZ	; List<VideoPacket>::List<VideoPacket>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 524				; 0000020cH
	call	??0?$List@E@@QAE@XZ			; List<unsigned char>::List<unsigned char>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 532				; 00000214H
	call	??0?$List@E@@QAE@XZ			; List<unsigned char>::List<unsigned char>

; 499  :         bUseCBR = AppConfig->GetInt(TEXT("Video Encoding"), TEXT("UseCBR")) != 0;

	push	0
	push	OFFSET ??_C@_1O@GNHABGLI@?$AAU?$AAs?$AAe?$AAC?$AAB?$AAR?$AA?$AA@
	push	OFFSET ??_C@_1BO@PCCCHKLK@?$AAV?$AAi?$AAd?$AAe?$AAo?$AA?5?$AAE?$AAn?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA?$AA@
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	test	eax, eax
	je	SHORT $LN69@QSVEncoder
	mov	DWORD PTR tv234[ebp], 1
	jmp	SHORT $LN70@QSVEncoder
$LN69@QSVEncoder:
	mov	DWORD PTR tv234[ebp], 0
$LN70@QSVEncoder:
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR tv234[ebp]
	mov	BYTE PTR [eax+512], cl

; 500  :         bUseCFR = bUseCFR_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR _bUseCFR_$[ebp]
	mov	BYTE PTR [edx+513], al

; 501  : 
; 502  :         if (maxBitrate > max_bitrate)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+484]
	cmp	DWORD PTR _maxBitrate$[ebp], edx
	jle	SHORT $LN66@QSVEncoder

; 503  :             Log(L"Configured bitrate %d exceeds QSV maximum of %u!", maxBitrate, max_bitrate);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+484]
	push	ecx
	mov	edx, DWORD PTR _maxBitrate$[ebp]
	push	edx
	push	OFFSET ??_C@_1GC@LANNAHFH@?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AAu?$AAr?$AAe?$AAd?$AA?5?$AAb?$AAi?$AAt?$AAr?$AAa?$AAt?$AAe?$AA?5?$AA?$CF?$AAd?$AA?5?$AAe?$AAx?$AAc?$AAe?$AAe?$AAd?$AAs?$AA?5?$AAQ?$AAS@
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 12					; 0000000cH
$LN66@QSVEncoder:

; 504  : 
; 505  :         UINT keyframeInterval = AppConfig->GetInt(TEXT("Video Encoding"), TEXT("KeyframeInterval"), 6);

	push	6
	push	OFFSET ??_C@_1CC@INKCNOFG@?$AAK?$AAe?$AAy?$AAf?$AAr?$AAa?$AAm?$AAe?$AAI?$AAn?$AAt?$AAe?$AAr?$AAv?$AAa?$AAl?$AA?$AA@
	push	OFFSET ??_C@_1BO@PCCCHKLK@?$AAV?$AAi?$AAd?$AAe?$AAo?$AA?5?$AAE?$AAn?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA?$AA@
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _keyframeInterval$[ebp], eax

; 506  : 
; 507  :         int keyint = fps*keyframeInterval;

	mov	eax, DWORD PTR _fps$[ebp]
	imul	eax, DWORD PTR _keyframeInterval$[ebp]
	mov	DWORD PTR _keyint$[ebp], eax

; 508  :         int bframes = 7;

	mov	DWORD PTR _bframes$[ebp], 7

; 509  : 
; 510  :         int qsv_preset = AppConfig->GetInt(L"Video Encoding", L"QSVPreset", 1); // MFX_TARGETUSAGE_BEST_QUALITY

	push	1
	push	OFFSET ??_C@_1BE@ODBMCAAO@?$AAQ?$AAS?$AAV?$AAP?$AAr?$AAe?$AAs?$AAe?$AAt?$AA?$AA@
	push	OFFSET ??_C@_1BO@PCCCHKLK@?$AAV?$AAi?$AAd?$AAe?$AAo?$AA?5?$AAE?$AAn?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA?$AA@
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _qsv_preset$[ebp], eax

; 511  :         if (qsv_preset < MFX_TARGETUSAGE_1 || qsv_preset > MFX_TARGETUSAGE_7) qsv_preset = MFX_TARGETUSAGE_1;

	cmp	DWORD PTR _qsv_preset$[ebp], 1
	jl	SHORT $LN64@QSVEncoder
	cmp	DWORD PTR _qsv_preset$[ebp], 7
	jle	SHORT $LN65@QSVEncoder
$LN64@QSVEncoder:
	mov	DWORD PTR _qsv_preset$[ebp], 1
$LN65@QSVEncoder:

; 512  : 
; 513  :         profile = MFX_PROFILE_AVC_HIGH;

	mov	ecx, 100				; 00000064H
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+482], cx

; 514  :         if (AppConfig->GetString(TEXT("Video Encoding"), TEXT("X264Profile"), TEXT("high")) != L"high")

	push	OFFSET ??_C@_19PKICIIJD@?$AAh?$AAi?$AAg?$AAh?$AA?$AA@
	push	OFFSET ??_C@_19PKICIIJD@?$AAh?$AAi?$AAg?$AAh?$AA?$AA@
	push	OFFSET ??_C@_1BI@CHOFIDHM@?$AAX?$AA2?$AA6?$AA4?$AAP?$AAr?$AAo?$AAf?$AAi?$AAl?$AAe?$AA?$AA@
	push	OFFSET ??_C@_1BO@PCCCHKLK@?$AAV?$AAi?$AAd?$AAe?$AAo?$AA?5?$AAE?$AAn?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA?$AA@
	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetString@ConfigFile@@QAE?AVString@@PB_W00@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??9String@@QBEHPB_W@Z
	mov	DWORD PTR $T22[ebp], eax
	lea	ecx, DWORD PTR $T7[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	cmp	DWORD PTR $T22[ebp], 0
	je	SHORT $LN63@QSVEncoder

; 515  :             profile = MFX_PROFILE_AVC_MAIN;

	mov	ecx, 77					; 0000004dH
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+482], cx
$LN63@QSVEncoder:

; 516  : 
; 517  :         bHaveCustomImpl = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+8], 0

; 518  :         impl_parameters custom = { 0 };

	mov	DWORD PTR _custom$[ebp], 0
	xor	ecx, ecx
	mov	DWORD PTR _custom$[ebp+4], ecx
	mov	DWORD PTR _custom$[ebp+8], ecx

; 519  : 
; 520  :         bool useCustomParams = AppConfig->GetInt(TEXT("Video Encoding"), TEXT("QSVUseVideoEncoderSettings")) != 0;

	push	0
	push	OFFSET ??_C@_1DG@KLBNDPKC@?$AAQ?$AAS?$AAV?$AAU?$AAs?$AAe?$AAV?$AAi?$AAd?$AAe?$AAo?$AAE?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AAS?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AAs?$AA?$AA@
	push	OFFSET ??_C@_1BO@PCCCHKLK@?$AAV?$AAi?$AAd?$AAe?$AAo?$AA?5?$AAE?$AAn?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA?$AA@
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	test	eax, eax
	je	SHORT $LN71@QSVEncoder
	mov	DWORD PTR tv282[ebp], 1
	jmp	SHORT $LN72@QSVEncoder
$LN71@QSVEncoder:
	mov	DWORD PTR tv282[ebp], 0
$LN72@QSVEncoder:
	mov	dl, BYTE PTR tv282[ebp]
	mov	BYTE PTR _useCustomParams$[ebp], dl

; 521  :         if(useCustomParams)

	movzx	eax, BYTE PTR _useCustomParams$[ebp]
	test	eax, eax
	je	$LN62@QSVEncoder

; 522  :         {
; 523  :             StringList paramList;

	lea	ecx, DWORD PTR _paramList$28[ebp]
	call	DWORD PTR __imp_??0StringList@@QAE@XZ

; 524  :             String strCustomParams = AppConfig->GetString(TEXT("Video Encoding"), TEXT("CustomQSVSettings"));

	push	0
	push	OFFSET ??_C@_1CE@FAHANJKA@?$AAC?$AAu?$AAs?$AAt?$AAo?$AAm?$AAQ?$AAS?$AAV?$AAS?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AAs?$AA?$AA@
	push	OFFSET ??_C@_1BO@PCCCHKLK@?$AAV?$AAi?$AAd?$AAe?$AAo?$AA?5?$AAE?$AAn?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA?$AA@
	lea	ecx, DWORD PTR _strCustomParams$30[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetString@ConfigFile@@QAE?AVString@@PB_W00@Z

; 525  :             strCustomParams.KillSpaces();

	lea	ecx, DWORD PTR _strCustomParams$30[ebp]
	call	DWORD PTR __imp_?KillSpaces@String@@QAEAAV1@XZ

; 526  : 
; 527  :             if(strCustomParams.IsValid())

	lea	ecx, DWORD PTR _strCustomParams$30[ebp]
	call	DWORD PTR __imp_?IsValid@String@@QBEHXZ
	test	eax, eax
	je	$LN61@QSVEncoder

; 528  :             {
; 529  :                 Log(TEXT("Using custom encoder settings: \"%s\""), strCustomParams.Array());

	lea	ecx, DWORD PTR _strCustomParams$30[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET ??_C@_1EI@EDAOEDLO@?$AAU?$AAs?$AAi?$AAn?$AAg?$AA?5?$AAc?$AAu?$AAs?$AAt?$AAo?$AAm?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?5?$AAs?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AAs?$AA?3?$AA?5?$AA?$CC@
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8

; 530  : 
; 531  :                 strCustomParams.GetTokenList(paramList, ' ', FALSE);

	push	0
	push	32					; 00000020H
	lea	edx, DWORD PTR _paramList$28[ebp]
	push	edx
	lea	ecx, DWORD PTR _strCustomParams$30[ebp]
	call	DWORD PTR __imp_?GetTokenList@String@@QBEXAAVStringList@@_WH@Z

; 532  :                 for(UINT i=0; i<paramList.Num(); i++)

	mov	DWORD PTR _i$37[ebp], 0
	jmp	SHORT $LN60@QSVEncoder
$LN59@QSVEncoder:
	mov	eax, DWORD PTR _i$37[ebp]
	add	eax, 1
	mov	DWORD PTR _i$37[ebp], eax
$LN60@QSVEncoder:
	lea	ecx, DWORD PTR _paramList$28[ebp]
	call	DWORD PTR __imp_?Num@?$List@VString@@@@QBEIXZ
	cmp	DWORD PTR _i$37[ebp], eax
	jae	$LN61@QSVEncoder

; 533  :                 {
; 534  :                     String &strParam = paramList[i];

	mov	ecx, DWORD PTR _i$37[ebp]
	push	ecx
	lea	ecx, DWORD PTR _paramList$28[ebp]
	call	DWORD PTR __imp_??A?$List@VString@@@@QAEAAVString@@I@Z
	mov	DWORD PTR _strParam$35[ebp], eax

; 535  :                     if(!schr(strParam, '='))

	push	61					; 0000003dH
	mov	ecx, DWORD PTR _strParam$35[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?schr@@YGPA_WPB_W_W@Z
	test	eax, eax
	jne	SHORT $LN57@QSVEncoder

; 536  :                         continue;

	jmp	SHORT $LN59@QSVEncoder
$LN57@QSVEncoder:

; 537  : 
; 538  :                     String strParamName = strParam.GetToken(0, '=');

	push	61					; 0000003dH
	push	0
	lea	edx, DWORD PTR _strParamName$38[ebp]
	push	edx
	mov	ecx, DWORD PTR _strParam$35[ebp]
	call	DWORD PTR __imp_?GetToken@String@@QBE?AV1@H_W@Z

; 539  :                     String strParamVal  = strParam.GetTokenOffset(1, '=');

	push	61					; 0000003dH
	push	1
	mov	ecx, DWORD PTR _strParam$35[ebp]
	call	DWORD PTR __imp_?GetTokenOffset@String@@QBEPB_WH_W@Z
	push	eax
	lea	ecx, DWORD PTR _strParamVal$41[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PB_W@Z

; 540  : 
; 541  :                     if(strParamName == "keyint")

	push	OFFSET ??_C@_06IONMGJI@keyint?$AA@
	lea	ecx, DWORD PTR $T18[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PBD@Z
	lea	eax, DWORD PTR $T18[ebp]
	push	eax
	lea	ecx, DWORD PTR _strParamName$38[ebp]
	call	DWORD PTR __imp_??8String@@QBEHABV0@@Z
	mov	DWORD PTR $T20[ebp], eax
	lea	ecx, DWORD PTR $T18[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	cmp	DWORD PTR $T20[ebp], 0
	je	SHORT $LN56@QSVEncoder

; 542  :                     {
; 543  :                         int keyint_ = strParamVal.ToInt();

	push	10					; 0000000aH
	lea	ecx, DWORD PTR _strParamVal$41[ebp]
	call	DWORD PTR __imp_?ToInt@String@@QBEHH@Z
	mov	DWORD PTR _keyint_$32[ebp], eax

; 544  :                         if(keyint_ < 0)

	cmp	DWORD PTR _keyint_$32[ebp], 0
	jge	SHORT $LN55@QSVEncoder

; 545  :                             continue;

	lea	ecx, DWORD PTR _strParamVal$41[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strParamName$38[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	jmp	$LN59@QSVEncoder
$LN55@QSVEncoder:

; 546  :                         keyint = keyint_;

	mov	ecx, DWORD PTR _keyint_$32[ebp]
	mov	DWORD PTR _keyint$[ebp], ecx
	jmp	$LN54@QSVEncoder
$LN56@QSVEncoder:

; 547  :                     }
; 548  :                     else if(strParamName == "bframes")

	push	OFFSET ??_C@_07IBIPAAJI@bframes?$AA@
	lea	ecx, DWORD PTR $T15[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PBD@Z
	lea	edx, DWORD PTR $T15[ebp]
	push	edx
	lea	ecx, DWORD PTR _strParamName$38[ebp]
	call	DWORD PTR __imp_??8String@@QBEHABV0@@Z
	mov	DWORD PTR $T25[ebp], eax
	lea	ecx, DWORD PTR $T15[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	cmp	DWORD PTR $T25[ebp], 0
	je	SHORT $LN53@QSVEncoder

; 549  :                     {
; 550  :                         int bframes_ = strParamVal.ToInt();

	push	10					; 0000000aH
	lea	ecx, DWORD PTR _strParamVal$41[ebp]
	call	DWORD PTR __imp_?ToInt@String@@QBEHH@Z
	mov	DWORD PTR _bframes_$29[ebp], eax

; 551  :                         if(bframes_ < 0)

	cmp	DWORD PTR _bframes_$29[ebp], 0
	jge	SHORT $LN52@QSVEncoder

; 552  :                             continue;

	lea	ecx, DWORD PTR _strParamVal$41[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strParamName$38[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	jmp	$LN59@QSVEncoder
$LN52@QSVEncoder:

; 553  :                         bframes = bframes_;

	mov	eax, DWORD PTR _bframes_$29[ebp]
	mov	DWORD PTR _bframes$[ebp], eax
	jmp	$LN54@QSVEncoder
$LN53@QSVEncoder:

; 554  :                     }
; 555  :                     else if(strParamName == "qsvimpl")

	push	OFFSET ??_C@_07DKALODOL@qsvimpl?$AA@
	lea	ecx, DWORD PTR $T14[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T14[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strParamName$38[ebp]
	call	DWORD PTR __imp_??8String@@QBEHABV0@@Z
	mov	DWORD PTR $T26[ebp], eax
	lea	ecx, DWORD PTR $T14[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	cmp	DWORD PTR $T26[ebp], 0
	je	$LN50@QSVEncoder

; 556  :                     {
; 557  :                         StringList bits;

	lea	ecx, DWORD PTR _bits$36[ebp]
	call	DWORD PTR __imp_??0StringList@@QAE@XZ

; 558  :                         strParamVal.GetTokenList(bits, ',', true);

	push	1
	push	44					; 0000002cH
	lea	edx, DWORD PTR _bits$36[ebp]
	push	edx
	lea	ecx, DWORD PTR _strParamVal$41[ebp]
	call	DWORD PTR __imp_?GetTokenList@String@@QBEXAAVStringList@@_WH@Z

; 559  :                         if(bits.Num() < 3)

	lea	ecx, DWORD PTR _bits$36[ebp]
	call	DWORD PTR __imp_?Num@?$List@VString@@@@QBEIXZ
	cmp	eax, 3
	jae	SHORT $LN49@QSVEncoder

; 560  :                             continue;

	lea	ecx, DWORD PTR _bits$36[ebp]
	call	DWORD PTR __imp_??1StringList@@QAE@XZ
	lea	ecx, DWORD PTR _strParamVal$41[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strParamName$38[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	jmp	$LN59@QSVEncoder
$LN49@QSVEncoder:

; 561  : 
; 562  :                         StringList version;

	lea	ecx, DWORD PTR _version$33[ebp]
	call	DWORD PTR __imp_??0StringList@@QAE@XZ

; 563  :                         bits[2].GetTokenList(version, '.', false);

	push	0
	push	46					; 0000002eH
	lea	eax, DWORD PTR _version$33[ebp]
	push	eax
	push	2
	lea	ecx, DWORD PTR _bits$36[ebp]
	call	DWORD PTR __imp_??A?$List@VString@@@@QAEAAVString@@I@Z
	mov	ecx, eax
	call	DWORD PTR __imp_?GetTokenList@String@@QBEXAAVStringList@@_WH@Z

; 564  :                         if(version.Num() != 2)

	lea	ecx, DWORD PTR _version$33[ebp]
	call	DWORD PTR __imp_?Num@?$List@VString@@@@QBEIXZ
	cmp	eax, 2
	je	SHORT $LN48@QSVEncoder

; 565  :                             continue;

	lea	ecx, DWORD PTR _version$33[ebp]
	call	DWORD PTR __imp_??1StringList@@QAE@XZ
	lea	ecx, DWORD PTR _bits$36[ebp]
	call	DWORD PTR __imp_??1StringList@@QAE@XZ
	lea	ecx, DWORD PTR _strParamVal$41[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strParamName$38[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	jmp	$LN59@QSVEncoder
$LN48@QSVEncoder:

; 566  : 
; 567  :                         custom.type = bits[0].ToInt();

	push	10					; 0000000aH
	push	0
	lea	ecx, DWORD PTR _bits$36[ebp]
	call	DWORD PTR __imp_??A?$List@VString@@@@QAEAAVString@@I@Z
	mov	ecx, eax
	call	DWORD PTR __imp_?ToInt@String@@QBEHH@Z
	mov	DWORD PTR _custom$[ebp], eax

; 568  :                         if(custom.type == 0)

	cmp	DWORD PTR _custom$[ebp], 0
	jne	SHORT $LN47@QSVEncoder

; 569  :                             custom.type = MFX_IMPL_HARDWARE_ANY;

	mov	DWORD PTR _custom$[ebp], 4
$LN47@QSVEncoder:

; 570  : 
; 571  :                         auto &intf = bits[1].MakeLower();

	push	1
	lea	ecx, DWORD PTR _bits$36[ebp]
	call	DWORD PTR __imp_??A?$List@VString@@@@QAEAAVString@@I@Z
	mov	ecx, eax
	call	DWORD PTR __imp_?MakeLower@String@@QAEAAV1@XZ
	mov	DWORD PTR _intf$31[ebp], eax

; 572  :                         custom.intf = intf == "d3d11" ? MFX_IMPL_VIA_D3D11 : (intf == "d3d9" ? MFX_IMPL_VIA_D3D9 : MFX_IMPL_VIA_ANY);

	push	OFFSET ??_C@_05GMGJDJAH@d3d11?$AA@
	lea	ecx, DWORD PTR $T13[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T13[ebp]
	push	ecx
	mov	ecx, DWORD PTR _intf$31[ebp]
	call	DWORD PTR __imp_??8String@@QBEHABV0@@Z
	test	eax, eax
	je	SHORT $LN75@QSVEncoder
	mov	DWORD PTR tv479[ebp], 768		; 00000300H
	jmp	SHORT $LN76@QSVEncoder
$LN75@QSVEncoder:
	push	OFFSET ??_C@_04PGKLGAGG@d3d9?$AA@
	lea	ecx, DWORD PTR $T17[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PBD@Z
	or	DWORD PTR $T39[ebp], 1
	lea	edx, DWORD PTR $T17[ebp]
	push	edx
	mov	ecx, DWORD PTR _intf$31[ebp]
	call	DWORD PTR __imp_??8String@@QBEHABV0@@Z
	test	eax, eax
	je	SHORT $LN73@QSVEncoder
	mov	DWORD PTR tv477[ebp], 512		; 00000200H
	jmp	SHORT $LN74@QSVEncoder
$LN73@QSVEncoder:
	mov	DWORD PTR tv477[ebp], 256		; 00000100H
$LN74@QSVEncoder:
	mov	eax, DWORD PTR tv477[ebp]
	mov	DWORD PTR tv479[ebp], eax
$LN76@QSVEncoder:
	mov	ecx, DWORD PTR tv479[ebp]
	mov	DWORD PTR _custom$[ebp+4], ecx
	mov	edx, DWORD PTR $T39[ebp]
	and	edx, 1
	je	SHORT $LN85@QSVEncoder
	and	DWORD PTR $T39[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T17[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN85@QSVEncoder:
	lea	ecx, DWORD PTR $T13[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 573  : 
; 574  :                         custom.version.Major = version[0].ToInt();

	push	10					; 0000000aH
	push	0
	lea	ecx, DWORD PTR _version$33[ebp]
	call	DWORD PTR __imp_??A?$List@VString@@@@QAEAAVString@@I@Z
	mov	ecx, eax
	call	DWORD PTR __imp_?ToInt@String@@QBEHH@Z
	mov	WORD PTR _custom$[ebp+10], ax

; 575  :                         custom.version.Minor = version[1].ToInt();

	push	10					; 0000000aH
	push	1
	lea	ecx, DWORD PTR _version$33[ebp]
	call	DWORD PTR __imp_??A?$List@VString@@@@QAEAAVString@@I@Z
	mov	ecx, eax
	call	DWORD PTR __imp_?ToInt@String@@QBEHH@Z
	mov	WORD PTR _custom$[ebp+8], ax

; 576  :                         bHaveCustomImpl = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+8], 1

; 577  :                     }

	lea	ecx, DWORD PTR _version$33[ebp]
	call	DWORD PTR __imp_??1StringList@@QAE@XZ
	lea	ecx, DWORD PTR _bits$36[ebp]
	call	DWORD PTR __imp_??1StringList@@QAE@XZ
	jmp	$LN54@QSVEncoder
$LN50@QSVEncoder:

; 578  :                     else if (strParamName == "profile")

	push	OFFSET ??_C@_07LNMDFKEJ@profile?$AA@
	lea	ecx, DWORD PTR $T16[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T16[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strParamName$38[ebp]
	call	DWORD PTR __imp_??8String@@QBEHABV0@@Z
	mov	DWORD PTR $T24[ebp], eax
	lea	ecx, DWORD PTR $T16[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	cmp	DWORD PTR $T24[ebp], 0
	je	$LN54@QSVEncoder

; 579  :                     {
; 580  :                         if (strParamVal == L"baseline")

	push	OFFSET ??_C@_1BC@PBFEDEIE@?$AAb?$AAa?$AAs?$AAe?$AAl?$AAi?$AAn?$AAe?$AA?$AA@
	lea	ecx, DWORD PTR _strParamVal$41[ebp]
	call	DWORD PTR __imp_??8String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN44@QSVEncoder

; 581  :                             profile = MFX_PROFILE_AVC_BASELINE;

	mov	edx, 66					; 00000042H
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+482], dx
	jmp	SHORT $LN54@QSVEncoder
$LN44@QSVEncoder:

; 582  :                         else if (strParamVal == L"main")

	push	OFFSET ??_C@_19NACPGGMO@?$AAm?$AAa?$AAi?$AAn?$AA?$AA@
	lea	ecx, DWORD PTR _strParamVal$41[ebp]
	call	DWORD PTR __imp_??8String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN42@QSVEncoder

; 583  :                             profile = MFX_PROFILE_AVC_MAIN;

	mov	ecx, 77					; 0000004dH
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+482], cx
	jmp	SHORT $LN54@QSVEncoder
$LN42@QSVEncoder:

; 584  :                         else if (strParamVal == L"high")

	push	OFFSET ??_C@_19PKICIIJD@?$AAh?$AAi?$AAg?$AAh?$AA?$AA@
	lea	ecx, DWORD PTR _strParamVal$41[ebp]
	call	DWORD PTR __imp_??8String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN40@QSVEncoder

; 585  :                             profile = MFX_PROFILE_AVC_HIGH;

	mov	eax, 100				; 00000064H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+482], ax

; 586  :                         else

	jmp	SHORT $LN54@QSVEncoder
$LN40@QSVEncoder:

; 587  :                         {
; 588  :                             profile = MFX_PROFILE_AVC_HIGH;

	mov	edx, 100				; 00000064H
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+482], dx

; 589  :                             Log(L"QSV: Unrecognized profile '%s', profile reset to default", strParamName.Array());

	lea	ecx, DWORD PTR _strParamName$38[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET ??_C@_1HC@EHFMGPIB@?$AAQ?$AAS?$AAV?$AA?3?$AA?5?$AAU?$AAn?$AAr?$AAe?$AAc?$AAo?$AAg?$AAn?$AAi?$AAz?$AAe?$AAd?$AA?5?$AAp?$AAr?$AAo?$AAf?$AAi?$AAl?$AAe?$AA?5?$AA?8?$AA?$CF?$AAs?$AA?8?$AA?0?$AA?5@
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8
$LN54@QSVEncoder:

; 590  :                         }
; 591  :                     }
; 592  :                 }

	lea	ecx, DWORD PTR _strParamVal$41[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strParamName$38[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	jmp	$LN59@QSVEncoder
$LN61@QSVEncoder:

; 593  :             }
; 594  :         }

	lea	ecx, DWORD PTR _strCustomParams$30[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _paramList$28[ebp]
	call	DWORD PTR __imp_??1StringList@@QAE@XZ
$LN62@QSVEncoder:

; 595  : 
; 596  :         if (!spawn_helper(event_prefix, qsvhelper_process, qsvhelper_thread, process_waiter))

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 16					; 00000010H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 488				; 000001e8H
	push	ecx
	call	?spawn_helper@?A0x7e09c670@@YA_NAAVString@@AAUsafe_handle@@1AAUIPCWaiter@@@Z ; `anonymous namespace'::spawn_helper
	add	esp, 16					; 00000010H
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN38@QSVEncoder

; 597  :         {
; 598  :             if (OSGetVersion() < 7)

	call	DWORD PTR __imp_?OSGetVersion@@YGHXZ
	cmp	eax, 7
	jge	SHORT $LN37@QSVEncoder

; 599  :                 ThrowQSVInitError(L"QSV is no longer supported on Vista", Str("Encoder.QSV.HelperLaunchFailedVista"));

	push	OFFSET ??_C@_1EI@MGAFFPDA@?$AAE?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?4?$AAQ?$AAS?$AAV?$AA?4?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AAL?$AAa?$AAu?$AAn?$AAc?$AAh?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AAV?$AAi@
	mov	eax, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	push	OFFSET ??_C@_1EI@BEBMIADP@?$AAQ?$AAS?$AAV?$AA?5?$AAi?$AAs?$AA?5?$AAn?$AAo?$AA?5?$AAl?$AAo?$AAn?$AAg?$AAe?$AAr?$AA?5?$AAs?$AAu?$AAp?$AAp?$AAo?$AAr?$AAt?$AAe?$AAd?$AA?5?$AAo?$AAn?$AA?5?$AAV?$AAi@
	call	??$ThrowQSVInitError@$$$V@?A0x7e09c670@@YAXPB_W0@Z ; `anonymous namespace'::ThrowQSVInitError<>
	add	esp, 8
$LN37@QSVEncoder:

; 600  :             ThrowQSVInitError(L"Couldn't launch QSVHelper.exe: %u!", Str("Encoder.QSV.HelperLaunchFailed"), GetLastError());

	call	DWORD PTR __imp__GetLastError@0
	push	eax
	push	OFFSET ??_C@_1DO@OPJHFIHF@?$AAE?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?4?$AAQ?$AAS?$AAV?$AA?4?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AAL?$AAa?$AAu?$AAn?$AAc?$AAh?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?$AA@
	mov	ecx, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	push	OFFSET ??_C@_1EG@KGHDNBFC@?$AAC?$AAo?$AAu?$AAl?$AAd?$AAn?$AA?8?$AAt?$AA?5?$AAl?$AAa?$AAu?$AAn?$AAc?$AAh?$AA?5?$AAQ?$AAS?$AAV?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AA?4?$AAe?$AAx?$AAe?$AA?3?$AA?5?$AA?$CF@
	call	??$ThrowQSVInitError@K@?A0x7e09c670@@YAXPB_W0K@Z ; `anonymous namespace'::ThrowQSVInitError<unsigned long>
	add	esp, 12					; 0000000cH
$LN38@QSVEncoder:

; 601  :         }
; 602  : 
; 603  :         ipc_init_request request((event_prefix + INIT_REQUEST).Array());

	push	OFFSET ??_C@_1BK@BCABKOOC@?$AAi?$AAn?$AAi?$AAt?$AA_?$AAr?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AA?$AA@
	lea	edx, DWORD PTR $T9[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 488				; 000001e8H
	call	DWORD PTR __imp_??HString@@QBE?AV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	push	eax
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	lea	ecx, DWORD PTR _request$[ebp]
	call	??0?$IPCSignalledType@Uinit_request@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; IPCSignalledType<init_request>::IPCSignalledType<init_request>
	lea	ecx, DWORD PTR $T9[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 604  : 
; 605  :         if (AppConfig->GetInt(L"QSV (Advanced)", L"UseCustomParams"))

	push	0
	push	OFFSET ??_C@_1CA@CDIPFIBO@?$AAU?$AAs?$AAe?$AAC?$AAu?$AAs?$AAt?$AAo?$AAm?$AAP?$AAa?$AAr?$AAa?$AAm?$AAs?$AA?$AA@
	push	OFFSET ??_C@_1BO@ENCKOBAL@?$AAQ?$AAS?$AAV?$AA?5?$AA?$CI?$AAA?$AAd?$AAv?$AAa?$AAn?$AAc?$AAe?$AAd?$AA?$CJ?$AA?$AA@
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	test	eax, eax
	je	$LN36@QSVEncoder

; 606  :         {
; 607  :             Log(L"QSV: Using custom parameters");

	push	OFFSET ??_C@_1DK@IPJBHBLN@?$AAQ?$AAS?$AAV?$AA?3?$AA?5?$AAU?$AAs?$AAi?$AAn?$AAg?$AA?5?$AAc?$AAu?$AAs?$AAt?$AAo?$AAm?$AA?5?$AAp?$AAa?$AAr?$AAa?$AAm?$AAe?$AAt?$AAe?$AAr?$AAs?$AA?$AA@
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 4

; 608  :             request->use_custom_parameters = true;

	lea	ecx, DWORD PTR _request$[ebp]
	call	??C?$IPCType@Uinit_request@@@@QAEPAUinit_request@@XZ ; IPCType<init_request>::operator->
	mov	BYTE PTR [eax+41], 1

; 609  :             auto &mfx = request->custom_parameters;

	lea	ecx, DWORD PTR _request$[ebp]
	call	??C?$IPCType@Uinit_request@@@@QAEPAUinit_request@@XZ ; IPCType<init_request>::operator->
	add	eax, 42					; 0000002aH
	mov	DWORD PTR _mfx$47[ebp], eax

; 610  :             mfx.RateControlMethod = AppConfig->GetInt(L"QSV (Advanced)", L"RateControlMethod", MFX_RATECONTROL_VBR);

	push	2
	push	OFFSET ??_C@_1CE@IBGNPBIO@?$AAR?$AAa?$AAt?$AAe?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AAM?$AAe?$AAt?$AAh?$AAo?$AAd?$AA?$AA@
	push	OFFSET ??_C@_1BO@ENCKOBAL@?$AAQ?$AAS?$AAV?$AA?5?$AA?$CI?$AAA?$AAd?$AAv?$AAa?$AAn?$AAc?$AAe?$AAd?$AA?$CJ?$AA?$AA@
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	ecx, DWORD PTR _mfx$47[ebp]
	mov	WORD PTR [ecx+120], ax

; 611  :             if (!valid_method(mfx.RateControlMethod))

	mov	edx, DWORD PTR _mfx$47[ebp]
	movzx	eax, WORD PTR [edx+120]
	push	eax
	call	?valid_method@@YA_NG@Z			; valid_method
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN35@QSVEncoder

; 612  :                 mfx.RateControlMethod = MFX_RATECONTROL_VBR;

	mov	edx, 2
	mov	eax, DWORD PTR _mfx$47[ebp]
	mov	WORD PTR [eax+120], dx
$LN35@QSVEncoder:

; 613  : 
; 614  :             auto load_int = [&](CTSTR name, int def) { return AppConfig->GetInt(L"QSV (Advanced)", name, def); };
; 615  : 
; 616  :             bool use_global_bitrate = !!load_int(L"UseGlobalBitrate", true);

	push	1
	push	OFFSET ??_C@_1CC@HBKEGJCM@?$AAU?$AAs?$AAe?$AAG?$AAl?$AAo?$AAb?$AAa?$AAl?$AAB?$AAi?$AAt?$AAr?$AAa?$AAt?$AAe?$AA?$AA@
	lea	ecx, DWORD PTR _load_int$48[ebp]
	call	??R<lambda_11bcb1900b2e1535704e287762a2ec52>@@QBEHPB_WH@Z ; <lambda_11bcb1900b2e1535704e287762a2ec52>::operator()
	test	eax, eax
	je	SHORT $LN77@QSVEncoder
	mov	DWORD PTR tv619[ebp], 1
	jmp	SHORT $LN78@QSVEncoder
$LN77@QSVEncoder:
	mov	DWORD PTR tv619[ebp], 0
$LN78@QSVEncoder:
	mov	cl, BYTE PTR tv619[ebp]
	mov	BYTE PTR _use_global_bitrate$43[ebp], cl

; 617  :             bool use_global_buffer = !!load_int(L"UseGlobalBufferSize", true);

	push	1
	push	OFFSET ??_C@_1CI@KDHOMFIK@?$AAU?$AAs?$AAe?$AAG?$AAl?$AAo?$AAb?$AAa?$AAl?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAS?$AAi?$AAz?$AAe?$AA?$AA@
	lea	ecx, DWORD PTR _load_int$48[ebp]
	call	??R<lambda_11bcb1900b2e1535704e287762a2ec52>@@QBEHPB_WH@Z ; <lambda_11bcb1900b2e1535704e287762a2ec52>::operator()
	test	eax, eax
	je	SHORT $LN79@QSVEncoder
	mov	DWORD PTR tv626[ebp], 1
	jmp	SHORT $LN80@QSVEncoder
$LN79@QSVEncoder:
	mov	DWORD PTR tv626[ebp], 0
$LN80@QSVEncoder:
	mov	dl, BYTE PTR tv626[ebp]
	mov	BYTE PTR _use_global_buffer$44[ebp], dl

; 618  : 
; 619  :             mfx.TargetKbps = use_global_bitrate ? maxBitrate : load_int(L"TargetKbps", 1000);

	movzx	eax, BYTE PTR _use_global_bitrate$43[ebp]
	test	eax, eax
	je	SHORT $LN81@QSVEncoder
	mov	ecx, DWORD PTR _maxBitrate$[ebp]
	mov	DWORD PTR tv635[ebp], ecx
	jmp	SHORT $LN82@QSVEncoder
$LN81@QSVEncoder:
	push	1000					; 000003e8H
	push	OFFSET ??_C@_1BG@IDKHPHBG@?$AAT?$AAa?$AAr?$AAg?$AAe?$AAt?$AAK?$AAb?$AAp?$AAs?$AA?$AA@
	lea	ecx, DWORD PTR _load_int$48[ebp]
	call	??R<lambda_11bcb1900b2e1535704e287762a2ec52>@@QBEHPB_WH@Z ; <lambda_11bcb1900b2e1535704e287762a2ec52>::operator()
	mov	DWORD PTR tv635[ebp], eax
$LN82@QSVEncoder:
	mov	edx, DWORD PTR _mfx$47[ebp]
	mov	ax, WORD PTR tv635[ebp]
	mov	WORD PTR [edx+126], ax

; 620  :             mfx.BufferSizeInKB = use_global_buffer ? (bufferSize / 8) : load_int(L"BufferSizeInKB", 0);

	movzx	ecx, BYTE PTR _use_global_buffer$44[ebp]
	test	ecx, ecx
	je	SHORT $LN83@QSVEncoder
	mov	eax, DWORD PTR _bufferSize$[ebp]
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	DWORD PTR tv677[ebp], eax
	jmp	SHORT $LN84@QSVEncoder
$LN83@QSVEncoder:
	push	0
	push	OFFSET ??_C@_1BO@CJMDAOPJ@?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAS?$AAi?$AAz?$AAe?$AAI?$AAn?$AAK?$AAB?$AA?$AA@
	lea	ecx, DWORD PTR _load_int$48[ebp]
	call	??R<lambda_11bcb1900b2e1535704e287762a2ec52>@@QBEHPB_WH@Z ; <lambda_11bcb1900b2e1535704e287762a2ec52>::operator()
	mov	DWORD PTR tv677[ebp], eax
$LN84@QSVEncoder:
	mov	edx, DWORD PTR _mfx$47[ebp]
	mov	ax, WORD PTR tv677[ebp]
	mov	WORD PTR [edx+124], ax

; 621  :             
; 622  :             switch (mfx.RateControlMethod)

	mov	ecx, DWORD PTR _mfx$47[ebp]
	movzx	edx, WORD PTR [ecx+120]
	mov	DWORD PTR tv681[ebp], edx
	mov	eax, DWORD PTR tv681[ebp]
	sub	eax, 2
	mov	DWORD PTR tv681[ebp], eax
	cmp	DWORD PTR tv681[ebp], 9
	ja	$LN36@QSVEncoder
	mov	ecx, DWORD PTR tv681[ebp]
	jmp	DWORD PTR $LN86@QSVEncoder[ecx*4]
$LN32@QSVEncoder:

; 623  :             {
; 624  :             case MFX_RATECONTROL_VBR:
; 625  :             case MFX_RATECONTROL_VCM:
; 626  :                 mfx.MaxKbps = load_int(L"MaxKbps", 0);

	push	0
	push	OFFSET ??_C@_1BA@IBNIMAHO@?$AAM?$AAa?$AAx?$AAK?$AAb?$AAp?$AAs?$AA?$AA@
	lea	ecx, DWORD PTR _load_int$48[ebp]
	call	??R<lambda_11bcb1900b2e1535704e287762a2ec52>@@QBEHPB_WH@Z ; <lambda_11bcb1900b2e1535704e287762a2ec52>::operator()
	mov	edx, DWORD PTR _mfx$47[ebp]
	mov	WORD PTR [edx+128], ax

; 627  :                 break;

	jmp	$LN36@QSVEncoder
$LN31@QSVEncoder:

; 628  : 
; 629  :             case MFX_RATECONTROL_AVBR:
; 630  :                 mfx.Accuracy = clamp(load_int(L"Accuracy", 1000), 0, 1000);

	push	1000					; 000003e8H
	push	0
	push	1000					; 000003e8H
	push	OFFSET ??_C@_1BC@OHENPEDC@?$AAA?$AAc?$AAc?$AAu?$AAr?$AAa?$AAc?$AAy?$AA?$AA@
	lea	ecx, DWORD PTR _load_int$48[ebp]
	call	??R<lambda_11bcb1900b2e1535704e287762a2ec52>@@QBEHPB_WH@Z ; <lambda_11bcb1900b2e1535704e287762a2ec52>::operator()
	push	eax
	call	??$clamp@HHH@@YAHHHH@Z			; clamp<int,int,int>
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _mfx$47[ebp]
	mov	WORD PTR [ecx+122], ax

; 631  :                 mfx.Convergence = load_int(L"Convergence", 1);

	push	1
	push	OFFSET ??_C@_1BI@CJLLPJDH@?$AAC?$AAo?$AAn?$AAv?$AAe?$AAr?$AAg?$AAe?$AAn?$AAc?$AAe?$AA?$AA@
	lea	ecx, DWORD PTR _load_int$48[ebp]
	call	??R<lambda_11bcb1900b2e1535704e287762a2ec52>@@QBEHPB_WH@Z ; <lambda_11bcb1900b2e1535704e287762a2ec52>::operator()
	mov	edx, DWORD PTR _mfx$47[ebp]
	mov	WORD PTR [edx+128], ax

; 632  :                 break;

	jmp	$LN36@QSVEncoder
$LN30@QSVEncoder:

; 633  : 
; 634  :             case MFX_RATECONTROL_CQP:
; 635  :                 mfx.QPI = clamp(load_int(L"QPI", 23), 1, 51);

	push	51					; 00000033H
	push	1
	push	23					; 00000017H
	push	OFFSET ??_C@_17OJMDMMIO@?$AAQ?$AAP?$AAI?$AA?$AA@
	lea	ecx, DWORD PTR _load_int$48[ebp]
	call	??R<lambda_11bcb1900b2e1535704e287762a2ec52>@@QBEHPB_WH@Z ; <lambda_11bcb1900b2e1535704e287762a2ec52>::operator()
	push	eax
	call	??$clamp@HHH@@YAHHHH@Z			; clamp<int,int,int>
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _mfx$47[ebp]
	mov	WORD PTR [ecx+122], ax

; 636  :                 mfx.QPP = clamp(load_int(L"QPP", 23), 1, 51);

	push	51					; 00000033H
	push	1
	push	23					; 00000017H
	push	OFFSET ??_C@_17MENCNEJL@?$AAQ?$AAP?$AAP?$AA?$AA@
	lea	ecx, DWORD PTR _load_int$48[ebp]
	call	??R<lambda_11bcb1900b2e1535704e287762a2ec52>@@QBEHPB_WH@Z ; <lambda_11bcb1900b2e1535704e287762a2ec52>::operator()
	push	eax
	call	??$clamp@HHH@@YAHHHH@Z			; clamp<int,int,int>
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _mfx$47[ebp]
	mov	WORD PTR [edx+126], ax

; 637  :                 mfx.QPB = clamp(load_int(L"QPB", 23), 1, 51);

	push	51					; 00000033H
	push	1
	push	23					; 00000017H
	push	OFFSET ??_C@_17DOMCELIP@?$AAQ?$AAP?$AAB?$AA?$AA@
	lea	ecx, DWORD PTR _load_int$48[ebp]
	call	??R<lambda_11bcb1900b2e1535704e287762a2ec52>@@QBEHPB_WH@Z ; <lambda_11bcb1900b2e1535704e287762a2ec52>::operator()
	push	eax
	call	??$clamp@HHH@@YAHHHH@Z			; clamp<int,int,int>
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _mfx$47[ebp]
	mov	WORD PTR [ecx+128], ax

; 638  :                 break;

	jmp	$LN36@QSVEncoder
$LN29@QSVEncoder:

; 639  : 
; 640  :             case MFX_RATECONTROL_ICQ:
; 641  :             case MFX_RATECONTROL_LA_ICQ:
; 642  :                 mfx.ICQQuality = clamp(load_int(L"ICQQuality", 23), 1, 51);

	push	51					; 00000033H
	push	1
	push	23					; 00000017H
	push	OFFSET ??_C@_1BG@OLCPADEI@?$AAI?$AAC?$AAQ?$AAQ?$AAu?$AAa?$AAl?$AAi?$AAt?$AAy?$AA?$AA@
	lea	ecx, DWORD PTR _load_int$48[ebp]
	call	??R<lambda_11bcb1900b2e1535704e287762a2ec52>@@QBEHPB_WH@Z ; <lambda_11bcb1900b2e1535704e287762a2ec52>::operator()
	push	eax
	call	??$clamp@HHH@@YAHHHH@Z			; clamp<int,int,int>
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _mfx$47[ebp]
	mov	WORD PTR [edx+126], ax
$LN28@QSVEncoder:

; 643  :             case MFX_RATECONTROL_LA:
; 644  :                 request->la_depth = load_int(L"LADepth", 40);

	push	40					; 00000028H
	push	OFFSET ??_C@_1BA@IAHEMFAP@?$AAL?$AAA?$AAD?$AAe?$AAp?$AAt?$AAh?$AA?$AA@
	lea	ecx, DWORD PTR _load_int$48[ebp]
	call	??R<lambda_11bcb1900b2e1535704e287762a2ec52>@@QBEHPB_WH@Z ; <lambda_11bcb1900b2e1535704e287762a2ec52>::operator()
	mov	esi, eax
	lea	ecx, DWORD PTR _request$[ebp]
	call	??C?$IPCType@Uinit_request@@@@QAEPAUinit_request@@XZ ; IPCType<init_request>::operator->
	mov	WORD PTR [eax+178], si

; 645  :                 if (request->la_depth != 0)

	lea	ecx, DWORD PTR _request$[ebp]
	call	??C?$IPCType@Uinit_request@@@@QAEPAUinit_request@@XZ ; IPCType<init_request>::operator->
	movzx	eax, WORD PTR [eax+178]
	test	eax, eax
	je	SHORT $LN36@QSVEncoder

; 646  :                     request->la_depth = clamp(request->la_depth, 10, 100);

	push	100					; 00000064H
	push	10					; 0000000aH
	lea	ecx, DWORD PTR _request$[ebp]
	call	??C?$IPCType@Uinit_request@@@@QAEPAUinit_request@@XZ ; IPCType<init_request>::operator->
	mov	cx, WORD PTR [eax+178]
	movzx	edx, cx
	push	edx
	call	??$clamp@GHH@@YAGGHH@Z			; clamp<unsigned short,int,int>
	add	esp, 12					; 0000000cH
	mov	si, ax
	lea	ecx, DWORD PTR _request$[ebp]
	call	??C?$IPCType@Uinit_request@@@@QAEPAUinit_request@@XZ ; IPCType<init_request>::operator->
	mov	WORD PTR [eax+178], si
$LN36@QSVEncoder:

; 647  :             }
; 648  :         }
; 649  : 
; 650  :         request->mode = request->MODE_ENCODE;

	lea	ecx, DWORD PTR _request$[ebp]
	call	??C?$IPCType@Uinit_request@@@@QAEPAUinit_request@@XZ ; IPCType<init_request>::operator->
	lea	ecx, DWORD PTR _request$[ebp]
	call	??C?$IPCType@Uinit_request@@@@QAEPAUinit_request@@XZ ; IPCType<init_request>::operator->
	mov	DWORD PTR [eax], 1

; 651  :         request->obs_process_id = GetCurrentProcessId();

	call	DWORD PTR __imp__GetCurrentProcessId@0
	mov	esi, eax
	lea	ecx, DWORD PTR _request$[ebp]
	call	??C?$IPCType@Uinit_request@@@@QAEPAUinit_request@@XZ ; IPCType<init_request>::operator->
	mov	DWORD PTR [eax+4], esi

; 652  : 
; 653  :         request->target_usage = qsv_preset;

	lea	ecx, DWORD PTR _request$[ebp]
	call	??C?$IPCType@Uinit_request@@@@QAEPAUinit_request@@XZ ; IPCType<init_request>::operator->
	mov	cx, WORD PTR _qsv_preset$[ebp]
	mov	WORD PTR [eax+8], cx

; 654  :         request->profile = profile;

	lea	ecx, DWORD PTR _request$[ebp]
	call	??C?$IPCType@Uinit_request@@@@QAEPAUinit_request@@XZ ; IPCType<init_request>::operator->
	mov	edx, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [edx+482]
	mov	WORD PTR [eax+10], cx

; 655  :         request->fps = fps;

	lea	ecx, DWORD PTR _request$[ebp]
	call	??C?$IPCType@Uinit_request@@@@QAEPAUinit_request@@XZ ; IPCType<init_request>::operator->
	mov	edx, DWORD PTR _fps$[ebp]
	mov	DWORD PTR [eax+12], edx

; 656  :         request->keyint = keyint;

	lea	ecx, DWORD PTR _request$[ebp]
	call	??C?$IPCType@Uinit_request@@@@QAEPAUinit_request@@XZ ; IPCType<init_request>::operator->
	mov	ecx, DWORD PTR _keyint$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 657  :         request->bframes = bframes;

	lea	ecx, DWORD PTR _request$[ebp]
	call	??C?$IPCType@Uinit_request@@@@QAEPAUinit_request@@XZ ; IPCType<init_request>::operator->
	mov	edx, DWORD PTR _bframes$[ebp]
	mov	DWORD PTR [eax+20], edx

; 658  :         request->width = width;

	lea	ecx, DWORD PTR _request$[ebp]
	call	??C?$IPCType@Uinit_request@@@@QAEPAUinit_request@@XZ ; IPCType<init_request>::operator->
	mov	ecx, DWORD PTR _width$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 659  :         request->height = height;

	lea	ecx, DWORD PTR _request$[ebp]
	call	??C?$IPCType@Uinit_request@@@@QAEPAUinit_request@@XZ ; IPCType<init_request>::operator->
	mov	edx, DWORD PTR _height$[ebp]
	mov	DWORD PTR [eax+28], edx

; 660  :         request->max_bitrate = maxBitrate;

	lea	ecx, DWORD PTR _request$[ebp]
	call	??C?$IPCType@Uinit_request@@@@QAEPAUinit_request@@XZ ; IPCType<init_request>::operator->
	mov	ecx, DWORD PTR _maxBitrate$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 661  :         request->buffer_size = bufferSize;

	lea	ecx, DWORD PTR _request$[ebp]
	call	??C?$IPCType@Uinit_request@@@@QAEPAUinit_request@@XZ ; IPCType<init_request>::operator->
	mov	edx, DWORD PTR _bufferSize$[ebp]
	mov	DWORD PTR [eax+36], edx

; 662  :         request->use_cbr = bUseCBR;

	lea	ecx, DWORD PTR _request$[ebp]
	call	??C?$IPCType@Uinit_request@@@@QAEPAUinit_request@@XZ ; IPCType<init_request>::operator->
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+512]
	mov	BYTE PTR [eax+40], dl

; 663  :         request->full_range = colorDesc.fullRange;

	lea	ecx, DWORD PTR _request$[ebp]
	call	??C?$IPCType@Uinit_request@@@@QAEPAUinit_request@@XZ ; IPCType<init_request>::operator->
	mov	ecx, DWORD PTR _colorDesc$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+180], edx

; 664  :         request->matrix = colorDesc.matrix;

	lea	ecx, DWORD PTR _request$[ebp]
	call	??C?$IPCType@Uinit_request@@@@QAEPAUinit_request@@XZ ; IPCType<init_request>::operator->
	mov	ecx, DWORD PTR _colorDesc$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+184], edx

; 665  :         request->primaries = colorDesc.primaries;

	lea	ecx, DWORD PTR _request$[ebp]
	call	??C?$IPCType@Uinit_request@@@@QAEPAUinit_request@@XZ ; IPCType<init_request>::operator->
	mov	ecx, DWORD PTR _colorDesc$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+188], edx

; 666  :         request->transfer = colorDesc.transfer;

	lea	ecx, DWORD PTR _request$[ebp]
	call	??C?$IPCType@Uinit_request@@@@QAEPAUinit_request@@XZ ; IPCType<init_request>::operator->
	mov	ecx, DWORD PTR _colorDesc$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+192], edx

; 667  :         request->use_custom_impl = bHaveCustomImpl;

	lea	ecx, DWORD PTR _request$[ebp]
	call	??C?$IPCType@Uinit_request@@@@QAEPAUinit_request@@XZ ; IPCType<init_request>::operator->
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+8]
	mov	BYTE PTR [eax+196], dl

; 668  :         request->custom_impl = custom.type;

	lea	ecx, DWORD PTR _request$[ebp]
	call	??C?$IPCType@Uinit_request@@@@QAEPAUinit_request@@XZ ; IPCType<init_request>::operator->
	mov	ecx, DWORD PTR _custom$[ebp]
	mov	DWORD PTR [eax+201], ecx

; 669  :         request->custom_intf = custom.intf;

	lea	ecx, DWORD PTR _request$[ebp]
	call	??C?$IPCType@Uinit_request@@@@QAEPAUinit_request@@XZ ; IPCType<init_request>::operator->
	mov	edx, DWORD PTR _custom$[ebp+4]
	mov	DWORD PTR [eax+205], edx

; 670  :         request->custom_version = custom.version;

	lea	ecx, DWORD PTR _request$[ebp]
	call	??C?$IPCType@Uinit_request@@@@QAEPAUinit_request@@XZ ; IPCType<init_request>::operator->
	mov	ecx, DWORD PTR _custom$[ebp+8]
	mov	DWORD PTR [eax+197], ecx

; 671  : 
; 672  :         request.signal();

	lea	ecx, DWORD PTR _request$[ebp+40]
	call	?signal@?$IPCSignal@$0A@@@QAEXXZ	; IPCSignal<0>::signal

; 673  :         
; 674  :         ipc_init_response response((event_prefix + INIT_RESPONSE).Array());

	push	OFFSET ??_C@_1BM@MFIKDNIH@?$AAi?$AAn?$AAi?$AAt?$AA_?$AAr?$AAe?$AAs?$AAp?$AAo?$AAn?$AAs?$AAe?$AA?$AA@
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 488				; 000001e8H
	call	DWORD PTR __imp_??HString@@QBE?AV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	push	eax
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	lea	ecx, DWORD PTR _response$[ebp]
	call	??0?$IPCSignalledType@Uinit_response@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; IPCSignalledType<init_response>::IPCSignalledType<init_response>
	lea	ecx, DWORD PTR $T4[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 675  :         IPCWaiter response_waiter = process_waiter;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 392				; 00000188H
	push	eax
	lea	ecx, DWORD PTR _response_waiter$[ebp]
	call	??0IPCWaiter@@QAE@ABU0@@Z

; 676  :         response_waiter.push_back(response.signal_);

	lea	ecx, DWORD PTR _response$[ebp+40]
	call	??Bsafe_handle@@QAEPAXXZ		; safe_handle::operator void *
	mov	DWORD PTR $T27[ebp], eax
	lea	ecx, DWORD PTR $T27[ebp]
	push	ecx
	lea	ecx, DWORD PTR _response_waiter$[ebp]
	call	?push_back@IPCWaiter@@QAEXABQAX@Z	; IPCWaiter::push_back

; 677  :         if(response_waiter.wait_for_two(0, 1, INFINITE))

	push	-1
	push	1
	push	0
	lea	ecx, DWORD PTR _response_waiter$[ebp]
	call	?wait_for_two@IPCWaiter@@QAE_NKKK@Z	; IPCWaiter::wait_for_two
	movzx	edx, al
	test	edx, edx
	je	$LN26@QSVEncoder

; 678  :         {
; 679  :             DWORD code = 0;

	mov	DWORD PTR _code$40[ebp], 0

; 680  :             if(!GetExitCodeProcess(qsvhelper_process.h, &code))

	lea	eax, DWORD PTR _code$40[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	DWORD PTR __imp__GetExitCodeProcess@8
	test	eax, eax
	jne	SHORT $LN25@QSVEncoder

; 681  :                 ThrowQSVInitError(L"Failed to get exit code while initializing QSVHelper.exe", Str("Encoder.QSV.HelperEarlyExit"));

	push	OFFSET ??_C@_1DI@NLPDPCNO@?$AAE?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?4?$AAQ?$AAS?$AAV?$AA?4?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AAE?$AAa?$AAr?$AAl?$AAy?$AAE?$AAx?$AAi?$AAt?$AA?$AA@
	mov	eax, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	push	OFFSET ??_C@_1HC@HGAJLDHP@?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAg?$AAe?$AAt?$AA?5?$AAe?$AAx?$AAi?$AAt?$AA?5?$AAc?$AAo?$AAd?$AAe?$AA?5?$AAw?$AAh?$AAi?$AAl?$AAe?$AA?5?$AAi?$AAn@
	call	??$ThrowQSVInitError@$$$V@?A0x7e09c670@@YAXPB_W0@Z ; `anonymous namespace'::ThrowQSVInitError<>
	add	esp, 8
$LN25@QSVEncoder:

; 682  :             switch(code)

	mov	ecx, DWORD PTR _code$40[ebp]
	mov	DWORD PTR tv1063[ebp], ecx
	cmp	DWORD PTR tv1063[ebp], 5
	je	SHORT $LN19@QSVEncoder
	cmp	DWORD PTR tv1063[ebp], 10		; 0000000aH
	je	SHORT $LN22@QSVEncoder
	jmp	SHORT $LN18@QSVEncoder
$LN22@QSVEncoder:

; 683  :             {
; 684  :             case EXIT_INCOMPATIBLE_CONFIGURATION:
; 685  :                 if (bHaveCustomImpl)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+8]
	test	eax, eax
	je	SHORT $LN21@QSVEncoder

; 686  :                     ThrowQSVInitError(L"QSVHelper.exe has exited because of an incompatible qsvimpl custom parameter (before response)", Str("Encoder.QSV.IncompatibleImpl"));

	push	OFFSET ??_C@_1DK@KOIAJGOC@?$AAE?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?4?$AAQ?$AAS?$AAV?$AA?4?$AAI?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AAI?$AAm?$AAp?$AAl?$AA?$AA@
	mov	ecx, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	push	OFFSET ??_C@_1LO@DHEHLBEE@?$AAQ?$AAS?$AAV?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AA?4?$AAe?$AAx?$AAe?$AA?5?$AAh?$AAa?$AAs?$AA?5?$AAe?$AAx?$AAi?$AAt?$AAe?$AAd?$AA?5?$AAb?$AAe?$AAc?$AAa?$AAu?$AAs?$AAe@
	call	??$ThrowQSVInitError@$$$V@?A0x7e09c670@@YAXPB_W0@Z ; `anonymous namespace'::ThrowQSVInitError<>
	add	esp, 8

; 687  :                 else

	jmp	SHORT $LN19@QSVEncoder
$LN21@QSVEncoder:

; 688  :                     ThrowQSVInitError(L"QSVHelper.exe has exited because the encoder was not initialized", Str("Encoder.QSV.NoValidConfig"));

	push	OFFSET ??_C@_1DE@MCCIFHMH@?$AAE?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?4?$AAQ?$AAS?$AAV?$AA?4?$AAN?$AAo?$AAV?$AAa?$AAl?$AAi?$AAd?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AA?$AA@
	mov	edx, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [edx]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	push	OFFSET ??_C@_1IC@JEHGHKKI@?$AAQ?$AAS?$AAV?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AA?4?$AAe?$AAx?$AAe?$AA?5?$AAh?$AAa?$AAs?$AA?5?$AAe?$AAx?$AAi?$AAt?$AAe?$AAd?$AA?5?$AAb?$AAe?$AAc?$AAa?$AAu?$AAs?$AAe@
	call	??$ThrowQSVInitError@$$$V@?A0x7e09c670@@YAXPB_W0@Z ; `anonymous namespace'::ThrowQSVInitError<>
	add	esp, 8
$LN19@QSVEncoder:

; 689  :             case EXIT_NO_VALID_CONFIGURATION:
; 690  :                 ThrowQSVInitError(L"QSVHelper.exe could not find a valid configuration", Str("Encoder.QSV.NoValidConfig"));

	push	OFFSET ??_C@_1DE@MCCIFHMH@?$AAE?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?4?$AAQ?$AAS?$AAV?$AA?4?$AAN?$AAo?$AAV?$AAa?$AAl?$AAi?$AAd?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AA?$AA@
	mov	eax, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	push	OFFSET ??_C@_1GG@IFDPCDFB@?$AAQ?$AAS?$AAV?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AA?4?$AAe?$AAx?$AAe?$AA?5?$AAc?$AAo?$AAu?$AAl?$AAd?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAf?$AAi?$AAn?$AAd?$AA?5?$AAa?$AA?5?$AAv@
	call	??$ThrowQSVInitError@$$$V@?A0x7e09c670@@YAXPB_W0@Z ; `anonymous namespace'::ThrowQSVInitError<>
	add	esp, 8
$LN18@QSVEncoder:

; 691  :             default:
; 692  :                 if (code == EXIT_ENCODER_INIT_FAILED && request->use_custom_parameters)

	cmp	DWORD PTR _code$40[ebp], 6
	jne	SHORT $LN17@QSVEncoder
	lea	ecx, DWORD PTR _request$[ebp]
	call	??C?$IPCType@Uinit_request@@@@QAEPAUinit_request@@XZ ; IPCType<init_request>::operator->
	movzx	ecx, BYTE PTR [eax+41]
	test	ecx, ecx
	je	SHORT $LN17@QSVEncoder

; 693  :                     ThrowQSVInitError(L"Encoder initialization failed with code %i while using custom parameters", Str("Encoder.QSV.InitCustomParamsFailed"), code);

	mov	edx, DWORD PTR _code$40[ebp]
	push	edx
	push	OFFSET ??_C@_1EG@ONGBBGA@?$AAE?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?4?$AAQ?$AAS?$AAV?$AA?4?$AAI?$AAn?$AAi?$AAt?$AAC?$AAu?$AAs?$AAt?$AAo?$AAm?$AAP?$AAa?$AAr?$AAa?$AAm?$AAs?$AAF?$AAa?$AAi?$AAl@
	mov	eax, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	push	OFFSET ??_C@_1JC@NLDIMFFD@?$AAE?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAw?$AAi@
	call	??$ThrowQSVInitError@K@?A0x7e09c670@@YAXPB_W0K@Z ; `anonymous namespace'::ThrowQSVInitError<unsigned long>
	add	esp, 12					; 0000000cH
$LN17@QSVEncoder:

; 694  :                 ThrowQSVInitError(L"QSVHelper.exe has exited with code %i (before response)", Str("Encoder.QSV.HelperEarlyExit"), code);

	mov	ecx, DWORD PTR _code$40[ebp]
	push	ecx
	push	OFFSET ??_C@_1DI@NLPDPCNO@?$AAE?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?4?$AAQ?$AAS?$AAV?$AA?4?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AAE?$AAa?$AAr?$AAl?$AAy?$AAE?$AAx?$AAi?$AAt?$AA?$AA@
	mov	edx, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [edx]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	push	OFFSET ??_C@_1HA@GIELBKIB@?$AAQ?$AAS?$AAV?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AA?4?$AAe?$AAx?$AAe?$AA?5?$AAh?$AAa?$AAs?$AA?5?$AAe?$AAx?$AAi?$AAt?$AAe?$AAd?$AA?5?$AAw?$AAi?$AAt?$AAh?$AA?5?$AAc?$AAo@
	call	??$ThrowQSVInitError@K@?A0x7e09c670@@YAXPB_W0K@Z ; `anonymous namespace'::ThrowQSVInitError<unsigned long>
	add	esp, 12					; 0000000cH
$LN26@QSVEncoder:

; 695  :             }
; 696  :         }
; 697  : 
; 698  :         Log(TEXT("------------------------------------------"));

	push	OFFSET ??_C@_1FG@KNBPKHHL@?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9@
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 4

; 699  : 
; 700  :         if(bHaveCustomImpl && !response->using_custom_impl)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN16@QSVEncoder
	lea	ecx, DWORD PTR _response$[ebp]
	call	??C?$IPCType@Uinit_response@@@@QAEPAUinit_response@@XZ ; IPCType<init_response>::operator->
	movzx	edx, BYTE PTR [eax+18]
	test	edx, edx
	jne	SHORT $LN16@QSVEncoder

; 701  :             AppWarning(TEXT("Could not initialize QSV session using custom settings")); //FIXME: convert to localized error

	push	OFFSET ??_C@_1GO@OPENBPNL@?$AAC?$AAo?$AAu?$AAl?$AAd?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?5?$AAQ?$AAS?$AAV?$AA?5?$AAs?$AAe?$AAs?$AAs?$AAi?$AAo?$AAn@
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 4
$LN16@QSVEncoder:

; 702  : 
; 703  :         ver = response->version;

	lea	ecx, DWORD PTR _response$[ebp]
	call	??C?$IPCType@Uinit_response@@@@QAEPAUinit_response@@XZ ; IPCType<init_response>::operator->
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 704  :         auto intf_str = qsv_intf_str(response->requested_impl),

	lea	ecx, DWORD PTR _response$[ebp]
	call	??C?$IPCType@Uinit_response@@@@QAEPAUinit_response@@XZ ; IPCType<init_response>::operator->
	mov	edx, DWORD PTR [eax+8]
	push	edx
	call	?qsv_intf_str@?A0x7e09c670@@YAPB_WI@Z	; `anonymous namespace'::qsv_intf_str
	add	esp, 4
	mov	DWORD PTR _intf_str$[ebp], eax

; 705  :              actual_intf_str = qsv_intf_str(response->actual_impl);

	lea	ecx, DWORD PTR _response$[ebp]
	call	??C?$IPCType@Uinit_response@@@@QAEPAUinit_response@@XZ ; IPCType<init_response>::operator->
	mov	eax, DWORD PTR [eax+12]
	push	eax
	call	?qsv_intf_str@?A0x7e09c670@@YAPB_WI@Z	; `anonymous namespace'::qsv_intf_str
	add	esp, 4
	mov	DWORD PTR _actual_intf_str$[ebp], eax

; 706  :         auto length = std::distance(std::begin(implStr), std::end(implStr));

	push	OFFSET ?implStr@?A0x7e09c670@@3PAPB_WA	; `anonymous namespace'::implStr
	call	??$end@PB_W$08@std@@YAPAPB_WAAY08PB_W@Z	; std::end<wchar_t const *,9>
	add	esp, 4
	push	eax
	push	OFFSET ?implStr@?A0x7e09c670@@3PAPB_WA	; `anonymous namespace'::implStr
	call	??$begin@PB_W$08@std@@YAPAPB_WAAY08PB_W@Z ; std::begin<wchar_t const *,9>
	add	esp, 4
	push	eax
	call	??$distance@PAPB_W@std@@YAHPAPB_W0@Z	; std::distance<wchar_t const * *>
	add	esp, 8
	mov	DWORD PTR _length$[ebp], eax

; 707  :         auto impl = response->requested_impl & (MFX_IMPL_VIA_ANY - 1);

	lea	ecx, DWORD PTR _response$[ebp]
	call	??C?$IPCType@Uinit_response@@@@QAEPAUinit_response@@XZ ; IPCType<init_response>::operator->
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 255				; 000000ffH
	mov	DWORD PTR _impl$[ebp], ecx

; 708  :         if(impl > length) impl = static_cast<mfxIMPL>(length-1);

	mov	edx, DWORD PTR _impl$[ebp]
	cmp	edx, DWORD PTR _length$[ebp]
	jle	SHORT $LN15@QSVEncoder
	mov	eax, DWORD PTR _length$[ebp]
	sub	eax, 1
	mov	DWORD PTR _impl$[ebp], eax
$LN15@QSVEncoder:

; 709  :         Log(TEXT("QSV version %u.%u using %s%s (actual: %s%s)"), ver.Major, ver.Minor,
; 710  :             implStr[impl], intf_str, implStr[response->actual_impl & (MFX_IMPL_VIA_ANY - 1)], actual_intf_str);

	mov	ecx, DWORD PTR _actual_intf_str$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _response$[ebp]
	call	??C?$IPCType@Uinit_response@@@@QAEPAUinit_response@@XZ ; IPCType<init_response>::operator->
	mov	edx, DWORD PTR [eax+12]
	and	edx, 255				; 000000ffH
	mov	eax, DWORD PTR ?implStr@?A0x7e09c670@@3PAPB_WA[edx*4]
	push	eax
	mov	ecx, DWORD PTR _intf_str$[ebp]
	push	ecx
	mov	edx, DWORD PTR _impl$[ebp]
	mov	eax, DWORD PTR ?implStr@?A0x7e09c670@@3PAPB_WA[edx*4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+6]
	push	ecx
	push	OFFSET ??_C@_1FI@HNDPAIDH@?$AAQ?$AAS?$AAV?$AA?5?$AAv?$AAe?$AAr?$AAs?$AAi?$AAo?$AAn?$AA?5?$AA?$CF?$AAu?$AA?4?$AA?$CF?$AAu?$AA?5?$AAu?$AAs?$AAi?$AAn?$AAg?$AA?5?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?5?$AA?$CI?$AAa?$AAc@
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 28					; 0000001cH

; 711  : 
; 712  :         target_usage = response->target_usage;

	lea	ecx, DWORD PTR _response$[ebp]
	call	??C?$IPCType@Uinit_response@@@@QAEPAUinit_response@@XZ ; IPCType<init_response>::operator->
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax]
	mov	WORD PTR [edx+480], ax

; 713  :         profile = response->profile;

	lea	ecx, DWORD PTR _response$[ebp]
	call	??C?$IPCType@Uinit_response@@@@QAEPAUinit_response@@XZ ; IPCType<init_response>::operator->
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [eax+2]
	mov	WORD PTR [ecx+482], dx

; 714  :         rate_control = response->rate_control;

	lea	ecx, DWORD PTR _response$[ebp]
	call	??C?$IPCType@Uinit_response@@@@QAEPAUinit_response@@XZ ; IPCType<init_response>::operator->
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [eax+16]
	mov	WORD PTR [ecx+486], dx

; 715  : 
; 716  :         encode_tasks.SetSize(response->bitstream_num);

	lea	ecx, DWORD PTR _response$[ebp]
	call	??C?$IPCType@Uinit_response@@@@QAEPAUinit_response@@XZ ; IPCType<init_response>::operator->
	movzx	eax, WORD PTR [eax+29]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	call	?SetSize@?$List@Uencode_task@QSVEncoder@@@@QAEHI@Z ; List<QSVEncoder::encode_task>::SetSize

; 717  : 
; 718  :         auto ipc_fail = [&](CTSTR name)
; 719  :         {

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _ipc_fail$[ebp]
	call	??0<lambda_d474bca0a2765bcf38e9e3bf3578a4c7>@@QAE@PAVQSVEncoder@@@Z ; <lambda_d474bca0a2765bcf38e9e3bf3578a4c7>::<lambda_d474bca0a2765bcf38e9e3bf3578a4c7>

; 720  :             AppWarning(L"Failed to initialize QSV IPC '%s' (full name: '%s') (%u)", name, (event_prefix + name).Array(), GetLastError());
; 721  :             StopHelper(stop, process_waiter, qsvhelper_process);
; 722  :             throw Str("Encoder.QSV.IPCInit");
; 723  :         };
; 724  : 
; 725  :         bs_buff = ipc_bitstream_buff((event_prefix + BITSTREAM_BUFF).Array(), response->bitstream_size*response->bitstream_num);

	lea	ecx, DWORD PTR _response$[ebp]
	call	??C?$IPCType@Uinit_response@@@@QAEPAUinit_response@@XZ ; IPCType<init_response>::operator->
	mov	esi, eax
	lea	ecx, DWORD PTR _response$[ebp]
	call	??C?$IPCType@Uinit_response@@@@QAEPAUinit_response@@XZ ; IPCType<init_response>::operator->
	movzx	edx, WORD PTR [eax+29]
	imul	edx, DWORD PTR [esi+33]
	xor	eax, eax
	push	eax
	push	edx
	push	OFFSET ??_C@_1BO@LPFGHFJC@?$AAb?$AAi?$AAt?$AAs?$AAt?$AAr?$AAe?$AAa?$AAm?$AA_?$AAb?$AAu?$AAf?$AAf?$AA?$AA@
	lea	ecx, DWORD PTR $T6[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 488				; 000001e8H
	call	DWORD PTR __imp_??HString@@QBE?AV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	push	eax
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	lea	ecx, DWORD PTR $T53[ebp]
	call	??0NamedSharedMemory@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_K@Z ; NamedSharedMemory::NamedSharedMemory
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??4NamedSharedMemory@@QAEAAU0@$$QAU0@@Z	; NamedSharedMemory::operator=
	lea	ecx, DWORD PTR $T53[ebp]
	call	??1NamedSharedMemory@@QAE@XZ		; NamedSharedMemory::~NamedSharedMemory
	lea	ecx, DWORD PTR $T6[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 726  :         if(!bs_buff)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??7NamedSharedMemory@@QBE_NXZ		; NamedSharedMemory::operator!
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN14@QSVEncoder

; 727  :             ipc_fail(BITSTREAM_BUFF);

	push	OFFSET ??_C@_1BO@LPFGHFJC@?$AAb?$AAi?$AAt?$AAs?$AAt?$AAr?$AAe?$AAa?$AAm?$AA_?$AAb?$AAu?$AAf?$AAf?$AA?$AA@
	lea	ecx, DWORD PTR _ipc_fail$[ebp]
	call	??R<lambda_d474bca0a2765bcf38e9e3bf3578a4c7>@@QBEXPB_W@Z ; <lambda_d474bca0a2765bcf38e9e3bf3578a4c7>::operator()
$LN14@QSVEncoder:

; 728  : 
; 729  :         mfxU8 *bs_start = (mfxU8*)(((size_t)&bs_buff + 31)/32*32);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??INamedSharedMemory@@QAEPAXXZ		; NamedSharedMemory::operator&
	add	eax, 31					; 0000001fH
	shr	eax, 5
	shl	eax, 5
	mov	DWORD PTR _bs_start$[ebp], eax

; 730  :         for(unsigned i = 0; i < encode_tasks.Num(); i++)

	mov	DWORD PTR _i$45[ebp], 0
	jmp	SHORT $LN13@QSVEncoder
$LN12@QSVEncoder:
	mov	eax, DWORD PTR _i$45[ebp]
	add	eax, 1
	mov	DWORD PTR _i$45[ebp], eax
$LN13@QSVEncoder:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	call	?Num@?$List@Uencode_task@QSVEncoder@@@@QBEIXZ ; List<QSVEncoder::encode_task>::Num
	cmp	DWORD PTR _i$45[ebp], eax
	jae	$LN11@QSVEncoder

; 731  :         {
; 732  :             zero(encode_tasks[i].surf);

	push	160					; 000000a0H
	mov	ecx, DWORD PTR _i$45[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	call	??A?$List@Uencode_task@QSVEncoder@@@@QAEAAUencode_task@QSVEncoder@@I@Z ; List<QSVEncoder::encode_task>::operator[]
	push	eax
	call	??$zero@UmfxFrameSurface1@@@@YAXAAUmfxFrameSurface1@@I@Z ; zero<mfxFrameSurface1>
	add	esp, 8

; 733  : 
; 734  :             mfxBitstream &bs = encode_tasks[i].bs;

	mov	edx, DWORD PTR _i$45[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	call	??A?$List@Uencode_task@QSVEncoder@@@@QAEAAUencode_task@QSVEncoder@@I@Z ; List<QSVEncoder::encode_task>::operator[]
	add	eax, 160				; 000000a0H
	mov	DWORD PTR _bs$34[ebp], eax

; 735  :             zero(bs);

	push	64					; 00000040H
	mov	eax, DWORD PTR _bs$34[ebp]
	push	eax
	call	??$zero@UmfxBitstream@@@@YAXAAUmfxBitstream@@I@Z ; zero<mfxBitstream>
	add	esp, 8

; 736  :             bs.Data = bs_start + i*response->bitstream_size;

	lea	ecx, DWORD PTR _response$[ebp]
	call	??C?$IPCType@Uinit_response@@@@QAEPAUinit_response@@XZ ; IPCType<init_response>::operator->
	mov	ecx, DWORD PTR _i$45[ebp]
	imul	ecx, DWORD PTR [eax+33]
	add	ecx, DWORD PTR _bs_start$[ebp]
	mov	edx, DWORD PTR _bs$34[ebp]
	mov	DWORD PTR [edx+40], ecx

; 737  :             bs.MaxLength = response->bitstream_size;

	lea	ecx, DWORD PTR _response$[ebp]
	call	??C?$IPCType@Uinit_response@@@@QAEPAUinit_response@@XZ ; IPCType<init_response>::operator->
	mov	ecx, DWORD PTR _bs$34[ebp]
	mov	edx, DWORD PTR [eax+33]
	mov	DWORD PTR [ecx+52], edx

; 738  : 
; 739  :             idle_tasks << i;

	lea	eax, DWORD PTR _i$45[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??6?$CircularList@I@@QAEAAV0@ABI@Z	; CircularList<unsigned int>::operator<<

; 740  :         }

	jmp	$LN12@QSVEncoder
$LN11@QSVEncoder:

; 741  : 
; 742  :         frames.SetSize(response->frame_num);

	lea	ecx, DWORD PTR _response$[ebp]
	call	??C?$IPCType@Uinit_response@@@@QAEPAUinit_response@@XZ ; IPCType<init_response>::operator->
	movzx	ecx, WORD PTR [eax+31]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 416				; 000001a0H
	call	?SetSize@?$List@UmfxFrameData@@@@QAEHI@Z ; List<mfxFrameData>::SetSize

; 743  : 
; 744  :         frame_buff = ipc_frame_buff((event_prefix + FRAME_BUFF).Array(), response->frame_size*response->frame_num);

	lea	ecx, DWORD PTR _response$[ebp]
	call	??C?$IPCType@Uinit_response@@@@QAEPAUinit_response@@XZ ; IPCType<init_response>::operator->
	mov	esi, eax
	lea	ecx, DWORD PTR _response$[ebp]
	call	??C?$IPCType@Uinit_response@@@@QAEPAUinit_response@@XZ ; IPCType<init_response>::operator->
	movzx	edx, WORD PTR [eax+31]
	imul	edx, DWORD PTR [esi+37]
	xor	eax, eax
	push	eax
	push	edx
	push	OFFSET ??_C@_1BG@ONLLBCFI@?$AAf?$AAr?$AAa?$AAm?$AAe?$AA_?$AAb?$AAu?$AAf?$AAf?$AA?$AA@
	lea	ecx, DWORD PTR $T11[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 488				; 000001e8H
	call	DWORD PTR __imp_??HString@@QBE?AV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	push	eax
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	lea	ecx, DWORD PTR $T54[ebp]
	call	??0NamedSharedMemory@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_K@Z ; NamedSharedMemory::NamedSharedMemory
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 232				; 000000e8H
	call	??4NamedSharedMemory@@QAEAAU0@$$QAU0@@Z	; NamedSharedMemory::operator=
	lea	ecx, DWORD PTR $T54[ebp]
	call	??1NamedSharedMemory@@QAE@XZ		; NamedSharedMemory::~NamedSharedMemory
	lea	ecx, DWORD PTR $T11[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 745  :         if(!frame_buff)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 232				; 000000e8H
	call	??7NamedSharedMemory@@QBE_NXZ		; NamedSharedMemory::operator!
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN10@QSVEncoder

; 746  :             ipc_fail(FRAME_BUFF);

	push	OFFSET ??_C@_1BG@ONLLBCFI@?$AAf?$AAr?$AAa?$AAm?$AAe?$AA_?$AAb?$AAu?$AAf?$AAf?$AA?$AA@
	lea	ecx, DWORD PTR _ipc_fail$[ebp]
	call	??R<lambda_d474bca0a2765bcf38e9e3bf3578a4c7>@@QBEXPB_W@Z ; <lambda_d474bca0a2765bcf38e9e3bf3578a4c7>::operator()
$LN10@QSVEncoder:

; 747  : 
; 748  :         mfxU8 *frame_start = (mfxU8*)(((size_t)&frame_buff + 15)/16*16);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 232				; 000000e8H
	call	??INamedSharedMemory@@QAEPAXXZ		; NamedSharedMemory::operator&
	add	eax, 15					; 0000000fH
	shr	eax, 4
	shl	eax, 4
	mov	DWORD PTR _frame_start$[ebp], eax

; 749  :         for(unsigned i = 0; i < frames.Num(); i++)

	mov	DWORD PTR _i$46[ebp], 0
	jmp	SHORT $LN9@QSVEncoder
$LN8@QSVEncoder:
	mov	eax, DWORD PTR _i$46[ebp]
	add	eax, 1
	mov	DWORD PTR _i$46[ebp], eax
$LN9@QSVEncoder:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 416				; 000001a0H
	call	?Num@?$List@UmfxFrameData@@@@QBEIXZ	; List<mfxFrameData>::Num
	cmp	DWORD PTR _i$46[ebp], eax
	jae	$LN7@QSVEncoder

; 750  :         {
; 751  :             mfxFrameData& frame = frames[i];

	mov	ecx, DWORD PTR _i$46[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 416				; 000001a0H
	call	??A?$List@UmfxFrameData@@@@QAEAAUmfxFrameData@@I@Z ; List<mfxFrameData>::operator[]
	mov	DWORD PTR _frame$42[ebp], eax

; 752  :             zero(frame);

	push	72					; 00000048H
	mov	edx, DWORD PTR _frame$42[ebp]
	push	edx
	call	??$zero@UmfxFrameData@@@@YAXAAUmfxFrameData@@I@Z ; zero<mfxFrameData>
	add	esp, 8

; 753  :             frame.Y = frame_start + i * response->frame_size;

	lea	ecx, DWORD PTR _response$[ebp]
	call	??C?$IPCType@Uinit_response@@@@QAEPAUinit_response@@XZ ; IPCType<init_response>::operator->
	mov	ecx, DWORD PTR _i$46[ebp]
	imul	ecx, DWORD PTR [eax+37]
	add	ecx, DWORD PTR _frame_start$[ebp]
	mov	edx, DWORD PTR _frame$42[ebp]
	mov	DWORD PTR [edx+48], ecx

; 754  :             frame.UV = frame_start + i * response->frame_size + response->UV_offset;

	lea	ecx, DWORD PTR _response$[ebp]
	call	??C?$IPCType@Uinit_response@@@@QAEPAUinit_response@@XZ ; IPCType<init_response>::operator->
	mov	esi, DWORD PTR _i$46[ebp]
	imul	esi, DWORD PTR [eax+37]
	add	esi, DWORD PTR _frame_start$[ebp]
	lea	ecx, DWORD PTR _response$[ebp]
	call	??C?$IPCType@Uinit_response@@@@QAEPAUinit_response@@XZ ; IPCType<init_response>::operator->
	add	esi, DWORD PTR [eax+41]
	mov	eax, DWORD PTR _frame$42[ebp]
	mov	DWORD PTR [eax+52], esi

; 755  :             frame.V = frame_start + i * response->frame_size + response->V_offset;

	lea	ecx, DWORD PTR _response$[ebp]
	call	??C?$IPCType@Uinit_response@@@@QAEPAUinit_response@@XZ ; IPCType<init_response>::operator->
	mov	esi, DWORD PTR _i$46[ebp]
	imul	esi, DWORD PTR [eax+37]
	add	esi, DWORD PTR _frame_start$[ebp]
	lea	ecx, DWORD PTR _response$[ebp]
	call	??C?$IPCType@Uinit_response@@@@QAEPAUinit_response@@XZ ; IPCType<init_response>::operator->
	add	esi, DWORD PTR [eax+45]
	mov	ecx, DWORD PTR _frame$42[ebp]
	mov	DWORD PTR [ecx+56], esi

; 756  :             frame.Pitch = response->frame_pitch;

	lea	ecx, DWORD PTR _response$[ebp]
	call	??C?$IPCType@Uinit_response@@@@QAEPAUinit_response@@XZ ; IPCType<init_response>::operator->
	mov	edx, DWORD PTR _frame$42[ebp]
	mov	ax, WORD PTR [eax+49]
	mov	WORD PTR [edx+46], ax

; 757  :         }

	jmp	$LN8@QSVEncoder
$LN7@QSVEncoder:

; 758  : 
; 759  :         Log(TEXT("Using %u bitstreams and %u frame buffers"), encode_tasks.Num(), frames.Num());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 416				; 000001a0H
	call	?Num@?$List@UmfxFrameData@@@@QBEIXZ	; List<mfxFrameData>::Num
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	call	?Num@?$List@Uencode_task@QSVEncoder@@@@QBEIXZ ; List<QSVEncoder::encode_task>::Num
	push	eax
	push	OFFSET ??_C@_1FC@PLEAILN@?$AAU?$AAs?$AAi?$AAn?$AAg?$AA?5?$AA?$CF?$AAu?$AA?5?$AAb?$AAi?$AAt?$AAs?$AAt?$AAr?$AAe?$AAa?$AAm?$AAs?$AA?5?$AAa?$AAn?$AAd?$AA?5?$AA?$CF?$AAu?$AA?5?$AAf?$AAr?$AAa?$AAm?$AAe@
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 12					; 0000000cH

; 760  : 
; 761  :         Log(TEXT("------------------------------------------"));

	push	OFFSET ??_C@_1FG@KNBPKHHL@?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9@
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 4

; 762  :         Log(GetInfoString());

	lea	ecx, DWORD PTR $T10[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetInfoString@QSVEncoder@@UBE?AVString@@XZ ; QSVEncoder::GetInfoString
	mov	ecx, eax
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 4
	lea	ecx, DWORD PTR $T10[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 763  :         Log(TEXT("------------------------------------------"));

	push	OFFSET ??_C@_1FG@KNBPKHHL@?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9@
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 4

; 764  : 
; 765  :         DataPacket packet;
; 766  :         GetHeaders(packet);

	lea	edx, DWORD PTR _packet$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetHeaders@QSVEncoder@@UAEXAAUDataPacket@@@Z ; QSVEncoder::GetHeaders

; 767  : 
; 768  :         frame_queue = ipc_frame_queue((event_prefix + FRAME_QUEUE).Array(), frames.Num());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 416				; 000001a0H
	call	?Num@?$List@UmfxFrameData@@@@QBEIXZ	; List<mfxFrameData>::Num
	push	eax
	push	OFFSET ??_C@_1BI@PNGIAEEE@?$AAf?$AAr?$AAa?$AAm?$AAe?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe?$AA?$AA@
	lea	eax, DWORD PTR $T12[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 488				; 000001e8H
	call	DWORD PTR __imp_??HString@@QBE?AV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	push	eax
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	lea	ecx, DWORD PTR $T49[ebp]
	call	??0?$IPCLockedSignalledArray@Uqueued_frame@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z ; IPCLockedSignalledArray<queued_frame>::IPCLockedSignalledArray<queued_frame>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 168				; 000000a8H
	call	??4?$IPCLockedSignalledArray@Uqueued_frame@@@@QAEAAU0@$$QAU0@@Z ; IPCLockedSignalledArray<queued_frame>::operator=
	lea	ecx, DWORD PTR $T49[ebp]
	call	??1?$IPCLockedSignalledArray@Uqueued_frame@@@@QAE@XZ
	lea	ecx, DWORD PTR $T12[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 769  :         if(!frame_queue)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 168				; 000000a8H
	call	??7?$IPCLockedSignalledArray@Uqueued_frame@@@@QAE_NXZ ; IPCLockedSignalledArray<queued_frame>::operator!
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@QSVEncoder

; 770  :             ipc_fail(FRAME_QUEUE);

	push	OFFSET ??_C@_1BI@PNGIAEEE@?$AAf?$AAr?$AAa?$AAm?$AAe?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe?$AA?$AA@
	lea	ecx, DWORD PTR _ipc_fail$[ebp]
	call	??R<lambda_d474bca0a2765bcf38e9e3bf3578a4c7>@@QBEXPB_W@Z ; <lambda_d474bca0a2765bcf38e9e3bf3578a4c7>::operator()
$LN6@QSVEncoder:

; 771  : 
; 772  :         frame_buff_status = ipc_frame_buff_status((event_prefix + FRAME_BUFF_STATUS).Array(), frames.Num());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 416				; 000001a0H
	call	?Num@?$List@UmfxFrameData@@@@QBEIXZ	; List<mfxFrameData>::Num
	push	eax
	push	OFFSET ??_C@_1CE@OKHPDFBP@?$AAf?$AAr?$AAa?$AAm?$AAe?$AA_?$AAb?$AAu?$AAf?$AAf?$AA_?$AAs?$AAt?$AAa?$AAt?$AAu?$AAs?$AA?$AA@
	lea	edx, DWORD PTR $T5[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 488				; 000001e8H
	call	DWORD PTR __imp_??HString@@QBE?AV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	push	eax
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	lea	ecx, DWORD PTR $T50[ebp]
	call	??0?$IPCLockedSignalledArray@I@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z ; IPCLockedSignalledArray<unsigned int>::IPCLockedSignalledArray<unsigned int>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 272				; 00000110H
	call	??4?$IPCLockedSignalledArray@I@@QAEAAU0@$$QAU0@@Z ; IPCLockedSignalledArray<unsigned int>::operator=
	lea	ecx, DWORD PTR $T50[ebp]
	call	??1?$IPCLockedSignalledArray@I@@QAE@XZ
	lea	ecx, DWORD PTR $T5[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 773  :         if(!frame_buff_status)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 272				; 00000110H
	call	??7?$IPCLockedSignalledArray@I@@QAE_NXZ	; IPCLockedSignalledArray<unsigned int>::operator!
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@QSVEncoder

; 774  :             ipc_fail(FRAME_BUFF_STATUS);

	push	OFFSET ??_C@_1CE@OKHPDFBP@?$AAf?$AAr?$AAa?$AAm?$AAe?$AA_?$AAb?$AAu?$AAf?$AAf?$AA_?$AAs?$AAt?$AAa?$AAt?$AAu?$AAs?$AA?$AA@
	lea	ecx, DWORD PTR _ipc_fail$[ebp]
	call	??R<lambda_d474bca0a2765bcf38e9e3bf3578a4c7>@@QBEXPB_W@Z ; <lambda_d474bca0a2765bcf38e9e3bf3578a4c7>::operator()
$LN5@QSVEncoder:

; 775  : 
; 776  :         bs_info = ipc_bitstream_info((event_prefix + BITSTREAM_INFO).Array(), response->bitstream_num);

	lea	ecx, DWORD PTR _response$[ebp]
	call	??C?$IPCType@Uinit_response@@@@QAEPAUinit_response@@XZ ; IPCType<init_response>::operator->
	movzx	ecx, WORD PTR [eax+29]
	push	ecx
	push	OFFSET ??_C@_1BO@BLGPOMJC@?$AAb?$AAi?$AAt?$AAs?$AAt?$AAr?$AAe?$AAa?$AAm?$AA_?$AAi?$AAn?$AAf?$AAo?$AA?$AA@
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 488				; 000001e8H
	call	DWORD PTR __imp_??HString@@QBE?AV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	push	eax
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	lea	ecx, DWORD PTR $T52[ebp]
	call	??0?$IPCArray@Ubitstream_info@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z ; IPCArray<bitstream_info>::IPCArray<bitstream_info>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	call	??4?$IPCArray@Ubitstream_info@@@@QAEAAU0@$$QAU0@@Z ; IPCArray<bitstream_info>::operator=
	lea	ecx, DWORD PTR $T52[ebp]
	call	??1?$IPCArray@Ubitstream_info@@@@QAE@XZ
	lea	ecx, DWORD PTR $T3[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 777  :         if(!bs_info)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	call	??7?$IPCArray@Ubitstream_info@@@@QBE_NXZ ; IPCArray<bitstream_info>::operator!
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@QSVEncoder

; 778  :             ipc_fail(BITSTREAM_INFO);

	push	OFFSET ??_C@_1BO@BLGPOMJC@?$AAb?$AAi?$AAt?$AAs?$AAt?$AAr?$AAe?$AAa?$AAm?$AA_?$AAi?$AAn?$AAf?$AAo?$AA?$AA@
	lea	ecx, DWORD PTR _ipc_fail$[ebp]
	call	??R<lambda_d474bca0a2765bcf38e9e3bf3578a4c7>@@QBEXPB_W@Z ; <lambda_d474bca0a2765bcf38e9e3bf3578a4c7>::operator()
$LN4@QSVEncoder:

; 779  : 
; 780  :         filled_bitstream = ipc_filled_bitstream((event_prefix + FILLED_BITSTREAM).Array());

	push	OFFSET ??_C@_1CC@CNJHBCEC@?$AAf?$AAi?$AAl?$AAl?$AAe?$AAd?$AA_?$AAb?$AAi?$AAt?$AAs?$AAt?$AAr?$AAe?$AAa?$AAm?$AA?$AA@
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 488				; 000001e8H
	call	DWORD PTR __imp_??HString@@QBE?AV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	push	eax
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	lea	ecx, DWORD PTR $T51[ebp]
	call	??0?$IPCLockedSignalledType@H@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; IPCLockedSignalledType<int>::IPCLockedSignalledType<int>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 336				; 00000150H
	call	??4?$IPCLockedSignalledType@H@@QAEAAU0@$$QAU0@@Z ; IPCLockedSignalledType<int>::operator=
	lea	ecx, DWORD PTR $T51[ebp]
	call	??1?$IPCLockedSignalledType@H@@QAE@XZ
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 781  :         if(!filled_bitstream)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 336				; 00000150H
	call	??7?$IPCLockedSignalledType@H@@QBE_NXZ	; IPCLockedSignalledType<int>::operator!
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@QSVEncoder

; 782  :             ipc_fail(FILLED_BITSTREAM);

	push	OFFSET ??_C@_1CC@CNJHBCEC@?$AAf?$AAi?$AAl?$AAl?$AAe?$AAd?$AA_?$AAb?$AAi?$AAt?$AAs?$AAt?$AAr?$AAe?$AAa?$AAm?$AA?$AA@
	lea	ecx, DWORD PTR _ipc_fail$[ebp]
	call	??R<lambda_d474bca0a2765bcf38e9e3bf3578a4c7>@@QBEXPB_W@Z ; <lambda_d474bca0a2765bcf38e9e3bf3578a4c7>::operator()
$LN3@QSVEncoder:

; 783  : 
; 784  :         stop = ipc_stop((event_prefix + STOP_REQUEST).Array());

	push	OFFSET ??_C@_19LLIMCLGL@?$AAs?$AAt?$AAo?$AAp?$AA?$AA@
	lea	eax, DWORD PTR $T8[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 488				; 000001e8H
	call	DWORD PTR __imp_??HString@@QBE?AV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	push	eax
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	lea	ecx, DWORD PTR $T23[ebp]
	call	??0?$IPCSignal@$00@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; IPCSignal<1>::IPCSignal<1>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??4?$IPCSignal@$00@@QAEAAU0@$$QAU0@@Z	; IPCSignal<1>::operator=
	lea	ecx, DWORD PTR $T23[ebp]
	call	??1?$IPCSignal@$00@@QAE@XZ
	lea	ecx, DWORD PTR $T8[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 785  :         if(!stop)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??7?$IPCSignal@$00@@QBE_NXZ		; IPCSignal<1>::operator!
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@QSVEncoder

; 786  :             ipc_fail(STOP_REQUEST);

	push	OFFSET ??_C@_19LLIMCLGL@?$AAs?$AAt?$AAo?$AAp?$AA?$AA@
	lea	ecx, DWORD PTR _ipc_fail$[ebp]
	call	??R<lambda_d474bca0a2765bcf38e9e3bf3578a4c7>@@QBEXPB_W@Z ; <lambda_d474bca0a2765bcf38e9e3bf3578a4c7>::operator()
$LN2@QSVEncoder:

; 787  : 
; 788  :         encoder_flushed = ipc_encoder_flushed((event_prefix + ENCODER_FLUSHED).Array());

	push	OFFSET ??_C@_1CA@KDLBGFEM@?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA_?$AAf?$AAl?$AAu?$AAs?$AAh?$AAe?$AAd?$AA?$AA@
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 488				; 000001e8H
	call	DWORD PTR __imp_??HString@@QBE?AV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	push	eax
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	lea	ecx, DWORD PTR $T21[ebp]
	call	??0?$IPCSignal@$00@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; IPCSignal<1>::IPCSignal<1>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	??4?$IPCSignal@$00@@QAEAAU0@$$QAU0@@Z	; IPCSignal<1>::operator=
	lea	ecx, DWORD PTR $T21[ebp]
	call	??1?$IPCSignal@$00@@QAE@XZ
	lea	ecx, DWORD PTR $T2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 789  :         if (!encoder_flushed)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	??7?$IPCSignal@$00@@QBE_NXZ		; IPCSignal<1>::operator!
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@QSVEncoder

; 790  :             ipc_fail(ENCODER_FLUSHED);

	push	OFFSET ??_C@_1CA@KDLBGFEM@?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA_?$AAf?$AAl?$AAu?$AAs?$AAh?$AAe?$AAd?$AA?$AA@
	lea	ecx, DWORD PTR _ipc_fail$[ebp]
	call	??R<lambda_d474bca0a2765bcf38e9e3bf3578a4c7>@@QBEXPB_W@Z ; <lambda_d474bca0a2765bcf38e9e3bf3578a4c7>::operator()
$LN1@QSVEncoder:

; 791  : 
; 792  :         filled_bitstream_waiter = process_waiter;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 404				; 00000194H
	call	??4IPCWaiter@@QAEAAU0@ABU0@@Z

; 793  :         filled_bitstream_waiter.push_back(filled_bitstream.signal_);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 376				; 00000178H
	call	??Bsafe_handle@@QAEPAXXZ		; safe_handle::operator void *
	mov	DWORD PTR $T19[ebp], eax
	lea	edx, DWORD PTR $T19[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 404				; 00000194H
	call	?push_back@IPCWaiter@@QAEXABQAX@Z	; IPCWaiter::push_back

; 794  : 
; 795  :         dts_gen.Init(response->bframe_delay, ver, bUseCFR_, response->frame_ticks);

	lea	ecx, DWORD PTR _response$[ebp]
	call	??C?$IPCType@Uinit_response@@@@QAEPAUinit_response@@XZ ; IPCType<init_response>::operator->
	mov	ecx, DWORD PTR [eax+25]
	push	ecx
	mov	edx, DWORD PTR [eax+21]
	push	edx
	movzx	eax, BYTE PTR _bUseCFR_$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	push	ecx
	lea	ecx, DWORD PTR _response$[ebp]
	call	??C?$IPCType@Uinit_response@@@@QAEPAUinit_response@@XZ ; IPCType<init_response>::operator->
	movzx	edx, WORD PTR [eax+19]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 432				; 000001b0H
	call	?Init@DTSGenerator@?A0x7e09c670@@QAEXIAATmfxVersion@@_N_K@Z ; `anonymous namespace'::DTSGenerator::Init

; 796  :     }

	lea	ecx, DWORD PTR _response_waiter$[ebp]
	call	??1IPCWaiter@@QAE@XZ
	lea	ecx, DWORD PTR _response$[ebp]
	call	??1?$IPCSignalledType@Uinit_response@@@@QAE@XZ
	lea	ecx, DWORD PTR _request$[ebp]
	call	??1?$IPCSignalledType@Uinit_request@@@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	40					; 00000028H
	npad	3
$LN86@QSVEncoder:
	DD	$LN32@QSVEncoder
	DD	$LN30@QSVEncoder
	DD	$LN31@QSVEncoder
	DD	$LN36@QSVEncoder
	DD	$LN36@QSVEncoder
	DD	$LN36@QSVEncoder
	DD	$LN28@QSVEncoder
	DD	$LN29@QSVEncoder
	DD	$LN32@QSVEncoder
	DD	$LN29@QSVEncoder
??0QSVEncoder@@QAE@HHHHPB_W_NAAUColorDescription@@HH1@Z ENDP ; QSVEncoder::QSVEncoder
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ??1QSVEncoder@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1QSVEncoder@@UAE@XZ PROC				; QSVEncoder::~QSVEncoder, COMDAT
; _this$ = ecx

; 799  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7QSVEncoder@@6B@

; 800  :         ClearPackets();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearPackets@QSVEncoder@@AAEXXZ	; QSVEncoder::ClearPackets

; 801  : 
; 802  :         StopHelper(stop, process_waiter, qsvhelper_process);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 392				; 00000188H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	call	?StopHelper@?A0x7e09c670@@YAXAAU?$IPCSignal@$00@@AAUIPCWaiter@@AAUsafe_handle@@@Z ; `anonymous namespace'::StopHelper
	add	esp, 12					; 0000000cH

; 803  :     }

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 532				; 00000214H
	call	??1?$List@E@@QAE@XZ			; List<unsigned char>::~List<unsigned char>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 524				; 0000020cH
	call	??1?$List@E@@QAE@XZ			; List<unsigned char>::~List<unsigned char>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 516				; 00000204H
	call	??1?$List@UVideoPacket@@@@QAE@XZ	; List<VideoPacket>::~List<VideoPacket>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 488				; 000001e8H
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 432				; 000001b0H
	call	??1DTSGenerator@?A0x7e09c670@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 416				; 000001a0H
	call	??1?$List@UmfxFrameData@@@@QAE@XZ	; List<mfxFrameData>::~List<mfxFrameData>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 404				; 00000194H
	call	??1IPCWaiter@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	??1IPCWaiter@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 336				; 00000150H
	call	??1?$IPCLockedSignalledType@H@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 272				; 00000110H
	call	??1?$IPCLockedSignalledArray@I@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 232				; 000000e8H
	call	??1NamedSharedMemory@@QAE@XZ		; NamedSharedMemory::~NamedSharedMemory
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 168				; 000000a8H
	call	??1?$IPCLockedSignalledArray@Uqueued_frame@@@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??1?$CircularList@I@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 128				; 00000080H
	call	??1?$CircularList@I@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	call	??1?$List@Uencode_task@QSVEncoder@@@@QAE@XZ ; List<QSVEncoder::encode_task>::~List<QSVEncoder::encode_task>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	call	??1?$IPCArray@Ubitstream_info@@@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??1NamedSharedMemory@@QAE@XZ		; NamedSharedMemory::~NamedSharedMemory
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	??1?$IPCSignal@$00@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??1?$IPCSignal@$00@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??1safe_handle@@QAE@XZ			; safe_handle::~safe_handle
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??1safe_handle@@QAE@XZ			; safe_handle::~safe_handle
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1VideoEncoder@@UAE@XZ			; VideoEncoder::~VideoEncoder
	mov	esp, ebp
	pop	ebp
	ret	0
??1QSVEncoder@@UAE@XZ ENDP				; QSVEncoder::~QSVEncoder
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ?ProcessEncodedFrame@QSVEncoder@@QAEXAAV?$List@UDataPacket@@@@AAV?$List@W4PacketType@@@@KAAKI@Z
_TEXT	SEGMENT
_search$1 = -308					; size = 4
_newPayloadSize$2 = -304				; size = 4
_ts$ = -300						; size = 8
_in_pts$ = -292						; size = 8
_lock$3 = -284						; size = 8
_packetOut$4 = -276					; size = 12
_packetOut$5 = -264					; size = 12
_nal$6 = -252						; size = 32
_packetOut$7 = -220					; size = 12
_packetOut$8 = -208					; size = 12
_skipBytes$9 = -196					; size = 4
_timeOffsetAddr$ = -192					; size = 4
tv295 = -188						; size = 4
tv441 = -184						; size = 4
tv405 = -180						; size = 4
_nalOut$ = -176						; size = 8
_task$ = -168						; size = 4
_skipBytes$10 = -164					; size = 4
tv497 = -160						; size = 4
_newPayloadSize$11 = -156				; size = 4
tv495 = -152						; size = 4
_skipBytes$12 = -148					; size = 4
tv493 = -144						; size = 4
tv454 = -140						; size = 4
tv491 = -136						; size = 4
_dts$ = -132						; size = 8
_newPayloadSize$13 = -124				; size = 4
tv489 = -120						; size = 4
_next$14 = -116						; size = 4
_end$15 = -112						; size = 4
_end$ = -108						; size = 4
_nalNum$ = -104						; size = 4
$T16 = -97						; size = 1
tv196 = -96						; size = 4
_skip$17 = -92						; size = 4
_index$ = -88						; size = 4
_skip$18 = -84						; size = 4
_i$19 = -80						; size = 4
_sei_type$20 = -76					; size = 4
_skip$21 = -72						; size = 4
_search$22 = -68					; size = 4
_sei_size$23 = -64					; size = 4
_i$24 = -60						; size = 4
$T25 = -53						; size = 1
_info$26 = -52						; size = 4
$T27 = -45						; size = 1
_timeOffset$ = -44					; size = 4
_payload_size$28 = -40					; size = 4
_sei_start$29 = -36					; size = 4
_start$ = -32						; size = 4
_bFoundFrame$ = -25					; size = 1
_newPacket$ = -24					; size = 4
_bestType$ = -20					; size = 4
_bs$ = -16						; size = 4
_sei$30 = -12						; size = 4
_nal$31 = -8						; size = 4
_this$ = -4						; size = 4
_packets$ = 8						; size = 4
_packetTypes$ = 12					; size = 4
_outputTimestamp$ = 16					; size = 4
_out_pts$ = 20						; size = 4
_wait$ = 24						; size = 4
?ProcessEncodedFrame@QSVEncoder@@QAEXAAV?$List@UDataPacket@@@@AAV?$List@W4PacketType@@@@KAAKI@Z PROC ; QSVEncoder::ProcessEncodedFrame, COMDAT
; _this$ = ecx

; 810  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 308				; 00000134H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 811  :         if (!filled_bitstream_waiter.wait_for(2, wait))

	mov	eax, DWORD PTR _wait$[ebp]
	push	eax
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 404				; 00000194H
	call	?wait_for@IPCWaiter@@QAE_NKK@Z		; IPCWaiter::wait_for
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN56@ProcessEnc

; 812  :         {
; 813  :             if (wait <= 0)

	cmp	DWORD PTR _wait$[ebp], 0
	ja	SHORT $LN55@ProcessEnc

; 814  :                 return;

	jmp	$LN57@ProcessEnc
$LN55@ProcessEnc:

; 815  : 
; 816  :             TerminateProcess(qsvhelper_process, (UINT)-1);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??Bsafe_handle@@QAEPAXXZ		; safe_handle::operator void *
	push	eax
	call	DWORD PTR __imp__TerminateProcess@8

; 817  :             AppWarning(L"Terminating QSVHelper.exe after timeout");

	push	OFFSET ??_C@_1FA@PLGDJKOD@?$AAT?$AAe?$AAr?$AAm?$AAi?$AAn?$AAa?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAQ?$AAS?$AAV?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AA?4?$AAe?$AAx?$AAe?$AA?5?$AAa?$AAf?$AAt?$AAe?$AAr?$AA?5@
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 4

; 818  :             helper_killed = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+24], 1

; 819  :             return;

	jmp	$LN57@ProcessEnc
$LN56@ProcessEnc:

; 820  :         }
; 821  : 
; 822  :         uint32_t index = 0;

	mov	DWORD PTR _index$[ebp], 0

; 823  :         {
; 824  :             auto lock = lock_mutex(filled_bitstream);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 336				; 00000150H
	push	eax
	lea	ecx, DWORD PTR _lock$3[ebp]
	push	ecx
	call	??$lock_mutex@U?$IPCLockedSignalledType@H@@@@YA?AU?$IPCMutexLock@U?$IPCLockedSignalledType@H@@@@AAU?$IPCLockedSignalledType@H@@@Z ; lock_mutex<IPCLockedSignalledType<int> >
	add	esp, 8

; 825  :             index = *filled_bitstream;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 336				; 00000150H
	call	??D?$IPCType@H@@QAEAAHXZ		; IPCType<int>::operator*
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _index$[ebp], edx

; 826  :             *filled_bitstream = -1;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 336				; 00000150H
	call	??D?$IPCType@H@@QAEAAHXZ		; IPCType<int>::operator*
	mov	DWORD PTR [eax], -1

; 827  :         }

	lea	ecx, DWORD PTR _lock$3[ebp]
	call	??1?$IPCMutexLock@U?$IPCLockedSignalledType@H@@@@QAE@XZ ; IPCMutexLock<IPCLockedSignalledType<int> >::~IPCMutexLock<IPCLockedSignalledType<int> >

; 828  :         encode_task& task = encode_tasks[index];

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	call	??A?$List@Uencode_task@QSVEncoder@@@@QAEAAUencode_task@QSVEncoder@@I@Z ; List<QSVEncoder::encode_task>::operator[]
	mov	DWORD PTR _task$[ebp], eax

; 829  : 
; 830  :         mfxBitstream& bs = task.bs;

	mov	ecx, DWORD PTR _task$[ebp]
	add	ecx, 160				; 000000a0H
	mov	DWORD PTR _bs$[ebp], ecx

; 831  : 
; 832  :         List<x264_nal_t> nalOut;

	lea	ecx, DWORD PTR _nalOut$[ebp]
	call	??0?$List@Ux264_nal_t@@@@QAE@XZ		; List<x264_nal_t>::List<x264_nal_t>

; 833  :         mfxU8 *start, *end;
; 834  :         {
; 835  :             bitstream_info &info = bs_info[index];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	call	??B?$IPCArray@Ubitstream_info@@@@QAEPAUbitstream_info@@XZ ; IPCArray<bitstream_info>::operator bitstream_info *
	imul	edx, DWORD PTR _index$[ebp], 28
	add	eax, edx
	mov	DWORD PTR _info$26[ebp], eax

; 836  :             bs.TimeStamp = info.time_stamp;

	mov	eax, DWORD PTR _bs$[ebp]
	mov	ecx, DWORD PTR _info$26[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+32], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+36], ecx

; 837  :             bs.DataLength = info.data_length;

	mov	edx, DWORD PTR _bs$[ebp]
	mov	eax, DWORD PTR _info$26[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+48], ecx

; 838  :             bs.DataOffset = info.data_offset;

	mov	edx, DWORD PTR _bs$[ebp]
	mov	eax, DWORD PTR _info$26[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+44], ecx

; 839  :             bs.PicStruct = info.pic_struct;

	mov	edx, DWORD PTR _bs$[ebp]
	mov	eax, DWORD PTR _info$26[ebp]
	mov	cx, WORD PTR [eax+24]
	mov	WORD PTR [edx+56], cx

; 840  :             bs.FrameType = info.frame_type;

	mov	edx, DWORD PTR _bs$[ebp]
	mov	eax, DWORD PTR _info$26[ebp]
	mov	cx, WORD PTR [eax+26]
	mov	WORD PTR [edx+58], cx

; 841  :             bs.DecodeTimeStamp = dts_gen(info.time_stamp, info.decode_time_stamp);

	mov	edx, DWORD PTR _info$26[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR [edx+8]
	push	ecx
	mov	edx, DWORD PTR _info$26[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR [edx]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 432				; 000001b0H
	call	??RDTSGenerator@?A0x7e09c670@@QAE_J_K_J@Z ; `anonymous namespace'::DTSGenerator::operator()
	mov	ecx, DWORD PTR _bs$[ebp]
	mov	DWORD PTR [ecx+24], eax
	mov	DWORD PTR [ecx+28], edx

; 842  :         }
; 843  :         start = bs.Data + bs.DataOffset;

	mov	edx, DWORD PTR _bs$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR _bs$[ebp]
	add	eax, DWORD PTR [ecx+44]
	mov	DWORD PTR _start$[ebp], eax

; 844  :         end = bs.Data + bs.DataOffset + bs.DataLength;

	mov	edx, DWORD PTR _bs$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR _bs$[ebp]
	add	eax, DWORD PTR [ecx+44]
	mov	edx, DWORD PTR _bs$[ebp]
	add	eax, DWORD PTR [edx+48]
	mov	DWORD PTR _end$[ebp], eax

; 845  :         const static mfxU8 start_seq[] = {0, 0, 1};
; 846  :         start = std::search(start, end, start_seq, start_seq+3);

	push	OFFSET ?start_seq@?8??ProcessEncodedFrame@QSVEncoder@@QAEXAAV?$List@UDataPacket@@@@AAV?$List@W4PacketType@@@@KAAKI@Z@4QBEB+3
	push	OFFSET ?start_seq@?8??ProcessEncodedFrame@QSVEncoder@@QAEXAAV?$List@UDataPacket@@@@AAV?$List@W4PacketType@@@@KAAKI@Z@4QBEB
	mov	eax, DWORD PTR _end$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	call	??$search@PAEPBE@std@@YAPAEPAE0PBE1@Z	; std::search<unsigned char *,unsigned char const *>
	add	esp, 16					; 00000010H
	mov	DWORD PTR _start$[ebp], eax
$LN54@ProcessEnc:

; 847  :         while(start != end)

	mov	edx, DWORD PTR _start$[ebp]
	cmp	edx, DWORD PTR _end$[ebp]
	je	$LN53@ProcessEnc

; 848  :         {
; 849  :             decltype(start) next = std::search(start+1, end, start_seq, start_seq+3);

	push	OFFSET ?start_seq@?8??ProcessEncodedFrame@QSVEncoder@@QAEXAAV?$List@UDataPacket@@@@AAV?$List@W4PacketType@@@@KAAKI@Z@4QBEB+3
	push	OFFSET ?start_seq@?8??ProcessEncodedFrame@QSVEncoder@@QAEXAAV?$List@UDataPacket@@@@AAV?$List@W4PacketType@@@@KAAKI@Z@4QBEB
	mov	eax, DWORD PTR _end$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	add	ecx, 1
	push	ecx
	call	??$search@PAEPBE@std@@YAPAEPAE0PBE1@Z	; std::search<unsigned char *,unsigned char const *>
	add	esp, 16					; 00000010H
	mov	DWORD PTR _next$14[ebp], eax

; 850  :             x264_nal_t nal;
; 851  :             nal.i_ref_idc = start[3]>>5;

	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _start$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	sar	edx, 5
	mov	DWORD PTR _nal$6[ebp], edx

; 852  :             nal.i_type = start[3]&0x1f;

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _start$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	and	eax, 31					; 0000001fH
	mov	DWORD PTR _nal$6[ebp+4], eax

; 853  :             if(nal.i_type == NAL_SLICE_IDR)

	cmp	DWORD PTR _nal$6[ebp+4], 5
	jne	SHORT $LN52@ProcessEnc

; 854  :                 nal.i_ref_idc = NAL_PRIORITY_HIGHEST;

	mov	DWORD PTR _nal$6[ebp], 3
	jmp	SHORT $LN51@ProcessEnc
$LN52@ProcessEnc:

; 855  :             else if(nal.i_type == NAL_SLICE)

	cmp	DWORD PTR _nal$6[ebp+4], 1
	jne	SHORT $LN51@ProcessEnc

; 856  :             {
; 857  :                 switch(bs.FrameType & (MFX_FRAMETYPE_REF | (MFX_FRAMETYPE_S-1)))

	mov	ecx, DWORD PTR _bs$[ebp]
	movzx	edx, WORD PTR [ecx+58]
	and	edx, 71					; 00000047H
	mov	DWORD PTR tv196[ebp], edx
	mov	eax, DWORD PTR tv196[ebp]
	sub	eax, 4
	mov	DWORD PTR tv196[ebp], eax
	cmp	DWORD PTR tv196[ebp], 64		; 00000040H
	ja	SHORT $LN44@ProcessEnc
	mov	ecx, DWORD PTR tv196[ebp]
	movzx	edx, BYTE PTR $LN69@ProcessEnc[ecx]
	jmp	DWORD PTR $LN70@ProcessEnc[edx*4]
$LN47@ProcessEnc:

; 858  :                 {
; 859  :                 case MFX_FRAMETYPE_REF|MFX_FRAMETYPE_I:
; 860  :                 case MFX_FRAMETYPE_REF|MFX_FRAMETYPE_P:
; 861  :                     nal.i_ref_idc = NAL_PRIORITY_HIGH;

	mov	DWORD PTR _nal$6[ebp], 2

; 862  :                     break;

	jmp	SHORT $LN51@ProcessEnc
$LN46@ProcessEnc:

; 863  :                 case MFX_FRAMETYPE_REF|MFX_FRAMETYPE_B:
; 864  :                     nal.i_ref_idc = NAL_PRIORITY_LOW;

	mov	DWORD PTR _nal$6[ebp], 1

; 865  :                     break;

	jmp	SHORT $LN51@ProcessEnc
$LN45@ProcessEnc:

; 866  :                 case MFX_FRAMETYPE_B:
; 867  :                     nal.i_ref_idc = NAL_PRIORITY_DISPOSABLE;

	mov	DWORD PTR _nal$6[ebp], 0

; 868  :                     break;

	jmp	SHORT $LN51@ProcessEnc
$LN44@ProcessEnc:

; 869  :                 default:
; 870  :                     Log(TEXT("Unhandled frametype %u"), bs.FrameType);

	mov	eax, DWORD PTR _bs$[ebp]
	movzx	ecx, WORD PTR [eax+58]
	push	ecx
	push	OFFSET ??_C@_1CO@CDPCGBKB@?$AAU?$AAn?$AAh?$AAa?$AAn?$AAd?$AAl?$AAe?$AAd?$AA?5?$AAf?$AAr?$AAa?$AAm?$AAe?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$CF?$AAu?$AA?$AA@
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8
$LN51@ProcessEnc:

; 871  :                 }
; 872  :             }
; 873  :             start[3] = ((nal.i_ref_idc<<5)&0x60) | nal.i_type;

	mov	edx, DWORD PTR _nal$6[ebp]
	shl	edx, 5
	and	edx, 96					; 00000060H
	or	edx, DWORD PTR _nal$6[ebp+4]
	mov	eax, 1
	imul	ecx, eax, 3
	mov	eax, DWORD PTR _start$[ebp]
	mov	BYTE PTR [eax+ecx], dl

; 874  :             nal.p_payload = start;

	mov	ecx, DWORD PTR _start$[ebp]
	mov	DWORD PTR _nal$6[ebp+24], ecx

; 875  :             nal.i_payload = int(next-start);

	mov	edx, DWORD PTR _next$14[ebp]
	sub	edx, DWORD PTR _start$[ebp]
	mov	DWORD PTR _nal$6[ebp+20], edx

; 876  :             nalOut << nal;

	lea	eax, DWORD PTR _nal$6[ebp]
	push	eax
	lea	ecx, DWORD PTR _nalOut$[ebp]
	call	??6?$List@Ux264_nal_t@@@@QAEAAV0@ABUx264_nal_t@@@Z ; List<x264_nal_t>::operator<<

; 877  :             start = next;

	mov	ecx, DWORD PTR _next$14[ebp]
	mov	DWORD PTR _start$[ebp], ecx

; 878  :         }

	jmp	$LN54@ProcessEnc
$LN53@ProcessEnc:

; 879  :         size_t nalNum = nalOut.Num();

	lea	ecx, DWORD PTR _nalOut$[ebp]
	call	?Num@?$List@Ux264_nal_t@@@@QBEIXZ	; List<x264_nal_t>::Num
	mov	DWORD PTR _nalNum$[ebp], eax

; 880  : 
; 881  :         packets.Clear();

	mov	ecx, DWORD PTR _packets$[ebp]
	call	?Clear@?$List@UDataPacket@@@@QAEXXZ	; List<DataPacket>::Clear

; 882  :         ClearPackets();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearPackets@QSVEncoder@@AAEXXZ	; QSVEncoder::ClearPackets

; 883  : 
; 884  :         INT64 dts = msFromTimestamp(bs.DecodeTimeStamp);

	mov	edx, DWORD PTR _bs$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR [edx+24]
	push	ecx
	call	??$msFromTimestamp@_J@?A0x7e09c670@@YA_J_J@Z ; `anonymous namespace'::msFromTimestamp<__int64>
	add	esp, 8
	mov	DWORD PTR _dts$[ebp], eax
	mov	DWORD PTR _dts$[ebp+4], edx

; 885  : 
; 886  :         INT64 in_pts = msFromTimestamp(task.surf.Data.TimeStamp);

	mov	edx, DWORD PTR _task$[ebp]
	mov	eax, DWORD PTR [edx+124]
	push	eax
	mov	ecx, DWORD PTR [edx+120]
	push	ecx
	call	??$msFromTimestamp@_K@?A0x7e09c670@@YA_K_K@Z ; `anonymous namespace'::msFromTimestamp<unsigned __int64>
	add	esp, 8
	mov	DWORD PTR _in_pts$[ebp], eax
	mov	DWORD PTR _in_pts$[ebp+4], edx

; 887  :         out_pts = (DWORD)msFromTimestamp(bs.TimeStamp);

	mov	edx, DWORD PTR _bs$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	mov	ecx, DWORD PTR [edx+32]
	push	ecx
	call	??$msFromTimestamp@_K@?A0x7e09c670@@YA_K_K@Z ; `anonymous namespace'::msFromTimestamp<unsigned __int64>
	add	esp, 8
	mov	edx, DWORD PTR _out_pts$[ebp]
	mov	DWORD PTR [edx], eax

; 888  : 
; 889  :         if(!bFirstFrameProcessed && nalNum)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+501]
	test	ecx, ecx
	jne	SHORT $LN43@ProcessEnc
	cmp	DWORD PTR _nalNum$[ebp], 0
	je	SHORT $LN43@ProcessEnc

; 890  :         {
; 891  :             delayOffset = -dts;

	mov	edx, DWORD PTR _dts$[ebp]
	neg	edx
	mov	eax, DWORD PTR _dts$[ebp+4]
	adc	eax, 0
	neg	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+544], edx
	mov	DWORD PTR [ecx+548], eax

; 892  :             bFirstFrameProcessed = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+501], 1
$LN43@ProcessEnc:

; 893  :         }
; 894  : 
; 895  :         INT64 ts = INT64(outputTimestamp);

	mov	eax, DWORD PTR _outputTimestamp$[ebp]
	xor	ecx, ecx
	mov	DWORD PTR _ts$[ebp], eax
	mov	DWORD PTR _ts$[ebp+4], ecx

; 896  :         int timeOffset;
; 897  : 
; 898  :         //if frame duplication is being used, the shift will be insignificant, so just don't bother adjusting audio
; 899  :         timeOffset = int(out_pts-dts);

	mov	edx, DWORD PTR _out_pts$[ebp]
	mov	eax, DWORD PTR [edx]
	xor	ecx, ecx
	sub	eax, DWORD PTR _dts$[ebp]
	sbb	ecx, DWORD PTR _dts$[ebp+4]
	mov	DWORD PTR _timeOffset$[ebp], eax

; 900  :         timeOffset += frameShift;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _timeOffset$[ebp]
	add	eax, DWORD PTR [edx+552]
	mov	DWORD PTR _timeOffset$[ebp], eax

; 901  : 
; 902  :         if(nalNum && timeOffset < 0)

	cmp	DWORD PTR _nalNum$[ebp], 0
	je	SHORT $LN42@ProcessEnc
	cmp	DWORD PTR _timeOffset$[ebp], 0
	jge	SHORT $LN42@ProcessEnc

; 903  :         {
; 904  :             frameShift -= timeOffset;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+552]
	sub	edx, DWORD PTR _timeOffset$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+552], edx

; 905  :             timeOffset = 0;

	mov	DWORD PTR _timeOffset$[ebp], 0
$LN42@ProcessEnc:

; 906  :         }
; 907  :         //Log(TEXT("inpts: %005d, dts: %005d, pts: %005d, timestamp: %005d, offset: %005d, newoffset: %005d"), task.surf.Data.TimeStamp/90, dts, bs.TimeStamp/90, outputTimestamp, timeOffset, bs.TimeStamp/90-dts);
; 908  : 
; 909  :         timeOffset = htonl(timeOffset);

	mov	ecx, DWORD PTR _timeOffset$[ebp]
	push	ecx
	call	DWORD PTR __imp__htonl@4
	mov	DWORD PTR _timeOffset$[ebp], eax

; 910  : 
; 911  :         BYTE *timeOffsetAddr = ((BYTE*)&timeOffset)+1;

	lea	edx, DWORD PTR _timeOffset$[ebp+1]
	mov	DWORD PTR _timeOffsetAddr$[ebp], edx

; 912  : 
; 913  :         VideoPacket *newPacket = NULL;

	mov	DWORD PTR _newPacket$[ebp], 0

; 914  : 
; 915  :         PacketType bestType = PacketType_VideoDisposable;

	mov	DWORD PTR _bestType$[ebp], 0

; 916  :         bool bFoundFrame = false;

	mov	BYTE PTR _bFoundFrame$[ebp], 0

; 917  : 
; 918  :         for(unsigned i=0; i<nalNum; i++)

	mov	DWORD PTR _i$19[ebp], 0
	jmp	SHORT $LN41@ProcessEnc
$LN40@ProcessEnc:
	mov	eax, DWORD PTR _i$19[ebp]
	add	eax, 1
	mov	DWORD PTR _i$19[ebp], eax
$LN41@ProcessEnc:
	mov	ecx, DWORD PTR _i$19[ebp]
	cmp	ecx, DWORD PTR _nalNum$[ebp]
	jae	$LN39@ProcessEnc

; 919  :         {
; 920  :             x264_nal_t &nal = nalOut[i];

	mov	edx, DWORD PTR _i$19[ebp]
	push	edx
	lea	ecx, DWORD PTR _nalOut$[ebp]
	call	??A?$List@Ux264_nal_t@@@@QAEAAUx264_nal_t@@I@Z ; List<x264_nal_t>::operator[]
	mov	DWORD PTR _nal$31[ebp], eax

; 921  : 
; 922  :             if(nal.i_type == NAL_SEI)

	mov	eax, DWORD PTR _nal$31[ebp]
	cmp	DWORD PTR [eax+4], 6
	jne	$LN38@ProcessEnc

; 923  :             {
; 924  :                 BYTE *end = nal.p_payload + nal.i_payload;

	mov	ecx, DWORD PTR _nal$31[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _nal$31[ebp]
	add	edx, DWORD PTR [eax+20]
	mov	DWORD PTR _end$15[ebp], edx

; 925  :                 BYTE *skip = nal.p_payload;

	mov	ecx, DWORD PTR _nal$31[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _skip$21[ebp], edx
$LN37@ProcessEnc:

; 926  :                 while(*(skip++) != 0x1);

	mov	eax, DWORD PTR _skip$21[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv295[ebp], ecx
	mov	edx, DWORD PTR _skip$21[ebp]
	add	edx, 1
	mov	DWORD PTR _skip$21[ebp], edx
	cmp	DWORD PTR tv295[ebp], 1
	je	SHORT $LN36@ProcessEnc
	jmp	SHORT $LN37@ProcessEnc
$LN36@ProcessEnc:

; 927  :                 int skipBytes = (int)(skip-nal.p_payload);

	mov	eax, DWORD PTR _nal$31[ebp]
	mov	ecx, DWORD PTR _skip$21[ebp]
	sub	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _skipBytes$9[ebp], ecx

; 928  : 
; 929  :                 int newPayloadSize = (nal.i_payload-skipBytes);

	mov	edx, DWORD PTR _nal$31[ebp]
	mov	eax, DWORD PTR [edx+20]
	sub	eax, DWORD PTR _skipBytes$9[ebp]
	mov	DWORD PTR _newPayloadSize$2[ebp], eax

; 930  :                 BYTE *sei_start = skip+1;

	mov	ecx, DWORD PTR _skip$21[ebp]
	add	ecx, 1
	mov	DWORD PTR _sei_start$29[ebp], ecx
$LN35@ProcessEnc:

; 931  :                 while(sei_start < end)

	mov	edx, DWORD PTR _sei_start$29[ebp]
	cmp	edx, DWORD PTR _end$15[ebp]
	jae	$LN34@ProcessEnc

; 932  :                 {
; 933  :                     BYTE *sei = sei_start;

	mov	eax, DWORD PTR _sei_start$29[ebp]
	mov	DWORD PTR _sei$30[ebp], eax

; 934  :                     int sei_type = 0;

	mov	DWORD PTR _sei_type$20[ebp], 0
$LN33@ProcessEnc:

; 935  :                     while(*sei == 0xff)

	mov	ecx, DWORD PTR _sei$30[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $LN32@ProcessEnc

; 936  :                     {
; 937  :                         sei_type += 0xff;

	mov	eax, DWORD PTR _sei_type$20[ebp]
	add	eax, 255				; 000000ffH
	mov	DWORD PTR _sei_type$20[ebp], eax

; 938  :                         sei += 1;

	mov	ecx, DWORD PTR _sei$30[ebp]
	add	ecx, 1
	mov	DWORD PTR _sei$30[ebp], ecx

; 939  :                     }

	jmp	SHORT $LN33@ProcessEnc
$LN32@ProcessEnc:

; 940  :                     sei_type += *sei++;

	mov	edx, DWORD PTR _sei$30[ebp]
	movzx	eax, BYTE PTR [edx]
	add	eax, DWORD PTR _sei_type$20[ebp]
	mov	DWORD PTR _sei_type$20[ebp], eax
	mov	ecx, DWORD PTR _sei$30[ebp]
	add	ecx, 1
	mov	DWORD PTR _sei$30[ebp], ecx

; 941  : 
; 942  :                     int payload_size = 0;

	mov	DWORD PTR _payload_size$28[ebp], 0
$LN31@ProcessEnc:

; 943  :                     while(*sei == 0xff)

	mov	edx, DWORD PTR _sei$30[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 255				; 000000ffH
	jne	SHORT $LN30@ProcessEnc

; 944  :                     {
; 945  :                         payload_size += 0xff;

	mov	ecx, DWORD PTR _payload_size$28[ebp]
	add	ecx, 255				; 000000ffH
	mov	DWORD PTR _payload_size$28[ebp], ecx

; 946  :                         sei += 1;

	mov	edx, DWORD PTR _sei$30[ebp]
	add	edx, 1
	mov	DWORD PTR _sei$30[ebp], edx

; 947  :                     }

	jmp	SHORT $LN31@ProcessEnc
$LN30@ProcessEnc:

; 948  :                     payload_size += *sei++;

	mov	eax, DWORD PTR _sei$30[ebp]
	movzx	ecx, BYTE PTR [eax]
	add	ecx, DWORD PTR _payload_size$28[ebp]
	mov	DWORD PTR _payload_size$28[ebp], ecx
	mov	edx, DWORD PTR _sei$30[ebp]
	add	edx, 1
	mov	DWORD PTR _sei$30[ebp], edx

; 949  : 
; 950  :                     const static BYTE emulation_prevention_pattern[] = {0, 0, 3};
; 951  :                     BYTE *search = sei;

	mov	eax, DWORD PTR _sei$30[ebp]
	mov	DWORD PTR _search$1[ebp], eax

; 952  :                     for(BYTE *search = sei;;)

	mov	ecx, DWORD PTR _sei$30[ebp]
	mov	DWORD PTR _search$22[ebp], ecx
$LN29@ProcessEnc:

; 953  :                     {
; 954  :                         search = std::search(search, sei+payload_size, emulation_prevention_pattern, emulation_prevention_pattern+3);

	push	OFFSET ?emulation_prevention_pattern@?CF@??ProcessEncodedFrame@QSVEncoder@@QAEXAAV?$List@UDataPacket@@@@AAV?$List@W4PacketType@@@@KAAKI@Z@4QBEB+3
	push	OFFSET ?emulation_prevention_pattern@?CF@??ProcessEncodedFrame@QSVEncoder@@QAEXAAV?$List@UDataPacket@@@@AAV?$List@W4PacketType@@@@KAAKI@Z@4QBEB
	mov	edx, DWORD PTR _sei$30[ebp]
	add	edx, DWORD PTR _payload_size$28[ebp]
	push	edx
	mov	eax, DWORD PTR _search$22[ebp]
	push	eax
	call	??$search@PAEPBE@std@@YAPAEPAE0PBE1@Z	; std::search<unsigned char *,unsigned char const *>
	add	esp, 16					; 00000010H
	mov	DWORD PTR _search$22[ebp], eax

; 955  :                         if(search == sei+payload_size)

	mov	ecx, DWORD PTR _sei$30[ebp]
	add	ecx, DWORD PTR _payload_size$28[ebp]
	cmp	DWORD PTR _search$22[ebp], ecx
	jne	SHORT $LN27@ProcessEnc

; 956  :                             break;

	jmp	SHORT $LN28@ProcessEnc
$LN27@ProcessEnc:

; 957  :                         payload_size += 1;

	mov	edx, DWORD PTR _payload_size$28[ebp]
	add	edx, 1
	mov	DWORD PTR _payload_size$28[ebp], edx

; 958  :                         search += 3;

	mov	eax, DWORD PTR _search$22[ebp]
	add	eax, 3
	mov	DWORD PTR _search$22[ebp], eax

; 959  :                     }

	jmp	SHORT $LN29@ProcessEnc
$LN28@ProcessEnc:

; 960  : 
; 961  :                     int sei_size = (int)(sei-sei_start) + payload_size;

	mov	ecx, DWORD PTR _sei$30[ebp]
	sub	ecx, DWORD PTR _sei_start$29[ebp]
	add	ecx, DWORD PTR _payload_size$28[ebp]
	mov	DWORD PTR _sei_size$23[ebp], ecx

; 962  :                     sei_start[-1] = NAL_SEI;

	mov	edx, 1
	imul	eax, edx, -1
	mov	ecx, DWORD PTR _sei_start$29[ebp]
	mov	BYTE PTR [ecx+eax], 6

; 963  : 
; 964  :                     if(sei_type == SEI_USER_DATA_UNREGISTERED) {

	cmp	DWORD PTR _sei_type$20[ebp], 5
	jne	SHORT $LN26@ProcessEnc

; 965  :                         SEIData.Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 532				; 00000214H
	call	?Clear@?$List@E@@QAEXXZ			; List<unsigned char>::Clear

; 966  :                         BufferOutputSerializer packetOut(SEIData);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 532				; 00000214H
	push	edx
	lea	ecx, DWORD PTR _packetOut$7[ebp]
	call	DWORD PTR __imp_??0BufferOutputSerializer@@QAE@AAV?$List@E@@H@Z

; 967  : 
; 968  :                         packetOut.OutputDword(htonl(sei_size + 2));

	mov	eax, DWORD PTR _sei_size$23[ebp]
	add	eax, 2
	push	eax
	call	DWORD PTR __imp__htonl@4
	push	eax
	lea	ecx, DWORD PTR _packetOut$7[ebp]
	call	DWORD PTR __imp_?OutputDword@Serializer@@QAEAAV1@K@Z

; 969  :                         packetOut.Serialize(sei_start - 1, sei_size + 1);

	mov	ecx, DWORD PTR _sei_size$23[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _sei_start$29[ebp]
	sub	edx, 1
	push	edx
	lea	ecx, DWORD PTR _packetOut$7[ebp]
	call	DWORD PTR __imp_?Serialize@BufferOutputSerializer@@UAEXPBXK@Z

; 970  :                         packetOut.OutputByte(0x80);

	push	128					; 00000080H
	lea	ecx, DWORD PTR _packetOut$7[ebp]
	call	DWORD PTR __imp_?OutputByte@Serializer@@QAEAAV1@E@Z

; 971  :                     } else {

	lea	ecx, DWORD PTR _packetOut$7[ebp]
	call	DWORD PTR __imp_??1BufferOutputSerializer@@UAE@XZ
	jmp	SHORT $LN25@ProcessEnc
$LN26@ProcessEnc:

; 972  :                         if (!newPacket)

	cmp	DWORD PTR _newPacket$[ebp], 0
	jne	SHORT $LN24@ProcessEnc

; 973  :                             newPacket = CurrentPackets.CreateNew();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 516				; 00000204H
	call	?CreateNew@?$List@UVideoPacket@@@@QAEPAUVideoPacket@@XZ ; List<VideoPacket>::CreateNew
	mov	DWORD PTR _newPacket$[ebp], eax
$LN24@ProcessEnc:

; 974  : 
; 975  :                         BufferOutputSerializer packetOut(newPacket->Packet);

	push	1
	mov	eax, DWORD PTR _newPacket$[ebp]
	push	eax
	lea	ecx, DWORD PTR _packetOut$8[ebp]
	call	DWORD PTR __imp_??0BufferOutputSerializer@@QAE@AAV?$List@E@@H@Z

; 976  : 
; 977  :                         packetOut.OutputDword(htonl(sei_size + 2));

	mov	ecx, DWORD PTR _sei_size$23[ebp]
	add	ecx, 2
	push	ecx
	call	DWORD PTR __imp__htonl@4
	push	eax
	lea	ecx, DWORD PTR _packetOut$8[ebp]
	call	DWORD PTR __imp_?OutputDword@Serializer@@QAEAAV1@K@Z

; 978  :                         packetOut.Serialize(sei_start - 1, sei_size + 1);

	mov	edx, DWORD PTR _sei_size$23[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _sei_start$29[ebp]
	sub	eax, 1
	push	eax
	lea	ecx, DWORD PTR _packetOut$8[ebp]
	call	DWORD PTR __imp_?Serialize@BufferOutputSerializer@@UAEXPBXK@Z

; 979  :                         packetOut.OutputByte(0x80);

	push	128					; 00000080H
	lea	ecx, DWORD PTR _packetOut$8[ebp]
	call	DWORD PTR __imp_?OutputByte@Serializer@@QAEAAV1@E@Z

; 980  :                     }

	lea	ecx, DWORD PTR _packetOut$8[ebp]
	call	DWORD PTR __imp_??1BufferOutputSerializer@@UAE@XZ
$LN25@ProcessEnc:

; 981  :                     sei_start += sei_size;

	mov	ecx, DWORD PTR _sei_start$29[ebp]
	add	ecx, DWORD PTR _sei_size$23[ebp]
	mov	DWORD PTR _sei_start$29[ebp], ecx

; 982  : 
; 983  :                     if (*sei_start == 0x80 && std::find_if_not(sei_start + 1, end, [](uint8_t val) { return val == 0; }) == end) //find rbsp_trailing_bits

	mov	edx, DWORD PTR _sei_start$29[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 128				; 00000080H
	jne	SHORT $LN23@ProcessEnc
	movzx	ecx, BYTE PTR $T16[ebp]
	push	ecx
	mov	edx, DWORD PTR _end$15[ebp]
	push	edx
	mov	eax, DWORD PTR _sei_start$29[ebp]
	add	eax, 1
	push	eax
	call	??$find_if_not@PAEV<lambda_4f23e6955dca7f806ec2428e9267999f>@@@std@@YAPAEPAE0V<lambda_4f23e6955dca7f806ec2428e9267999f>@@@Z ; std::find_if_not<unsigned char *,<lambda_4f23e6955dca7f806ec2428e9267999f> >
	add	esp, 12					; 0000000cH
	cmp	eax, DWORD PTR _end$15[ebp]
	jne	SHORT $LN23@ProcessEnc

; 984  :                         break;

	jmp	SHORT $LN34@ProcessEnc
$LN23@ProcessEnc:

; 985  :                 }

	jmp	$LN35@ProcessEnc
$LN34@ProcessEnc:

; 986  :             }
; 987  :             else if(nal.i_type == NAL_AUD)

	jmp	$LN22@ProcessEnc
$LN38@ProcessEnc:
	mov	ecx, DWORD PTR _nal$31[ebp]
	cmp	DWORD PTR [ecx+4], 9
	jne	$LN21@ProcessEnc

; 988  :             {
; 989  :                 BYTE *skip = nal.p_payload;

	mov	edx, DWORD PTR _nal$31[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _skip$17[ebp], eax
$LN20@ProcessEnc:

; 990  :                 while(*(skip++) != 0x1);

	mov	ecx, DWORD PTR _skip$17[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR tv405[ebp], edx
	mov	eax, DWORD PTR _skip$17[ebp]
	add	eax, 1
	mov	DWORD PTR _skip$17[ebp], eax
	cmp	DWORD PTR tv405[ebp], 1
	je	SHORT $LN19@ProcessEnc
	jmp	SHORT $LN20@ProcessEnc
$LN19@ProcessEnc:

; 991  :                 int skipBytes = (int)(skip-nal.p_payload);

	mov	ecx, DWORD PTR _nal$31[ebp]
	mov	edx, DWORD PTR _skip$17[ebp]
	sub	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _skipBytes$10[ebp], edx

; 992  : 
; 993  :                 int newPayloadSize = (nal.i_payload-skipBytes);

	mov	eax, DWORD PTR _nal$31[ebp]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR _skipBytes$10[ebp]
	mov	DWORD PTR _newPayloadSize$13[ebp], ecx

; 994  : 
; 995  :                 if (!newPacket)

	cmp	DWORD PTR _newPacket$[ebp], 0
	jne	SHORT $LN18@ProcessEnc

; 996  :                     newPacket = CurrentPackets.CreateNew();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 516				; 00000204H
	call	?CreateNew@?$List@UVideoPacket@@@@QAEPAUVideoPacket@@XZ ; List<VideoPacket>::CreateNew
	mov	DWORD PTR _newPacket$[ebp], eax
$LN18@ProcessEnc:

; 997  : 
; 998  :                 BufferOutputSerializer packetOut(newPacket->Packet);

	push	1
	mov	edx, DWORD PTR _newPacket$[ebp]
	push	edx
	lea	ecx, DWORD PTR _packetOut$5[ebp]
	call	DWORD PTR __imp_??0BufferOutputSerializer@@QAE@AAV?$List@E@@H@Z

; 999  : 
; 1000 :                 packetOut.OutputDword(htonl(newPayloadSize));

	mov	eax, DWORD PTR _newPayloadSize$13[ebp]
	push	eax
	call	DWORD PTR __imp__htonl@4
	push	eax
	lea	ecx, DWORD PTR _packetOut$5[ebp]
	call	DWORD PTR __imp_?OutputDword@Serializer@@QAEAAV1@K@Z

; 1001 :                 packetOut.Serialize(nal.p_payload+skipBytes, newPayloadSize);

	mov	ecx, DWORD PTR _newPayloadSize$13[ebp]
	push	ecx
	mov	edx, DWORD PTR _nal$31[ebp]
	mov	eax, DWORD PTR [edx+24]
	add	eax, DWORD PTR _skipBytes$10[ebp]
	push	eax
	lea	ecx, DWORD PTR _packetOut$5[ebp]
	call	DWORD PTR __imp_?Serialize@BufferOutputSerializer@@UAEXPBXK@Z

; 1002 :             }

	lea	ecx, DWORD PTR _packetOut$5[ebp]
	call	DWORD PTR __imp_??1BufferOutputSerializer@@UAE@XZ
	jmp	$LN22@ProcessEnc
$LN21@ProcessEnc:

; 1003 :             else if(nal.i_type == NAL_SLICE_IDR || nal.i_type == NAL_SLICE)

	mov	ecx, DWORD PTR _nal$31[ebp]
	cmp	DWORD PTR [ecx+4], 5
	je	SHORT $LN15@ProcessEnc
	mov	edx, DWORD PTR _nal$31[ebp]
	cmp	DWORD PTR [edx+4], 1
	jne	$LN16@ProcessEnc
$LN15@ProcessEnc:

; 1004 :             {
; 1005 :                 BYTE *skip = nal.p_payload;

	mov	eax, DWORD PTR _nal$31[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _skip$18[ebp], ecx
$LN14@ProcessEnc:

; 1006 :                 while(*(skip++) != 0x1);

	mov	edx, DWORD PTR _skip$18[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR tv441[ebp], eax
	mov	ecx, DWORD PTR _skip$18[ebp]
	add	ecx, 1
	mov	DWORD PTR _skip$18[ebp], ecx
	cmp	DWORD PTR tv441[ebp], 1
	je	SHORT $LN13@ProcessEnc
	jmp	SHORT $LN14@ProcessEnc
$LN13@ProcessEnc:

; 1007 :                 int skipBytes = (int)(skip-nal.p_payload);

	mov	edx, DWORD PTR _nal$31[ebp]
	mov	eax, DWORD PTR _skip$18[ebp]
	sub	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _skipBytes$12[ebp], eax

; 1008 : 
; 1009 :                 if (!newPacket)

	cmp	DWORD PTR _newPacket$[ebp], 0
	jne	SHORT $LN12@ProcessEnc

; 1010 :                     newPacket = CurrentPackets.CreateNew();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 516				; 00000204H
	call	?CreateNew@?$List@UVideoPacket@@@@QAEPAUVideoPacket@@XZ ; List<VideoPacket>::CreateNew
	mov	DWORD PTR _newPacket$[ebp], eax
$LN12@ProcessEnc:

; 1011 : 
; 1012 :                 if (!bFoundFrame)

	movzx	ecx, BYTE PTR _bFoundFrame$[ebp]
	test	ecx, ecx
	jne	SHORT $LN11@ProcessEnc

; 1013 :                 {
; 1014 :                     newPacket->Packet.Insert(0, (nal.i_type == NAL_SLICE_IDR) ? 0x17 : 0x27);

	mov	edx, DWORD PTR _nal$31[ebp]
	cmp	DWORD PTR [edx+4], 5
	jne	SHORT $LN59@ProcessEnc
	mov	DWORD PTR tv454[ebp], 23		; 00000017H
	jmp	SHORT $LN60@ProcessEnc
$LN59@ProcessEnc:
	mov	DWORD PTR tv454[ebp], 39		; 00000027H
$LN60@ProcessEnc:
	mov	al, BYTE PTR tv454[ebp]
	mov	BYTE PTR $T27[ebp], al
	lea	ecx, DWORD PTR $T27[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _newPacket$[ebp]
	call	?Insert@?$List@E@@QAEXIABE@Z		; List<unsigned char>::Insert

; 1015 :                     newPacket->Packet.Insert(1, 1);

	mov	BYTE PTR $T25[ebp], 1
	lea	edx, DWORD PTR $T25[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _newPacket$[ebp]
	call	?Insert@?$List@E@@QAEXIABE@Z		; List<unsigned char>::Insert

; 1016 :                     newPacket->Packet.InsertArray(2, timeOffsetAddr, 3);

	push	3
	mov	eax, DWORD PTR _timeOffsetAddr$[ebp]
	push	eax
	push	2
	mov	ecx, DWORD PTR _newPacket$[ebp]
	call	?InsertArray@?$List@E@@QAEXIPBEI@Z	; List<unsigned char>::InsertArray

; 1017 : 
; 1018 :                     bFoundFrame = true;

	mov	BYTE PTR _bFoundFrame$[ebp], 1
$LN11@ProcessEnc:

; 1019 :                 }
; 1020 : 
; 1021 :                 int newPayloadSize = (nal.i_payload-skipBytes);

	mov	ecx, DWORD PTR _nal$31[ebp]
	mov	edx, DWORD PTR [ecx+20]
	sub	edx, DWORD PTR _skipBytes$12[ebp]
	mov	DWORD PTR _newPayloadSize$11[ebp], edx

; 1022 :                 BufferOutputSerializer packetOut(newPacket->Packet);

	push	1
	mov	eax, DWORD PTR _newPacket$[ebp]
	push	eax
	lea	ecx, DWORD PTR _packetOut$4[ebp]
	call	DWORD PTR __imp_??0BufferOutputSerializer@@QAE@AAV?$List@E@@H@Z

; 1023 : 
; 1024 :                 packetOut.OutputDword(htonl(newPayloadSize));

	mov	ecx, DWORD PTR _newPayloadSize$11[ebp]
	push	ecx
	call	DWORD PTR __imp__htonl@4
	push	eax
	lea	ecx, DWORD PTR _packetOut$4[ebp]
	call	DWORD PTR __imp_?OutputDword@Serializer@@QAEAAV1@K@Z

; 1025 :                 packetOut.Serialize(nal.p_payload+skipBytes, newPayloadSize);

	mov	edx, DWORD PTR _newPayloadSize$11[ebp]
	push	edx
	mov	eax, DWORD PTR _nal$31[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, DWORD PTR _skipBytes$12[ebp]
	push	ecx
	lea	ecx, DWORD PTR _packetOut$4[ebp]
	call	DWORD PTR __imp_?Serialize@BufferOutputSerializer@@UAEXPBXK@Z

; 1026 : 
; 1027 :                 switch(nal.i_ref_idc)

	mov	edx, DWORD PTR _nal$31[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv489[ebp], eax
	cmp	DWORD PTR tv489[ebp], 3
	ja	$LN9@ProcessEnc
	mov	ecx, DWORD PTR tv489[ebp]
	jmp	DWORD PTR $LN71@ProcessEnc[ecx*4]
$LN8@ProcessEnc:

; 1028 :                 {
; 1029 :                 case NAL_PRIORITY_DISPOSABLE:   bestType = MAX(bestType, PacketType_VideoDisposable);  break;

	cmp	DWORD PTR _bestType$[ebp], 0
	jle	SHORT $LN61@ProcessEnc
	mov	edx, DWORD PTR _bestType$[ebp]
	mov	DWORD PTR tv491[ebp], edx
	jmp	SHORT $LN62@ProcessEnc
$LN61@ProcessEnc:
	mov	DWORD PTR tv491[ebp], 0
$LN62@ProcessEnc:
	mov	eax, DWORD PTR tv491[ebp]
	mov	DWORD PTR _bestType$[ebp], eax
	jmp	SHORT $LN9@ProcessEnc
$LN7@ProcessEnc:

; 1030 :                 case NAL_PRIORITY_LOW:          bestType = MAX(bestType, PacketType_VideoLow);         break;

	cmp	DWORD PTR _bestType$[ebp], 1
	jle	SHORT $LN63@ProcessEnc
	mov	ecx, DWORD PTR _bestType$[ebp]
	mov	DWORD PTR tv493[ebp], ecx
	jmp	SHORT $LN64@ProcessEnc
$LN63@ProcessEnc:
	mov	DWORD PTR tv493[ebp], 1
$LN64@ProcessEnc:
	mov	edx, DWORD PTR tv493[ebp]
	mov	DWORD PTR _bestType$[ebp], edx
	jmp	SHORT $LN9@ProcessEnc
$LN6@ProcessEnc:

; 1031 :                 case NAL_PRIORITY_HIGH:         bestType = MAX(bestType, PacketType_VideoHigh);        break;

	cmp	DWORD PTR _bestType$[ebp], 2
	jle	SHORT $LN65@ProcessEnc
	mov	eax, DWORD PTR _bestType$[ebp]
	mov	DWORD PTR tv495[ebp], eax
	jmp	SHORT $LN66@ProcessEnc
$LN65@ProcessEnc:
	mov	DWORD PTR tv495[ebp], 2
$LN66@ProcessEnc:
	mov	ecx, DWORD PTR tv495[ebp]
	mov	DWORD PTR _bestType$[ebp], ecx
	jmp	SHORT $LN9@ProcessEnc
$LN5@ProcessEnc:

; 1032 :                 case NAL_PRIORITY_HIGHEST:      bestType = MAX(bestType, PacketType_VideoHighest);     break;

	cmp	DWORD PTR _bestType$[ebp], 3
	jle	SHORT $LN67@ProcessEnc
	mov	edx, DWORD PTR _bestType$[ebp]
	mov	DWORD PTR tv497[ebp], edx
	jmp	SHORT $LN68@ProcessEnc
$LN67@ProcessEnc:
	mov	DWORD PTR tv497[ebp], 3
$LN68@ProcessEnc:
	mov	eax, DWORD PTR tv497[ebp]
	mov	DWORD PTR _bestType$[ebp], eax
$LN9@ProcessEnc:

; 1033 :                 }
; 1034 :             }

	lea	ecx, DWORD PTR _packetOut$4[ebp]
	call	DWORD PTR __imp_??1BufferOutputSerializer@@UAE@XZ

; 1035 :             /*else if(nal.i_type == NAL_SPS)
; 1036 :             {
; 1037 :             VideoPacket *newPacket = CurrentPackets.CreateNew();
; 1038 :             BufferOutputSerializer headerOut(newPacket->Packet);
; 1039 : 
; 1040 :             headerOut.OutputByte(0x17);
; 1041 :             headerOut.OutputByte(0);
; 1042 :             headerOut.Serialize(timeOffsetAddr, 3);
; 1043 :             headerOut.OutputByte(1);
; 1044 :             headerOut.Serialize(nal.p_payload+5, 3);
; 1045 :             headerOut.OutputByte(0xff);
; 1046 :             headerOut.OutputByte(0xe1);
; 1047 :             headerOut.OutputWord(htons(nal.i_payload-4));
; 1048 :             headerOut.Serialize(nal.p_payload+4, nal.i_payload-4);
; 1049 : 
; 1050 :             x264_nal_t &pps = nalOut[i+1]; //the PPS always comes after the SPS
; 1051 : 
; 1052 :             headerOut.OutputByte(1);
; 1053 :             headerOut.OutputWord(htons(pps.i_payload-4));
; 1054 :             headerOut.Serialize(pps.p_payload+4, pps.i_payload-4);
; 1055 :             }*/
; 1056 :             else

	jmp	SHORT $LN22@ProcessEnc
$LN16@ProcessEnc:

; 1057 :                 continue;

	jmp	$LN40@ProcessEnc
$LN22@ProcessEnc:

; 1058 :         }

	jmp	$LN40@ProcessEnc
$LN39@ProcessEnc:

; 1059 : 
; 1060 :         packetTypes << bestType;

	lea	ecx, DWORD PTR _bestType$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _packetTypes$[ebp]
	call	??6?$List@W4PacketType@@@@QAEAAV0@ABW4PacketType@@@Z ; List<enum PacketType>::operator<<

; 1061 : 
; 1062 :         packets.SetSize(CurrentPackets.Num());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 516				; 00000204H
	call	?Num@?$List@UVideoPacket@@@@QBEIXZ	; List<VideoPacket>::Num
	push	eax
	mov	ecx, DWORD PTR _packets$[ebp]
	call	?SetSize@?$List@UDataPacket@@@@QAEHI@Z	; List<DataPacket>::SetSize

; 1063 :         for(UINT i=0; i<packets.Num(); i++)

	mov	DWORD PTR _i$24[ebp], 0
	jmp	SHORT $LN3@ProcessEnc
$LN2@ProcessEnc:
	mov	edx, DWORD PTR _i$24[ebp]
	add	edx, 1
	mov	DWORD PTR _i$24[ebp], edx
$LN3@ProcessEnc:
	mov	ecx, DWORD PTR _packets$[ebp]
	call	?Num@?$List@UDataPacket@@@@QBEIXZ	; List<DataPacket>::Num
	cmp	DWORD PTR _i$24[ebp], eax
	jae	SHORT $LN1@ProcessEnc

; 1064 :         {
; 1065 :             packets[i].lpPacket = CurrentPackets[i].Packet.Array();

	mov	eax, DWORD PTR _i$24[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 516				; 00000204H
	call	??A?$List@UVideoPacket@@@@QAEAAUVideoPacket@@I@Z ; List<VideoPacket>::operator[]
	mov	ecx, eax
	call	?Array@?$List@E@@QBEPAEXZ		; List<unsigned char>::Array
	mov	esi, eax
	mov	ecx, DWORD PTR _i$24[ebp]
	push	ecx
	mov	ecx, DWORD PTR _packets$[ebp]
	call	??A?$List@UDataPacket@@@@QAEAAUDataPacket@@I@Z ; List<DataPacket>::operator[]
	mov	DWORD PTR [eax], esi

; 1066 :             packets[i].size     = CurrentPackets[i].Packet.Num();

	mov	edx, DWORD PTR _i$24[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 516				; 00000204H
	call	??A?$List@UVideoPacket@@@@QAEAAUVideoPacket@@I@Z ; List<VideoPacket>::operator[]
	mov	ecx, eax
	call	?Num@?$List@E@@QBEIXZ			; List<unsigned char>::Num
	mov	esi, eax
	mov	eax, DWORD PTR _i$24[ebp]
	push	eax
	mov	ecx, DWORD PTR _packets$[ebp]
	call	??A?$List@UDataPacket@@@@QAEAAUDataPacket@@I@Z ; List<DataPacket>::operator[]
	mov	DWORD PTR [eax+4], esi

; 1067 :         }

	jmp	SHORT $LN2@ProcessEnc
$LN1@ProcessEnc:

; 1068 : 
; 1069 :         idle_tasks << index;

	lea	ecx, DWORD PTR _index$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??6?$CircularList@I@@QAEAAV0@ABI@Z	; CircularList<unsigned int>::operator<<

; 1070 :         assert(queued_tasks[0] == index);
; 1071 :         queued_tasks.Remove(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 128				; 00000080H
	call	?Remove@?$CircularList@I@@QAEXI@Z	; CircularList<unsigned int>::Remove

; 1072 :     }

	lea	ecx, DWORD PTR _nalOut$[ebp]
	call	??1?$List@Ux264_nal_t@@@@QAE@XZ		; List<x264_nal_t>::~List<x264_nal_t>
$LN57@ProcessEnc:
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
	npad	1
$LN70@ProcessEnc:
	DD	$LN45@ProcessEnc
	DD	$LN47@ProcessEnc
	DD	$LN46@ProcessEnc
	DD	$LN44@ProcessEnc
$LN69@ProcessEnc:
	DB	0
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	1
	DB	1
	DB	3
	DB	2
	npad	3
$LN71@ProcessEnc:
	DD	$LN8@ProcessEnc
	DD	$LN7@ProcessEnc
	DD	$LN6@ProcessEnc
	DD	$LN5@ProcessEnc
?ProcessEncodedFrame@QSVEncoder@@QAEXAAV?$List@UDataPacket@@@@AAV?$List@W4PacketType@@@@KAAKI@Z ENDP ; QSVEncoder::ProcessEncodedFrame
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ?RequestBuffers@QSVEncoder@@UAEXPAX@Z
_TEXT	SEGMENT
_lock$ = -24						; size = 8
_data$1 = -16						; size = 4
_this$ = -12						; size = 4
_i$2 = -8						; size = 4
_buff$ = -4						; size = 4
_buffers$ = 8						; size = 4
?RequestBuffers@QSVEncoder@@UAEXPAX@Z PROC		; QSVEncoder::RequestBuffers, COMDAT
; _this$ = ecx

; 1075 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1076 :         if(!buffers)

	cmp	DWORD PTR _buffers$[ebp], 0
	jne	SHORT $LN8@RequestBuf

; 1077 :             return;

	jmp	$LN9@RequestBuf
$LN8@RequestBuf:

; 1078 : 
; 1079 :         mfxFrameData& buff = *(mfxFrameData*)buffers;

	mov	eax, DWORD PTR _buffers$[ebp]
	mov	DWORD PTR _buff$[ebp], eax

; 1080 : 
; 1081 :         auto lock = lock_mutex(frame_buff_status);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 272				; 00000110H
	push	ecx
	lea	edx, DWORD PTR _lock$[ebp]
	push	edx
	call	??$lock_mutex@U?$IPCLockedSignalledArray@I@@@@YA?AU?$IPCMutexLock@U?$IPCLockedSignalledArray@I@@@@AAU?$IPCLockedSignalledArray@I@@@Z ; lock_mutex<IPCLockedSignalledArray<unsigned int> >
	add	esp, 8

; 1082 : 
; 1083 :         if(buff.MemId && !frame_buff_status[(unsigned)buff.MemId-1]) //Reuse buffer if not in use

	mov	eax, DWORD PTR _buff$[ebp]
	cmp	DWORD PTR [eax+64], 0
	je	SHORT $LN7@RequestBuf
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 272				; 00000110H
	call	??B?$IPCArray@I@@QAEPAIXZ		; IPCArray<unsigned int>::operator unsigned int *
	mov	ecx, DWORD PTR _buff$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	cmp	DWORD PTR [eax+edx*4-4], 0
	jne	SHORT $LN7@RequestBuf

; 1084 :             return;

	lea	ecx, DWORD PTR _lock$[ebp]
	call	??1?$IPCMutexLock@U?$IPCLockedSignalledArray@I@@@@QAE@XZ ; IPCMutexLock<IPCLockedSignalledArray<unsigned int> >::~IPCMutexLock<IPCLockedSignalledArray<unsigned int> >
	jmp	$LN9@RequestBuf
$LN7@RequestBuf:

; 1085 : 
; 1086 :         for(unsigned i = 0; i < frames.Num(); i++)

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN6@RequestBuf
$LN5@RequestBuf:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN6@RequestBuf:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 416				; 000001a0H
	call	?Num@?$List@UmfxFrameData@@@@QBEIXZ	; List<mfxFrameData>::Num
	cmp	DWORD PTR _i$2[ebp], eax
	jae	$LN4@RequestBuf

; 1087 :         {
; 1088 :             if(frame_buff_status[i] || frames[i].MemId)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 272				; 00000110H
	call	??B?$IPCArray@I@@QAEPAIXZ		; IPCArray<unsigned int>::operator unsigned int *
	mov	ecx, DWORD PTR _i$2[ebp]
	cmp	DWORD PTR [eax+ecx*4], 0
	jne	SHORT $LN2@RequestBuf
	mov	edx, DWORD PTR _i$2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 416				; 000001a0H
	call	??A?$List@UmfxFrameData@@@@QAEAAUmfxFrameData@@I@Z ; List<mfxFrameData>::operator[]
	cmp	DWORD PTR [eax+64], 0
	je	SHORT $LN3@RequestBuf
$LN2@RequestBuf:

; 1089 :                 continue;

	jmp	SHORT $LN5@RequestBuf
$LN3@RequestBuf:

; 1090 :             mfxFrameData& data = frames[i];

	mov	eax, DWORD PTR _i$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 416				; 000001a0H
	call	??A?$List@UmfxFrameData@@@@QAEAAUmfxFrameData@@I@Z ; List<mfxFrameData>::operator[]
	mov	DWORD PTR _data$1[ebp], eax

; 1091 :             buff.Y = data.Y;

	mov	ecx, DWORD PTR _buff$[ebp]
	mov	edx, DWORD PTR _data$1[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR [ecx+48], eax

; 1092 :             buff.UV = data.UV;

	mov	ecx, DWORD PTR _buff$[ebp]
	mov	edx, DWORD PTR _data$1[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	DWORD PTR [ecx+52], eax

; 1093 :             buff.Pitch = data.Pitch;

	mov	ecx, DWORD PTR _buff$[ebp]
	mov	edx, DWORD PTR _data$1[ebp]
	mov	ax, WORD PTR [edx+46]
	mov	WORD PTR [ecx+46], ax

; 1094 :             if(buff.MemId)

	mov	ecx, DWORD PTR _buff$[ebp]
	cmp	DWORD PTR [ecx+64], 0
	je	SHORT $LN1@RequestBuf

; 1095 :                 frames[(unsigned)buff.MemId-1].MemId = nullptr;

	mov	edx, DWORD PTR _buff$[ebp]
	mov	eax, DWORD PTR [edx+64]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 416				; 000001a0H
	call	??A?$List@UmfxFrameData@@@@QAEAAUmfxFrameData@@I@Z ; List<mfxFrameData>::operator[]
	mov	DWORD PTR [eax+64], 0
$LN1@RequestBuf:

; 1096 :             buff.MemId = mfxMemId(i+1);

	mov	ecx, DWORD PTR _i$2[ebp]
	add	ecx, 1
	mov	edx, DWORD PTR _buff$[ebp]
	mov	DWORD PTR [edx+64], ecx

; 1097 :             data.MemId = mfxMemId(i+1);

	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _data$1[ebp]
	mov	DWORD PTR [ecx+64], eax

; 1098 :             return;

	lea	ecx, DWORD PTR _lock$[ebp]
	call	??1?$IPCMutexLock@U?$IPCLockedSignalledArray@I@@@@QAE@XZ ; IPCMutexLock<IPCLockedSignalledArray<unsigned int> >::~IPCMutexLock<IPCLockedSignalledArray<unsigned int> >
	jmp	SHORT $LN9@RequestBuf

; 1099 :         }

	jmp	$LN5@RequestBuf
$LN4@RequestBuf:

; 1100 :         Log(TEXT("Error: all frames are in use"));

	push	OFFSET ??_C@_1DK@NCJGJBIK@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAa?$AAl?$AAl?$AA?5?$AAf?$AAr?$AAa?$AAm?$AAe?$AAs?$AA?5?$AAa?$AAr?$AAe?$AA?5?$AAi?$AAn?$AA?5?$AAu?$AAs?$AAe?$AA?$AA@
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 4

; 1101 :     }

	lea	ecx, DWORD PTR _lock$[ebp]
	call	??1?$IPCMutexLock@U?$IPCLockedSignalledArray@I@@@@QAE@XZ ; IPCMutexLock<IPCLockedSignalledArray<unsigned int> >::~IPCMutexLock<IPCLockedSignalledArray<unsigned int> >
$LN9@RequestBuf:
	mov	esp, ebp
	pop	ebp
	ret	4
?RequestBuffers@QSVEncoder@@UAEXPAX@Z ENDP		; QSVEncoder::RequestBuffers
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ?QueueEncodeTask@QSVEncoder@@QAEXPAUmfxFrameSurface1@@K@Z
_TEXT	SEGMENT
__curProfiler$ = -92					; size = 48
_lock_status$1 = -44					; size = 8
_lock_queue$ = -36					; size = 8
tv160 = -28						; size = 8
_task$ = -20						; size = 4
tv187 = -16						; size = 4
_i$2 = -12						; size = 4
_info$3 = -8						; size = 4
_this$ = -4						; size = 4
_pic$ = 8						; size = 4
_in_pts$ = 12						; size = 4
?QueueEncodeTask@QSVEncoder@@QAEXPAUmfxFrameSurface1@@K@Z PROC ; QSVEncoder::QueueEncodeTask, COMDAT
; _this$ = ecx

; 1104 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	DWORD PTR _this$[ebp], ecx

; 1105 :         profileSegment("QueueEncodeTask");

	push	0
	push	OFFSET ??_C@_1CA@JOCIALON@?$AAQ?$AAu?$AAe?$AAu?$AAe?$AAE?$AAn?$AAc?$AAo?$AAd?$AAe?$AAT?$AAa?$AAs?$AAk?$AA?$AA@
	lea	ecx, DWORD PTR __curProfiler$[ebp]
	call	DWORD PTR __imp_??0ProfilerNode@@QAE@PB_W_N@Z

; 1106 :         encode_task& task = encode_tasks[idle_tasks[0]];

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??A?$CircularList@I@@QAEAAII@Z		; CircularList<unsigned int>::operator[]
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	call	??A?$List@Uencode_task@QSVEncoder@@@@QAEAAUencode_task@QSVEncoder@@I@Z ; List<QSVEncoder::encode_task>::operator[]
	mov	DWORD PTR _task$[ebp], eax

; 1107 : 
; 1108 :         auto lock_queue = lock_mutex(frame_queue);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 168				; 000000a8H
	push	ecx
	lea	edx, DWORD PTR _lock_queue$[ebp]
	push	edx
	call	??$lock_mutex@U?$IPCLockedSignalledArray@Uqueued_frame@@@@@@YA?AU?$IPCMutexLock@U?$IPCLockedSignalledArray@Uqueued_frame@@@@@@AAU?$IPCLockedSignalledArray@Uqueued_frame@@@@@Z ; lock_mutex<IPCLockedSignalledArray<queued_frame> >
	add	esp, 8

; 1109 : 
; 1110 :         for(unsigned i = 0; i < frame_queue.size; i++)

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN6@QueueEncod
$LN5@QueueEncod:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN6@QueueEncod:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$2[ebp]
	cmp	edx, DWORD PTR [ecx+208]
	jae	$LN4@QueueEncod

; 1111 :         {
; 1112 :             queued_frame &info = frame_queue[i];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 168				; 000000a8H
	call	??B?$IPCArray@Uqueued_frame@@@@QAEPAUqueued_frame@@XZ ; IPCArray<queued_frame>::operator queued_frame *
	imul	ecx, DWORD PTR _i$2[ebp], 15
	add	eax, ecx
	mov	DWORD PTR _info$3[ebp], eax

; 1113 : 
; 1114 :             if(info.is_new)

	mov	edx, DWORD PTR _info$3[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN3@QueueEncod

; 1115 :                 continue;

	jmp	SHORT $LN5@QueueEncod
$LN3@QueueEncod:

; 1116 :             queued_tasks << idle_tasks[0];

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??A?$CircularList@I@@QAEAAII@Z		; CircularList<unsigned int>::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 128				; 00000080H
	call	??6?$CircularList@I@@QAEAAV0@ABI@Z	; CircularList<unsigned int>::operator<<

; 1117 :             idle_tasks.Remove(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	?Remove@?$CircularList@I@@QAEXI@Z	; CircularList<unsigned int>::Remove

; 1118 :             info.is_new = true;

	mov	ecx, DWORD PTR _info$3[ebp]
	mov	BYTE PTR [ecx], 1

; 1119 : 
; 1120 :             info.request_keyframe = bRequestKeyframe;

	mov	edx, DWORD PTR _info$3[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+500]
	mov	BYTE PTR [edx+1], cl

; 1121 :             bRequestKeyframe = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+500], 0

; 1122 : 
; 1123 :             if (!pic)

	cmp	DWORD PTR _pic$[ebp], 0
	jne	SHORT $LN2@QueueEncod

; 1124 :             {
; 1125 :                 info.flush = true;

	mov	eax, DWORD PTR _info$3[ebp]
	mov	BYTE PTR [eax+2], 1

; 1126 :                 dts_gen.add(timestampFromMS(in_pts));

	mov	ecx, DWORD PTR _in_pts$[ebp]
	push	ecx
	call	??$timestampFromMS@K@?A0x7e09c670@@YAKK@Z ; `anonymous namespace'::timestampFromMS<unsigned long>
	add	esp, 4
	xor	edx, edx
	push	edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 432				; 000001b0H
	call	?add@DTSGenerator@?A0x7e09c670@@QAEX_K@Z ; `anonymous namespace'::DTSGenerator::add

; 1127 :             }
; 1128 :             else

	jmp	$LN1@QueueEncod
$LN2@QueueEncod:

; 1129 :             {
; 1130 :                 info.timestamp = task.surf.Data.TimeStamp = timestampFromMS(pic->Data.TimeStamp);

	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+124]
	push	ecx
	mov	edx, DWORD PTR [eax+120]
	push	edx
	call	??$timestampFromMS@_K@?A0x7e09c670@@YA_K_K@Z ; `anonymous namespace'::timestampFromMS<unsigned __int64>
	add	esp, 8
	mov	DWORD PTR tv160[ebp], eax
	mov	DWORD PTR tv160[ebp+4], edx
	mov	eax, DWORD PTR _task$[ebp]
	mov	ecx, DWORD PTR tv160[ebp]
	mov	DWORD PTR [eax+120], ecx
	mov	edx, DWORD PTR tv160[ebp+4]
	mov	DWORD PTR [eax+124], edx
	mov	eax, DWORD PTR _info$3[ebp]
	mov	ecx, DWORD PTR tv160[ebp]
	mov	DWORD PTR [eax+3], ecx
	mov	edx, DWORD PTR tv160[ebp+4]
	mov	DWORD PTR [eax+7], edx

; 1131 :                 dts_gen.add(info.timestamp);

	mov	eax, DWORD PTR _info$3[ebp]
	mov	ecx, DWORD PTR [eax+7]
	push	ecx
	mov	edx, DWORD PTR [eax+3]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 432				; 000001b0H
	call	?add@DTSGenerator@?A0x7e09c670@@QAEX_K@Z ; `anonymous namespace'::DTSGenerator::add

; 1132 :                 info.frame_index = (uint32_t)pic->Data.MemId - 1;

	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	sub	ecx, 1
	mov	edx, DWORD PTR _info$3[ebp]
	mov	DWORD PTR [edx+11], ecx

; 1133 :                 auto lock_status = lock_mutex(frame_buff_status);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 272				; 00000110H
	push	eax
	lea	ecx, DWORD PTR _lock_status$1[ebp]
	push	ecx
	call	??$lock_mutex@U?$IPCLockedSignalledArray@I@@@@YA?AU?$IPCMutexLock@U?$IPCLockedSignalledArray@I@@@@AAU?$IPCLockedSignalledArray@I@@@Z ; lock_mutex<IPCLockedSignalledArray<unsigned int> >
	add	esp, 8

; 1134 :                 frame_buff_status[info.frame_index] += 1;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 272				; 00000110H
	call	??B?$IPCArray@I@@QAEPAIXZ		; IPCArray<unsigned int>::operator unsigned int *
	mov	edx, DWORD PTR _info$3[ebp]
	mov	ecx, DWORD PTR [edx+11]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR tv187[ebp], edx
	mov	eax, DWORD PTR tv187[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR tv187[ebp]
	mov	DWORD PTR [edx], ecx

; 1135 :             }

	lea	ecx, DWORD PTR _lock_status$1[ebp]
	call	??1?$IPCMutexLock@U?$IPCLockedSignalledArray@I@@@@QAE@XZ ; IPCMutexLock<IPCLockedSignalledArray<unsigned int> >::~IPCMutexLock<IPCLockedSignalledArray<unsigned int> >
$LN1@QueueEncod:

; 1136 :             frame_queue.signal();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 216				; 000000d8H
	call	?signal@?$IPCSignal@$0A@@@QAEXXZ	; IPCSignal<0>::signal

; 1137 :             return;

	lea	ecx, DWORD PTR _lock_queue$[ebp]
	call	??1?$IPCMutexLock@U?$IPCLockedSignalledArray@Uqueued_frame@@@@@@QAE@XZ ; IPCMutexLock<IPCLockedSignalledArray<queued_frame> >::~IPCMutexLock<IPCLockedSignalledArray<queued_frame> >
	lea	ecx, DWORD PTR __curProfiler$[ebp]
	call	DWORD PTR __imp_??1ProfilerNode@@QAE@XZ
	jmp	SHORT $LN8@QueueEncod

; 1138 :         }

	jmp	$LN5@QueueEncod
$LN4@QueueEncod:

; 1139 :         CrashError(TEXT("QSV encoder is too slow"));

	push	OFFSET ??_C@_1DA@KMEGBFDO@?$AAQ?$AAS?$AAV?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?5?$AAi?$AAs?$AA?5?$AAt?$AAo?$AAo?$AA?5?$AAs?$AAl?$AAo?$AAw?$AA?$AA@
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ

; 1140 :     }

	lea	ecx, DWORD PTR _lock_queue$[ebp]
	call	??1?$IPCMutexLock@U?$IPCLockedSignalledArray@Uqueued_frame@@@@@@QAE@XZ ; IPCMutexLock<IPCLockedSignalledArray<queued_frame> >::~IPCMutexLock<IPCLockedSignalledArray<queued_frame> >
	lea	ecx, DWORD PTR __curProfiler$[ebp]
	call	DWORD PTR __imp_??1ProfilerNode@@QAE@XZ
$LN8@QueueEncod:
	mov	esp, ebp
	pop	ebp
	ret	8
?QueueEncodeTask@QSVEncoder@@QAEXPAUmfxFrameSurface1@@K@Z ENDP ; QSVEncoder::QueueEncodeTask
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ?Encode@QSVEncoder@@UAE_NPAXAAV?$List@UDataPacket@@@@AAV?$List@W4PacketType@@@@KAAK@Z
_TEXT	SEGMENT
__curProfiler$1 = -68					; size = 48
tv87 = -20						; size = 4
tv145 = -16						; size = 4
_code$2 = -12						; size = 4
_this$ = -8						; size = 4
_queued$ = -1						; size = 1
_picInPtr$ = 8						; size = 4
_packets$ = 12						; size = 4
_packetTypes$ = 16					; size = 4
_outputTimestamp$ = 20					; size = 4
_out_pts$ = 24						; size = 4
?Encode@QSVEncoder@@UAE_NPAXAAV?$List@UDataPacket@@@@AAV?$List@W4PacketType@@@@KAAK@Z PROC ; QSVEncoder::Encode, COMDAT
; _this$ = ecx

; 1143 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 1144 :         if(helper_killed || !process_waiter.wait_timeout())

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+24]
	test	ecx, ecx
	jne	SHORT $LN15@Encode
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	?wait_timeout@IPCWaiter@@QAE_NK@Z	; IPCWaiter::wait_timeout
	movzx	edx, al
	test	edx, edx
	jne	$LN16@Encode
$LN15@Encode:

; 1145 :         {
; 1146 :             int code = 0;

	mov	DWORD PTR _code$2[ebp], 0

; 1147 :             if(!GetExitCodeProcess(process_waiter.list[0], (LPDWORD)&code))

	lea	eax, DWORD PTR _code$2[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	??A?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAPAXI@Z ; std::vector<void *,std::allocator<void *> >::operator[]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__GetExitCodeProcess@8
	test	eax, eax
	jne	SHORT $LN14@Encode

; 1148 :                 CrashError(TEXT("QSVHelper.exe exited!"));

	push	OFFSET ??_C@_1CM@LDBFCFIL@?$AAQ?$AAS?$AAV?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AA?4?$AAe?$AAx?$AAe?$AA?5?$AAe?$AAx?$AAi?$AAt?$AAe?$AAd?$AA?$CB?$AA?$AA@
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ
$LN14@Encode:

; 1149 :             if (helper_killed)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+24]
	test	eax, eax
	je	SHORT $LN13@Encode

; 1150 :                 CrashError(L"QSVHelper.exe was killed, encode failed");

	push	OFFSET ??_C@_1FA@BILEIEBO@?$AAQ?$AAS?$AAV?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AA?4?$AAe?$AAx?$AAe?$AA?5?$AAw?$AAa?$AAs?$AA?5?$AAk?$AAi?$AAl?$AAl?$AAe?$AAd?$AA?0?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe@
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ
$LN13@Encode:

; 1151 :             switch(code)

	mov	ecx, DWORD PTR _code$2[ebp]
	mov	DWORD PTR tv87[ebp], ecx
	cmp	DWORD PTR tv87[ebp], 10			; 0000000aH
	je	SHORT $LN10@Encode
	jmp	SHORT $LN7@Encode
$LN10@Encode:

; 1152 :             {
; 1153 :             case EXIT_INCOMPATIBLE_CONFIGURATION:
; 1154 :                 if (bHaveCustomImpl)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+8]
	test	eax, eax
	je	SHORT $LN9@Encode

; 1155 :                     CrashError(TEXT("QSVHelper.exe has exited because of an incompatible qsvimpl custom parameter"));

	push	OFFSET ??_C@_1JK@CGJBOKOI@?$AAQ?$AAS?$AAV?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AA?4?$AAe?$AAx?$AAe?$AA?5?$AAh?$AAa?$AAs?$AA?5?$AAe?$AAx?$AAi?$AAt?$AAe?$AAd?$AA?5?$AAb?$AAe?$AAc?$AAa?$AAu?$AAs?$AAe@
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ

; 1156 :                 else

	jmp	SHORT $LN7@Encode
$LN9@Encode:

; 1157 :                     CrashError(TEXT("QSVHelper.exe has exited because the encoder was not initialized"));

	push	OFFSET ??_C@_1IC@JEHGHKKI@?$AAQ?$AAS?$AAV?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AA?4?$AAe?$AAx?$AAe?$AA?5?$AAh?$AAa?$AAs?$AA?5?$AAe?$AAx?$AAi?$AAt?$AAe?$AAd?$AA?5?$AAb?$AAe?$AAc?$AAa?$AAu?$AAs?$AAe@
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ
$LN7@Encode:

; 1158 :             default:
; 1159 :                 CrashError(TEXT("QSVHelper.exe has exited with code %i"), code);

	mov	ecx, DWORD PTR _code$2[ebp]
	push	ecx
	push	OFFSET ??_C@_1EM@POGNGIIP@?$AAQ?$AAS?$AAV?$AAH?$AAe?$AAl?$AAp?$AAe?$AAr?$AA?4?$AAe?$AAx?$AAe?$AA?5?$AAh?$AAa?$AAs?$AA?5?$AAe?$AAx?$AAi?$AAt?$AAe?$AAd?$AA?5?$AAw?$AAi?$AAt?$AAh?$AA?5?$AAc?$AAo@
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ
$LN16@Encode:

; 1160 :             }
; 1161 :         }
; 1162 : 
; 1163 :         bool queued = false;

	mov	BYTE PTR _queued$[ebp], 0

; 1164 :         if (idle_tasks.Num())

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	?Num@?$CircularList@I@@QBEIXZ		; CircularList<unsigned int>::Num
	test	eax, eax
	je	SHORT $LN6@Encode

; 1165 :         {
; 1166 :             QueueEncodeTask((mfxFrameSurface1*)picInPtr, outputTimestamp);

	mov	edx, DWORD PTR _outputTimestamp$[ebp]
	push	edx
	mov	eax, DWORD PTR _picInPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?QueueEncodeTask@QSVEncoder@@QAEXPAUmfxFrameSurface1@@K@Z ; QSVEncoder::QueueEncodeTask

; 1167 :             queued = true;

	mov	BYTE PTR _queued$[ebp], 1
$LN6@Encode:

; 1168 :         }
; 1169 : 
; 1170 :         profileIn("ProcessEncodedFrame");

	push	0
	push	OFFSET ??_C@_1CI@CHNAFGEH@?$AAP?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AAE?$AAn?$AAc?$AAo?$AAd?$AAe?$AAd?$AAF?$AAr?$AAa?$AAm?$AAe?$AA?$AA@
	lea	ecx, DWORD PTR __curProfiler$1[ebp]
	call	DWORD PTR __imp_??0ProfilerNode@@QAE@PB_W_N@Z
$LN5@Encode:

; 1171 :         do
; 1172 :         {
; 1173 :             ProcessEncodedFrame(packets, packetTypes, outputTimestamp, out_pts, idle_tasks.Num() ? 0 : 1000);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	?Num@?$CircularList@I@@QBEIXZ		; CircularList<unsigned int>::Num
	test	eax, eax
	je	SHORT $LN19@Encode
	mov	DWORD PTR tv145[ebp], 0
	jmp	SHORT $LN20@Encode
$LN19@Encode:
	mov	DWORD PTR tv145[ebp], 1000		; 000003e8H
$LN20@Encode:
	mov	ecx, DWORD PTR tv145[ebp]
	push	ecx
	mov	edx, DWORD PTR _out_pts$[ebp]
	push	edx
	mov	eax, DWORD PTR _outputTimestamp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _packetTypes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _packets$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ProcessEncodedFrame@QSVEncoder@@QAEXAAV?$List@UDataPacket@@@@AAV?$List@W4PacketType@@@@KAAKI@Z ; QSVEncoder::ProcessEncodedFrame

; 1174 :         }
; 1175 :         while(!helper_killed && !idle_tasks.Num());

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+24]
	test	ecx, ecx
	jne	SHORT $LN3@Encode
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	?Num@?$CircularList@I@@QBEIXZ		; CircularList<unsigned int>::Num
	test	eax, eax
	je	SHORT $LN5@Encode
$LN3@Encode:

; 1176 :         profileOut;

	lea	ecx, DWORD PTR __curProfiler$1[ebp]
	call	DWORD PTR __imp_??1ProfilerNode@@QAE@XZ

; 1177 : 
; 1178 :         if(!helper_killed && !queued)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+24]
	test	eax, eax
	jne	SHORT $LN1@Encode
	movzx	ecx, BYTE PTR _queued$[ebp]
	test	ecx, ecx
	jne	SHORT $LN1@Encode

; 1179 :             QueueEncodeTask((mfxFrameSurface1*)picInPtr, outputTimestamp);

	mov	edx, DWORD PTR _outputTimestamp$[ebp]
	push	edx
	mov	eax, DWORD PTR _picInPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?QueueEncodeTask@QSVEncoder@@QAEXPAUmfxFrameSurface1@@K@Z ; QSVEncoder::QueueEncodeTask
$LN1@Encode:

; 1180 : 
; 1181 :         return true;

	mov	al, 1
$LN18@Encode:

; 1182 :     }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?Encode@QSVEncoder@@UAE_NPAXAAV?$List@UDataPacket@@@@AAV?$List@W4PacketType@@@@KAAK@Z ENDP ; QSVEncoder::Encode
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ?GetHeaders@QSVEncoder@@UAEXAAUDataPacket@@@Z
_TEXT	SEGMENT
$T1 = -220						; size = 8
$T2 = -212						; size = 8
$T3 = -204						; size = 8
_spspps_waiter$4 = -196					; size = 12
$T5 = -184						; size = 4
_headerOut$6 = -180					; size = 12
_this$ = -168						; size = 4
_pps$7 = -164						; size = 56
_sps$8 = -108						; size = 56
_spspps$9 = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_packet$ = 8						; size = 4
?GetHeaders@QSVEncoder@@UAEXAAUDataPacket@@@Z PROC	; QSVEncoder::GetHeaders, COMDAT
; _this$ = ecx

; 1185 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1186 :         if(!HeaderPacket.Num())

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 524				; 0000020cH
	call	?Num@?$List@E@@QBEIXZ			; List<unsigned char>::Num
	test	eax, eax
	jne	$LN2@GetHeaders

; 1187 :         {
; 1188 :             IPCSignalledType<spspps_size> spspps((event_prefix + SPSPPS_SIZES).Array());

	push	OFFSET ??_C@_1BI@JCHINCJN@?$AAs?$AAp?$AAs?$AAp?$AAp?$AAs?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 488				; 000001e8H
	call	DWORD PTR __imp_??HString@@QBE?AV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	push	eax
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	lea	ecx, DWORD PTR _spspps$9[ebp]
	call	??0?$IPCSignalledType@Uspspps_size@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; IPCSignalledType<spspps_size>::IPCSignalledType<spspps_size>
	lea	ecx, DWORD PTR $T2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 1189 :             IPCSignalledArray<mfxU8> sps((event_prefix + SPS_BUFF).Array(), spspps->sps_size),

	lea	ecx, DWORD PTR _spspps$9[ebp]
	call	??C?$IPCType@Uspspps_size@@@@QAEPAUspspps_size@@XZ ; IPCType<spspps_size>::operator->
	movzx	ecx, WORD PTR [eax]
	push	ecx
	push	OFFSET ??_C@_1BC@ENMPJGED@?$AAs?$AAp?$AAs?$AA_?$AAb?$AAu?$AAf?$AAf?$AA?$AA@
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 488				; 000001e8H
	call	DWORD PTR __imp_??HString@@QBE?AV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	push	eax
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	lea	ecx, DWORD PTR _sps$8[ebp]
	call	??0?$IPCSignalledArray@E@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z ; IPCSignalledArray<unsigned char>::IPCSignalledArray<unsigned char>
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 1190 :                                      pps((event_prefix + PPS_BUFF).Array(), spspps->pps_size);

	lea	ecx, DWORD PTR _spspps$9[ebp]
	call	??C?$IPCType@Uspspps_size@@@@QAEPAUspspps_size@@XZ ; IPCType<spspps_size>::operator->
	movzx	eax, WORD PTR [eax+2]
	push	eax
	push	OFFSET ??_C@_1BC@KHEJELCB@?$AAp?$AAp?$AAs?$AA_?$AAb?$AAu?$AAf?$AAf?$AA?$AA@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 488				; 000001e8H
	call	DWORD PTR __imp_??HString@@QBE?AV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	push	eax
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	lea	ecx, DWORD PTR _pps$7[ebp]
	call	??0?$IPCSignalledArray@E@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z ; IPCSignalledArray<unsigned char>::IPCSignalledArray<unsigned char>
	lea	ecx, DWORD PTR $T3[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 1191 : 
; 1192 :             IPCWaiter spspps_waiter = process_waiter;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 392				; 00000188H
	push	edx
	lea	ecx, DWORD PTR _spspps_waiter$4[ebp]
	call	??0IPCWaiter@@QAE@ABU0@@Z

; 1193 :             spspps_waiter.push_back(spspps.signal_);

	lea	ecx, DWORD PTR _spspps$9[ebp+40]
	call	??Bsafe_handle@@QAEPAXXZ		; safe_handle::operator void *
	mov	DWORD PTR $T5[ebp], eax
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	lea	ecx, DWORD PTR _spspps_waiter$4[ebp]
	call	?push_back@IPCWaiter@@QAEXABQAX@Z	; IPCWaiter::push_back

; 1194 : 
; 1195 :             if(!spspps_waiter.wait_for(2, INFINITE))

	push	-1
	push	2
	lea	ecx, DWORD PTR _spspps_waiter$4[ebp]
	call	?wait_for@IPCWaiter@@QAE_NKK@Z		; IPCWaiter::wait_for
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@GetHeaders

; 1196 :                 return;

	lea	ecx, DWORD PTR _spspps_waiter$4[ebp]
	call	??1IPCWaiter@@QAE@XZ
	lea	ecx, DWORD PTR _pps$7[ebp]
	call	??1?$IPCSignalledArray@E@@QAE@XZ
	lea	ecx, DWORD PTR _sps$8[ebp]
	call	??1?$IPCSignalledArray@E@@QAE@XZ
	lea	ecx, DWORD PTR _spspps$9[ebp]
	call	??1?$IPCSignalledType@Uspspps_size@@@@QAE@XZ
	jmp	$LN3@GetHeaders
$LN1@GetHeaders:

; 1197 : 
; 1198 :             BufferOutputSerializer headerOut(HeaderPacket);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 524				; 0000020cH
	push	edx
	lea	ecx, DWORD PTR _headerOut$6[ebp]
	call	DWORD PTR __imp_??0BufferOutputSerializer@@QAE@AAV?$List@E@@H@Z

; 1199 : 
; 1200 :             headerOut.OutputByte(0x17);

	push	23					; 00000017H
	lea	ecx, DWORD PTR _headerOut$6[ebp]
	call	DWORD PTR __imp_?OutputByte@Serializer@@QAEAAV1@E@Z

; 1201 :             headerOut.OutputByte(0);

	push	0
	lea	ecx, DWORD PTR _headerOut$6[ebp]
	call	DWORD PTR __imp_?OutputByte@Serializer@@QAEAAV1@E@Z

; 1202 :             headerOut.OutputByte(0);

	push	0
	lea	ecx, DWORD PTR _headerOut$6[ebp]
	call	DWORD PTR __imp_?OutputByte@Serializer@@QAEAAV1@E@Z

; 1203 :             headerOut.OutputByte(0);

	push	0
	lea	ecx, DWORD PTR _headerOut$6[ebp]
	call	DWORD PTR __imp_?OutputByte@Serializer@@QAEAAV1@E@Z

; 1204 :             headerOut.OutputByte(0);

	push	0
	lea	ecx, DWORD PTR _headerOut$6[ebp]
	call	DWORD PTR __imp_?OutputByte@Serializer@@QAEAAV1@E@Z

; 1205 :             headerOut.OutputByte(1);

	push	1
	lea	ecx, DWORD PTR _headerOut$6[ebp]
	call	DWORD PTR __imp_?OutputByte@Serializer@@QAEAAV1@E@Z

; 1206 :             headerOut.Serialize(sps+5, 3);

	push	3
	lea	ecx, DWORD PTR _sps$8[ebp]
	call	??B?$IPCArray@E@@QAEPAEXZ		; IPCArray<unsigned char>::operator unsigned char *
	add	eax, 5
	push	eax
	lea	ecx, DWORD PTR _headerOut$6[ebp]
	call	DWORD PTR __imp_?Serialize@BufferOutputSerializer@@UAEXPBXK@Z

; 1207 :             headerOut.OutputByte(0xff);

	push	255					; 000000ffH
	lea	ecx, DWORD PTR _headerOut$6[ebp]
	call	DWORD PTR __imp_?OutputByte@Serializer@@QAEAAV1@E@Z

; 1208 :             headerOut.OutputByte(0xe1);

	push	225					; 000000e1H
	lea	ecx, DWORD PTR _headerOut$6[ebp]
	call	DWORD PTR __imp_?OutputByte@Serializer@@QAEAAV1@E@Z

; 1209 :             headerOut.OutputWord(htons(spspps->sps_size-4));

	lea	ecx, DWORD PTR _spspps$9[ebp]
	call	??C?$IPCType@Uspspps_size@@@@QAEPAUspspps_size@@XZ ; IPCType<spspps_size>::operator->
	movzx	eax, WORD PTR [eax]
	sub	eax, 4
	push	eax
	call	DWORD PTR __imp__htons@4
	movzx	ecx, ax
	push	ecx
	lea	ecx, DWORD PTR _headerOut$6[ebp]
	call	DWORD PTR __imp_?OutputWord@Serializer@@QAEAAV1@G@Z

; 1210 :             headerOut.Serialize(sps+4, spspps->sps_size-4);

	lea	ecx, DWORD PTR _spspps$9[ebp]
	call	??C?$IPCType@Uspspps_size@@@@QAEPAUspspps_size@@XZ ; IPCType<spspps_size>::operator->
	movzx	edx, WORD PTR [eax]
	sub	edx, 4
	push	edx
	lea	ecx, DWORD PTR _sps$8[ebp]
	call	??B?$IPCArray@E@@QAEPAEXZ		; IPCArray<unsigned char>::operator unsigned char *
	add	eax, 4
	push	eax
	lea	ecx, DWORD PTR _headerOut$6[ebp]
	call	DWORD PTR __imp_?Serialize@BufferOutputSerializer@@UAEXPBXK@Z

; 1211 : 
; 1212 : 
; 1213 :             headerOut.OutputByte(1);

	push	1
	lea	ecx, DWORD PTR _headerOut$6[ebp]
	call	DWORD PTR __imp_?OutputByte@Serializer@@QAEAAV1@E@Z

; 1214 :             headerOut.OutputWord(htons(spspps->pps_size-4));

	lea	ecx, DWORD PTR _spspps$9[ebp]
	call	??C?$IPCType@Uspspps_size@@@@QAEPAUspspps_size@@XZ ; IPCType<spspps_size>::operator->
	movzx	eax, WORD PTR [eax+2]
	sub	eax, 4
	push	eax
	call	DWORD PTR __imp__htons@4
	movzx	ecx, ax
	push	ecx
	lea	ecx, DWORD PTR _headerOut$6[ebp]
	call	DWORD PTR __imp_?OutputWord@Serializer@@QAEAAV1@G@Z

; 1215 :             headerOut.Serialize(pps+4, spspps->pps_size-4);

	lea	ecx, DWORD PTR _spspps$9[ebp]
	call	??C?$IPCType@Uspspps_size@@@@QAEPAUspspps_size@@XZ ; IPCType<spspps_size>::operator->
	movzx	edx, WORD PTR [eax+2]
	sub	edx, 4
	push	edx
	lea	ecx, DWORD PTR _pps$7[ebp]
	call	??B?$IPCArray@E@@QAEPAEXZ		; IPCArray<unsigned char>::operator unsigned char *
	add	eax, 4
	push	eax
	lea	ecx, DWORD PTR _headerOut$6[ebp]
	call	DWORD PTR __imp_?Serialize@BufferOutputSerializer@@UAEXPBXK@Z

; 1216 :         }

	lea	ecx, DWORD PTR _headerOut$6[ebp]
	call	DWORD PTR __imp_??1BufferOutputSerializer@@UAE@XZ
	lea	ecx, DWORD PTR _spspps_waiter$4[ebp]
	call	??1IPCWaiter@@QAE@XZ
	lea	ecx, DWORD PTR _pps$7[ebp]
	call	??1?$IPCSignalledArray@E@@QAE@XZ
	lea	ecx, DWORD PTR _sps$8[ebp]
	call	??1?$IPCSignalledArray@E@@QAE@XZ
	lea	ecx, DWORD PTR _spspps$9[ebp]
	call	??1?$IPCSignalledType@Uspspps_size@@@@QAE@XZ
$LN2@GetHeaders:

; 1217 : 
; 1218 :         packet.lpPacket = HeaderPacket.Array();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 524				; 0000020cH
	call	?Array@?$List@E@@QBEPAEXZ		; List<unsigned char>::Array
	mov	ecx, DWORD PTR _packet$[ebp]
	mov	DWORD PTR [ecx], eax

; 1219 :         packet.size     = HeaderPacket.Num();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 524				; 0000020cH
	call	?Num@?$List@E@@QBEIXZ			; List<unsigned char>::Num
	mov	edx, DWORD PTR _packet$[ebp]
	mov	DWORD PTR [edx+4], eax
$LN3@GetHeaders:

; 1220 :     }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?GetHeaders@QSVEncoder@@UAEXAAUDataPacket@@@Z ENDP	; QSVEncoder::GetHeaders
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ?GetSEI@QSVEncoder@@UAEXAAUDataPacket@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_packet$ = 8						; size = 4
?GetSEI@QSVEncoder@@UAEXAAUDataPacket@@@Z PROC		; QSVEncoder::GetSEI, COMDAT
; _this$ = ecx

; 1223 :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1224 :         packet.lpPacket = SEIData.Array();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 532				; 00000214H
	call	?Array@?$List@E@@QBEPAEXZ		; List<unsigned char>::Array
	mov	ecx, DWORD PTR _packet$[ebp]
	mov	DWORD PTR [ecx], eax

; 1225 :         packet.size     = SEIData.Num();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 532				; 00000214H
	call	?Num@?$List@E@@QBEIXZ			; List<unsigned char>::Num
	mov	edx, DWORD PTR _packet$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1226 :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetSEI@QSVEncoder@@UAEXAAUDataPacket@@@Z ENDP		; QSVEncoder::GetSEI
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ?GetBitRate@QSVEncoder@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBitRate@QSVEncoder@@UBEHXZ PROC			; QSVEncoder::GetBitRate, COMDAT
; _this$ = ecx

; 1229 :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1230 :         return max_bitrate;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, WORD PTR [eax+484]

; 1231 :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetBitRate@QSVEncoder@@UBEHXZ ENDP			; QSVEncoder::GetBitRate
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ?GetInfoString@QSVEncoder@@UBE?AVString@@XZ
_TEXT	SEGMENT
$T1 = -88						; size = 8
$T2 = -80						; size = 8
$T3 = -72						; size = 8
$T4 = -64						; size = 8
$T5 = -56						; size = 8
$T6 = -48						; size = 8
_strInfo$ = -40						; size = 8
_$S5$7 = -32						; size = 4
tv178 = -28						; size = 4
tv188 = -24						; size = 4
_name$ = -20						; size = 4
_names$8 = -16						; size = 4
_$S3$9 = -12						; size = 4
_$S4$10 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetInfoString@QSVEncoder@@UBE?AVString@@XZ PROC	; QSVEncoder::GetInfoString, COMDAT
; _this$ = ecx

; 1234 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	mov	DWORD PTR _this$[ebp], ecx

; 1235 :         String strInfo;

	lea	ecx, DWORD PTR _strInfo$[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 1236 : 
; 1237 :         const char* name = "UNKNOWN";

	mov	DWORD PTR _name$[ebp], OFFSET ??_C@_07NFANNNEC@UNKNOWN?$AA@

; 1238 :         for (auto &names : rate_control_str)

	mov	DWORD PTR _$S3$9[ebp], OFFSET ?rate_control_str@?A0x7e09c670@@3PAU<unnamed-type-rate_control_str>@1@A ; `anonymous namespace'::rate_control_str
	mov	eax, DWORD PTR _$S3$9[ebp]
	mov	DWORD PTR _$S4$10[ebp], eax
	mov	ecx, DWORD PTR _$S3$9[ebp]
	add	ecx, 96					; 00000060H
	mov	DWORD PTR _$S5$7[ebp], ecx
	jmp	SHORT $LN4@GetInfoStr
$LN3@GetInfoStr:
	mov	edx, DWORD PTR _$S4$10[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _$S4$10[ebp], edx
$LN4@GetInfoStr:
	mov	eax, DWORD PTR _$S4$10[ebp]
	cmp	eax, DWORD PTR _$S5$7[ebp]
	je	SHORT $LN2@GetInfoStr
	mov	ecx, DWORD PTR _$S4$10[ebp]
	mov	DWORD PTR _names$8[ebp], ecx

; 1239 :         {
; 1240 :             if (names.method != rate_control)

	mov	edx, DWORD PTR _names$8[ebp]
	movzx	eax, WORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+486]
	cmp	eax, edx
	je	SHORT $LN1@GetInfoStr

; 1241 :                 continue;

	jmp	SHORT $LN3@GetInfoStr
$LN1@GetInfoStr:

; 1242 : 
; 1243 :             name = names.name;

	mov	eax, DWORD PTR _names$8[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _name$[ebp], ecx

; 1244 :             break;

	jmp	SHORT $LN2@GetInfoStr

; 1238 :         for (auto &names : rate_control_str)

	jmp	SHORT $LN3@GetInfoStr
$LN2@GetInfoStr:

; 1245 :         }
; 1246 : 
; 1247 :         strInfo << TEXT("Video Encoding: QSV")    <<
; 1248 :                    TEXT("\r\n    fps: ")          << IntString(fps) <<
; 1249 :                    TEXT("\r\n    width: ")        << IntString(width) << TEXT(", height: ") << IntString(height) <<
; 1250 :                    TEXT("\r\n    target-usage: ") << usageStr[target_usage] <<
; 1251 :                    TEXT("\r\n    profile: ")      << qsv_profile_str(profile) <<
; 1252 :                    TEXT("\r\n    CBR: ")          << CTSTR((rate_control == MFX_RATECONTROL_CBR) ? TEXT("yes") : TEXT("no")) <<
; 1253 :                    TEXT("\r\n    CFR: ")          << CTSTR((bUseCFR) ? TEXT("yes") : TEXT("no")) <<
; 1254 :                    TEXT("\r\n    max bitrate: ")  << IntString(max_bitrate) <<
; 1255 :                    TEXT("\r\n    buffer size: ")  << IntString(encode_tasks[0].bs.MaxLength * 8 / 1000) <<
; 1256 :                    TEXT("\r\n    rate control: ") << name;

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	lea	ecx, DWORD PTR $T6[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PBD@Z
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+513]
	test	ecx, ecx
	je	SHORT $LN9@GetInfoStr
	mov	DWORD PTR tv188[ebp], OFFSET ??_C@_17IHBDLLG@?$AAy?$AAe?$AAs?$AA?$AA@
	jmp	SHORT $LN10@GetInfoStr
$LN9@GetInfoStr:
	mov	DWORD PTR tv188[ebp], OFFSET ??_C@_15BPIGNHCD@?$AAn?$AAo?$AA?$AA@
$LN10@GetInfoStr:
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, WORD PTR [edx+486]
	cmp	eax, 1
	jne	SHORT $LN7@GetInfoStr
	mov	DWORD PTR tv178[ebp], OFFSET ??_C@_17IHBDLLG@?$AAy?$AAe?$AAs?$AA?$AA@
	jmp	SHORT $LN8@GetInfoStr
$LN7@GetInfoStr:
	mov	DWORD PTR tv178[ebp], OFFSET ??_C@_15BPIGNHCD@?$AAn?$AAo?$AA?$AA@
$LN8@GetInfoStr:
	lea	ecx, DWORD PTR $T6[ebp]
	push	ecx
	push	OFFSET ??_C@_1CK@LENIODAI@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAr?$AAa?$AAt?$AAe?$AA?5?$AAc?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AA?3?$AA?5?$AA?$AA@
	push	10					; 0000000aH
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	call	??A?$List@Uencode_task@QSVEncoder@@@@QBEAAUencode_task@QSVEncoder@@I@Z ; List<QSVEncoder::encode_task>::operator[]
	mov	eax, DWORD PTR [eax+212]
	shl	eax, 3
	xor	edx, edx
	mov	ecx, 1000				; 000003e8H
	div	ecx
	push	eax
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	DWORD PTR __imp_?IntString@@YA?AVString@@HH@Z
	add	esp, 12					; 0000000cH
	push	eax
	push	OFFSET ??_C@_1CI@EBHCIKPJ@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?3?$AA?5?$AA?$AA@
	push	10					; 0000000aH
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+484]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	call	DWORD PTR __imp_?IntString@@YA?AVString@@HH@Z
	add	esp, 12					; 0000000cH
	push	eax
	push	OFFSET ??_C@_1CI@MGGEJOEN@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAm?$AAa?$AAx?$AA?5?$AAb?$AAi?$AAt?$AAr?$AAa?$AAt?$AAe?$AA?3?$AA?5?$AA?$AA@
	mov	eax, DWORD PTR tv188[ebp]
	push	eax
	push	OFFSET ??_C@_1BI@KKGLJLKO@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAC?$AAF?$AAR?$AA?3?$AA?5?$AA?$AA@
	mov	ecx, DWORD PTR tv178[ebp]
	push	ecx
	push	OFFSET ??_C@_1BI@KDIADLNE@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAC?$AAB?$AAR?$AA?3?$AA?5?$AA?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, WORD PTR [edx+482]
	push	eax
	call	?qsv_profile_str@?A0x7e09c670@@YAPB_WG@Z ; `anonymous namespace'::qsv_profile_str
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_1CA@CJBHDLKD@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAp?$AAr?$AAo?$AAf?$AAi?$AAl?$AAe?$AA?3?$AA?5?$AA?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+480]
	mov	eax, DWORD PTR ?usageStr@?A0x7e09c670@@3PAPB_WA[edx*4]
	push	eax
	push	OFFSET ??_C@_1CK@EKEMKBOE@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAt?$AAa?$AAr?$AAg?$AAe?$AAt?$AA?9?$AAu?$AAs?$AAa?$AAg?$AAe?$AA?3?$AA?5?$AA?$AA@
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+508]
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	DWORD PTR __imp_?IntString@@YA?AVString@@HH@Z
	add	esp, 12					; 0000000cH
	push	eax
	push	OFFSET ??_C@_1BG@CGNKKOP@?$AA?0?$AA?5?$AAh?$AAe?$AAi?$AAg?$AAh?$AAt?$AA?3?$AA?5?$AA?$AA@
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+504]
	push	edx
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	DWORD PTR __imp_?IntString@@YA?AVString@@HH@Z
	add	esp, 12					; 0000000cH
	push	eax
	push	OFFSET ??_C@_1BM@NGONPCKN@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?3?$AA?5?$AA?$AA@
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+496]
	push	edx
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	DWORD PTR __imp_?IntString@@YA?AVString@@HH@Z
	add	esp, 12					; 0000000cH
	push	eax
	push	OFFSET ??_C@_1BI@HKMIKHPB@?$AA?$AN?$AA?6?$AA?5?$AA?5?$AA?5?$AA?5?$AAf?$AAp?$AAs?$AA?3?$AA?5?$AA?$AA@
	push	OFFSET ??_C@_1CI@PIFIBIKK@?$AAV?$AAi?$AAd?$AAe?$AAo?$AA?5?$AAE?$AAn?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA?3?$AA?5?$AAQ?$AAS?$AAV?$AA?$AA@
	lea	ecx, DWORD PTR _strInfo$[ebp]
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T5[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR $T4[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR $T3[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR $T2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR $T6[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 1257 : 
; 1258 :         return strInfo;

	lea	ecx, DWORD PTR _strInfo$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0String@@QAE@ABV0@@Z
	lea	ecx, DWORD PTR _strInfo$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1259 :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetInfoString@QSVEncoder@@UBE?AVString@@XZ ENDP	; QSVEncoder::GetInfoString
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ?DynamicBitrateSupported@QSVEncoder@@UBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DynamicBitrateSupported@QSVEncoder@@UBE_NXZ PROC	; QSVEncoder::DynamicBitrateSupported, COMDAT
; _this$ = ecx

; 1262 :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1263 :         return false;

	xor	al, al

; 1264 :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?DynamicBitrateSupported@QSVEncoder@@UBE_NXZ ENDP	; QSVEncoder::DynamicBitrateSupported
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ?SetBitRate@QSVEncoder@@UAE_NKK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_maxBitrate$ = 8					; size = 4
_bufferSize$ = 12					; size = 4
?SetBitRate@QSVEncoder@@UAE_NKK@Z PROC			; QSVEncoder::SetBitRate, COMDAT
; _this$ = ecx

; 1267 :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1268 :         return false;

	xor	al, al

; 1269 :     }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetBitRate@QSVEncoder@@UAE_NKK@Z ENDP			; QSVEncoder::SetBitRate
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ?RequestKeyframe@QSVEncoder@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RequestKeyframe@QSVEncoder@@UAEXXZ PROC		; QSVEncoder::RequestKeyframe, COMDAT
; _this$ = ecx

; 1272 :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1273 :         bRequestKeyframe = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+500], 1

; 1274 :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?RequestKeyframe@QSVEncoder@@UAEXXZ ENDP		; QSVEncoder::RequestKeyframe
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ?isQSV@QSVEncoder@@UAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isQSV@QSVEncoder@@UAE_NXZ PROC				; QSVEncoder::isQSV, COMDAT
; _this$ = ecx

; 1276 :     virtual bool isQSV() { return true; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	al, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?isQSV@QSVEncoder@@UAE_NXZ ENDP				; QSVEncoder::isQSV
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ?HasBufferedFrames@QSVEncoder@@UAE_NXZ
_TEXT	SEGMENT
tv73 = -8						; size = 4
_this$ = -4						; size = 4
?HasBufferedFrames@QSVEncoder@@UAE_NXZ PROC		; QSVEncoder::HasBufferedFrames, COMDAT
; _this$ = ecx

; 1279 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1280 :         return !helper_killed && !encoder_flushed.is_signalled();

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+24]
	test	ecx, ecx
	jne	SHORT $LN3@HasBuffere
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?is_signalled@?$IPCSignal@$00@@QAE_NK@Z	; IPCSignal<1>::is_signalled
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN3@HasBuffere
	mov	DWORD PTR tv73[ebp], 1
	jmp	SHORT $LN4@HasBuffere
$LN3@HasBuffere:
	mov	DWORD PTR tv73[ebp], 0
$LN4@HasBuffere:
	mov	al, BYTE PTR tv73[ebp]

; 1281 :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?HasBufferedFrames@QSVEncoder@@UAE_NXZ ENDP		; QSVEncoder::HasBufferedFrames
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ??R<lambda_11bcb1900b2e1535704e287762a2ec52>@@QBEHPB_WH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_name$ = 8						; size = 4
_def$ = 12						; size = 4
??R<lambda_11bcb1900b2e1535704e287762a2ec52>@@QBEHPB_WH@Z PROC ; <lambda_11bcb1900b2e1535704e287762a2ec52>::operator(), COMDAT
; _this$ = ecx

; 614  :             auto load_int = [&](CTSTR name, int def) { return AppConfig->GetInt(L"QSV (Advanced)", name, def); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _def$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET $SG4294870430
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	esp, ebp
	pop	ebp
	ret	8
??R<lambda_11bcb1900b2e1535704e287762a2ec52>@@QBEHPB_WH@Z ENDP ; <lambda_11bcb1900b2e1535704e287762a2ec52>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ?<helper_func_cdecl>@<lambda_11bcb1900b2e1535704e287762a2ec52>@@CAHPB_WH@Z
_TEXT	SEGMENT
_name$ = 8						; size = 4
_def$ = 12						; size = 4
?<helper_func_cdecl>@<lambda_11bcb1900b2e1535704e287762a2ec52>@@CAHPB_WH@Z PROC ; <lambda_11bcb1900b2e1535704e287762a2ec52>::<helper_func_cdecl>, COMDAT

; 614  :             auto load_int = [&](CTSTR name, int def) { return AppConfig->GetInt(L"QSV (Advanced)", name, def); };

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _def$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET $SG4294870429
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	pop	ebp
	ret	0
?<helper_func_cdecl>@<lambda_11bcb1900b2e1535704e287762a2ec52>@@CAHPB_WH@Z ENDP ; <lambda_11bcb1900b2e1535704e287762a2ec52>::<helper_func_cdecl>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ?<helper_func_stdcall>@<lambda_11bcb1900b2e1535704e287762a2ec52>@@CGHPB_WH@Z
_TEXT	SEGMENT
_name$ = 8						; size = 4
_def$ = 12						; size = 4
?<helper_func_stdcall>@<lambda_11bcb1900b2e1535704e287762a2ec52>@@CGHPB_WH@Z PROC ; <lambda_11bcb1900b2e1535704e287762a2ec52>::<helper_func_stdcall>, COMDAT

; 614  :             auto load_int = [&](CTSTR name, int def) { return AppConfig->GetInt(L"QSV (Advanced)", name, def); };

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _def$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET $SG4294870428
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	pop	ebp
	ret	8
?<helper_func_stdcall>@<lambda_11bcb1900b2e1535704e287762a2ec52>@@CGHPB_WH@Z ENDP ; <lambda_11bcb1900b2e1535704e287762a2ec52>::<helper_func_stdcall>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ?<helper_func_fastcall>@<lambda_11bcb1900b2e1535704e287762a2ec52>@@CIHPB_WH@Z
_TEXT	SEGMENT
_name$ = -8						; size = 4
_def$ = -4						; size = 4
?<helper_func_fastcall>@<lambda_11bcb1900b2e1535704e287762a2ec52>@@CIHPB_WH@Z PROC ; <lambda_11bcb1900b2e1535704e287762a2ec52>::<helper_func_fastcall>, COMDAT
; _name$ = ecx
; _def$ = edx

; 614  :             auto load_int = [&](CTSTR name, int def) { return AppConfig->GetInt(L"QSV (Advanced)", name, def); };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _def$[ebp], edx
	mov	DWORD PTR _name$[ebp], ecx
	mov	eax, DWORD PTR _def$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET $SG4294870427
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	esp, ebp
	pop	ebp
	ret	0
?<helper_func_fastcall>@<lambda_11bcb1900b2e1535704e287762a2ec52>@@CIHPB_WH@Z ENDP ; <lambda_11bcb1900b2e1535704e287762a2ec52>::<helper_func_fastcall>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ?<helper_func_vectorcall>@<lambda_11bcb1900b2e1535704e287762a2ec52>@@CQHPB_WH@Z
_TEXT	SEGMENT
_name$ = -8						; size = 4
_def$ = -4						; size = 4
?<helper_func_vectorcall>@<lambda_11bcb1900b2e1535704e287762a2ec52>@@CQHPB_WH@Z PROC ; <lambda_11bcb1900b2e1535704e287762a2ec52>::<helper_func_vectorcall>, COMDAT
; _name$ = ecx
; _def$ = edx

; 614  :             auto load_int = [&](CTSTR name, int def) { return AppConfig->GetInt(L"QSV (Advanced)", name, def); };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _def$[ebp], edx
	mov	DWORD PTR _name$[ebp], ecx
	mov	eax, DWORD PTR _def$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET $SG4294870426
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	esp, ebp
	pop	ebp
	ret	0
?<helper_func_vectorcall>@<lambda_11bcb1900b2e1535704e287762a2ec52>@@CQHPB_WH@Z ENDP ; <lambda_11bcb1900b2e1535704e287762a2ec52>::<helper_func_vectorcall>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ??0<lambda_d474bca0a2765bcf38e9e3bf3578a4c7>@@QAE@PAVQSVEncoder@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__This$ = 8						; size = 4
??0<lambda_d474bca0a2765bcf38e9e3bf3578a4c7>@@QAE@PAVQSVEncoder@@@Z PROC ; <lambda_d474bca0a2765bcf38e9e3bf3578a4c7>::<lambda_d474bca0a2765bcf38e9e3bf3578a4c7>, COMDAT
; _this$ = ecx

; 719  :         {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __This$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0<lambda_d474bca0a2765bcf38e9e3bf3578a4c7>@@QAE@PAVQSVEncoder@@@Z ENDP ; <lambda_d474bca0a2765bcf38e9e3bf3578a4c7>::<lambda_d474bca0a2765bcf38e9e3bf3578a4c7>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ??R<lambda_d474bca0a2765bcf38e9e3bf3578a4c7>@@QBEXPB_W@Z
_TEXT	SEGMENT
$T1 = -16						; size = 8
$T2 = -8						; size = 4
_this$ = -4						; size = 4
_name$ = 8						; size = 4
??R<lambda_d474bca0a2765bcf38e9e3bf3578a4c7>@@QBEXPB_W@Z PROC ; <lambda_d474bca0a2765bcf38e9e3bf3578a4c7>::operator(), COMDAT
; _this$ = ecx

; 719  :         {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 720  :             AppWarning(L"Failed to initialize QSV IPC '%s' (full name: '%s') (%u)", name, (event_prefix + name).Array(), GetLastError());

	call	DWORD PTR __imp__GetLastError@0
	push	eax
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	add	ecx, 488				; 000001e8H
	call	DWORD PTR __imp_??HString@@QBE?AV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET $SG4294870425
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 16					; 00000010H
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 721  :             StopHelper(stop, process_waiter, qsvhelper_process);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 12					; 0000000cH
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 392				; 00000188H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 20					; 00000014H
	push	eax
	call	?StopHelper@?A0x7e09c670@@YAXAAU?$IPCSignal@$00@@AAUIPCWaiter@@AAUsafe_handle@@@Z ; `anonymous namespace'::StopHelper
	add	esp, 12					; 0000000cH

; 722  :             throw Str("Encoder.QSV.IPCInit");

	push	OFFSET $SG4294870424
	mov	ecx, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	mov	DWORD PTR $T2[ebp], eax
	push	OFFSET __TI2CPA_W
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	call	__CxxThrowException@8
$LN2@operator:

; 723  :         };

	mov	esp, ebp
	pop	ebp
	ret	4
??R<lambda_d474bca0a2765bcf38e9e3bf3578a4c7>@@QBEXPB_W@Z ENDP ; <lambda_d474bca0a2765bcf38e9e3bf3578a4c7>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ??R<lambda_4f23e6955dca7f806ec2428e9267999f>@@QBE_NE@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
_val$ = 8						; size = 1
??R<lambda_4f23e6955dca7f806ec2428e9267999f>@@QBE_NE@Z PROC ; <lambda_4f23e6955dca7f806ec2428e9267999f>::operator(), COMDAT
; _this$ = ecx

; 983  :                     if (*sei_start == 0x80 && std::find_if_not(sei_start + 1, end, [](uint8_t val) { return val == 0; }) == end) //find rbsp_trailing_bits

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	movzx	eax, BYTE PTR _val$[ebp]
	test	eax, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv66[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv66[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??R<lambda_4f23e6955dca7f806ec2428e9267999f>@@QBE_NE@Z ENDP ; <lambda_4f23e6955dca7f806ec2428e9267999f>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ?<helper_func_cdecl>@<lambda_4f23e6955dca7f806ec2428e9267999f>@@CA_NE@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
_val$ = 8						; size = 1
?<helper_func_cdecl>@<lambda_4f23e6955dca7f806ec2428e9267999f>@@CA_NE@Z PROC ; <lambda_4f23e6955dca7f806ec2428e9267999f>::<helper_func_cdecl>, COMDAT

; 983  :                     if (*sei_start == 0x80 && std::find_if_not(sei_start + 1, end, [](uint8_t val) { return val == 0; }) == end) //find rbsp_trailing_bits

	push	ebp
	mov	ebp, esp
	push	ecx
	movzx	eax, BYTE PTR _val$[ebp]
	test	eax, eax
	jne	SHORT $LN3@
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@
$LN3@:
	mov	DWORD PTR tv66[ebp], 0
$LN4@:
	mov	al, BYTE PTR tv66[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?<helper_func_cdecl>@<lambda_4f23e6955dca7f806ec2428e9267999f>@@CA_NE@Z ENDP ; <lambda_4f23e6955dca7f806ec2428e9267999f>::<helper_func_cdecl>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ?<helper_func_stdcall>@<lambda_4f23e6955dca7f806ec2428e9267999f>@@CG_NE@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
_val$ = 8						; size = 1
?<helper_func_stdcall>@<lambda_4f23e6955dca7f806ec2428e9267999f>@@CG_NE@Z PROC ; <lambda_4f23e6955dca7f806ec2428e9267999f>::<helper_func_stdcall>, COMDAT

; 983  :                     if (*sei_start == 0x80 && std::find_if_not(sei_start + 1, end, [](uint8_t val) { return val == 0; }) == end) //find rbsp_trailing_bits

	push	ebp
	mov	ebp, esp
	push	ecx
	movzx	eax, BYTE PTR _val$[ebp]
	test	eax, eax
	jne	SHORT $LN3@
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@
$LN3@:
	mov	DWORD PTR tv66[ebp], 0
$LN4@:
	mov	al, BYTE PTR tv66[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?<helper_func_stdcall>@<lambda_4f23e6955dca7f806ec2428e9267999f>@@CG_NE@Z ENDP ; <lambda_4f23e6955dca7f806ec2428e9267999f>::<helper_func_stdcall>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ?<helper_func_fastcall>@<lambda_4f23e6955dca7f806ec2428e9267999f>@@CI_NE@Z
_TEXT	SEGMENT
tv66 = -8						; size = 4
_val$ = -4						; size = 1
?<helper_func_fastcall>@<lambda_4f23e6955dca7f806ec2428e9267999f>@@CI_NE@Z PROC ; <lambda_4f23e6955dca7f806ec2428e9267999f>::<helper_func_fastcall>, COMDAT
; _val$ = cl

; 983  :                     if (*sei_start == 0x80 && std::find_if_not(sei_start + 1, end, [](uint8_t val) { return val == 0; }) == end) //find rbsp_trailing_bits

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	BYTE PTR _val$[ebp], cl
	movzx	eax, BYTE PTR _val$[ebp]
	test	eax, eax
	jne	SHORT $LN3@
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@
$LN3@:
	mov	DWORD PTR tv66[ebp], 0
$LN4@:
	mov	al, BYTE PTR tv66[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?<helper_func_fastcall>@<lambda_4f23e6955dca7f806ec2428e9267999f>@@CI_NE@Z ENDP ; <lambda_4f23e6955dca7f806ec2428e9267999f>::<helper_func_fastcall>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ?<helper_func_vectorcall>@<lambda_4f23e6955dca7f806ec2428e9267999f>@@CQ_NE@Z
_TEXT	SEGMENT
tv66 = -8						; size = 4
_val$ = -4						; size = 1
?<helper_func_vectorcall>@<lambda_4f23e6955dca7f806ec2428e9267999f>@@CQ_NE@Z PROC ; <lambda_4f23e6955dca7f806ec2428e9267999f>::<helper_func_vectorcall>, COMDAT
; _val$ = cl

; 983  :                     if (*sei_start == 0x80 && std::find_if_not(sei_start + 1, end, [](uint8_t val) { return val == 0; }) == end) //find rbsp_trailing_bits

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	BYTE PTR _val$[ebp], cl
	movzx	eax, BYTE PTR _val$[ebp]
	test	eax, eax
	jne	SHORT $LN3@
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@
$LN3@:
	mov	DWORD PTR tv66[ebp], 0
$LN4@:
	mov	al, BYTE PTR tv66[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?<helper_func_vectorcall>@<lambda_4f23e6955dca7f806ec2428e9267999f>@@CQ_NE@Z ENDP ; <lambda_4f23e6955dca7f806ec2428e9267999f>::<helper_func_vectorcall>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GQSVEncoder@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GQSVEncoder@@UAEPAXI@Z PROC				; QSVEncoder::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1QSVEncoder@@UAE@XZ			; QSVEncoder::~QSVEncoder
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GQSVEncoder@@UAEPAXI@Z ENDP				; QSVEncoder::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0VideoEncoder@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0VideoEncoder@@QAE@XZ PROC				; VideoEncoder::VideoEncoder, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7VideoEncoder@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0VideoEncoder@@QAE@XZ ENDP				; VideoEncoder::VideoEncoder
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$IPCSignal@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$IPCSignal@$00@@QAE@XZ PROC				; IPCSignal<1>::~IPCSignal<1>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1safe_handle@@QAE@XZ			; safe_handle::~safe_handle
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$IPCSignal@$00@@QAE@XZ ENDP				; IPCSignal<1>::~IPCSignal<1>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$IPCArray@Ubitstream_info@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$IPCArray@Ubitstream_info@@@@QAE@XZ PROC		; IPCArray<bitstream_info>::~IPCArray<bitstream_info>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1NamedSharedMemory@@QAE@XZ		; NamedSharedMemory::~NamedSharedMemory
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$IPCArray@Ubitstream_info@@@@QAE@XZ ENDP		; IPCArray<bitstream_info>::~IPCArray<bitstream_info>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$CircularList@I@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CircularList@I@@QAE@XZ PROC			; CircularList<unsigned int>::~CircularList<unsigned int>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$List@I@@QAE@XZ			; List<unsigned int>::~List<unsigned int>
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CircularList@I@@QAE@XZ ENDP			; CircularList<unsigned int>::~CircularList<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$IPCLockedSignalledArray@Uqueued_frame@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$IPCLockedSignalledArray@Uqueued_frame@@@@QAE@XZ PROC ; IPCLockedSignalledArray<queued_frame>::~IPCLockedSignalledArray<queued_frame>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	call	??1IPCMutex@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$IPCSignalledArray@Uqueued_frame@@@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$IPCLockedSignalledArray@Uqueued_frame@@@@QAE@XZ ENDP ; IPCLockedSignalledArray<queued_frame>::~IPCLockedSignalledArray<queued_frame>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$IPCLockedSignalledArray@I@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$IPCLockedSignalledArray@I@@QAE@XZ PROC		; IPCLockedSignalledArray<unsigned int>::~IPCLockedSignalledArray<unsigned int>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	call	??1IPCMutex@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$IPCSignalledArray@I@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$IPCLockedSignalledArray@I@@QAE@XZ ENDP		; IPCLockedSignalledArray<unsigned int>::~IPCLockedSignalledArray<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$IPCLockedSignalledType@H@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$IPCLockedSignalledType@H@@QAE@XZ PROC		; IPCLockedSignalledType<int>::~IPCLockedSignalledType<int>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??1IPCMutex@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$IPCSignalledType@H@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$IPCLockedSignalledType@H@@QAE@XZ ENDP		; IPCLockedSignalledType<int>::~IPCLockedSignalledType<int>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1DTSGenerator@?A0x7e09c670@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1DTSGenerator@?A0x7e09c670@@QAE@XZ PROC		; `anonymous namespace'::DTSGenerator::~DTSGenerator, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	??1?$List@_J@@QAE@XZ			; List<__int64>::~List<__int64>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??1?$List@_J@@QAE@XZ			; List<__int64>::~List<__int64>
	mov	esp, ebp
	pop	ebp
	ret	0
??1DTSGenerator@?A0x7e09c670@@QAE@XZ ENDP		; `anonymous namespace'::DTSGenerator::~DTSGenerator
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$IPCSignalledType@Uinit_response@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$IPCSignalledType@Uinit_response@@@@QAE@XZ PROC	; IPCSignalledType<init_response>::~IPCSignalledType<init_response>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	??1?$IPCSignal@$0A@@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$IPCType@Uinit_response@@@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$IPCSignalledType@Uinit_response@@@@QAE@XZ ENDP	; IPCSignalledType<init_response>::~IPCSignalledType<init_response>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0IPCWaiter@@QAE@ABU0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0IPCWaiter@@QAE@ABU0@@Z PROC				; IPCWaiter::IPCWaiter, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@ABV01@@Z ; std::vector<void *,std::allocator<void *> >::vector<void *,std::allocator<void *> >
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0IPCWaiter@@QAE@ABU0@@Z ENDP				; IPCWaiter::IPCWaiter
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??4IPCWaiter@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4IPCWaiter@@QAEAAU0@ABU0@@Z PROC			; IPCWaiter::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<void *,std::allocator<void *> >::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4IPCWaiter@@QAEAAU0@ABU0@@Z ENDP			; IPCWaiter::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$IPCSignalledType@Uspspps_size@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$IPCSignalledType@Uspspps_size@@@@QAE@XZ PROC	; IPCSignalledType<spspps_size>::~IPCSignalledType<spspps_size>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	??1?$IPCSignal@$0A@@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$IPCType@Uspspps_size@@@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$IPCSignalledType@Uspspps_size@@@@QAE@XZ ENDP	; IPCSignalledType<spspps_size>::~IPCSignalledType<spspps_size>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$IPCSignalledArray@E@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$IPCSignalledArray@E@@QAE@XZ PROC			; IPCSignalledArray<unsigned char>::~IPCSignalledArray<unsigned char>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??1?$IPCSignal@$0A@@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$IPCArray@E@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$IPCSignalledArray@E@@QAE@XZ ENDP			; IPCSignalledArray<unsigned char>::~IPCSignalledArray<unsigned char>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$IPCSignalledArray@Uqueued_frame@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$IPCSignalledArray@Uqueued_frame@@@@QAE@XZ PROC	; IPCSignalledArray<queued_frame>::~IPCSignalledArray<queued_frame>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??1?$IPCSignal@$0A@@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$IPCArray@Uqueued_frame@@@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$IPCSignalledArray@Uqueued_frame@@@@QAE@XZ ENDP	; IPCSignalledArray<queued_frame>::~IPCSignalledArray<queued_frame>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1IPCMutex@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1IPCMutex@@QAE@XZ PROC				; IPCMutex::~IPCMutex, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1safe_handle@@QAE@XZ			; safe_handle::~safe_handle
	mov	esp, ebp
	pop	ebp
	ret	0
??1IPCMutex@@QAE@XZ ENDP				; IPCMutex::~IPCMutex
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$IPCSignalledArray@I@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$IPCSignalledArray@I@@QAE@XZ PROC			; IPCSignalledArray<unsigned int>::~IPCSignalledArray<unsigned int>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??1?$IPCSignal@$0A@@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$IPCArray@I@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$IPCSignalledArray@I@@QAE@XZ ENDP			; IPCSignalledArray<unsigned int>::~IPCSignalledArray<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$IPCSignalledType@H@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$IPCSignalledType@H@@QAE@XZ PROC			; IPCSignalledType<int>::~IPCSignalledType<int>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	??1?$IPCSignal@$0A@@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$IPCType@H@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$IPCSignalledType@H@@QAE@XZ ENDP			; IPCSignalledType<int>::~IPCSignalledType<int>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$IPCType@Uinit_response@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$IPCType@Uinit_response@@@@QAE@XZ PROC		; IPCType<init_response>::~IPCType<init_response>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1NamedSharedMemory@@QAE@XZ		; NamedSharedMemory::~NamedSharedMemory
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$IPCType@Uinit_response@@@@QAE@XZ ENDP		; IPCType<init_response>::~IPCType<init_response>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$IPCType@Uspspps_size@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$IPCType@Uspspps_size@@@@QAE@XZ PROC		; IPCType<spspps_size>::~IPCType<spspps_size>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1NamedSharedMemory@@QAE@XZ		; NamedSharedMemory::~NamedSharedMemory
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$IPCType@Uspspps_size@@@@QAE@XZ ENDP		; IPCType<spspps_size>::~IPCType<spspps_size>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$IPCArray@E@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$IPCArray@E@@QAE@XZ PROC				; IPCArray<unsigned char>::~IPCArray<unsigned char>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1NamedSharedMemory@@QAE@XZ		; NamedSharedMemory::~NamedSharedMemory
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$IPCArray@E@@QAE@XZ ENDP				; IPCArray<unsigned char>::~IPCArray<unsigned char>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$IPCArray@Uqueued_frame@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$IPCArray@Uqueued_frame@@@@QAE@XZ PROC		; IPCArray<queued_frame>::~IPCArray<queued_frame>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1NamedSharedMemory@@QAE@XZ		; NamedSharedMemory::~NamedSharedMemory
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$IPCArray@Uqueued_frame@@@@QAE@XZ ENDP		; IPCArray<queued_frame>::~IPCArray<queued_frame>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$IPCArray@I@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$IPCArray@I@@QAE@XZ PROC				; IPCArray<unsigned int>::~IPCArray<unsigned int>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1NamedSharedMemory@@QAE@XZ		; NamedSharedMemory::~NamedSharedMemory
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$IPCArray@I@@QAE@XZ ENDP				; IPCArray<unsigned int>::~IPCArray<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$IPCType@H@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$IPCType@H@@QAE@XZ PROC				; IPCType<int>::~IPCType<int>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1NamedSharedMemory@@QAE@XZ		; NamedSharedMemory::~NamedSharedMemory
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$IPCType@H@@QAE@XZ ENDP				; IPCType<int>::~IPCType<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ?CreateQSVEncoder@@YAPAVVideoEncoder@@HHHHPB_W_NAAUColorDescription@@HH1AAVString@@@Z
_TEXT	SEGMENT
$T2 = -60						; size = 8
$T3 = -52						; size = 8
$T4 = -44						; size = 8
_str$5 = -36						; size = 4
$T6 = -32						; size = 4
tv176 = -28						; size = 4
$T7 = -24						; size = 4
_append_help$8 = -20					; size = 4
__$EHRec$ = -16						; size = 16
_fps$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_quality$ = 20						; size = 4
_preset$ = 24						; size = 4
_bUse444$ = 28						; size = 1
_colorDesc$ = 32					; size = 4
_maxBitRate$ = 36					; size = 4
_bufferSize$ = 40					; size = 4
_bUseCFR$ = 44						; size = 1
_errors$ = 48						; size = 4
?CreateQSVEncoder@@YAPAVVideoEncoder@@HHHHPB_W_NAAUColorDescription@@HH1AAVString@@@Z PROC ; CreateQSVEncoder, COMDAT

; 1285 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CreateQSVEncoder@@YAPAVVideoEncoder@@HHHHPB_W_NAAUColorDescription@@HH1AAVString@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 44					; 0000002cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 1286 :     if (!CheckQSVHardwareSupport())

	push	0
	push	1
	call	?CheckQSVHardwareSupport@@YA_N_NPA_N@Z	; CheckQSVHardwareSupport
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN8@CreateQSVE

; 1287 :     {
; 1288 :         errors << Str("Encoder.QSV.NoHardwareSupport");

	push	OFFSET $SG4294870423
	mov	ecx, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	mov	ecx, DWORD PTR _errors$[ebp]
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z

; 1289 :         return nullptr;

	xor	eax, eax
	jmp	$LN10@CreateQSVE
$LN8@CreateQSVE:

; 1290 :     }
; 1291 :     
; 1292 :     if (qsv_get_cpu_platform() <= QSV_CPU_PLATFORM_IVB)

	call	?qsv_get_cpu_platform@?A0x7e09c670@@YA?AW4qsv_cpu_platform@1@XZ ; `anonymous namespace'::qsv_get_cpu_platform
	cmp	eax, 3
	jg	$LN7@CreateQSVE

; 1293 :     {
; 1294 :         auto append_help = [&] { errors << Str("Encoder.QSV.ExceededResolutionHelp"); }; //might need to merge this into the actual error messages if there are problems with translations

	mov	edx, DWORD PTR _errors$[ebp]
	push	edx
	lea	ecx, DWORD PTR _append_help$8[ebp]
	call	??0<lambda_847973be62fdd1e04d4d6867d05182b0>@@QAE@AAVString@@@Z ; <lambda_847973be62fdd1e04d4d6867d05182b0>::<lambda_847973be62fdd1e04d4d6867d05182b0>

; 1295 : 
; 1296 :         if (width > 1920 && height > 1200)

	cmp	DWORD PTR _width$[ebp], 1920		; 00000780H
	jle	SHORT $LN6@CreateQSVE
	cmp	DWORD PTR _height$[ebp], 1200		; 000004b0H
	jle	SHORT $LN6@CreateQSVE

; 1297 :         {
; 1298 :             Log(TEXT("QSV: Output resolution of %ux%u exceeds the maximum of 1920x1200 supported by QuickSync on Sandy Bridge and Ivy Bridge based processors"), width, height);

	mov	eax, DWORD PTR _height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	push	OFFSET $SG4294870422
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 12					; 0000000cH

; 1299 :             errors << FormattedString(Str("Encoder.QSV.SNBIVBMaximumResolutionWidthHeightExceeded"), width, height);

	mov	edx, DWORD PTR _height$[ebp]
	push	edx
	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	push	OFFSET $SG4294870421
	mov	ecx, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR _errors$[ebp]
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T4[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 1300 :             append_help();

	lea	ecx, DWORD PTR _append_help$8[ebp]
	call	??R<lambda_847973be62fdd1e04d4d6867d05182b0>@@QBEXXZ ; <lambda_847973be62fdd1e04d4d6867d05182b0>::operator()

; 1301 :             return nullptr;

	xor	eax, eax
	jmp	$LN10@CreateQSVE
	jmp	$LN7@CreateQSVE
$LN6@CreateQSVE:

; 1302 :         }
; 1303 :         else if (width > 1920)

	cmp	DWORD PTR _width$[ebp], 1920		; 00000780H
	jle	SHORT $LN4@CreateQSVE

; 1304 :         {
; 1305 :             Log(TEXT("QSV: Output resolution width of %u exceeds the maximum of 1920 supported by QuickSync on Sandy Bridge and Ivy Bridge based processors"), width);

	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	push	OFFSET $SG4294870420
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8

; 1306 :             errors << FormattedString(Str("Encoder.QSV.SNBIVBMaximumResolutionWidthExceeded"), width);

	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	push	OFFSET $SG4294870419
	mov	edx, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [edx]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _errors$[ebp]
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T3[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 1307 :             append_help();

	lea	ecx, DWORD PTR _append_help$8[ebp]
	call	??R<lambda_847973be62fdd1e04d4d6867d05182b0>@@QBEXXZ ; <lambda_847973be62fdd1e04d4d6867d05182b0>::operator()

; 1308 :             return nullptr;

	xor	eax, eax
	jmp	$LN10@CreateQSVE
	jmp	SHORT $LN7@CreateQSVE
$LN4@CreateQSVE:

; 1309 :         }
; 1310 :         else if (height > 1200)

	cmp	DWORD PTR _height$[ebp], 1200		; 000004b0H
	jle	SHORT $LN7@CreateQSVE

; 1311 :         {
; 1312 :             Log(TEXT("QSV: Output resolution height of %u exceeds the maximum of 1200 supported by QuickSync on Sandy Bridge and Ivy Bridge based processors"), height);

	mov	ecx, DWORD PTR _height$[ebp]
	push	ecx
	push	OFFSET $SG4294870418
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8

; 1313 :             errors << FormattedString(Str("Encoder.QSV.SNBIVBMaximumResolutionHeightExceeded"), height);

	mov	edx, DWORD PTR _height$[ebp]
	push	edx
	push	OFFSET $SG4294870417
	mov	eax, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _errors$[ebp]
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 1314 :             append_help();

	lea	ecx, DWORD PTR _append_help$8[ebp]
	call	??R<lambda_847973be62fdd1e04d4d6867d05182b0>@@QBEXXZ ; <lambda_847973be62fdd1e04d4d6867d05182b0>::operator()

; 1315 :             return nullptr;

	xor	eax, eax
	jmp	$LN10@CreateQSVE
$LN7@CreateQSVE:

; 1316 :         }
; 1317 :     }
; 1318 : 
; 1319 :     try
; 1320 :     {

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1321 :         return new QSVEncoder(fps, width, height, quality, preset, bUse444, colorDesc, maxBitRate, bufferSize, bUseCFR);

	push	560					; 00000230H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T7[ebp], eax
	cmp	DWORD PTR $T7[ebp], 0
	je	SHORT $LN11@CreateQSVE
	movzx	edx, BYTE PTR _bUseCFR$[ebp]
	push	edx
	mov	eax, DWORD PTR _bufferSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _maxBitRate$[ebp]
	push	ecx
	mov	edx, DWORD PTR _colorDesc$[ebp]
	push	edx
	movzx	eax, BYTE PTR _bUse444$[ebp]
	push	eax
	mov	ecx, DWORD PTR _preset$[ebp]
	push	ecx
	mov	edx, DWORD PTR _quality$[ebp]
	push	edx
	mov	eax, DWORD PTR _height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fps$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T7[ebp]
	call	??0QSVEncoder@@QAE@HHHHPB_W_NAAUColorDescription@@HH1@Z ; QSVEncoder::QSVEncoder
	mov	DWORD PTR tv176[ebp], eax
	jmp	SHORT $LN12@CreateQSVE
$LN11@CreateQSVE:
	mov	DWORD PTR tv176[ebp], 0
$LN12@CreateQSVE:
	mov	eax, DWORD PTR tv176[ebp]
	jmp	SHORT $LN10@CreateQSVE
__catch$?CreateQSVEncoder@@YAPAVVideoEncoder@@HHHHPB_W_NAAUColorDescription@@HH1AAVString@@@Z$0:

; 1322 :     }
; 1323 :     catch (CTSTR str)
; 1324 :     {
; 1325 :         errors << str;

	mov	eax, DWORD PTR _str$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _errors$[ebp]
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z

; 1326 :         return nullptr;

	mov	DWORD PTR $T6[ebp], 0
	mov	eax, $LN17@CreateQSVE
	ret	0

; 1327 :     }

	mov	eax, __tryend$?CreateQSVEncoder@@YAPAVVideoEncoder@@HHHHPB_W_NAAUColorDescription@@HH1AAVString@@@Z$2
	ret	0
__catch$?CreateQSVEncoder@@YAPAVVideoEncoder@@HHHHPB_W_NAAUColorDescription@@HH1AAVString@@@Z$1:

; 1328 :     catch (...)
; 1329 :     {
; 1330 :         CrashError(L"Caught unhandled exception");

	push	OFFSET $SG4294870416
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ

; 1331 :     }

	mov	eax, $LN19@CreateQSVE
	ret	0
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?CreateQSVEncoder@@YAPAVVideoEncoder@@HHHHPB_W_NAAUColorDescription@@HH1AAVString@@@Z$2
$LN19@CreateQSVE:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?CreateQSVEncoder@@YAPAVVideoEncoder@@HHHHPB_W_NAAUColorDescription@@HH1AAVString@@@Z$2:
	jmp	SHORT $LN10@CreateQSVE
$LN17@CreateQSVE:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1326 :         return nullptr;

	mov	eax, DWORD PTR $T6[ebp]
$LN10@CreateQSVE:

; 1332 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?CreateQSVEncoder@@YAPAVVideoEncoder@@HHHHPB_W_NAAUColorDescription@@HH1AAVString@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?CreateQSVEncoder@@YAPAVVideoEncoder@@HHHHPB_W_NAAUColorDescription@@HH1AAVString@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CreateQSVEncoder@@YAPAVVideoEncoder@@HHHHPB_W_NAAUColorDescription@@HH1AAVString@@@Z ENDP ; CreateQSVEncoder
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ??0<lambda_847973be62fdd1e04d4d6867d05182b0>@@QAE@AAVString@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___errors$ = 8						; size = 4
??0<lambda_847973be62fdd1e04d4d6867d05182b0>@@QAE@AAVString@@@Z PROC ; <lambda_847973be62fdd1e04d4d6867d05182b0>::<lambda_847973be62fdd1e04d4d6867d05182b0>, COMDAT
; _this$ = ecx

; 1294 :         auto append_help = [&] { errors << Str("Encoder.QSV.ExceededResolutionHelp"); }; //might need to merge this into the actual error messages if there are problems with translations

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___errors$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0<lambda_847973be62fdd1e04d4d6867d05182b0>@@QAE@AAVString@@@Z ENDP ; <lambda_847973be62fdd1e04d4d6867d05182b0>::<lambda_847973be62fdd1e04d4d6867d05182b0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ??R<lambda_847973be62fdd1e04d4d6867d05182b0>@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??R<lambda_847973be62fdd1e04d4d6867d05182b0>@@QBEXXZ PROC ; <lambda_847973be62fdd1e04d4d6867d05182b0>::operator(), COMDAT
; _this$ = ecx

; 1294 :         auto append_help = [&] { errors << Str("Encoder.QSV.ExceededResolutionHelp"); }; //might need to merge this into the actual error messages if there are problems with translations

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET $SG4294870415
	mov	eax, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	esp, ebp
	pop	ebp
	ret	0
??R<lambda_847973be62fdd1e04d4d6867d05182b0>@@QBEXXZ ENDP ; <lambda_847973be62fdd1e04d4d6867d05182b0>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Insert@?$List@E@@QAEXIABE@Z
_TEXT	SEGMENT
_moveCount$ = -16					; size = 4
tv94 = -12						; size = 4
_temp$ = -8						; size = 4
_this$ = -4						; size = 4
_index$ = 8						; size = 4
_val$ = 12						; size = 4
?Insert@?$List@E@@QAEXIABE@Z PROC			; List<unsigned char>::Insert, COMDAT
; _this$ = ecx

; 64   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 65   :         assert(index <= num);
; 66   :         if(index > num) return;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jbe	SHORT $LN3@Insert
	jmp	$LN4@Insert
$LN3@Insert:

; 67   : 
; 68   :         if(!num && !index)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN2@Insert
	cmp	DWORD PTR _index$[ebp], 0
	jne	SHORT $LN2@Insert

; 69   :         {
; 70   :             Add(val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Add@?$List@E@@QAEIABE@Z		; List<unsigned char>::Add

; 71   :             return;

	jmp	$LN4@Insert
$LN2@Insert:

; 72   :         }
; 73   : 
; 74   :         //this makes it safe to insert an item already in the list
; 75   :         T *temp = (T*)Allocate(sizeof(T));

	push	1
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	mov	DWORD PTR _temp$[ebp], eax

; 76   :         mcpy(temp, &val, sizeof(T));

	mov	ecx, DWORD PTR _temp$[ebp]
	mov	edx, DWORD PTR _val$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al

; 77   : 
; 78   :         UINT moveCount = num-index;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, DWORD PTR _index$[ebp]
	mov	DWORD PTR _moveCount$[ebp], edx

; 79   :         array = (T*)ReAllocate(array, sizeof(T)*++num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	DWORD PTR tv94[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv94[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR tv94[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 80   :         if(moveCount)

	cmp	DWORD PTR _moveCount$[ebp], 0
	je	SHORT $LN1@Insert

; 81   :             mcpyrev(array+(index+1), array+index, moveCount*sizeof(T));

	mov	edx, DWORD PTR _moveCount$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _index$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _index$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	push	edx
	call	?mcpyrev@@YGXPAXPBXI@Z			; mcpyrev
$LN1@Insert:

; 82   :         mcpy(&array[index], temp, sizeof(T));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _temp$[ebp]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [ecx+edx], al

; 83   : 
; 84   :         Free(temp);

	mov	ecx, DWORD PTR _temp$[ebp]
	push	ecx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4
$LN4@Insert:

; 85   :     }

	mov	esp, ebp
	pop	ebp
	ret	8
?Insert@?$List@E@@QAEXIABE@Z ENDP			; List<unsigned char>::Insert
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?InsertArray@?$List@E@@QAEXIPBEI@Z
_TEXT	SEGMENT
_oldnum$ = -8						; size = 4
_this$ = -4						; size = 4
_index$ = 8						; size = 4
_new_array$ = 12					; size = 4
_n$ = 16						; size = 4
?InsertArray@?$List@E@@QAEXIPBEI@Z PROC			; List<unsigned char>::InsertArray, COMDAT
; _this$ = ecx

; 155  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 156  :         assert(index <= num);
; 157  : 
; 158  :         if(index > num)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jbe	SHORT $LN4@InsertArra

; 159  :             return;

	jmp	$LN5@InsertArra
$LN4@InsertArra:

; 160  : 
; 161  :         if(!new_array && n)

	cmp	DWORD PTR _new_array$[ebp], 0
	jne	SHORT $LN3@InsertArra
	cmp	DWORD PTR _n$[ebp], 0
	je	SHORT $LN3@InsertArra

; 162  :         {
; 163  :             AppWarning(TEXT("List::InsertArray:  NULL array with count above zero"));

	push	OFFSET ??_C@_1GK@LBKOEOMF@?$AAL?$AAi?$AAs?$AAt?$AA?3?$AA?3?$AAI?$AAn?$AAs?$AAe?$AAr?$AAt?$AAA?$AAr?$AAr?$AAa?$AAy?$AA?3?$AA?5?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?5?$AAw@
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 4

; 164  :             return;

	jmp	SHORT $LN5@InsertArra
$LN3@InsertArra:

; 165  :         }
; 166  : 
; 167  :         if(!n)

	cmp	DWORD PTR _n$[ebp], 0
	jne	SHORT $LN2@InsertArra

; 168  :             return;

	jmp	SHORT $LN5@InsertArra
$LN2@InsertArra:

; 169  : 
; 170  :         int oldnum = num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _oldnum$[ebp], eax

; 171  : 
; 172  :         SetSize(n+num);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	add	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSize@?$List@E@@QAEHI@Z		; List<unsigned char>::SetSize

; 173  : 
; 174  :         assert(num);
; 175  : 
; 176  :         if(!num) {array=NULL; return;}

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN1@InsertArra
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], 0
	jmp	SHORT $LN5@InsertArra
$LN1@InsertArra:

; 177  : 
; 178  :         mcpyrev(array+index+n, array+index, sizeof(T)*(oldnum-index));

	mov	edx, DWORD PTR _oldnum$[ebp]
	sub	edx, DWORD PTR _index$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _index$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, DWORD PTR _index$[ebp]
	add	eax, DWORD PTR _n$[ebp]
	push	eax
	call	?mcpyrev@@YGXPAXPBXI@Z			; mcpyrev

; 179  :         mcpy(array+index, new_array, sizeof(T)*n);

	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	mov	edx, DWORD PTR _new_array$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _index$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN5@InsertArra:

; 180  :     }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?InsertArray@?$List@E@@QAEXIPBEI@Z ENDP			; List<unsigned char>::InsertArray
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 738  : 		{	// construct empty string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 739  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 740  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 767  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 768  : 		assign(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 769  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 1023 : 		{	// append _Right

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1024 : 		return (append(_Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1025 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1038 : 		{	// append _Right

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1039 : 		return (append(_Right, 0, npos));

	mov	eax, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
	push	eax
	push	0
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1040 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare, COMDAT
; _this$ = ecx

; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare

; 2160 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -2						; size = 1
$T2 = -1						; size = 1
__Right$ = 8						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 724  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
	mov	ecx, eax
	call	?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<wchar_t> >::select_on_container_copy_construction
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t> > >

; 725  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy

; 726  : 		assign(_Right, 0, npos);

	mov	edx, DWORD PTR ?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::npos
	push	edx
	push	0
	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 727  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 738  : 		{	// construct empty string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@_W@std@@QAE@XZ		; std::allocator<wchar_t>::allocator<wchar_t>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t> > >

; 739  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy

; 740  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 780  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@_W@std@@QAE@XZ		; std::allocator<wchar_t>::allocator<wchar_t>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t> > >

; 781  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy

; 782  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 783  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Right$ = 8						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 887  : 		{	// construct by moving _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t> > >

; 888  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy

; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	call	??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv

; 890  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 990  : 		{	// destroy the string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 991  : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy

; 992  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -3						; size = 1
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Right$ = 8						; size = 4
??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=, COMDAT
; _this$ = ecx

; 997  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 998  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	SHORT $LN2@operator

; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)

	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
	push	eax
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
	push	eax
	call	??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ; std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t> >
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator
	xor	ecx, ecx
	je	SHORT $LN1@operator

; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy

; 1004 : 				this->_Change_alloc(_Right._Getal());

	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Change_alloc
$LN1@operator:

; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
$LN2@operator:

; 1008 : 			}
; 1009 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 1010 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str, COMDAT
; _this$ = ecx

; 1738 : 		{	// return pointer to null-terminated nonmutable array

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1739 : 		return (this->_Myptr());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr

; 1740 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??0?$CircularList@I@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CircularList@I@@QAE@XZ PROC			; CircularList<unsigned int>::CircularList<unsigned int>, COMDAT
; _this$ = ecx

; 784  :     inline CircularList() : startID(0), endID(0), storedNum(0) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$List@I@@QAE@XZ			; List<unsigned int>::List<unsigned int>
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CircularList@I@@QAE@XZ ENDP			; CircularList<unsigned int>::CircularList<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Remove@?$CircularList@I@@QAEXI@Z
_TEXT	SEGMENT
_count$1 = -24						; size = 4
_count$2 = -20						; size = 4
tv94 = -16						; size = 4
tv80 = -12						; size = 4
_realID$ = -8						; size = 4
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?Remove@?$CircularList@I@@QAEXI@Z PROC			; CircularList<unsigned int>::Remove, COMDAT
; _this$ = ecx

; 860  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 861  :         unsigned int realID = GetRealIndex(index);

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRealIndex@?$CircularList@I@@AAEII@Z	; CircularList<unsigned int>::GetRealIndex
	mov	DWORD PTR _realID$[ebp], eax

; 862  : 
; 863  :         if (realID == endID) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _realID$[ebp]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $LN8@Remove

; 864  :             endID = (endID == 0) ? num-1 : endID-1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN11@Remove
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	DWORD PTR tv80[ebp], edx
	jmp	SHORT $LN12@Remove
$LN11@Remove:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, 1
	mov	DWORD PTR tv80[ebp], ecx
$LN12@Remove:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv80[ebp]
	mov	DWORD PTR [edx+12], eax
	jmp	$LN7@Remove
$LN8@Remove:

; 865  :         } else if (realID == startID) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _realID$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN6@Remove

; 866  :             startID = (startID == num-1) ? 0 : startID+1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8], ecx
	jne	SHORT $LN13@Remove
	mov	DWORD PTR tv94[ebp], 0
	jmp	SHORT $LN14@Remove
$LN13@Remove:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	DWORD PTR tv94[ebp], ecx
$LN14@Remove:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv94[ebp]
	mov	DWORD PTR [edx+8], eax
	jmp	$LN7@Remove
$LN6@Remove:

; 867  :         } else if (realID < endID) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _realID$[ebp]
	cmp	edx, DWORD PTR [ecx+12]
	jae	SHORT $LN4@Remove

; 868  :             unsigned int count = endID-realID;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, DWORD PTR _realID$[ebp]
	mov	DWORD PTR _count$2[ebp], ecx

; 869  :             mcpy(array+realID, array+realID+1, count*sizeof(T));

	mov	edx, DWORD PTR _count$2[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _realID$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _realID$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 870  :             --endID;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax
	jmp	SHORT $LN7@Remove
$LN4@Remove:

; 871  :         } else if (realID > startID) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _realID$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jbe	SHORT $LN7@Remove

; 872  :             unsigned int count = realID-startID;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _realID$[ebp]
	sub	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _count$1[ebp], edx

; 873  :             mcpyrev(array+startID+1, array+startID, count*sizeof(T));

	mov	eax, DWORD PTR _count$1[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx+edx*4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*4+4]
	push	ecx
	call	?mcpyrev@@YGXPAXPBXI@Z			; mcpyrev

; 874  :             ++startID;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN7@Remove:

; 875  :         }
; 876  : 
; 877  :         --storedNum;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 878  : 
; 879  :         if (!storedNum)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+16], 0
	jne	SHORT $LN9@Remove

; 880  :             startID = endID = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
$LN9@Remove:

; 881  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?Remove@?$CircularList@I@@QAEXI@Z ENDP			; CircularList<unsigned int>::Remove
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Num@?$CircularList@I@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Num@?$CircularList@I@@QBEIXZ PROC			; CircularList<unsigned int>::Num, COMDAT
; _this$ = ecx

; 908  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 909  :         return storedNum;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 910  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?Num@?$CircularList@I@@QBEIXZ ENDP			; CircularList<unsigned int>::Num
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??6?$CircularList@I@@QAEAAV0@ABI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_val$ = 8						; size = 4
??6?$CircularList@I@@QAEAAV0@ABI@Z PROC			; CircularList<unsigned int>::operator<<, COMDAT
; _this$ = ecx

; 937  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 938  :         Add(val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Add@?$CircularList@I@@QAEIABI@Z	; CircularList<unsigned int>::Add

; 939  :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 940  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??6?$CircularList@I@@QAEAAV0@ABI@Z ENDP			; CircularList<unsigned int>::operator<<
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??A?$CircularList@I@@QAEAAII@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$CircularList@I@@QAEAAII@Z PROC			; CircularList<unsigned int>::operator[], COMDAT
; _this$ = ecx

; 949  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 950  :         if (index >= storedNum) DumpError(TEXT("Out of range!  CircularList::operator[](%d)"), index);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN1@operator
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	push	OFFSET ??_C@_1FI@OMPFMOGB@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAC?$AAi?$AAr?$AAc?$AAu?$AAl?$AAa?$AAr?$AAL?$AAi?$AAs?$AAt?$AA?3?$AA?3?$AAo?$AAp?$AAe@
	call	DWORD PTR __imp_?DumpError@@YAXPB_WZZ
$LN1@operator:

; 951  :         return array[GetRealIndex(index)];

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRealIndex@?$CircularList@I@@AAEII@Z	; CircularList<unsigned int>::GetRealIndex
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+eax*4]
$LN3@operator:

; 952  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CircularList@I@@QAEAAII@Z ENDP			; CircularList<unsigned int>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@XZ PROC	; std::vector<void *,std::allocator<void *> >::vector<void *,std::allocator<void *> >, COMDAT
; _this$ = ecx

; 680  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@PAX@std@@QAE@XZ		; std::allocator<void *>::allocator<void *>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QAE@ABV?$allocator@PAX@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<void *,std::allocator<void *> > >::_Vector_alloc<0,std::_Vec_base_types<void *,std::allocator<void *> > >

; 681  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@XZ ENDP	; std::vector<void *,std::allocator<void *> >::vector<void *,std::allocator<void *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
$T2 = -32						; size = 4
$T3 = -28						; size = 4
_this$ = -24						; size = 4
$T4 = -18						; size = 1
$T5 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<void *,std::allocator<void *> >::vector<void *,std::allocator<void *> >, COMDAT
; _this$ = ecx

; 721  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAX@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<void *,std::allocator<void *> > >::_Getal
	mov	ecx, eax
	call	?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<void *> >::select_on_container_copy_construction
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QAE@ABV?$allocator@PAX@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<void *,std::allocator<void *> > >::_Vector_alloc<0,std::_Vec_base_types<void *,std::allocator<void *> > >

; 722  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAE_NI@Z ; std::vector<void *,std::allocator<void *> >::_Buy
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@vector

; 723  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 724  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 725  : 				this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@PAXV?$allocator@PAX@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@2@XZ ; std::vector<void *,std::allocator<void *> >::end
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@PAXV?$allocator@PAX@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@2@XZ ; std::vector<void *,std::allocator<void *> >::begin
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@std@@@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEPAPAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@1@0PAPAX@Z ; std::vector<void *,std::allocator<void *> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<void *> > > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN5@vector
__catch$??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@ABV01@@Z$0:

; 726  : 			_CATCH_ALL
; 727  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXXZ ; std::vector<void *,std::allocator<void *> >::_Tidy

; 728  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 729  : 			_CATCH_END

	mov	eax, $LN8@vector
	ret	0
$LN5@vector:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN3@vector
$LN8@vector:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN3@vector:

; 730  : 		}

	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<void *,std::allocator<void *> >::vector<void *,std::allocator<void *> >
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ??1?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@XZ PROC	; std::vector<void *,std::allocator<void *> >::~vector<void *,std::allocator<void *> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 945  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXXZ ; std::vector<void *,std::allocator<void *> >::_Tidy

; 946  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@XZ ENDP	; std::vector<void *,std::allocator<void *> >::~vector<void *,std::allocator<void *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ??4?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Ptr$2 = -32						; size = 4
__Ptr$3 = -28						; size = 4
_this$ = -24						; size = 4
$T4 = -20						; size = 1
$T5 = -19						; size = 1
$T6 = -18						; size = 1
$T7 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??4?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<void *,std::allocator<void *> >::operator=, COMDAT
; _this$ = ecx

; 949  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??4?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAV01@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 950  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN11@operator

; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)

	lea	ecx, DWORD PTR $T7[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAX@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<void *,std::allocator<void *> > >::_Getal
	push	eax
	lea	edx, DWORD PTR $T6[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAX@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<void *,std::allocator<void *> > >::_Getal
	push	eax
	call	??$?9V?$allocator@PAX@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@0@Z ; std::operator!=<std::allocator<void *>,std::allocator<void *> >
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN10@operator
	xor	ecx, ecx
	je	SHORT $LN10@operator

; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXXZ ; std::vector<void *,std::allocator<void *> >::_Tidy

; 956  : 				this->_Change_alloc(_Right._Getal());

	lea	edx, DWORD PTR $T5[ebp]
	push	edx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAX@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<void *,std::allocator<void *> > >::_Getal
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@PAX@std@@@2@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<void *,std::allocator<void *> > >::_Change_alloc
$LN10@operator:

; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 960  : 
; 961  : 			if (_Right.empty())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?empty@?$vector@PAXV?$allocator@PAX@std@@@std@@QBE_NXZ ; std::vector<void *,std::allocator<void *> >::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@operator

; 962  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEXXZ ; std::vector<void *,std::allocator<void *> >::clear
	jmp	$LN11@operator
$LN9@operator:

; 963  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::size
	cmp	esi, eax
	ja	SHORT $LN7@operator

; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	??$_Copy_impl@PAPAXPAPAX@std@@YAPAPAXPAPAX00@Z ; std::_Copy_impl<void * *,void * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$2[ebp], eax

; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR __Ptr$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXPAPAX0@Z ; std::vector<void *,std::allocator<void *> >::_Destroy

; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax
	jmp	$LN11@operator
$LN7@operator:

; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::capacity
	cmp	esi, eax
	ja	SHORT $LN5@operator

; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::size
	mov	edx, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Ptr$3[ebp], edx

; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Ptr$3[ebp]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??$_Copy_impl@PAPAXPAPAX@std@@YAPAPAXPAPAX00@Z ; std::_Copy_impl<void * *,void * *>
	add	esp, 12					; 0000000cH

; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR __Ptr$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAX@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEPAPAXPAPAX00@Z ; std::vector<void *,std::allocator<void *> >::_Ucopy<void * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 976  : 				}
; 977  : 			else

	jmp	$LN11@operator
$LN5@operator:

; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN3@operator

; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXPAPAX0@Z ; std::vector<void *,std::allocator<void *> >::_Destroy

; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx]
	sar	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAX@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<void *,std::allocator<void *> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QAEXPAPAXI@Z ; std::_Wrap_alloc<std::allocator<void *> >::deallocate
$LN3@operator:

; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAE_NI@Z ; std::vector<void *,std::allocator<void *> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN11@operator

; 986  : 					_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAX@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEPAPAXPAPAX00@Z ; std::vector<void *,std::allocator<void *> >::_Ucopy<void * *>
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax
	jmp	SHORT $LN14@operator
__catch$??4?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAV01@ABV01@@Z$0:

; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXXZ ; std::vector<void *,std::allocator<void *> >::_Tidy

; 991  : 					_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 992  : 					_CATCH_END

	mov	eax, $LN17@operator
	ret	0
$LN14@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN11@operator
$LN17@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN11@operator:

; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN13@operator:

; 996  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??4?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAV01@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??4?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAV01@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??4?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<void *,std::allocator<void *> >::operator=
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ?size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ PROC ; std::vector<void *,std::allocator<void *> >::size, COMDAT
; _this$ = ecx

; 1147 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1149 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ENDP ; std::vector<void *,std::allocator<void *> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ??A?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAPAXI@Z PROC ; std::vector<void *,std::allocator<void *> >::operator[], COMDAT
; _this$ = ecx

; 1197 : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 1210 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAPAXI@Z ENDP ; std::vector<void *,std::allocator<void *> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ?front@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAPAXXZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?front@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAPAXXZ PROC ; std::vector<void *,std::allocator<void *> >::front, COMDAT
; _this$ = ecx

; 1223 : 		{	// return first element of mutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1224 : 		return (*begin());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAXV?$allocator@PAX@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@2@XZ ; std::vector<void *,std::allocator<void *> >::begin
	mov	ecx, eax
	call	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@std@@QBEAAPAXXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<void *> > >::operator*

; 1225 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?front@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAPAXXZ ENDP ; std::vector<void *,std::allocator<void *> >::front
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ?push_back@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEXABQAX@Z
_TEXT	SEGMENT
__Idx$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Val$ = 8						; size = 4
?push_back@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEXABQAX@Z PROC ; std::vector<void *,std::allocator<void *> >::push_back, COMDAT
; _this$ = ecx

; 1243 : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1244 : 		if (_Inside(_STD addressof(_Val)))

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$addressof@QAX@std@@YAPBQAXABQAX@Z	; std::addressof<void * const>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$vector@PAXV?$allocator@PAX@std@@@std@@IBE_NPBQAX@Z ; std::vector<void *,std::allocator<void *> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@push_back

; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	??$addressof@QAX@std@@YAPBQAXABQAX@Z	; std::addressof<void * const>
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	mov	DWORD PTR __Idx$1[ebp], eax

; 1247 : 			if (this->_Mylast == this->_Myend)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN3@push_back

; 1248 : 				_Reserve(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reserve@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXI@Z ; std::vector<void *,std::allocator<void *> >::_Reserve
$LN3@push_back:

; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@PAXV?$allocator@PAX@std@@@std@@IBEXPAPAX0@Z ; std::vector<void *,std::allocator<void *> >::_Orphan_range

; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Idx$1[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAX@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<void *,std::allocator<void *> > >::_Getal
	mov	ecx, eax
	call	??$construct@PAXAAPAX@?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QAEXPAPAXAAPAX@Z ; std::_Wrap_alloc<std::allocator<void *> >::construct<void *,void * &>

; 1252 : 			++this->_Mylast;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 1253 : 			}
; 1254 : 		else

	jmp	SHORT $LN5@push_back
$LN4@push_back:

; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN1@push_back

; 1257 : 				_Reserve(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reserve@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXI@Z ; std::vector<void *,std::allocator<void *> >::_Reserve
$LN1@push_back:

; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@PAXV?$allocator@PAX@std@@@std@@IBEXPAPAX0@Z ; std::vector<void *,std::allocator<void *> >::_Orphan_range

; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAX@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<void *,std::allocator<void *> > >::_Getal
	mov	ecx, eax
	call	??$construct@PAXABQAX@?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QAEXPAPAXABQAX@Z ; std::_Wrap_alloc<std::allocator<void *> >::construct<void *,void * const &>

; 1261 : 			++this->_Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx
$LN5@push_back:

; 1262 : 			}
; 1263 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEXABQAX@Z ENDP ; std::vector<void *,std::allocator<void *> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ?signal@?$IPCSignal@$0A@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?signal@?$IPCSignal@$0A@@@QAEXXZ PROC			; IPCSignal<0>::signal, COMDAT
; _this$ = ecx

; 92   :     void signal() { SetEvent(signal_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Bsafe_handle@@QAEPAXXZ		; safe_handle::operator void *
	push	eax
	call	DWORD PTR __imp__SetEvent@4
	mov	esp, ebp
	pop	ebp
	ret	0
?signal@?$IPCSignal@$0A@@@QAEXXZ ENDP			; IPCSignal<0>::signal
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??0?$List@_J@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$List@_J@@QAE@XZ PROC				; List<__int64>::List<__int64>, COMDAT
; _this$ = ecx

; 35   :     inline List() : array(NULL), num(0) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@_J@@QAE@XZ ENDP				; List<__int64>::List<__int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??1?$List@_J@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$List@_J@@QAE@XZ PROC				; List<__int64>::~List<__int64>, COMDAT
; _this$ = ecx

; 37   :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 38   :         Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@_J@@QAEXXZ		; List<__int64>::Clear

; 39   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@_J@@QAE@XZ ENDP				; List<__int64>::~List<__int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Num@?$List@_J@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Num@?$List@_J@@QBEIXZ PROC				; List<__int64>::Num, COMDAT
; _this$ = ecx

; 42   :     inline unsigned int Num() const     {return num;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?Num@?$List@_J@@QBEIXZ ENDP				; List<__int64>::Num
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Remove@?$List@_J@@QAEXI@Z
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?Remove@?$List@_J@@QAEXI@Z PROC				; List<__int64>::Remove, COMDAT
; _this$ = ecx

; 88   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 89   :         assert(index < num);
; 90   :         if(index >= num) return;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN2@Remove
	jmp	$LN3@Remove
$LN2@Remove:

; 91   : 
; 92   :         if(!--num) {Free(array); array=NULL; return;}

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	mov	DWORD PTR tv68[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv68[ebp]
	mov	DWORD PTR [ecx+4], edx
	cmp	DWORD PTR tv68[ebp], 0
	jne	SHORT $LN1@Remove
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 0
	jmp	SHORT $LN3@Remove
$LN1@Remove:

; 93   : 
; 94   :         mcpy(&array[index], &array[index+1], sizeof(T)*(num-index));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR _index$[ebp]
	shl	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _index$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _index$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 95   : 
; 96   :         array = (T*)ReAllocate(array, sizeof(T)*num);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 3
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$LN3@Remove:

; 97   :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?Remove@?$List@_J@@QAEXI@Z ENDP				; List<__int64>::Remove
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Clear@?$List@_J@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@?$List@_J@@QAEXXZ PROC				; List<__int64>::Clear, COMDAT
; _this$ = ecx

; 334  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 335  :         if(array)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Clear

; 336  :         {
; 337  :             /*if(IsBadWritePtr(array, sizeof(T)*num))
; 338  :                 CrashError(TEXT("what the.."));*/
; 339  :             Free(array);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4

; 340  :             array = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 341  :             num = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$LN2@Clear:

; 342  :         }
; 343  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$List@_J@@QAEXXZ ENDP				; List<__int64>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??6?$List@_J@@QAEAAV0@AB_J@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_val$ = 8						; size = 4
??6?$List@_J@@QAEAAV0@AB_J@Z PROC			; List<__int64>::operator<<, COMDAT
; _this$ = ecx

; 366  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 367  :         Add(val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Add@?$List@_J@@QAEIAB_J@Z		; List<__int64>::Add

; 368  :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 369  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??6?$List@_J@@QAEAAV0@AB_J@Z ENDP			; List<__int64>::operator<<
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??A?$List@_J@@QAEAA_JI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$List@_J@@QAEAA_JI@Z PROC				; List<__int64>::operator[], COMDAT
; _this$ = ecx

; 379  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  :         assert(index < num);
; 381  :         if(index >= num) {DumpError(TEXT("Out of range!  List<%S>::operator[](%d)"), typeid(T).name(), index); return array[0];}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN1@operator
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	push	OFFSET ?__type_info_root_node@@3U__type_info_node@@A ; __type_info_root_node
	mov	ecx, OFFSET ??_R0_J@8
	call	?name@type_info@@QBEPBDPAU__type_info_node@@@Z ; type_info::name
	push	eax
	push	OFFSET ??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp_?DumpError@@YAXPB_WZZ
	mov	eax, 8
	imul	eax, eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN3@operator
$LN1@operator:

; 382  :         return array[index];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _index$[ebp]
	lea	eax, DWORD PTR [eax+ecx*8]
$LN3@operator:

; 383  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@_J@@QAEAA_JI@Z ENDP				; List<__int64>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?FindValueIndex@?$List@_J@@QBEIAB_J@Z
_TEXT	SEGMENT
tv80 = -20						; size = 4
tv78 = -16						; size = 4
tv79 = -12						; size = 4
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
_val$ = 8						; size = 4
?FindValueIndex@?$List@_J@@QBEIAB_J@Z PROC		; List<__int64>::FindValueIndex, COMDAT
; _this$ = ecx

; 422  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 423  :         for(UINT i=0; i<num; i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@FindValueI
$LN3@FindValueI:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@FindValueI:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$1[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jae	SHORT $LN2@FindValueI

; 424  :             if(array[i] == val) return i;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR tv78[ebp], ecx
	mov	DWORD PTR tv79[ebp], edx
	mov	DWORD PTR tv80[ebp], eax
	mov	ecx, DWORD PTR tv79[ebp]
	mov	edx, DWORD PTR tv78[ebp]
	mov	eax, DWORD PTR tv80[ebp]
	mov	ecx, DWORD PTR [edx+ecx*8]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN1@FindValueI
	mov	edx, DWORD PTR tv79[ebp]
	mov	eax, DWORD PTR tv78[ebp]
	mov	ecx, DWORD PTR tv80[ebp]
	mov	edx, DWORD PTR [eax+edx*8+4]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN1@FindValueI
	mov	eax, DWORD PTR _i$1[ebp]
	jmp	SHORT $LN5@FindValueI
$LN1@FindValueI:

; 425  : 
; 426  :         return INVALID;

	jmp	SHORT $LN3@FindValueI
$LN2@FindValueI:
	or	eax, -1
$LN5@FindValueI:

; 427  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?FindValueIndex@?$List@_J@@QBEIAB_J@Z ENDP		; List<__int64>::FindValueIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ?is_signalled@?$IPCSignal@$00@@QAE_NK@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv71 = -4						; size = 4
_timeout$ = 8						; size = 4
?is_signalled@?$IPCSignal@$00@@QAE_NK@Z PROC		; IPCSignal<1>::is_signalled, COMDAT
; _this$ = ecx

; 91   :     bool is_signalled(DWORD timeout=0) { return WaitForSingleObject(signal_, timeout) == WAIT_OBJECT_0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _timeout$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Bsafe_handle@@QAEPAXXZ		; safe_handle::operator void *
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
	test	eax, eax
	jne	SHORT $LN3@is_signall
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN4@is_signall
$LN3@is_signall:
	mov	DWORD PTR tv71[ebp], 0
$LN4@is_signall:
	mov	al, BYTE PTR tv71[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?is_signalled@?$IPCSignal@$00@@QAE_NK@Z ENDP		; IPCSignal<1>::is_signalled
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ?signal@?$IPCSignal@$00@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?signal@?$IPCSignal@$00@@QAEXXZ PROC			; IPCSignal<1>::signal, COMDAT
; _this$ = ecx

; 92   :     void signal() { SetEvent(signal_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Bsafe_handle@@QAEPAXXZ		; safe_handle::operator void *
	push	eax
	call	DWORD PTR __imp__SetEvent@4
	mov	esp, ebp
	pop	ebp
	ret	0
?signal@?$IPCSignal@$00@@QAEXXZ ENDP			; IPCSignal<1>::signal
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??7?$IPCSignal@$00@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??7?$IPCSignal@$00@@QBE_NXZ PROC			; IPCSignal<1>::operator!, COMDAT
; _this$ = ecx

; 95   :     bool operator!() const { return !signal_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??7safe_handle@@QBE_NXZ			; safe_handle::operator!
	mov	esp, ebp
	pop	ebp
	ret	0
??7?$IPCSignal@$00@@QBE_NXZ ENDP			; IPCSignal<1>::operator!
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??4?$IPCSignal@$00@@QAEAAU0@$$QAU0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
??4?$IPCSignal@$00@@QAEAAU0@$$QAU0@@Z PROC		; IPCSignal<1>::operator=, COMDAT
; _this$ = ecx

; 97   :     IPCSignal &operator=(IPCSignal &&other) { signal_ = std::move(other.signal_); return *this; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _other$[ebp]
	push	eax
	call	??$move@AAUsafe_handle@@@std@@YA$$QAUsafe_handle@@AAU1@@Z ; std::move<safe_handle &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4safe_handle@@QAEAAU0@$$QAU0@@Z	; safe_handle::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$IPCSignal@$00@@QAEAAU0@$$QAU0@@Z ENDP		; IPCSignal<1>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??0?$IPCSignal@$00@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_name$ = 8						; size = 24
??0?$IPCSignal@$00@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z PROC ; IPCSignal<1>::IPCSignal<1>, COMDAT
; _this$ = ecx

; 99   :     IPCSignal(std::wstring name) { signal_.reset(CreateEvent(nullptr, manual, false, name.c_str())); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0safe_handle@@QAE@PAX@Z		; safe_handle::safe_handle
	lea	ecx, DWORD PTR _name$[ebp]
	call	?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
	push	eax
	push	0
	push	1
	push	0
	call	DWORD PTR __imp__CreateEventW@16
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?reset@safe_handle@@QAEXPAX@Z		; safe_handle::reset
	lea	ecx, DWORD PTR _name$[ebp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
??0?$IPCSignal@$00@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ENDP ; IPCSignal<1>::IPCSignal<1>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??0?$IPCSignal@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$IPCSignal@$00@@QAE@XZ PROC				; IPCSignal<1>::IPCSignal<1>, COMDAT
; _this$ = ecx

; 100  :     IPCSignal() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0safe_handle@@QAE@PAX@Z		; safe_handle::safe_handle
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$IPCSignal@$00@@QAE@XZ ENDP				; IPCSignal<1>::IPCSignal<1>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??0?$IPCSignalledType@Uinit_request@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_name$ = 8						; size = 24
??0?$IPCSignalledType@Uinit_request@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z PROC ; IPCSignalledType<init_request>::IPCSignalledType<init_request>, COMDAT
; _this$ = ecx

; 172  :     IPCSignalledType(std::wstring name) : IPCType(name), IPCSignal(name+L"Signal") {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$IPCType@Uinit_request@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; IPCType<init_request>::IPCType<init_request>
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	push	OFFSET ??_C@_1O@IENHAHCD@?$AAS?$AAi?$AAg?$AAn?$AAa?$AAl?$AA?$AA@
	lea	edx, DWORD PTR _name$[ebp]
	push	edx
	push	ecx
	call	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	??0?$IPCSignal@$0A@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; IPCSignal<0>::IPCSignal<0>
	lea	ecx, DWORD PTR _name$[ebp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
??0?$IPCSignalledType@Uinit_request@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ENDP ; IPCSignalledType<init_request>::IPCSignalledType<init_request>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??C?$IPCType@Uinit_request@@@@QAEPAUinit_request@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??C?$IPCType@Uinit_request@@@@QAEPAUinit_request@@XZ PROC ; IPCType<init_request>::operator->, COMDAT
; _this$ = ecx

; 156  :     T *operator->() { return &memory.as<T>(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$as@Uinit_request@@@NamedSharedMemory@@QAEAAUinit_request@@XZ ; NamedSharedMemory::as<init_request>
	mov	esp, ebp
	pop	ebp
	ret	0
??C?$IPCType@Uinit_request@@@@QAEPAUinit_request@@XZ ENDP ; IPCType<init_request>::operator->
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??7?$IPCArray@Ubitstream_info@@@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??7?$IPCArray@Ubitstream_info@@@@QBE_NXZ PROC		; IPCArray<bitstream_info>::operator!, COMDAT
; _this$ = ecx

; 193  :     bool operator!() const { return !memory; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??7NamedSharedMemory@@QBE_NXZ		; NamedSharedMemory::operator!
	mov	esp, ebp
	pop	ebp
	ret	0
??7?$IPCArray@Ubitstream_info@@@@QBE_NXZ ENDP		; IPCArray<bitstream_info>::operator!
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??B?$IPCArray@Ubitstream_info@@@@QAEPAUbitstream_info@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??B?$IPCArray@Ubitstream_info@@@@QAEPAUbitstream_info@@XZ PROC ; IPCArray<bitstream_info>::operator bitstream_info *, COMDAT
; _this$ = ecx

; 194  :     operator T*() { return static_cast<T*>(&memory); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??INamedSharedMemory@@QAEPAXXZ		; NamedSharedMemory::operator&
	mov	esp, ebp
	pop	ebp
	ret	0
??B?$IPCArray@Ubitstream_info@@@@QAEPAUbitstream_info@@XZ ENDP ; IPCArray<bitstream_info>::operator bitstream_info *
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??4?$IPCArray@Ubitstream_info@@@@QAEAAU0@$$QAU0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
??4?$IPCArray@Ubitstream_info@@@@QAEAAU0@$$QAU0@@Z PROC	; IPCArray<bitstream_info>::operator=, COMDAT
; _this$ = ecx

; 196  :     IPCArray &operator=(IPCArray &&other) { memory = std::move(other.memory); size = other.size; return *this; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _other$[ebp]
	push	eax
	call	??$move@AAUNamedSharedMemory@@@std@@YA$$QAUNamedSharedMemory@@AAU1@@Z ; std::move<NamedSharedMemory &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4NamedSharedMemory@@QAEAAU0@$$QAU0@@Z	; NamedSharedMemory::operator=
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _other$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [ecx+40], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$IPCArray@Ubitstream_info@@@@QAEAAU0@$$QAU0@@Z ENDP	; IPCArray<bitstream_info>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??0?$IPCArray@Ubitstream_info@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_name$ = 8						; size = 24
_size$ = 32						; size = 4
??0?$IPCArray@Ubitstream_info@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z PROC ; IPCArray<bitstream_info>::IPCArray<bitstream_info>, COMDAT
; _this$ = ecx

; 198  :     IPCArray(std::wstring name, size_t size) : memory(name, sizeof(T)*size), size(size) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	imul	eax, DWORD PTR _size$[ebp], 28
	xor	ecx, ecx
	push	ecx
	push	eax
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	lea	edx, DWORD PTR _name$[ebp]
	push	edx
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0NamedSharedMemory@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_K@Z ; NamedSharedMemory::NamedSharedMemory
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [eax+40], ecx
	lea	ecx, DWORD PTR _name$[ebp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
??0?$IPCArray@Ubitstream_info@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z ENDP ; IPCArray<bitstream_info>::IPCArray<bitstream_info>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??0?$IPCArray@Ubitstream_info@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$IPCArray@Ubitstream_info@@@@QAE@XZ PROC		; IPCArray<bitstream_info>::IPCArray<bitstream_info>, COMDAT
; _this$ = ecx

; 199  :     IPCArray() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0NamedSharedMemory@@QAE@XZ		; NamedSharedMemory::NamedSharedMemory
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$IPCArray@Ubitstream_info@@@@QAE@XZ ENDP		; IPCArray<bitstream_info>::IPCArray<bitstream_info>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??0?$List@Uencode_task@QSVEncoder@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$List@Uencode_task@QSVEncoder@@@@QAE@XZ PROC	; List<QSVEncoder::encode_task>::List<QSVEncoder::encode_task>, COMDAT
; _this$ = ecx

; 35   :     inline List() : array(NULL), num(0) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@Uencode_task@QSVEncoder@@@@QAE@XZ ENDP	; List<QSVEncoder::encode_task>::List<QSVEncoder::encode_task>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??1?$List@Uencode_task@QSVEncoder@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$List@Uencode_task@QSVEncoder@@@@QAE@XZ PROC	; List<QSVEncoder::encode_task>::~List<QSVEncoder::encode_task>, COMDAT
; _this$ = ecx

; 37   :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 38   :         Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@Uencode_task@QSVEncoder@@@@QAEXXZ ; List<QSVEncoder::encode_task>::Clear

; 39   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@Uencode_task@QSVEncoder@@@@QAE@XZ ENDP	; List<QSVEncoder::encode_task>::~List<QSVEncoder::encode_task>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Num@?$List@Uencode_task@QSVEncoder@@@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Num@?$List@Uencode_task@QSVEncoder@@@@QBEIXZ PROC	; List<QSVEncoder::encode_task>::Num, COMDAT
; _this$ = ecx

; 42   :     inline unsigned int Num() const     {return num;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?Num@?$List@Uencode_task@QSVEncoder@@@@QBEIXZ ENDP	; List<QSVEncoder::encode_task>::Num
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?SetSize@?$List@Uencode_task@QSVEncoder@@@@QAEHI@Z
_TEXT	SEGMENT
_bClear$ = -16						; size = 4
_oldNum$ = -12						; size = 4
tv70 = -8						; size = 4
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?SetSize@?$List@Uencode_task@QSVEncoder@@@@QAEHI@Z PROC	; List<QSVEncoder::encode_task>::SetSize, COMDAT
; _this$ = ecx

; 205  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 206  :         if(num == n)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _n$[ebp]
	jne	SHORT $LN4@SetSize

; 207  :             return FALSE;

	xor	eax, eax
	jmp	$LN5@SetSize
	jmp	SHORT $LN3@SetSize
$LN4@SetSize:

; 208  :         else if(!n)

	cmp	DWORD PTR _n$[ebp], 0
	jne	SHORT $LN3@SetSize

; 209  :         {
; 210  :             Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@Uencode_task@QSVEncoder@@@@QAEXXZ ; List<QSVEncoder::encode_task>::Clear

; 211  :             return TRUE;

	mov	eax, 1
	jmp	$LN5@SetSize
$LN3@SetSize:

; 212  :         }
; 213  : 
; 214  :         BOOL bClear=(n>num);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jbe	SHORT $LN7@SetSize
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN8@SetSize
$LN7@SetSize:
	mov	DWORD PTR tv70[ebp], 0
$LN8@SetSize:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _bClear$[ebp], ecx

; 215  :         UINT oldNum=num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _oldNum$[ebp], eax

; 216  : 
; 217  :         num = n;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 218  :         array = (T*)ReAllocate(array, sizeof(T)*num);

	mov	eax, DWORD PTR _this$[ebp]
	imul	ecx, DWORD PTR [eax+4], 232
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 219  : 
; 220  :         if(bClear)

	cmp	DWORD PTR _bClear$[ebp], 0
	je	SHORT $LN1@SetSize

; 221  :             zero(&array[oldNum], sizeof(T)*(num-oldNum));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, DWORD PTR _oldNum$[ebp]
	imul	ecx, eax, 232
	push	ecx
	imul	edx, DWORD PTR _oldNum$[ebp], 232
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax]
	push	edx
	call	?zero@@YGXPAXI@Z			; zero
$LN1@SetSize:

; 222  : 
; 223  :         return TRUE;

	mov	eax, 1
$LN5@SetSize:

; 224  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetSize@?$List@Uencode_task@QSVEncoder@@@@QAEHI@Z ENDP	; List<QSVEncoder::encode_task>::SetSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??A?$List@Uencode_task@QSVEncoder@@@@QAEAAUencode_task@QSVEncoder@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$List@Uencode_task@QSVEncoder@@@@QAEAAUencode_task@QSVEncoder@@I@Z PROC ; List<QSVEncoder::encode_task>::operator[], COMDAT
; _this$ = ecx

; 379  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  :         assert(index < num);
; 381  :         if(index >= num) {DumpError(TEXT("Out of range!  List<%S>::operator[](%d)"), typeid(T).name(), index); return array[0];}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN1@operator
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	push	OFFSET ?__type_info_root_node@@3U__type_info_node@@A ; __type_info_root_node
	mov	ecx, OFFSET ??_R0?AUencode_task@QSVEncoder@@@8
	call	?name@type_info@@QBEPBDPAU__type_info_node@@@Z ; type_info::name
	push	eax
	push	OFFSET ??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp_?DumpError@@YAXPB_WZZ
	mov	eax, 232				; 000000e8H
	imul	eax, eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN3@operator
$LN1@operator:

; 382  :         return array[index];

	imul	eax, DWORD PTR _index$[ebp], 232
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx]
$LN3@operator:

; 383  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@Uencode_task@QSVEncoder@@@@QAEAAUencode_task@QSVEncoder@@I@Z ENDP ; List<QSVEncoder::encode_task>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??A?$List@Uencode_task@QSVEncoder@@@@QBEAAUencode_task@QSVEncoder@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$List@Uencode_task@QSVEncoder@@@@QBEAAUencode_task@QSVEncoder@@I@Z PROC ; List<QSVEncoder::encode_task>::operator[], COMDAT
; _this$ = ecx

; 386  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 387  :         assert(index < num);
; 388  :         if (index >= num) { DumpError(TEXT("Out of range!  List<%S>::operator[](%d)"), typeid(T).name(), index); return array[0]; }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN1@operator
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	push	OFFSET ?__type_info_root_node@@3U__type_info_node@@A ; __type_info_root_node
	mov	ecx, OFFSET ??_R0?AUencode_task@QSVEncoder@@@8
	call	?name@type_info@@QBEPBDPAU__type_info_node@@@Z ; type_info::name
	push	eax
	push	OFFSET ??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp_?DumpError@@YAXPB_WZZ
	mov	eax, 232				; 000000e8H
	imul	eax, eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN3@operator
$LN1@operator:

; 389  :         return array[index];

	imul	eax, DWORD PTR _index$[ebp], 232
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx]
$LN3@operator:

; 390  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@Uencode_task@QSVEncoder@@@@QBEAAUencode_task@QSVEncoder@@I@Z ENDP ; List<QSVEncoder::encode_task>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??7?$IPCLockedSignalledArray@Uqueued_frame@@@@QAE_NXZ
_TEXT	SEGMENT
tv91 = -8						; size = 4
_this$ = -4						; size = 4
??7?$IPCLockedSignalledArray@Uqueued_frame@@@@QAE_NXZ PROC ; IPCLockedSignalledArray<queued_frame>::operator!, COMDAT
; _this$ = ecx

; 216  :     bool operator!() { return !memory || !signal_ || !mutex_; }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??7NamedSharedMemory@@QBE_NXZ		; NamedSharedMemory::operator!
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??7safe_handle@@QBE_NXZ			; safe_handle::operator!
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	call	??7safe_handle@@QBE_NXZ			; safe_handle::operator!
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv91[ebp], 0
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv91[ebp], 1
$LN4@operator:
	mov	al, BYTE PTR tv91[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??7?$IPCLockedSignalledArray@Uqueued_frame@@@@QAE_NXZ ENDP ; IPCLockedSignalledArray<queued_frame>::operator!
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??4?$IPCLockedSignalledArray@Uqueued_frame@@@@QAEAAU0@$$QAU0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
??4?$IPCLockedSignalledArray@Uqueued_frame@@@@QAEAAU0@$$QAU0@@Z PROC ; IPCLockedSignalledArray<queued_frame>::operator=, COMDAT
; _this$ = ecx

; 219  :     { memory = std::move(other.memory); signal_ = std::move(other.signal_); mutex_ = std::move(other.mutex_); size = other.size; return *this; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _other$[ebp]
	push	eax
	call	??$move@AAUNamedSharedMemory@@@std@@YA$$QAUNamedSharedMemory@@AAU1@@Z ; std::move<NamedSharedMemory &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4NamedSharedMemory@@QAEAAU0@$$QAU0@@Z	; NamedSharedMemory::operator=
	mov	ecx, DWORD PTR _other$[ebp]
	add	ecx, 48					; 00000030H
	push	ecx
	call	??$move@AAUsafe_handle@@@std@@YA$$QAUsafe_handle@@AAU1@@Z ; std::move<safe_handle &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??4safe_handle@@QAEAAU0@$$QAU0@@Z	; safe_handle::operator=
	mov	edx, DWORD PTR _other$[ebp]
	add	edx, 56					; 00000038H
	push	edx
	call	??$move@AAUsafe_handle@@@std@@YA$$QAUsafe_handle@@AAU1@@Z ; std::move<safe_handle &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	call	??4safe_handle@@QAEAAU0@$$QAU0@@Z	; safe_handle::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _other$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+40], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$IPCLockedSignalledArray@Uqueued_frame@@@@QAEAAU0@$$QAU0@@Z ENDP ; IPCLockedSignalledArray<queued_frame>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??0?$IPCLockedSignalledArray@Uqueued_frame@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_name$ = 8						; size = 24
_size$ = 32						; size = 4
??0?$IPCLockedSignalledArray@Uqueued_frame@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z PROC ; IPCLockedSignalledArray<queued_frame>::IPCLockedSignalledArray<queued_frame>, COMDAT
; _this$ = ecx

; 221  :     IPCLockedSignalledArray(std::wstring name, size_t size) : IPCSignalledArray(name, size), IPCMutex(name+L"Lock") {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	lea	edx, DWORD PTR _name$[ebp]
	push	edx
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$IPCSignalledArray@Uqueued_frame@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z ; IPCSignalledArray<queued_frame>::IPCSignalledArray<queued_frame>
	sub	esp, 24					; 00000018H
	mov	eax, esp
	push	OFFSET ??_C@_19PDHPMPEG@?$AAL?$AAo?$AAc?$AAk?$AA?$AA@
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	eax
	call	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	call	??0IPCMutex@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; IPCMutex::IPCMutex
	lea	ecx, DWORD PTR _name$[ebp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
??0?$IPCLockedSignalledArray@Uqueued_frame@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z ENDP ; IPCLockedSignalledArray<queued_frame>::IPCLockedSignalledArray<queued_frame>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??0?$IPCLockedSignalledArray@Uqueued_frame@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$IPCLockedSignalledArray@Uqueued_frame@@@@QAE@XZ PROC ; IPCLockedSignalledArray<queued_frame>::IPCLockedSignalledArray<queued_frame>, COMDAT
; _this$ = ecx

; 222  :     IPCLockedSignalledArray() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$IPCSignalledArray@Uqueued_frame@@@@QAE@XZ ; IPCSignalledArray<queued_frame>::IPCSignalledArray<queued_frame>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	call	??0IPCMutex@@QAE@XZ			; IPCMutex::IPCMutex
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$IPCLockedSignalledArray@Uqueued_frame@@@@QAE@XZ ENDP ; IPCLockedSignalledArray<queued_frame>::IPCLockedSignalledArray<queued_frame>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??B?$IPCArray@Uqueued_frame@@@@QAEPAUqueued_frame@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??B?$IPCArray@Uqueued_frame@@@@QAEPAUqueued_frame@@XZ PROC ; IPCArray<queued_frame>::operator queued_frame *, COMDAT
; _this$ = ecx

; 194  :     operator T*() { return static_cast<T*>(&memory); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??INamedSharedMemory@@QAEPAXXZ		; NamedSharedMemory::operator&
	mov	esp, ebp
	pop	ebp
	ret	0
??B?$IPCArray@Uqueued_frame@@@@QAEPAUqueued_frame@@XZ ENDP ; IPCArray<queued_frame>::operator queued_frame *
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??7?$IPCLockedSignalledArray@I@@QAE_NXZ
_TEXT	SEGMENT
tv91 = -8						; size = 4
_this$ = -4						; size = 4
??7?$IPCLockedSignalledArray@I@@QAE_NXZ PROC		; IPCLockedSignalledArray<unsigned int>::operator!, COMDAT
; _this$ = ecx

; 216  :     bool operator!() { return !memory || !signal_ || !mutex_; }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??7NamedSharedMemory@@QBE_NXZ		; NamedSharedMemory::operator!
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??7safe_handle@@QBE_NXZ			; safe_handle::operator!
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	call	??7safe_handle@@QBE_NXZ			; safe_handle::operator!
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv91[ebp], 0
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv91[ebp], 1
$LN4@operator:
	mov	al, BYTE PTR tv91[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??7?$IPCLockedSignalledArray@I@@QAE_NXZ ENDP		; IPCLockedSignalledArray<unsigned int>::operator!
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??4?$IPCLockedSignalledArray@I@@QAEAAU0@$$QAU0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
??4?$IPCLockedSignalledArray@I@@QAEAAU0@$$QAU0@@Z PROC	; IPCLockedSignalledArray<unsigned int>::operator=, COMDAT
; _this$ = ecx

; 219  :     { memory = std::move(other.memory); signal_ = std::move(other.signal_); mutex_ = std::move(other.mutex_); size = other.size; return *this; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _other$[ebp]
	push	eax
	call	??$move@AAUNamedSharedMemory@@@std@@YA$$QAUNamedSharedMemory@@AAU1@@Z ; std::move<NamedSharedMemory &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4NamedSharedMemory@@QAEAAU0@$$QAU0@@Z	; NamedSharedMemory::operator=
	mov	ecx, DWORD PTR _other$[ebp]
	add	ecx, 48					; 00000030H
	push	ecx
	call	??$move@AAUsafe_handle@@@std@@YA$$QAUsafe_handle@@AAU1@@Z ; std::move<safe_handle &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??4safe_handle@@QAEAAU0@$$QAU0@@Z	; safe_handle::operator=
	mov	edx, DWORD PTR _other$[ebp]
	add	edx, 56					; 00000038H
	push	edx
	call	??$move@AAUsafe_handle@@@std@@YA$$QAUsafe_handle@@AAU1@@Z ; std::move<safe_handle &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	call	??4safe_handle@@QAEAAU0@$$QAU0@@Z	; safe_handle::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _other$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+40], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$IPCLockedSignalledArray@I@@QAEAAU0@$$QAU0@@Z ENDP	; IPCLockedSignalledArray<unsigned int>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??0?$IPCLockedSignalledArray@I@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_name$ = 8						; size = 24
_size$ = 32						; size = 4
??0?$IPCLockedSignalledArray@I@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z PROC ; IPCLockedSignalledArray<unsigned int>::IPCLockedSignalledArray<unsigned int>, COMDAT
; _this$ = ecx

; 221  :     IPCLockedSignalledArray(std::wstring name, size_t size) : IPCSignalledArray(name, size), IPCMutex(name+L"Lock") {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	lea	edx, DWORD PTR _name$[ebp]
	push	edx
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$IPCSignalledArray@I@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z ; IPCSignalledArray<unsigned int>::IPCSignalledArray<unsigned int>
	sub	esp, 24					; 00000018H
	mov	eax, esp
	push	OFFSET ??_C@_19PDHPMPEG@?$AAL?$AAo?$AAc?$AAk?$AA?$AA@
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	eax
	call	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	call	??0IPCMutex@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; IPCMutex::IPCMutex
	lea	ecx, DWORD PTR _name$[ebp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
??0?$IPCLockedSignalledArray@I@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z ENDP ; IPCLockedSignalledArray<unsigned int>::IPCLockedSignalledArray<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??0?$IPCLockedSignalledArray@I@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$IPCLockedSignalledArray@I@@QAE@XZ PROC		; IPCLockedSignalledArray<unsigned int>::IPCLockedSignalledArray<unsigned int>, COMDAT
; _this$ = ecx

; 222  :     IPCLockedSignalledArray() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$IPCSignalledArray@I@@QAE@XZ	; IPCSignalledArray<unsigned int>::IPCSignalledArray<unsigned int>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	call	??0IPCMutex@@QAE@XZ			; IPCMutex::IPCMutex
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$IPCLockedSignalledArray@I@@QAE@XZ ENDP		; IPCLockedSignalledArray<unsigned int>::IPCLockedSignalledArray<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??B?$IPCArray@I@@QAEPAIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??B?$IPCArray@I@@QAEPAIXZ PROC				; IPCArray<unsigned int>::operator unsigned int *, COMDAT
; _this$ = ecx

; 194  :     operator T*() { return static_cast<T*>(&memory); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??INamedSharedMemory@@QAEPAXXZ		; NamedSharedMemory::operator&
	mov	esp, ebp
	pop	ebp
	ret	0
??B?$IPCArray@I@@QAEPAIXZ ENDP				; IPCArray<unsigned int>::operator unsigned int *
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??7?$IPCLockedSignalledType@H@@QBE_NXZ
_TEXT	SEGMENT
tv91 = -8						; size = 4
_this$ = -4						; size = 4
??7?$IPCLockedSignalledType@H@@QBE_NXZ PROC		; IPCLockedSignalledType<int>::operator!, COMDAT
; _this$ = ecx

; 179  :     bool operator!() const { return !memory || !signal_ || !mutex_; }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??7NamedSharedMemory@@QBE_NXZ		; NamedSharedMemory::operator!
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	??7safe_handle@@QBE_NXZ			; safe_handle::operator!
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??7safe_handle@@QBE_NXZ			; safe_handle::operator!
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv91[ebp], 0
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv91[ebp], 1
$LN4@operator:
	mov	al, BYTE PTR tv91[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??7?$IPCLockedSignalledType@H@@QBE_NXZ ENDP		; IPCLockedSignalledType<int>::operator!
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??4?$IPCLockedSignalledType@H@@QAEAAU0@$$QAU0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
??4?$IPCLockedSignalledType@H@@QAEAAU0@$$QAU0@@Z PROC	; IPCLockedSignalledType<int>::operator=, COMDAT
; _this$ = ecx

; 181  :     IPCLockedSignalledType &operator=(IPCLockedSignalledType &&other) { memory = std::move(other.memory); signal_ = std::move(other.signal_); mutex_ = std::move(other.mutex_); return *this; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _other$[ebp]
	push	eax
	call	??$move@AAUNamedSharedMemory@@@std@@YA$$QAUNamedSharedMemory@@AAU1@@Z ; std::move<NamedSharedMemory &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4NamedSharedMemory@@QAEAAU0@$$QAU0@@Z	; NamedSharedMemory::operator=
	mov	ecx, DWORD PTR _other$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	call	??$move@AAUsafe_handle@@@std@@YA$$QAUsafe_handle@@AAU1@@Z ; std::move<safe_handle &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	??4safe_handle@@QAEAAU0@$$QAU0@@Z	; safe_handle::operator=
	mov	edx, DWORD PTR _other$[ebp]
	add	edx, 48					; 00000030H
	push	edx
	call	??$move@AAUsafe_handle@@@std@@YA$$QAUsafe_handle@@AAU1@@Z ; std::move<safe_handle &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??4safe_handle@@QAEAAU0@$$QAU0@@Z	; safe_handle::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$IPCLockedSignalledType@H@@QAEAAU0@$$QAU0@@Z ENDP	; IPCLockedSignalledType<int>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??0?$IPCLockedSignalledType@H@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_name$ = 8						; size = 24
??0?$IPCLockedSignalledType@H@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z PROC ; IPCLockedSignalledType<int>::IPCLockedSignalledType<int>, COMDAT
; _this$ = ecx

; 183  :     IPCLockedSignalledType(std::wstring name) : IPCSignalledType(name), IPCMutex(name+L"Lock") {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$IPCSignalledType@H@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; IPCSignalledType<int>::IPCSignalledType<int>
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	push	OFFSET ??_C@_19PDHPMPEG@?$AAL?$AAo?$AAc?$AAk?$AA?$AA@
	lea	edx, DWORD PTR _name$[ebp]
	push	edx
	push	ecx
	call	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??0IPCMutex@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; IPCMutex::IPCMutex
	lea	ecx, DWORD PTR _name$[ebp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
??0?$IPCLockedSignalledType@H@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ENDP ; IPCLockedSignalledType<int>::IPCLockedSignalledType<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??0?$IPCLockedSignalledType@H@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$IPCLockedSignalledType@H@@QAE@XZ PROC		; IPCLockedSignalledType<int>::IPCLockedSignalledType<int>, COMDAT
; _this$ = ecx

; 184  :     IPCLockedSignalledType() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$IPCSignalledType@H@@QAE@XZ		; IPCSignalledType<int>::IPCSignalledType<int>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??0IPCMutex@@QAE@XZ			; IPCMutex::IPCMutex
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$IPCLockedSignalledType@H@@QAE@XZ ENDP		; IPCLockedSignalledType<int>::IPCLockedSignalledType<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??D?$IPCType@H@@QAEAAHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$IPCType@H@@QAEAAHXZ PROC				; IPCType<int>::operator*, COMDAT
; _this$ = ecx

; 157  :     T &operator*() { return memory.as<T>(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$as@H@NamedSharedMemory@@QAEAAHXZ	; NamedSharedMemory::as<int>
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$IPCType@H@@QAEAAHXZ ENDP				; IPCType<int>::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??0?$List@UmfxFrameData@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$List@UmfxFrameData@@@@QAE@XZ PROC			; List<mfxFrameData>::List<mfxFrameData>, COMDAT
; _this$ = ecx

; 35   :     inline List() : array(NULL), num(0) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@UmfxFrameData@@@@QAE@XZ ENDP			; List<mfxFrameData>::List<mfxFrameData>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??1?$List@UmfxFrameData@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$List@UmfxFrameData@@@@QAE@XZ PROC			; List<mfxFrameData>::~List<mfxFrameData>, COMDAT
; _this$ = ecx

; 37   :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 38   :         Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@UmfxFrameData@@@@QAEXXZ	; List<mfxFrameData>::Clear

; 39   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@UmfxFrameData@@@@QAE@XZ ENDP			; List<mfxFrameData>::~List<mfxFrameData>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Num@?$List@UmfxFrameData@@@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Num@?$List@UmfxFrameData@@@@QBEIXZ PROC		; List<mfxFrameData>::Num, COMDAT
; _this$ = ecx

; 42   :     inline unsigned int Num() const     {return num;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?Num@?$List@UmfxFrameData@@@@QBEIXZ ENDP		; List<mfxFrameData>::Num
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?SetSize@?$List@UmfxFrameData@@@@QAEHI@Z
_TEXT	SEGMENT
_bClear$ = -16						; size = 4
_oldNum$ = -12						; size = 4
tv70 = -8						; size = 4
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?SetSize@?$List@UmfxFrameData@@@@QAEHI@Z PROC		; List<mfxFrameData>::SetSize, COMDAT
; _this$ = ecx

; 205  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 206  :         if(num == n)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _n$[ebp]
	jne	SHORT $LN4@SetSize

; 207  :             return FALSE;

	xor	eax, eax
	jmp	$LN5@SetSize
	jmp	SHORT $LN3@SetSize
$LN4@SetSize:

; 208  :         else if(!n)

	cmp	DWORD PTR _n$[ebp], 0
	jne	SHORT $LN3@SetSize

; 209  :         {
; 210  :             Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@UmfxFrameData@@@@QAEXXZ	; List<mfxFrameData>::Clear

; 211  :             return TRUE;

	mov	eax, 1
	jmp	$LN5@SetSize
$LN3@SetSize:

; 212  :         }
; 213  : 
; 214  :         BOOL bClear=(n>num);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jbe	SHORT $LN7@SetSize
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN8@SetSize
$LN7@SetSize:
	mov	DWORD PTR tv70[ebp], 0
$LN8@SetSize:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _bClear$[ebp], ecx

; 215  :         UINT oldNum=num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _oldNum$[ebp], eax

; 216  : 
; 217  :         num = n;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 218  :         array = (T*)ReAllocate(array, sizeof(T)*num);

	mov	eax, DWORD PTR _this$[ebp]
	imul	ecx, DWORD PTR [eax+4], 72
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 219  : 
; 220  :         if(bClear)

	cmp	DWORD PTR _bClear$[ebp], 0
	je	SHORT $LN1@SetSize

; 221  :             zero(&array[oldNum], sizeof(T)*(num-oldNum));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, DWORD PTR _oldNum$[ebp]
	imul	ecx, eax, 72
	push	ecx
	imul	edx, DWORD PTR _oldNum$[ebp], 72
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax]
	push	edx
	call	?zero@@YGXPAXI@Z			; zero
$LN1@SetSize:

; 222  : 
; 223  :         return TRUE;

	mov	eax, 1
$LN5@SetSize:

; 224  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetSize@?$List@UmfxFrameData@@@@QAEHI@Z ENDP		; List<mfxFrameData>::SetSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??A?$List@UmfxFrameData@@@@QAEAAUmfxFrameData@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$List@UmfxFrameData@@@@QAEAAUmfxFrameData@@I@Z PROC	; List<mfxFrameData>::operator[], COMDAT
; _this$ = ecx

; 379  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  :         assert(index < num);
; 381  :         if(index >= num) {DumpError(TEXT("Out of range!  List<%S>::operator[](%d)"), typeid(T).name(), index); return array[0];}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN1@operator
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	push	OFFSET ?__type_info_root_node@@3U__type_info_node@@A ; __type_info_root_node
	mov	ecx, OFFSET ??_R0?AUmfxFrameData@@@8
	call	?name@type_info@@QBEPBDPAU__type_info_node@@@Z ; type_info::name
	push	eax
	push	OFFSET ??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp_?DumpError@@YAXPB_WZZ
	mov	eax, 72					; 00000048H
	imul	eax, eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN3@operator
$LN1@operator:

; 382  :         return array[index];

	imul	eax, DWORD PTR _index$[ebp], 72
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx]
$LN3@operator:

; 383  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@UmfxFrameData@@@@QAEAAUmfxFrameData@@I@Z ENDP	; List<mfxFrameData>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??0?$List@UVideoPacket@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$List@UVideoPacket@@@@QAE@XZ PROC			; List<VideoPacket>::List<VideoPacket>, COMDAT
; _this$ = ecx

; 35   :     inline List() : array(NULL), num(0) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@UVideoPacket@@@@QAE@XZ ENDP			; List<VideoPacket>::List<VideoPacket>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??1?$List@UVideoPacket@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$List@UVideoPacket@@@@QAE@XZ PROC			; List<VideoPacket>::~List<VideoPacket>, COMDAT
; _this$ = ecx

; 37   :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 38   :         Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@UVideoPacket@@@@QAEXXZ	; List<VideoPacket>::Clear

; 39   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@UVideoPacket@@@@QAE@XZ ENDP			; List<VideoPacket>::~List<VideoPacket>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Num@?$List@UVideoPacket@@@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Num@?$List@UVideoPacket@@@@QBEIXZ PROC			; List<VideoPacket>::Num, COMDAT
; _this$ = ecx

; 42   :     inline unsigned int Num() const     {return num;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?Num@?$List@UVideoPacket@@@@QBEIXZ ENDP			; List<VideoPacket>::Num
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Clear@?$List@UVideoPacket@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@?$List@UVideoPacket@@@@QAEXXZ PROC		; List<VideoPacket>::Clear, COMDAT
; _this$ = ecx

; 334  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 335  :         if(array)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Clear

; 336  :         {
; 337  :             /*if(IsBadWritePtr(array, sizeof(T)*num))
; 338  :                 CrashError(TEXT("what the.."));*/
; 339  :             Free(array);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4

; 340  :             array = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 341  :             num = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$LN2@Clear:

; 342  :         }
; 343  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$List@UVideoPacket@@@@QAEXXZ ENDP		; List<VideoPacket>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?CreateNew@?$List@UVideoPacket@@@@QAEPAUVideoPacket@@XZ
_TEXT	SEGMENT
_value$ = -8						; size = 4
_this$ = -4						; size = 4
?CreateNew@?$List@UVideoPacket@@@@QAEPAUVideoPacket@@XZ PROC ; List<VideoPacket>::CreateNew, COMDAT
; _this$ = ecx

; 346  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 347  :         SetSize(num+1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSize@?$List@UVideoPacket@@@@QAEHI@Z	; List<VideoPacket>::SetSize

; 348  : 
; 349  :         T *value = &array[num-1];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+eax*8-8]
	mov	DWORD PTR _value$[ebp], eax

; 350  : 
; 351  :         return value;

	mov	eax, DWORD PTR _value$[ebp]

; 352  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?CreateNew@?$List@UVideoPacket@@@@QAEPAUVideoPacket@@XZ ENDP ; List<VideoPacket>::CreateNew
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??A?$List@UVideoPacket@@@@QAEAAUVideoPacket@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$List@UVideoPacket@@@@QAEAAUVideoPacket@@I@Z PROC	; List<VideoPacket>::operator[], COMDAT
; _this$ = ecx

; 379  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  :         assert(index < num);
; 381  :         if(index >= num) {DumpError(TEXT("Out of range!  List<%S>::operator[](%d)"), typeid(T).name(), index); return array[0];}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN1@operator
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	push	OFFSET ?__type_info_root_node@@3U__type_info_node@@A ; __type_info_root_node
	mov	ecx, OFFSET ??_R0?AUVideoPacket@@@8
	call	?name@type_info@@QBEPBDPAU__type_info_node@@@Z ; type_info::name
	push	eax
	push	OFFSET ??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp_?DumpError@@YAXPB_WZZ
	mov	eax, 8
	imul	eax, eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN3@operator
$LN1@operator:

; 382  :         return array[index];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _index$[ebp]
	lea	eax, DWORD PTR [eax+ecx*8]
$LN3@operator:

; 383  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@UVideoPacket@@@@QAEAAUVideoPacket@@I@Z ENDP	; List<VideoPacket>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??0?$IPCSignalledType@Uinit_response@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_name$ = 8						; size = 24
??0?$IPCSignalledType@Uinit_response@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z PROC ; IPCSignalledType<init_response>::IPCSignalledType<init_response>, COMDAT
; _this$ = ecx

; 172  :     IPCSignalledType(std::wstring name) : IPCType(name), IPCSignal(name+L"Signal") {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$IPCType@Uinit_response@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; IPCType<init_response>::IPCType<init_response>
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	push	OFFSET ??_C@_1O@IENHAHCD@?$AAS?$AAi?$AAg?$AAn?$AAa?$AAl?$AA?$AA@
	lea	edx, DWORD PTR _name$[ebp]
	push	edx
	push	ecx
	call	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	??0?$IPCSignal@$0A@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; IPCSignal<0>::IPCSignal<0>
	lea	ecx, DWORD PTR _name$[ebp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
??0?$IPCSignalledType@Uinit_response@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ENDP ; IPCSignalledType<init_response>::IPCSignalledType<init_response>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??C?$IPCType@Uinit_response@@@@QAEPAUinit_response@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??C?$IPCType@Uinit_response@@@@QAEPAUinit_response@@XZ PROC ; IPCType<init_response>::operator->, COMDAT
; _this$ = ecx

; 156  :     T *operator->() { return &memory.as<T>(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$as@Uinit_response@@@NamedSharedMemory@@QAEAAUinit_response@@XZ ; NamedSharedMemory::as<init_response>
	mov	esp, ebp
	pop	ebp
	ret	0
??C?$IPCType@Uinit_response@@@@QAEPAUinit_response@@XZ ENDP ; IPCType<init_response>::operator->
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??1?$IPCMutexLock@U?$IPCLockedSignalledType@H@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$IPCMutexLock@U?$IPCLockedSignalledType@H@@@@QAE@XZ PROC ; IPCMutexLock<IPCLockedSignalledType<int> >::~IPCMutexLock<IPCLockedSignalledType<int> >, COMDAT
; _this$ = ecx

; 138  :     ~IPCMutexLock() { if(enabled) t.unlock(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN2@IPCMutexLo
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	add	ecx, 48					; 00000030H
	call	?unlock@IPCMutex@@QAEXXZ		; IPCMutex::unlock
$LN2@IPCMutexLo:
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$IPCMutexLock@U?$IPCLockedSignalledType@H@@@@QAE@XZ ENDP ; IPCMutexLock<IPCLockedSignalledType<int> >::~IPCMutexLock<IPCLockedSignalledType<int> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??0?$List@Ux264_nal_t@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$List@Ux264_nal_t@@@@QAE@XZ PROC			; List<x264_nal_t>::List<x264_nal_t>, COMDAT
; _this$ = ecx

; 35   :     inline List() : array(NULL), num(0) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@Ux264_nal_t@@@@QAE@XZ ENDP			; List<x264_nal_t>::List<x264_nal_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??1?$List@Ux264_nal_t@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$List@Ux264_nal_t@@@@QAE@XZ PROC			; List<x264_nal_t>::~List<x264_nal_t>, COMDAT
; _this$ = ecx

; 37   :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 38   :         Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@Ux264_nal_t@@@@QAEXXZ	; List<x264_nal_t>::Clear

; 39   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@Ux264_nal_t@@@@QAE@XZ ENDP			; List<x264_nal_t>::~List<x264_nal_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Num@?$List@Ux264_nal_t@@@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Num@?$List@Ux264_nal_t@@@@QBEIXZ PROC			; List<x264_nal_t>::Num, COMDAT
; _this$ = ecx

; 42   :     inline unsigned int Num() const     {return num;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?Num@?$List@Ux264_nal_t@@@@QBEIXZ ENDP			; List<x264_nal_t>::Num
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??6?$List@Ux264_nal_t@@@@QAEAAV0@ABUx264_nal_t@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_val$ = 8						; size = 4
??6?$List@Ux264_nal_t@@@@QAEAAV0@ABUx264_nal_t@@@Z PROC	; List<x264_nal_t>::operator<<, COMDAT
; _this$ = ecx

; 366  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 367  :         Add(val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Add@?$List@Ux264_nal_t@@@@QAEIABUx264_nal_t@@@Z ; List<x264_nal_t>::Add

; 368  :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 369  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??6?$List@Ux264_nal_t@@@@QAEAAV0@ABUx264_nal_t@@@Z ENDP	; List<x264_nal_t>::operator<<
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??A?$List@Ux264_nal_t@@@@QAEAAUx264_nal_t@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$List@Ux264_nal_t@@@@QAEAAUx264_nal_t@@I@Z PROC	; List<x264_nal_t>::operator[], COMDAT
; _this$ = ecx

; 379  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  :         assert(index < num);
; 381  :         if(index >= num) {DumpError(TEXT("Out of range!  List<%S>::operator[](%d)"), typeid(T).name(), index); return array[0];}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN1@operator
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	push	OFFSET ?__type_info_root_node@@3U__type_info_node@@A ; __type_info_root_node
	mov	ecx, OFFSET ??_R0?AUx264_nal_t@@@8
	call	?name@type_info@@QBEPBDPAU__type_info_node@@@Z ; type_info::name
	push	eax
	push	OFFSET ??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp_?DumpError@@YAXPB_WZZ
	mov	eax, 32					; 00000020H
	imul	eax, eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN3@operator
$LN1@operator:

; 382  :         return array[index];

	mov	eax, DWORD PTR _index$[ebp]
	shl	eax, 5
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx]
$LN3@operator:

; 383  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@Ux264_nal_t@@@@QAEAAUx264_nal_t@@I@Z ENDP	; List<x264_nal_t>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Num@?$List@UDataPacket@@@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Num@?$List@UDataPacket@@@@QBEIXZ PROC			; List<DataPacket>::Num, COMDAT
; _this$ = ecx

; 42   :     inline unsigned int Num() const     {return num;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?Num@?$List@UDataPacket@@@@QBEIXZ ENDP			; List<DataPacket>::Num
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?SetSize@?$List@UDataPacket@@@@QAEHI@Z
_TEXT	SEGMENT
_bClear$ = -16						; size = 4
_oldNum$ = -12						; size = 4
tv70 = -8						; size = 4
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?SetSize@?$List@UDataPacket@@@@QAEHI@Z PROC		; List<DataPacket>::SetSize, COMDAT
; _this$ = ecx

; 205  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 206  :         if(num == n)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _n$[ebp]
	jne	SHORT $LN4@SetSize

; 207  :             return FALSE;

	xor	eax, eax
	jmp	$LN5@SetSize
	jmp	SHORT $LN3@SetSize
$LN4@SetSize:

; 208  :         else if(!n)

	cmp	DWORD PTR _n$[ebp], 0
	jne	SHORT $LN3@SetSize

; 209  :         {
; 210  :             Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@UDataPacket@@@@QAEXXZ	; List<DataPacket>::Clear

; 211  :             return TRUE;

	mov	eax, 1
	jmp	$LN5@SetSize
$LN3@SetSize:

; 212  :         }
; 213  : 
; 214  :         BOOL bClear=(n>num);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jbe	SHORT $LN7@SetSize
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN8@SetSize
$LN7@SetSize:
	mov	DWORD PTR tv70[ebp], 0
$LN8@SetSize:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _bClear$[ebp], ecx

; 215  :         UINT oldNum=num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _oldNum$[ebp], eax

; 216  : 
; 217  :         num = n;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 218  :         array = (T*)ReAllocate(array, sizeof(T)*num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 219  : 
; 220  :         if(bClear)

	cmp	DWORD PTR _bClear$[ebp], 0
	je	SHORT $LN1@SetSize

; 221  :             zero(&array[oldNum], sizeof(T)*(num-oldNum));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, DWORD PTR _oldNum$[ebp]
	shl	eax, 3
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _oldNum$[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	push	ecx
	call	?zero@@YGXPAXI@Z			; zero
$LN1@SetSize:

; 222  : 
; 223  :         return TRUE;

	mov	eax, 1
$LN5@SetSize:

; 224  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetSize@?$List@UDataPacket@@@@QAEHI@Z ENDP		; List<DataPacket>::SetSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Clear@?$List@UDataPacket@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@?$List@UDataPacket@@@@QAEXXZ PROC		; List<DataPacket>::Clear, COMDAT
; _this$ = ecx

; 334  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 335  :         if(array)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Clear

; 336  :         {
; 337  :             /*if(IsBadWritePtr(array, sizeof(T)*num))
; 338  :                 CrashError(TEXT("what the.."));*/
; 339  :             Free(array);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4

; 340  :             array = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 341  :             num = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$LN2@Clear:

; 342  :         }
; 343  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$List@UDataPacket@@@@QAEXXZ ENDP		; List<DataPacket>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??A?$List@UDataPacket@@@@QAEAAUDataPacket@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$List@UDataPacket@@@@QAEAAUDataPacket@@I@Z PROC	; List<DataPacket>::operator[], COMDAT
; _this$ = ecx

; 379  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  :         assert(index < num);
; 381  :         if(index >= num) {DumpError(TEXT("Out of range!  List<%S>::operator[](%d)"), typeid(T).name(), index); return array[0];}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN1@operator
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	push	OFFSET ?__type_info_root_node@@3U__type_info_node@@A ; __type_info_root_node
	mov	ecx, OFFSET ??_R0?AUDataPacket@@@8
	call	?name@type_info@@QBEPBDPAU__type_info_node@@@Z ; type_info::name
	push	eax
	push	OFFSET ??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp_?DumpError@@YAXPB_WZZ
	mov	eax, 8
	imul	eax, eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN3@operator
$LN1@operator:

; 382  :         return array[index];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _index$[ebp]
	lea	eax, DWORD PTR [eax+ecx*8]
$LN3@operator:

; 383  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@UDataPacket@@@@QAEAAUDataPacket@@I@Z ENDP	; List<DataPacket>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??6?$List@W4PacketType@@@@QAEAAV0@ABW4PacketType@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_val$ = 8						; size = 4
??6?$List@W4PacketType@@@@QAEAAV0@ABW4PacketType@@@Z PROC ; List<enum PacketType>::operator<<, COMDAT
; _this$ = ecx

; 366  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 367  :         Add(val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Add@?$List@W4PacketType@@@@QAEIABW4PacketType@@@Z ; List<enum PacketType>::Add

; 368  :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 369  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??6?$List@W4PacketType@@@@QAEAAV0@ABW4PacketType@@@Z ENDP ; List<enum PacketType>::operator<<
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??1?$IPCMutexLock@U?$IPCLockedSignalledArray@I@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$IPCMutexLock@U?$IPCLockedSignalledArray@I@@@@QAE@XZ PROC ; IPCMutexLock<IPCLockedSignalledArray<unsigned int> >::~IPCMutexLock<IPCLockedSignalledArray<unsigned int> >, COMDAT
; _this$ = ecx

; 138  :     ~IPCMutexLock() { if(enabled) t.unlock(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN2@IPCMutexLo
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	add	ecx, 56					; 00000038H
	call	?unlock@IPCMutex@@QAEXXZ		; IPCMutex::unlock
$LN2@IPCMutexLo:
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$IPCMutexLock@U?$IPCLockedSignalledArray@I@@@@QAE@XZ ENDP ; IPCMutexLock<IPCLockedSignalledArray<unsigned int> >::~IPCMutexLock<IPCLockedSignalledArray<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??1?$IPCMutexLock@U?$IPCLockedSignalledArray@Uqueued_frame@@@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$IPCMutexLock@U?$IPCLockedSignalledArray@Uqueued_frame@@@@@@QAE@XZ PROC ; IPCMutexLock<IPCLockedSignalledArray<queued_frame> >::~IPCMutexLock<IPCLockedSignalledArray<queued_frame> >, COMDAT
; _this$ = ecx

; 138  :     ~IPCMutexLock() { if(enabled) t.unlock(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN2@IPCMutexLo
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	add	ecx, 56					; 00000038H
	call	?unlock@IPCMutex@@QAEXXZ		; IPCMutex::unlock
$LN2@IPCMutexLo:
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$IPCMutexLock@U?$IPCLockedSignalledArray@Uqueued_frame@@@@@@QAE@XZ ENDP ; IPCMutexLock<IPCLockedSignalledArray<queued_frame> >::~IPCMutexLock<IPCLockedSignalledArray<queued_frame> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??0?$IPCSignalledType@Uspspps_size@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_name$ = 8						; size = 24
??0?$IPCSignalledType@Uspspps_size@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z PROC ; IPCSignalledType<spspps_size>::IPCSignalledType<spspps_size>, COMDAT
; _this$ = ecx

; 172  :     IPCSignalledType(std::wstring name) : IPCType(name), IPCSignal(name+L"Signal") {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$IPCType@Uspspps_size@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; IPCType<spspps_size>::IPCType<spspps_size>
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	push	OFFSET ??_C@_1O@IENHAHCD@?$AAS?$AAi?$AAg?$AAn?$AAa?$AAl?$AA?$AA@
	lea	edx, DWORD PTR _name$[ebp]
	push	edx
	push	ecx
	call	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	??0?$IPCSignal@$0A@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; IPCSignal<0>::IPCSignal<0>
	lea	ecx, DWORD PTR _name$[ebp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
??0?$IPCSignalledType@Uspspps_size@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ENDP ; IPCSignalledType<spspps_size>::IPCSignalledType<spspps_size>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??C?$IPCType@Uspspps_size@@@@QAEPAUspspps_size@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??C?$IPCType@Uspspps_size@@@@QAEPAUspspps_size@@XZ PROC	; IPCType<spspps_size>::operator->, COMDAT
; _this$ = ecx

; 156  :     T *operator->() { return &memory.as<T>(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$as@Uspspps_size@@@NamedSharedMemory@@QAEAAUspspps_size@@XZ ; NamedSharedMemory::as<spspps_size>
	mov	esp, ebp
	pop	ebp
	ret	0
??C?$IPCType@Uspspps_size@@@@QAEPAUspspps_size@@XZ ENDP	; IPCType<spspps_size>::operator->
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??0?$IPCSignalledArray@E@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_name$ = 8						; size = 24
_size$ = 32						; size = 4
??0?$IPCSignalledArray@E@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z PROC ; IPCSignalledArray<unsigned char>::IPCSignalledArray<unsigned char>, COMDAT
; _this$ = ecx

; 209  :     IPCSignalledArray(std::wstring name, size_t size) : IPCArray(name, size), IPCSignal(name+L"Signal") {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	lea	edx, DWORD PTR _name$[ebp]
	push	edx
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$IPCArray@E@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z ; IPCArray<unsigned char>::IPCArray<unsigned char>
	sub	esp, 24					; 00000018H
	mov	eax, esp
	push	OFFSET ??_C@_1O@IENHAHCD@?$AAS?$AAi?$AAg?$AAn?$AAa?$AAl?$AA?$AA@
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	eax
	call	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??0?$IPCSignal@$0A@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; IPCSignal<0>::IPCSignal<0>
	lea	ecx, DWORD PTR _name$[ebp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
??0?$IPCSignalledArray@E@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z ENDP ; IPCSignalledArray<unsigned char>::IPCSignalledArray<unsigned char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??B?$IPCArray@E@@QAEPAEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??B?$IPCArray@E@@QAEPAEXZ PROC				; IPCArray<unsigned char>::operator unsigned char *, COMDAT
; _this$ = ecx

; 194  :     operator T*() { return static_cast<T*>(&memory); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??INamedSharedMemory@@QAEPAXXZ		; NamedSharedMemory::operator&
	mov	esp, ebp
	pop	ebp
	ret	0
??B?$IPCArray@E@@QAEPAEXZ ENDP				; IPCArray<unsigned char>::operator unsigned char *
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Add@?$List@E@@QAEIABE@Z
_TEXT	SEGMENT
tv73 = -8						; size = 4
_this$ = -4						; size = 4
_val$ = 8						; size = 4
?Add@?$List@E@@QAEIABE@Z PROC				; List<unsigned char>::Add, COMDAT
; _this$ = ecx

; 45   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 46   :         array = (T*)ReAllocate(array, sizeof(T)*++num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	DWORD PTR tv73[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR tv73[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 47   :         mcpy(&array[(num-1)], (void*)&val, sizeof(T));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _val$[ebp]
	mov	cl, BYTE PTR [ecx]
	mov	BYTE PTR [edx+eax-1], cl

; 48   :         return num-1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1

; 49   :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?Add@?$List@E@@QAEIABE@Z ENDP				; List<unsigned char>::Add
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1045 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN4@append

; 1046 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@append:

; 1047 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1048 : 		if (_Num < _Count)

	mov	eax, DWORD PTR __Num$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN3@append

; 1049 : 			_Count = _Num;	// trim _Count to size

	mov	ecx, DWORD PTR __Num$[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN3@append:

; 1050 : 		if (npos - this->_Mysize <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN2@append

; 1051 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN2@append:

; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@append
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], edx
	push	0
	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@append

; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1057 : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@append:

; 1058 : 			}
; 1059 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@append:

; 1060 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z
_TEXT	SEGMENT
tv134 = -24						; size = 4
tv133 = -20						; size = 4
tv132 = -16						; size = 4
__Ans$ = -12						; size = 4
tv86 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__N0$ = 12						; size = 4
__Ptr$ = 16						; size = 4
__Count$ = 20						; size = 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare, COMDAT
; _this$ = ecx

; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN2@compare

; 2177 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN2@compare:

; 2178 : 		if (this->_Mysize - _Off < _N0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __N0$[ebp]
	jae	SHORT $LN1@compare

; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __N0$[ebp], edx
$LN1@compare:

; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);

	mov	eax, DWORD PTR __N0$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN5@compare
	mov	ecx, DWORD PTR __N0$[ebp]
	mov	DWORD PTR tv86[ebp], ecx
	jmp	SHORT $LN6@compare
$LN5@compare:
	mov	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv86[ebp], edx
$LN6@compare:
	mov	eax, DWORD PTR tv86[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	push	eax
	call	?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ans$[ebp], eax

; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);

	cmp	DWORD PTR __Ans$[ebp], 0
	je	SHORT $LN11@compare
	mov	edx, DWORD PTR __Ans$[ebp]
	mov	DWORD PTR tv134[ebp], edx
	jmp	SHORT $LN12@compare
$LN11@compare:
	mov	eax, DWORD PTR __N0$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN9@compare
	mov	DWORD PTR tv133[ebp], -1
	jmp	SHORT $LN10@compare
$LN9@compare:
	mov	ecx, DWORD PTR __N0$[ebp]
	cmp	ecx, DWORD PTR __Count$[ebp]
	jne	SHORT $LN7@compare
	mov	DWORD PTR tv132[ebp], 0
	jmp	SHORT $LN8@compare
$LN7@compare:
	mov	DWORD PTR tv132[ebp], 1
$LN8@compare:
	mov	edx, DWORD PTR tv132[ebp]
	mov	DWORD PTR tv133[ebp], edx
$LN10@compare:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR tv134[ebp], eax
$LN12@compare:
	mov	eax, DWORD PTR tv134[ebp]
$LN4@compare:

; 2185 : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Right$ = 8						; size = 4
?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv, COMDAT
; _this$ = ecx

; 935  : 		{	// assign by moving _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 936  : 		if (_Right._Myres < this->_BUF_SIZE)

	mov	eax, DWORD PTR __Right$[ebp]
	cmp	DWORD PTR [eax+20], 8
	jae	SHORT $LN2@Assign_rv

; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move
	add	esp, 12					; 0000000cH

; 939  : 		else

	jmp	SHORT $LN1@Assign_rv
$LN2@Assign_rv:

; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);

	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
	mov	ecx, eax
	call	??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>

; 942  : 			_Right._Bx._Ptr = pointer();

	mov	edx, DWORD PTR __Right$[ebp]
	mov	DWORD PTR [edx], 0
$LN1@Assign_rv:

; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 945  : 		this->_Myres = _Right._Myres;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx

; 946  : 		_Right._Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy

; 947  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		return (assign(_Right, 0, npos));

	mov	eax, DWORD PTR ?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::npos
	push	eax
	push	0
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 1125 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1130 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1131 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran
$LN5@assign:

; 1132 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1133 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1134 : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1135 : 
; 1136 : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1138 : 		else if (_Grow(_Num))

	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
	mov	edx, DWORD PTR __Roff$[ebp]
	lea	eax, DWORD PTR [eax+edx*2]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
	push	eax
	call	?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy
	add	esp, 12					; 0000000cH

; 1142 : 			_Eos(_Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos
$LN2@assign:

; 1143 : 			}
; 1144 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1145 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 1167 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@_W@std@@SAIPB_W@Z	; std::char_traits<wchar_t>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 1170 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size, COMDAT
; _this$ = ecx

; 1753 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1754 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 1755 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy, COMDAT
; _this$ = ecx

; 2272 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2273 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 8
	jb	SHORT $LN3@Tidy

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Ptr$1[ebp], eax

; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::destroy<wchar_t *>

; 2279 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	push	ecx
	call	??$addressof@_W@std@@YAPA_WAA_W@Z	; std::addressof<wchar_t>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$1[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN3@Tidy:

; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 7

; 2285 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos

; 2286 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??0?$allocator@_W@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@_W@std@@QAE@XZ PROC			; std::allocator<wchar_t>::allocator<wchar_t>, COMDAT
; _this$ = ecx

; 552  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@_W@std@@QAE@XZ ENDP			; std::allocator<wchar_t>::allocator<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t> > >, COMDAT
; _this$ = ecx

; 630  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >

; 631  : 		{	// construct allocator from _Al
; 632  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z PROC ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Change_alloc, COMDAT
; _this$ = ecx

; 635  : 		{	// replace old allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Change_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal, COMDAT
; _this$ = ecx

; 683  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 684  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 685  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 778  : 		{	// get allocator to use

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 779  : 		return (_Mytraits::select_on_container_copy_construction(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z ; std::allocator_traits<std::allocator<wchar_t> >::select_on_container_copy_construction
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 780  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT
; _this$ = ecx

; 517  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 518  : 		return (this->_BUF_SIZE <= this->_Myres
; 519  : 			? _STD addressof(*this->_Bx._Ptr)
; 520  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 8
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@_W@std@@YAPA_WAA_W@Z	; std::addressof<wchar_t>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 521  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?GetRealIndex@?$CircularList@I@@AAEII@Z
_TEXT	SEGMENT
_newIndex$1 = -8					; size = 4
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?GetRealIndex@?$CircularList@I@@AAEII@Z PROC		; CircularList<unsigned int>::GetRealIndex, COMDAT
; _this$ = ecx

; 771  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 772  :         if (startID == 0) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN3@GetRealInd

; 773  :             return index;

	mov	eax, DWORD PTR _index$[ebp]
	jmp	SHORT $LN4@GetRealInd

; 774  :         } else {

	jmp	SHORT $LN4@GetRealInd
$LN3@GetRealInd:

; 775  :             unsigned int newIndex = startID + index;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, DWORD PTR _index$[ebp]
	mov	DWORD PTR _newIndex$1[ebp], edx

; 776  :             if (newIndex >= num)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newIndex$1[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN1@GetRealInd

; 777  :                 newIndex -= num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _newIndex$1[ebp]
	sub	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _newIndex$1[ebp], eax
$LN1@GetRealInd:

; 778  : 
; 779  :             return newIndex;

	mov	eax, DWORD PTR _newIndex$1[ebp]
$LN4@GetRealInd:

; 780  :         }
; 781  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetRealIndex@?$CircularList@I@@AAEII@Z ENDP		; CircularList<unsigned int>::GetRealIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Add@?$CircularList@I@@QAEIABI@Z
_TEXT	SEGMENT
tv198 = -12						; size = 4
tv180 = -8						; size = 4
_this$ = -4						; size = 4
_val$ = 8						; size = 4
?Add@?$CircularList@I@@QAEIABI@Z PROC			; CircularList<unsigned int>::Add, COMDAT
; _this$ = ecx

; 787  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 788  :         if (storedNum == num) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+16]
	cmp	edx, DWORD PTR [ecx+4]
	jne	$LN6@Add

; 789  :             if (startID == 0) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN5@Add

; 790  :                 List::Add(val);

	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Add@?$List@I@@QAEIABI@Z		; List<unsigned int>::Add

; 791  : 
; 792  :                 if (storedNum != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	SHORT $LN4@Add

; 793  :                     ++endID;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], ecx
$LN4@Add:

; 794  :             } else {

	jmp	SHORT $LN3@Add
$LN5@Add:

; 795  :                 List::SetSize(storedNum+1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSize@?$List@I@@QAEHI@Z		; List<unsigned int>::SetSize

; 796  :                 mcpyrev(array+startID+1, array+startID, (storedNum-startID)*sizeof(T));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+16]
	sub	ecx, DWORD PTR [eax+8]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+eax*4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx+edx*4+4]
	push	edx
	call	?mcpyrev@@YGXPAXPBXI@Z			; mcpyrev

; 797  :                 mcpy(array+startID, &val, sizeof(T));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _val$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [eax+ecx*4], edx

; 798  :                 ++startID;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 799  :                 ++endID;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], ecx
$LN3@Add:

; 800  :             }
; 801  :         } else {

	jmp	SHORT $LN2@Add
$LN6@Add:

; 802  :             if (storedNum > 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jbe	SHORT $LN1@Add

; 803  :                 endID = (endID == num-1) ? 0 : endID+1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], edx
	jne	SHORT $LN9@Add
	mov	DWORD PTR tv180[ebp], 0
	jmp	SHORT $LN10@Add
$LN9@Add:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, 1
	mov	DWORD PTR tv180[ebp], edx
$LN10@Add:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR tv180[ebp]
	mov	DWORD PTR [eax+12], ecx
$LN1@Add:

; 804  :             mcpy(array+endID, &val, sizeof(T));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [edx+eax*4], ecx
$LN2@Add:

; 805  :         }
; 806  : 
; 807  :         return storedNum++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR tv198[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR tv198[ebp]

; 808  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?Add@?$CircularList@I@@QAEIABI@Z ENDP			; CircularList<unsigned int>::Add
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ?capacity@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ PROC ; std::vector<void *,std::allocator<void *> >::capacity, COMDAT
; _this$ = ecx

; 1009 : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1010 : 		return (this->_Myend - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1011 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ENDP ; std::vector<void *,std::allocator<void *> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ?begin@?$vector@PAXV?$allocator@PAX@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAXV?$allocator@PAX@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@2@XZ PROC ; std::vector<void *,std::allocator<void *> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@std@@QAE@PAPAXPBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<void *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<void *> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1026 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAXV?$allocator@PAX@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@2@XZ ENDP ; std::vector<void *,std::allocator<void *> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ?begin@?$vector@PAXV?$allocator@PAX@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAXV?$allocator@PAX@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@2@XZ PROC ; std::vector<void *,std::allocator<void *> >::begin, COMDAT
; _this$ = ecx

; 1029 : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1030 : 		return (const_iterator(this->_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@std@@QAE@PAPAXPBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<void *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<void *> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1031 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAXV?$allocator@PAX@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@2@XZ ENDP ; std::vector<void *,std::allocator<void *> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ?end@?$vector@PAXV?$allocator@PAX@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAXV?$allocator@PAX@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@2@XZ PROC ; std::vector<void *,std::allocator<void *> >::end, COMDAT
; _this$ = ecx

; 1039 : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1040 : 		return (const_iterator(this->_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@std@@QAE@PAPAXPBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<void *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<void *> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1041 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAXV?$allocator@PAX@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@2@XZ ENDP ; std::vector<void *,std::allocator<void *> >::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ?empty@?$vector@PAXV?$allocator@PAX@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
tv75 = -8						; size = 4
_this$ = -4						; size = 4
?empty@?$vector@PAXV?$allocator@PAX@std@@@std@@QBE_NXZ PROC ; std::vector<void *,std::allocator<void *> >::empty, COMDAT
; _this$ = ecx

; 1157 : 		{	// test if sequence is empty

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1158 : 		return (this->_Myfirst == this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN3@empty
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@empty
$LN3@empty:
	mov	DWORD PTR tv75[ebp], 0
$LN4@empty:
	mov	al, BYTE PTR tv75[ebp]

; 1159 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?empty@?$vector@PAXV?$allocator@PAX@std@@@std@@QBE_NXZ ENDP ; std::vector<void *,std::allocator<void *> >::empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ?clear@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEXXZ PROC ; std::vector<void *,std::allocator<void *> >::clear, COMDAT
; _this$ = ecx

; 1507 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1508 : 		this->_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXPAPAX0@Z ; std::vector<void *,std::allocator<void *> >::_Destroy

; 1510 : 		this->_Mylast = this->_Myfirst;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+4], eax

; 1511 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEXXZ ENDP ; std::vector<void *,std::allocator<void *> >::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ?_Buy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAE_NI@Z PROC ; std::vector<void *,std::allocator<void *> >::_Buy, COMDAT
; _this$ = ecx

; 1546 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1547 : 		this->_Myfirst = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 1548 : 		this->_Mylast = pointer();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 1549 : 		this->_Myend = pointer();

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 1550 : 
; 1551 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy

; 1552 : 			return (false);

	xor	al, al
	jmp	SHORT $LN6@Buy
	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1553 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy

; 1554 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$vector@PAXV?$allocator@PAX@std@@@std@@IBEXXZ ; std::vector<void *,std::allocator<void *> >::_Xlen

; 1555 : 		else

	jmp	SHORT $LN3@Buy
$LN2@Buy:

; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAX@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<void *,std::allocator<void *> > >::_Getal
	mov	ecx, eax
	call	?allocate@?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QAEPAPAXI@Z ; std::_Wrap_alloc<std::allocator<void *> >::allocate
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], eax

; 1558 : 			this->_Mylast = this->_Myfirst;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Capacity$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN3@Buy:

; 1560 : 			}
; 1561 : 		return (true);

	mov	al, 1
$LN6@Buy:

; 1562 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAE_NI@Z ENDP ; std::vector<void *,std::allocator<void *> >::_Buy
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXPAPAX0@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Alval$ = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXPAPAX0@Z PROC ; std::vector<void *,std::allocator<void *> >::_Destroy, COMDAT
; _this$ = ecx

; 1565 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1566 : 		_Alty _Alval(this->_Getal());

	lea	eax, DWORD PTR __Alval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAX@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<void *,std::allocator<void *> > >::_Getal

; 1567 : 		_Destroy_range(_First, _Last, _Alval);

	lea	ecx, DWORD PTR __Alval$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@@std@@YAXPAPAX0AAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<void *> > >
	add	esp, 12					; 0000000cH

; 1568 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXPAPAX0@Z ENDP ; std::vector<void *,std::allocator<void *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ?_Inside@?$vector@PAXV?$allocator@PAX@std@@@std@@IBE_NPBQAX@Z
_TEXT	SEGMENT
tv76 = -8						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@PAXV?$allocator@PAX@std@@@std@@IBE_NPBQAX@Z PROC ; std::vector<void *,std::allocator<void *> >::_Inside, COMDAT
; _this$ = ecx

; 1582 : 		{	// test if _Ptr points inside vector

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN3@Inside
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN4@Inside
$LN3@Inside:
	mov	DWORD PTR tv76[ebp], 0
$LN4@Inside:
	mov	al, BYTE PTR tv76[ebp]

; 1584 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$vector@PAXV?$allocator@PAX@std@@@std@@IBE_NPBQAX@Z ENDP ; std::vector<void *,std::allocator<void *> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ?_Reserve@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXI@Z PROC ; std::vector<void *,std::allocator<void *> >::_Reserve, COMDAT
; _this$ = ecx

; 1612 : 		{	// ensure room for _Count new elements, grow exponentially

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1613 : 		if (_Unused_capacity() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Unused_capacity@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::_Unused_capacity
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN4@Reserve

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN1@Reserve

; 1616 : 				_Xlen();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$vector@PAXV?$allocator@PAX@std@@@std@@IBEXXZ ; std::vector<void *,std::allocator<void *> >::_Xlen
$LN1@Reserve:

; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow_to@?$vector@PAXV?$allocator@PAX@std@@@std@@IBEII@Z ; std::vector<void *,std::allocator<void *> >::_Grow_to
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reallocate@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXI@Z ; std::vector<void *,std::allocator<void *> >::_Reallocate
$LN4@Reserve:

; 1618 : 			}
; 1619 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Reserve@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXI@Z ENDP ; std::vector<void *,std::allocator<void *> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Tidy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXXZ PROC ; std::vector<void *,std::allocator<void *> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1623 : 		if (this->_Myfirst != pointer())

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Tidy

; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXPAPAX0@Z ; std::vector<void *,std::allocator<void *> >::_Destroy

; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax]
	sar	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAX@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<void *,std::allocator<void *> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QAEXPAPAXI@Z ; std::_Wrap_alloc<std::allocator<void *> >::deallocate

; 1629 : 			this->_Myfirst = pointer();

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 0

; 1630 : 			this->_Mylast = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 1631 : 			this->_Myend = pointer();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
$LN2@Tidy:

; 1632 : 			}
; 1633 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXXZ ENDP ; std::vector<void *,std::allocator<void *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAXV?$allocator@PAX@std@@@std@@IBEXPAPAX0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@PAXV?$allocator@PAX@std@@@std@@IBEXPAPAX0@Z PROC ; std::vector<void *,std::allocator<void *> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1780 : 		{	// orphan iterators within specified (inclusive) range

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1781 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Orphan_range@?$vector@PAXV?$allocator@PAX@std@@@std@@IBEXPAPAX0@Z ENDP ; std::vector<void *,std::allocator<void *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAX@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@PAX@std@@QAE@XZ PROC			; std::allocator<void *>::allocator<void *>, COMDAT
; _this$ = ecx

; 552  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@PAX@std@@QAE@XZ ENDP			; std::allocator<void *>::allocator<void *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QAE@ABV?$allocator@PAX@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QAE@ABV?$allocator@PAX@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<void *,std::allocator<void *> > >::_Vector_alloc<0,std::_Vec_base_types<void *,std::allocator<void *> > >, COMDAT
; _this$ = ecx

; 588  : 	_Vector_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<void *> >::_Vector_val<std::_Simple_types<void *> >

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QAE@ABV?$allocator@PAX@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<void *,std::allocator<void *> > >::_Vector_alloc<0,std::_Vec_base_types<void *,std::allocator<void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@PAX@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@PAX@std@@@2@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<void *,std::allocator<void *> > >::_Change_alloc, COMDAT
; _this$ = ecx

; 593  : 		{	// replace old allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 594  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@PAX@std@@@2@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<void *,std::allocator<void *> > >::_Change_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAX@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAX@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<void *,std::allocator<void *> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<void *> >::_Wrap_alloc<std::allocator<void *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAX@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<void *,std::allocator<void *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QBE?AU12@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QBE?AU12@XZ PROC ; std::_Wrap_alloc<std::allocator<void *> >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 778  : 		{	// get allocator to use

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 779  : 		return (_Mytraits::select_on_container_copy_construction(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	?select_on_container_copy_construction@?$allocator_traits@V?$allocator@PAX@std@@@std@@SA?AV?$allocator@PAX@2@ABV32@@Z ; std::allocator_traits<std::allocator<void *> >::select_on_container_copy_construction
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QAE@ABV?$allocator@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<void *> >::_Wrap_alloc<std::allocator<void *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 780  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QBE?AU12@XZ ENDP ; std::_Wrap_alloc<std::allocator<void *> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QAEXPAPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QAEXPAPAXI@Z PROC ; std::_Wrap_alloc<std::allocator<void *> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@PAX@std@@QAEXPAPAXI@Z ; std::allocator<void *>::deallocate

; 859  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QAEXPAPAXI@Z ENDP ; std::_Wrap_alloc<std::allocator<void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??0?$IPCSignal@$0A@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_name$ = 8						; size = 24
??0?$IPCSignal@$0A@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z PROC ; IPCSignal<0>::IPCSignal<0>, COMDAT
; _this$ = ecx

; 99   :     IPCSignal(std::wstring name) { signal_.reset(CreateEvent(nullptr, manual, false, name.c_str())); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0safe_handle@@QAE@PAX@Z		; safe_handle::safe_handle
	lea	ecx, DWORD PTR _name$[ebp]
	call	?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
	push	eax
	push	0
	push	0
	push	0
	call	DWORD PTR __imp__CreateEventW@16
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?reset@safe_handle@@QAEXPAX@Z		; safe_handle::reset
	lea	ecx, DWORD PTR _name$[ebp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
??0?$IPCSignal@$0A@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ENDP ; IPCSignal<0>::IPCSignal<0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Add@?$List@_J@@QAEIAB_J@Z
_TEXT	SEGMENT
tv73 = -8						; size = 4
_this$ = -4						; size = 4
_val$ = 8						; size = 4
?Add@?$List@_J@@QAEIAB_J@Z PROC				; List<__int64>::Add, COMDAT
; _this$ = ecx

; 45   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 46   :         array = (T*)ReAllocate(array, sizeof(T)*++num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	DWORD PTR tv73[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR tv73[ebp]
	shl	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 47   :         mcpy(&array[(num-1)], (void*)&val, sizeof(T));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _val$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [edx+eax*8-8], esi
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+eax*8-4], ecx

; 48   :         return num-1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1

; 49   :     }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?Add@?$List@_J@@QAEIAB_J@Z ENDP				; List<__int64>::Add
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??0?$IPCType@Uinit_request@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_name$ = 8						; size = 24
??0?$IPCType@Uinit_request@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z PROC ; IPCType<init_request>::IPCType<init_request>, COMDAT
; _this$ = ecx

; 161  :     IPCType(std::wstring name) : memory(name, sizeof(T)) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	push	209					; 000000d1H
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0NamedSharedMemory@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_K@Z ; NamedSharedMemory::NamedSharedMemory
	lea	ecx, DWORD PTR _name$[ebp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
??0?$IPCType@Uinit_request@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ENDP ; IPCType<init_request>::IPCType<init_request>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Clear@?$List@Uencode_task@QSVEncoder@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@?$List@Uencode_task@QSVEncoder@@@@QAEXXZ PROC	; List<QSVEncoder::encode_task>::Clear, COMDAT
; _this$ = ecx

; 334  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 335  :         if(array)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Clear

; 336  :         {
; 337  :             /*if(IsBadWritePtr(array, sizeof(T)*num))
; 338  :                 CrashError(TEXT("what the.."));*/
; 339  :             Free(array);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4

; 340  :             array = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 341  :             num = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$LN2@Clear:

; 342  :         }
; 343  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$List@Uencode_task@QSVEncoder@@@@QAEXXZ ENDP	; List<QSVEncoder::encode_task>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??0?$IPCSignalledArray@Uqueued_frame@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_name$ = 8						; size = 24
_size$ = 32						; size = 4
??0?$IPCSignalledArray@Uqueued_frame@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z PROC ; IPCSignalledArray<queued_frame>::IPCSignalledArray<queued_frame>, COMDAT
; _this$ = ecx

; 209  :     IPCSignalledArray(std::wstring name, size_t size) : IPCArray(name, size), IPCSignal(name+L"Signal") {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	lea	edx, DWORD PTR _name$[ebp]
	push	edx
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$IPCArray@Uqueued_frame@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z ; IPCArray<queued_frame>::IPCArray<queued_frame>
	sub	esp, 24					; 00000018H
	mov	eax, esp
	push	OFFSET ??_C@_1O@IENHAHCD@?$AAS?$AAi?$AAg?$AAn?$AAa?$AAl?$AA?$AA@
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	eax
	call	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??0?$IPCSignal@$0A@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; IPCSignal<0>::IPCSignal<0>
	lea	ecx, DWORD PTR _name$[ebp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
??0?$IPCSignalledArray@Uqueued_frame@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z ENDP ; IPCSignalledArray<queued_frame>::IPCSignalledArray<queued_frame>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??0?$IPCSignalledArray@Uqueued_frame@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$IPCSignalledArray@Uqueued_frame@@@@QAE@XZ PROC	; IPCSignalledArray<queued_frame>::IPCSignalledArray<queued_frame>, COMDAT
; _this$ = ecx

; 210  :     IPCSignalledArray() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$IPCArray@Uqueued_frame@@@@QAE@XZ	; IPCArray<queued_frame>::IPCArray<queued_frame>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??0?$IPCSignal@$0A@@@QAE@XZ		; IPCSignal<0>::IPCSignal<0>
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$IPCSignalledArray@Uqueued_frame@@@@QAE@XZ ENDP	; IPCSignalledArray<queued_frame>::IPCSignalledArray<queued_frame>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??0?$IPCSignalledArray@I@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_name$ = 8						; size = 24
_size$ = 32						; size = 4
??0?$IPCSignalledArray@I@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z PROC ; IPCSignalledArray<unsigned int>::IPCSignalledArray<unsigned int>, COMDAT
; _this$ = ecx

; 209  :     IPCSignalledArray(std::wstring name, size_t size) : IPCArray(name, size), IPCSignal(name+L"Signal") {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	lea	edx, DWORD PTR _name$[ebp]
	push	edx
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$IPCArray@I@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z ; IPCArray<unsigned int>::IPCArray<unsigned int>
	sub	esp, 24					; 00000018H
	mov	eax, esp
	push	OFFSET ??_C@_1O@IENHAHCD@?$AAS?$AAi?$AAg?$AAn?$AAa?$AAl?$AA?$AA@
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	eax
	call	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??0?$IPCSignal@$0A@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; IPCSignal<0>::IPCSignal<0>
	lea	ecx, DWORD PTR _name$[ebp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
??0?$IPCSignalledArray@I@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z ENDP ; IPCSignalledArray<unsigned int>::IPCSignalledArray<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??0?$IPCSignalledArray@I@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$IPCSignalledArray@I@@QAE@XZ PROC			; IPCSignalledArray<unsigned int>::IPCSignalledArray<unsigned int>, COMDAT
; _this$ = ecx

; 210  :     IPCSignalledArray() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$IPCArray@I@@QAE@XZ			; IPCArray<unsigned int>::IPCArray<unsigned int>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??0?$IPCSignal@$0A@@@QAE@XZ		; IPCSignal<0>::IPCSignal<0>
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$IPCSignalledArray@I@@QAE@XZ ENDP			; IPCSignalledArray<unsigned int>::IPCSignalledArray<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??0?$IPCSignalledType@H@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_name$ = 8						; size = 24
??0?$IPCSignalledType@H@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z PROC ; IPCSignalledType<int>::IPCSignalledType<int>, COMDAT
; _this$ = ecx

; 172  :     IPCSignalledType(std::wstring name) : IPCType(name), IPCSignal(name+L"Signal") {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$IPCType@H@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; IPCType<int>::IPCType<int>
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	push	OFFSET ??_C@_1O@IENHAHCD@?$AAS?$AAi?$AAg?$AAn?$AAa?$AAl?$AA?$AA@
	lea	edx, DWORD PTR _name$[ebp]
	push	edx
	push	ecx
	call	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	??0?$IPCSignal@$0A@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; IPCSignal<0>::IPCSignal<0>
	lea	ecx, DWORD PTR _name$[ebp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
??0?$IPCSignalledType@H@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ENDP ; IPCSignalledType<int>::IPCSignalledType<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??0?$IPCSignalledType@H@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$IPCSignalledType@H@@QAE@XZ PROC			; IPCSignalledType<int>::IPCSignalledType<int>, COMDAT
; _this$ = ecx

; 173  :     IPCSignalledType() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$IPCType@H@@QAE@XZ			; IPCType<int>::IPCType<int>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	??0?$IPCSignal@$0A@@@QAE@XZ		; IPCSignal<0>::IPCSignal<0>
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$IPCSignalledType@H@@QAE@XZ ENDP			; IPCSignalledType<int>::IPCSignalledType<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Clear@?$List@UmfxFrameData@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@?$List@UmfxFrameData@@@@QAEXXZ PROC		; List<mfxFrameData>::Clear, COMDAT
; _this$ = ecx

; 334  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 335  :         if(array)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Clear

; 336  :         {
; 337  :             /*if(IsBadWritePtr(array, sizeof(T)*num))
; 338  :                 CrashError(TEXT("what the.."));*/
; 339  :             Free(array);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4

; 340  :             array = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 341  :             num = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$LN2@Clear:

; 342  :         }
; 343  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$List@UmfxFrameData@@@@QAEXXZ ENDP		; List<mfxFrameData>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?SetSize@?$List@UVideoPacket@@@@QAEHI@Z
_TEXT	SEGMENT
_bClear$ = -16						; size = 4
_oldNum$ = -12						; size = 4
tv70 = -8						; size = 4
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?SetSize@?$List@UVideoPacket@@@@QAEHI@Z PROC		; List<VideoPacket>::SetSize, COMDAT
; _this$ = ecx

; 205  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 206  :         if(num == n)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _n$[ebp]
	jne	SHORT $LN4@SetSize

; 207  :             return FALSE;

	xor	eax, eax
	jmp	$LN5@SetSize
	jmp	SHORT $LN3@SetSize
$LN4@SetSize:

; 208  :         else if(!n)

	cmp	DWORD PTR _n$[ebp], 0
	jne	SHORT $LN3@SetSize

; 209  :         {
; 210  :             Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@UVideoPacket@@@@QAEXXZ	; List<VideoPacket>::Clear

; 211  :             return TRUE;

	mov	eax, 1
	jmp	$LN5@SetSize
$LN3@SetSize:

; 212  :         }
; 213  : 
; 214  :         BOOL bClear=(n>num);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jbe	SHORT $LN7@SetSize
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN8@SetSize
$LN7@SetSize:
	mov	DWORD PTR tv70[ebp], 0
$LN8@SetSize:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _bClear$[ebp], ecx

; 215  :         UINT oldNum=num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _oldNum$[ebp], eax

; 216  : 
; 217  :         num = n;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 218  :         array = (T*)ReAllocate(array, sizeof(T)*num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 219  : 
; 220  :         if(bClear)

	cmp	DWORD PTR _bClear$[ebp], 0
	je	SHORT $LN1@SetSize

; 221  :             zero(&array[oldNum], sizeof(T)*(num-oldNum));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, DWORD PTR _oldNum$[ebp]
	shl	eax, 3
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _oldNum$[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	push	ecx
	call	?zero@@YGXPAXI@Z			; zero
$LN1@SetSize:

; 222  : 
; 223  :         return TRUE;

	mov	eax, 1
$LN5@SetSize:

; 224  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetSize@?$List@UVideoPacket@@@@QAEHI@Z ENDP		; List<VideoPacket>::SetSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??0?$IPCType@Uinit_response@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_name$ = 8						; size = 24
??0?$IPCType@Uinit_response@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z PROC ; IPCType<init_response>::IPCType<init_response>, COMDAT
; _this$ = ecx

; 161  :     IPCType(std::wstring name) : memory(name, sizeof(T)) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	push	53					; 00000035H
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0NamedSharedMemory@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_K@Z ; NamedSharedMemory::NamedSharedMemory
	lea	ecx, DWORD PTR _name$[ebp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
??0?$IPCType@Uinit_response@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ENDP ; IPCType<init_response>::IPCType<init_response>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Add@?$List@Ux264_nal_t@@@@QAEIABUx264_nal_t@@@Z
_TEXT	SEGMENT
tv73 = -8						; size = 4
_this$ = -4						; size = 4
_val$ = 8						; size = 4
?Add@?$List@Ux264_nal_t@@@@QAEIABUx264_nal_t@@@Z PROC	; List<x264_nal_t>::Add, COMDAT
; _this$ = ecx

; 45   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 46   :         array = (T*)ReAllocate(array, sizeof(T)*++num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	DWORD PTR tv73[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR tv73[ebp]
	shl	ecx, 5
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 47   :         mcpy(&array[(num-1)], (void*)&val, sizeof(T));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR [ecx]
	add	edi, eax
	mov	ecx, 8
	mov	esi, DWORD PTR _val$[ebp]
	rep movsd

; 48   :         return num-1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1

; 49   :     }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?Add@?$List@Ux264_nal_t@@@@QAEIABUx264_nal_t@@@Z ENDP	; List<x264_nal_t>::Add
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Clear@?$List@Ux264_nal_t@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@?$List@Ux264_nal_t@@@@QAEXXZ PROC		; List<x264_nal_t>::Clear, COMDAT
; _this$ = ecx

; 334  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 335  :         if(array)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Clear

; 336  :         {
; 337  :             /*if(IsBadWritePtr(array, sizeof(T)*num))
; 338  :                 CrashError(TEXT("what the.."));*/
; 339  :             Free(array);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4

; 340  :             array = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 341  :             num = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$LN2@Clear:

; 342  :         }
; 343  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$List@Ux264_nal_t@@@@QAEXXZ ENDP		; List<x264_nal_t>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Add@?$List@W4PacketType@@@@QAEIABW4PacketType@@@Z
_TEXT	SEGMENT
tv73 = -8						; size = 4
_this$ = -4						; size = 4
_val$ = 8						; size = 4
?Add@?$List@W4PacketType@@@@QAEIABW4PacketType@@@Z PROC	; List<enum PacketType>::Add, COMDAT
; _this$ = ecx

; 45   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 46   :         array = (T*)ReAllocate(array, sizeof(T)*++num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	DWORD PTR tv73[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR tv73[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 47   :         mcpy(&array[(num-1)], (void*)&val, sizeof(T));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [edx+eax*4-4], ecx

; 48   :         return num-1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1

; 49   :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?Add@?$List@W4PacketType@@@@QAEIABW4PacketType@@@Z ENDP	; List<enum PacketType>::Add
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??0?$IPCType@Uspspps_size@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_name$ = 8						; size = 24
??0?$IPCType@Uspspps_size@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z PROC ; IPCType<spspps_size>::IPCType<spspps_size>, COMDAT
; _this$ = ecx

; 161  :     IPCType(std::wstring name) : memory(name, sizeof(T)) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	push	4
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0NamedSharedMemory@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_K@Z ; NamedSharedMemory::NamedSharedMemory
	lea	ecx, DWORD PTR _name$[ebp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
??0?$IPCType@Uspspps_size@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ENDP ; IPCType<spspps_size>::IPCType<spspps_size>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??0?$IPCArray@E@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_name$ = 8						; size = 24
_size$ = 32						; size = 4
??0?$IPCArray@E@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z PROC ; IPCArray<unsigned char>::IPCArray<unsigned char>, COMDAT
; _this$ = ecx

; 198  :     IPCArray(std::wstring name, size_t size) : memory(name, sizeof(T)*size), size(size) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _size$[ebp]
	xor	ecx, ecx
	push	ecx
	push	eax
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	lea	edx, DWORD PTR _name$[ebp]
	push	edx
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0NamedSharedMemory@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_K@Z ; NamedSharedMemory::NamedSharedMemory
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [eax+40], ecx
	lea	ecx, DWORD PTR _name$[ebp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
??0?$IPCArray@E@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z ENDP ; IPCArray<unsigned char>::IPCArray<unsigned char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@std@@QBEAAPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@std@@QBEAAPAXXZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<void *> > >::operator*, COMDAT
; _this$ = ecx

; 323  : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 324  : 		return ((reference)**(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@std@@QBEABQAXXZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<void *> > >::operator*

; 325  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@std@@QBEAAPAXXZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<void *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	sar	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	jmp	SHORT $LN3@assign
$LN2@assign:

; 1157 : 
; 1158 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
	push	eax
	call	?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy
	add	esp, 12					; 0000000cH

; 1161 : 			_Eos(_Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos
$LN1@assign:

; 1162 : 			}
; 1163 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 1164 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase, COMDAT
; _this$ = ecx

; 1334 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1335 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1336 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran
$LN1@erase:

; 1337 : 		_Eos(_Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos

; 1338 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1339 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -12					; size = 4
__Ptr$2 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase, COMDAT
; _this$ = ecx

; 1342 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1343 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1344 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran
$LN4@erase:

; 1345 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1347 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
	mov	edx, DWORD PTR __Off$[ebp]
	lea	eax, DWORD PTR [eax+edx*2]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1350 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], edx

; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	eax, DWORD PTR __Newsize$1[ebp]
	sub	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Ptr$2[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	push	eax
	mov	ecx, DWORD PTR __Ptr$2[ebp]
	push	ecx
	call	?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move
	add	esp, 12					; 0000000cH

; 1352 : 			_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos
$LN2@erase:

; 1353 : 			}
; 1354 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1355 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -2						; size = 2
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos, COMDAT
; _this$ = ecx

; 2236 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	xor	eax, eax
	mov	WORD PTR $T1[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [ecx+16], edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
	mov	ecx, DWORD PTR __Newsize$[ebp]
	lea	edx, DWORD PTR [eax+ecx*2]
	push	edx
	call	?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z ; std::char_traits<wchar_t>::assign
	add	esp, 8

; 2238 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -12						; size = 4
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow, COMDAT
; _this$ = ecx

; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2243 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2244 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen
$LN6@Grow:

; 2245 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 8
	jae	SHORT $LN3@Grow

; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2250 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2251 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos
$LN4@Grow:

; 2252 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2253 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran, COMDAT
; _this$ = ecx

; 2294 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2295 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 2296 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 801  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@_W@std@@QAE@XZ		; std::allocator<wchar_t>::allocator<wchar_t>

; 802  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 806  : 		{	// construct by copying base

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@_W@std@@QAE@ABV01@@Z	; std::allocator<wchar_t>::allocator<wchar_t>

; 807  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z ; std::allocator<wchar_t>::deallocate

; 859  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<wchar_t> >::select_on_container_copy_construction, COMDAT

; 740  : 		{	// get allocator to use

	push	ebp
	mov	ebp, esp

; 741  : 		return (_Al.select_on_container_copy_construction());

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ ; std::allocator<wchar_t>::select_on_container_copy_construction
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 742  : 		}

	pop	ebp
	ret	0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<wchar_t> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >, COMDAT
; _this$ = ecx

; 492  : 	_String_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 493  : 		{	// initialize values
; 494  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 495  : 		_Myres = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 496  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT
; _this$ = ecx

; 510  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 511  : 		return (this->_BUF_SIZE <= this->_Myres
; 512  : 			? _STD addressof(*this->_Bx._Ptr)
; 513  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 8
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@_W@std@@YAPA_WAA_W@Z	; std::addressof<wchar_t>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 514  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Unused_capacity@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ PROC ; std::vector<void *,std::allocator<void *> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1014 : 		{	// micro-optimization for capacity() - size()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1015 : 		return (this->_Myend - this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 1016 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Unused_capacity@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ENDP ; std::vector<void *,std::allocator<void *> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ?max_size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ PROC ; std::vector<void *,std::allocator<void *> >::max_size, COMDAT
; _this$ = ecx

; 1152 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1153 : 		return (this->_Getal().max_size());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAX@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<void *,std::allocator<void *> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<void *> >::max_size

; 1154 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ENDP ; std::vector<void *,std::allocator<void *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@PAXV?$allocator@PAX@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -12						; size = 4
_this$ = -8						; size = 4
__Capacity$ = -4					; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@PAXV?$allocator@PAX@std@@@std@@IBEII@Z PROC ; std::vector<void *,std::allocator<void *> >::_Grow_to, COMDAT
; _this$ = ecx

; 1571 : 		{	// grow by 50% or at least to _Count

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1572 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN4@Grow_to
	mov	DWORD PTR tv73[ebp], 0
	jmp	SHORT $LN5@Grow_to
$LN4@Grow_to:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv73[ebp], edx
$LN5@Grow_to:
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1576 : 		if (_Capacity < _Count)

	mov	ecx, DWORD PTR __Capacity$[ebp]
	cmp	ecx, DWORD PTR __Count$[ebp]
	jae	SHORT $LN1@Grow_to

; 1577 : 			_Capacity = _Count;

	mov	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx
$LN1@Grow_to:

; 1578 : 		return (_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]

; 1579 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Grow_to@?$vector@PAXV?$allocator@PAX@std@@@std@@IBEII@Z ENDP ; std::vector<void *,std::allocator<void *> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -32						; size = 4
__Ptr$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?_Reallocate@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXI@Z PROC ; std::vector<void *,std::allocator<void *> >::_Reallocate, COMDAT
; _this$ = ecx

; 1587 : 		{	// move to array of exactly _Count elements

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Reallocate@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAX@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<void *,std::allocator<void *> > >::_Getal
	mov	ecx, eax
	call	?allocate@?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QAEPAPAXI@Z ; std::_Wrap_alloc<std::allocator<void *> >::allocate
	mov	DWORD PTR __Ptr$[ebp], eax

; 1589 : 
; 1590 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);

	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAX@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEPAPAXPAPAX00@Z ; std::vector<void *,std::allocator<void *> >::_Umove<void * *>
	jmp	SHORT $LN5@Reallocate
__catch$?_Reallocate@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXI@Z$0:

; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAX@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<void *,std::allocator<void *> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QAEXPAPAXI@Z ; std::_Wrap_alloc<std::allocator<void *> >::deallocate

; 1594 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1595 : 		_CATCH_END

	mov	eax, $LN8@Reallocate
	ret	0
$LN5@Reallocate:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Reallocate@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXI@Z$1
$LN8@Reallocate:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Reallocate@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXI@Z$1:

; 1596 : 
; 1597 : 		size_type _Size = size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::size
	mov	DWORD PTR __Size$[ebp], eax

; 1598 : 		if (this->_Myfirst != pointer())

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN1@Reallocate

; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXPAPAX0@Z ; std::vector<void *,std::allocator<void *> >::_Destroy

; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx]
	sar	edx, 2
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAX@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<void *,std::allocator<void *> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QAEXPAPAXI@Z ; std::_Wrap_alloc<std::allocator<void *> >::deallocate
$LN1@Reallocate:

; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1606 : 		this->_Myend = _Ptr + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 1607 : 		this->_Mylast = _Ptr + _Size;

	mov	ecx, DWORD PTR __Size$[ebp]
	mov	edx, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1608 : 		this->_Myfirst = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx], eax
$LN4@Reallocate:

; 1609 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Reallocate@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Reallocate@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXI@Z ENDP ; std::vector<void *,std::allocator<void *> >::_Reallocate
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ?_Xlen@?$vector@PAXV?$allocator@PAX@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$vector@PAXV?$allocator@PAX@std@@@std@@IBEXXZ PROC ; std::vector<void *,std::allocator<void *> >::_Xlen, COMDAT
; _this$ = ecx

; 1753 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1754 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 1755 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$vector@PAXV?$allocator@PAX@std@@@std@@IBEXXZ ENDP ; std::vector<void *,std::allocator<void *> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAX@std@@QAEXPAPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAX@std@@QAEXPAPAXI@Z PROC	; std::allocator<void *>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 573  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 574  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAX@std@@QAEXPAPAXI@Z ENDP	; std::allocator<void *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<void *> >::_Wrap_alloc<std::allocator<void *> >, COMDAT
; _this$ = ecx

; 801  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@PAX@std@@QAE@XZ		; std::allocator<void *>::allocator<void *>

; 802  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<void *> >::_Wrap_alloc<std::allocator<void *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QAE@ABV?$allocator@PAX@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QAE@ABV?$allocator@PAX@1@@Z PROC ; std::_Wrap_alloc<std::allocator<void *> >::_Wrap_alloc<std::allocator<void *> >, COMDAT
; _this$ = ecx

; 806  : 		{	// construct by copying base

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@PAX@std@@QAE@ABV01@@Z	; std::allocator<void *>::allocator<void *>

; 807  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QAE@ABV?$allocator@PAX@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<void *> >::_Wrap_alloc<std::allocator<void *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QAEPAPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QAEPAPAXI@Z PROC ; std::_Wrap_alloc<std::allocator<void *> >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 847  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@PAX@std@@QAEPAPAXI@Z ; std::allocator<void *>::allocate

; 848  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QAEPAPAXI@Z ENDP ; std::_Wrap_alloc<std::allocator<void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@PAX@std@@@std@@SA?AV?$allocator@PAX@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@PAX@std@@@std@@SA?AV?$allocator@PAX@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<void *> >::select_on_container_copy_construction, COMDAT

; 740  : 		{	// get allocator to use

	push	ebp
	mov	ebp, esp

; 741  : 		return (_Al.select_on_container_copy_construction());

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?select_on_container_copy_construction@?$allocator@PAX@std@@QBE?AV12@XZ ; std::allocator<void *>::select_on_container_copy_construction
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 742  : 		}

	pop	ebp
	ret	0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@PAX@std@@@std@@SA?AV?$allocator@PAX@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<void *> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<void *> >::_Vector_val<std::_Simple_types<void *> >, COMDAT
; _this$ = ecx

; 480  : 	_Vector_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 483  : 		_Mylast = pointer();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 485  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<void *> >::_Vector_val<std::_Simple_types<void *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??0?$IPCSignal@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$IPCSignal@$0A@@@QAE@XZ PROC			; IPCSignal<0>::IPCSignal<0>, COMDAT
; _this$ = ecx

; 100  :     IPCSignal() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0safe_handle@@QAE@PAX@Z		; safe_handle::safe_handle
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$IPCSignal@$0A@@@QAE@XZ ENDP			; IPCSignal<0>::IPCSignal<0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??0?$IPCArray@Uqueued_frame@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_name$ = 8						; size = 24
_size$ = 32						; size = 4
??0?$IPCArray@Uqueued_frame@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z PROC ; IPCArray<queued_frame>::IPCArray<queued_frame>, COMDAT
; _this$ = ecx

; 198  :     IPCArray(std::wstring name, size_t size) : memory(name, sizeof(T)*size), size(size) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	imul	eax, DWORD PTR _size$[ebp], 15
	xor	ecx, ecx
	push	ecx
	push	eax
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	lea	edx, DWORD PTR _name$[ebp]
	push	edx
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0NamedSharedMemory@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_K@Z ; NamedSharedMemory::NamedSharedMemory
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [eax+40], ecx
	lea	ecx, DWORD PTR _name$[ebp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
??0?$IPCArray@Uqueued_frame@@@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z ENDP ; IPCArray<queued_frame>::IPCArray<queued_frame>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??0?$IPCArray@Uqueued_frame@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$IPCArray@Uqueued_frame@@@@QAE@XZ PROC		; IPCArray<queued_frame>::IPCArray<queued_frame>, COMDAT
; _this$ = ecx

; 199  :     IPCArray() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0NamedSharedMemory@@QAE@XZ		; NamedSharedMemory::NamedSharedMemory
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$IPCArray@Uqueued_frame@@@@QAE@XZ ENDP		; IPCArray<queued_frame>::IPCArray<queued_frame>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??0?$IPCArray@I@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_name$ = 8						; size = 24
_size$ = 32						; size = 4
??0?$IPCArray@I@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z PROC ; IPCArray<unsigned int>::IPCArray<unsigned int>, COMDAT
; _this$ = ecx

; 198  :     IPCArray(std::wstring name, size_t size) : memory(name, sizeof(T)*size), size(size) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _size$[ebp]
	shl	eax, 2
	xor	ecx, ecx
	push	ecx
	push	eax
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	lea	edx, DWORD PTR _name$[ebp]
	push	edx
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0NamedSharedMemory@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_K@Z ; NamedSharedMemory::NamedSharedMemory
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [eax+40], ecx
	lea	ecx, DWORD PTR _name$[ebp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
??0?$IPCArray@I@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z ENDP ; IPCArray<unsigned int>::IPCArray<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??0?$IPCArray@I@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$IPCArray@I@@QAE@XZ PROC				; IPCArray<unsigned int>::IPCArray<unsigned int>, COMDAT
; _this$ = ecx

; 199  :     IPCArray() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0NamedSharedMemory@@QAE@XZ		; NamedSharedMemory::NamedSharedMemory
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$IPCArray@I@@QAE@XZ ENDP				; IPCArray<unsigned int>::IPCArray<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??0?$IPCType@H@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_name$ = 8						; size = 24
??0?$IPCType@H@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z PROC ; IPCType<int>::IPCType<int>, COMDAT
; _this$ = ecx

; 161  :     IPCType(std::wstring name) : memory(name, sizeof(T)) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	push	4
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0NamedSharedMemory@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_K@Z ; NamedSharedMemory::NamedSharedMemory
	lea	ecx, DWORD PTR _name$[ebp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
??0?$IPCType@H@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ENDP ; IPCType<int>::IPCType<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??0?$IPCType@H@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$IPCType@H@@QAE@XZ PROC				; IPCType<int>::IPCType<int>, COMDAT
; _this$ = ecx

; 162  :     IPCType() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0NamedSharedMemory@@QAE@XZ		; NamedSharedMemory::NamedSharedMemory
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$IPCType@H@@QAE@XZ ENDP				; IPCType<int>::IPCType<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@std@@QAE@PAPAXPBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@std@@QAE@PAPAXPBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<void *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<void *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [eax], ecx

; 48   : 		this->_Adopt(_Pvector);

	mov	edx, DWORD PTR __Pvector$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z	; std::_Iterator_base0::_Adopt

; 49   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@std@@QAE@PAPAXPBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<void *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@std@@QBEABQAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@std@@QBEABQAXXZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<void *> > >::operator*, COMDAT
; _this$ = ecx

; 65   : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 87   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@std@@QBEABQAXXZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<void *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@std@@QAE@PAPAXPBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@std@@QAE@PAPAXPBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<void *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<void *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@std@@QAE@PAPAXPBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<void *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<void *> > >

; 307  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@std@@QAE@PAPAXPBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<void *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv75 = -12						; size = 4
__Num$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size, COMDAT
; _this$ = ecx

; 1758 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1759 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<wchar_t> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	ecx, DWORD PTR __Num$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv75[ebp], ecx
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1761 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
_TEXT	SEGMENT
__Ptr$ = -32						; size = 4
__Newres$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy, COMDAT
; _this$ = ecx

; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 7
	mov	DWORD PTR __Newres$[ebp], eax

; 2203 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2204 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	esi, 3
	div	esi
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	sub	eax, ecx
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+20], eax
	ja	SHORT $LN5@Copy

; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	shr	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+20]
	mov	DWORD PTR __Newres$[ebp], ecx

; 2210 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2211 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
	mov	ecx, eax
	call	?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::allocate
	mov	DWORD PTR __Ptr$[ebp], eax
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0:

; 2216 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], edx

; 2218 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
	mov	ecx, eax
	call	?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::allocate
	mov	DWORD PTR __Ptr$[ebp], eax
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1:

; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy

; 2222 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2223 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$2:

; 2224 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$3:

; 2225 : 
; 2226 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements

	mov	edx, DWORD PTR __Oldlen$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
	push	eax
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2229 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy

; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
	mov	ecx, eax
	call	??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>

; 2231 : 		this->_Myres = _Newres;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [ecx+20], edx

; 2232 : 		_Eos(_Oldlen);

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos
$LN11@Copy:

; 2233 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Inside, COMDAT
; _this$ = ecx

; 2256 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	lea	eax, DWORD PTR [eax+edx*2]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2259 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2260 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2261 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2262 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen, COMDAT
; _this$ = ecx

; 2289 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2290 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 2291 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ PROC ; std::allocator<wchar_t>::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 532  : 		{	// return this allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 533  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$allocator@_W@std@@QAE@ABV01@@Z	; std::allocator<wchar_t>::allocator<wchar_t>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 534  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ ENDP ; std::allocator<wchar_t>::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??0?$allocator@_W@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@_W@std@@QAE@ABV01@@Z PROC		; std::allocator<wchar_t>::allocator<wchar_t>, COMDAT
; _this$ = ecx

; 556  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 557  : 		{	// construct by copying (do nothing)
; 558  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@_W@std@@QAE@ABV01@@Z ENDP		; std::allocator<wchar_t>::allocator<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z PROC	; std::allocator<wchar_t>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 573  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 574  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z ENDP	; std::allocator<wchar_t>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator@PAX@std@@QBE?AV12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?select_on_container_copy_construction@?$allocator@PAX@std@@QBE?AV12@XZ PROC ; std::allocator<void *>::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 532  : 		{	// return this allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 533  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$allocator@PAX@std@@QAE@ABV01@@Z	; std::allocator<void *>::allocator<void *>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 534  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?select_on_container_copy_construction@?$allocator@PAX@std@@QBE?AV12@XZ ENDP ; std::allocator<void *>::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAX@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAX@std@@QAE@ABV01@@Z PROC		; std::allocator<void *>::allocator<void *>, COMDAT
; _this$ = ecx

; 556  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 557  : 		{	// construct by copying (do nothing)
; 558  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@PAX@std@@QAE@ABV01@@Z ENDP		; std::allocator<void *>::allocator<void *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAX@std@@QAEPAPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAX@std@@QAEPAPAXI@Z PROC		; std::allocator<void *>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 578  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAX@std@@YAPAPAXIPAPAX@Z	; std::_Allocate<void *>
	add	esp, 8

; 579  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAX@std@@QAEPAPAXI@Z ENDP		; std::allocator<void *>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<void *> >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 884  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@PAX@std@@@std@@SAIABV?$allocator@PAX@2@@Z ; std::allocator_traits<std::allocator<void *> >::max_size
	add	esp, 4

; 885  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<void *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 847  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate

; 848  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 884  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z ; std::allocator_traits<std::allocator<wchar_t> >::max_size
	add	esp, 4

; 885  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@PAX@std@@@std@@SAIABV?$allocator@PAX@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@PAX@std@@@std@@SAIABV?$allocator@PAX@2@@Z PROC ; std::allocator_traits<std::allocator<void *> >::max_size, COMDAT

; 734  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 735  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@PAX@std@@QBEIXZ	; std::allocator<void *>::max_size

; 736  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@PAX@std@@@std@@SAIABV?$allocator@PAX@2@@Z ENDP ; std::allocator_traits<std::allocator<void *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@_W@std@@QAEPA_WI@Z PROC		; std::allocator<wchar_t>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 578  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@_W@std@@YAPA_WIPA_W@Z	; std::_Allocate<wchar_t>
	add	esp, 8

; 579  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@_W@std@@QAEPA_WI@Z ENDP		; std::allocator<wchar_t>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z PROC ; std::allocator_traits<std::allocator<wchar_t> >::max_size, COMDAT

; 734  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 735  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@_W@std@@QBEIXZ	; std::allocator<wchar_t>::max_size

; 736  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z ENDP ; std::allocator_traits<std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@PAX@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@PAX@std@@QBEIXZ PROC		; std::allocator<void *>::max_size, COMDAT
; _this$ = ecx

; 611  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 1073741823				; 3fffffffH

; 613  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PAX@std@@QBEIXZ ENDP		; std::allocator<void *>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@_W@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@_W@std@@QBEIXZ PROC		; std::allocator<wchar_t>::max_size, COMDAT
; _this$ = ecx

; 611  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 2147483647				; 7fffffffH

; 613  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@_W@std@@QBEIXZ ENDP		; std::allocator<wchar_t>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$move@AAUsafe_handle@@@std@@YA$$QAUsafe_handle@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUsafe_handle@@@std@@YA$$QAUsafe_handle@@AAU1@@Z PROC ; std::move<safe_handle &>, COMDAT

; 1519 : 	{	// forward _Arg as movable

	push	ebp
	mov	ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

	pop	ebp
	ret	0
??$move@AAUsafe_handle@@@std@@YA$$QAUsafe_handle@@AAU1@@Z ENDP ; std::move<safe_handle &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\utilities.h
;	COMDAT ??$zero@U_PROCESS_INFORMATION@@@@YAXAAU_PROCESS_INFORMATION@@I@Z
_TEXT	SEGMENT
_t$ = 8							; size = 4
_size$ = 12						; size = 4
??$zero@U_PROCESS_INFORMATION@@@@YAXAAU_PROCESS_INFORMATION@@I@Z PROC ; zero<_PROCESS_INFORMATION>, COMDAT

; 25   : {

	push	ebp
	mov	ebp, esp

; 26   :     memset(&t, 0, size);

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 27   : }

	pop	ebp
	ret	0
??$zero@U_PROCESS_INFORMATION@@@@YAXAAU_PROCESS_INFORMATION@@I@Z ENDP ; zero<_PROCESS_INFORMATION>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\utilities.h
;	COMDAT ??$zero@U_STARTUPINFOW@@@@YAXAAU_STARTUPINFOW@@I@Z
_TEXT	SEGMENT
_t$ = 8							; size = 4
_size$ = 12						; size = 4
??$zero@U_STARTUPINFOW@@@@YAXAAU_STARTUPINFOW@@I@Z PROC	; zero<_STARTUPINFOW>, COMDAT

; 25   : {

	push	ebp
	mov	ebp, esp

; 26   :     memset(&t, 0, size);

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 27   : }

	pop	ebp
	ret	0
??$zero@U_STARTUPINFOW@@@@YAXAAU_STARTUPINFOW@@I@Z ENDP	; zero<_STARTUPINFOW>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z PROC ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2518 : 	{	// test for string vs. NTCS inequality

	push	ebp
	mov	ebp, esp
	push	ecx

; 2519 : 	return (!(_Left == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	push	ecx
	call	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 2520 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ENDP ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\utilities.h
;	COMDAT ??$saturate@GH@@YAGH@Z
_TEXT	SEGMENT
_val$ = 8						; size = 4
??$saturate@GH@@YAGH@Z PROC				; saturate<unsigned short,int>, COMDAT

; 38   : {

	push	ebp
	mov	ebp, esp

; 39   :     if (val > std::numeric_limits<T>::max())

	call	?max@?$numeric_limits@G@std@@SAGXZ	; std::numeric_limits<unsigned short>::max
	movzx	eax, ax
	cmp	DWORD PTR _val$[ebp], eax
	jle	SHORT $LN2@saturate

; 40   :         return std::numeric_limits<T>::max();

	call	?max@?$numeric_limits@G@std@@SAGXZ	; std::numeric_limits<unsigned short>::max
	jmp	SHORT $LN3@saturate
$LN2@saturate:

; 41   :     if (val < std::numeric_limits<T>::min())

	call	?min@?$numeric_limits@G@std@@SAGXZ	; std::numeric_limits<unsigned short>::min
	movzx	ecx, ax
	cmp	DWORD PTR _val$[ebp], ecx
	jge	SHORT $LN1@saturate

; 42   :         return std::numeric_limits<T>::min();

	call	?min@?$numeric_limits@G@std@@SAGXZ	; std::numeric_limits<unsigned short>::min
	jmp	SHORT $LN3@saturate
$LN1@saturate:

; 43   :     return val;

	mov	ax, WORD PTR _val$[ebp]
$LN3@saturate:

; 44   : }

	pop	ebp
	ret	0
??$saturate@GH@@YAGH@Z ENDP				; saturate<unsigned short,int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ??$ThrowQSVInitError@$$$V@?A0x7e09c670@@YAXPB_W0@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
_message$ = 8						; size = 4
_localized_message$ = 12				; size = 4
??$ThrowQSVInitError@$$$V@?A0x7e09c670@@YAXPB_W0@Z PROC	; `anonymous namespace'::ThrowQSVInitError<>, COMDAT

; 330  :     {

	push	ebp
	mov	ebp, esp
	push	ecx

; 331  :         AppWarning(message, ts...);

	mov	eax, DWORD PTR _message$[ebp]
	push	eax
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 4

; 332  :         throw localized_message;

	mov	ecx, DWORD PTR _localized_message$[ebp]
	mov	DWORD PTR $T1[ebp], ecx
	push	OFFSET __TI2CPA_W
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	__CxxThrowException@8
$LN2@ThrowQSVIn:

; 333  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
??$ThrowQSVInitError@$$$V@?A0x7e09c670@@YAXPB_W0@Z ENDP	; `anonymous namespace'::ThrowQSVInitError<>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ??$ThrowQSVInitError@K@?A0x7e09c670@@YAXPB_W0K@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
_message$ = 8						; size = 4
_localized_message$ = 12				; size = 4
_<ts_0>$ = 16						; size = 4
??$ThrowQSVInitError@K@?A0x7e09c670@@YAXPB_W0K@Z PROC	; `anonymous namespace'::ThrowQSVInitError<unsigned long>, COMDAT

; 330  :     {

	push	ebp
	mov	ebp, esp
	push	ecx

; 331  :         AppWarning(message, ts...);

	mov	eax, DWORD PTR _<ts_0>$[ebp]
	push	eax
	mov	ecx, DWORD PTR _message$[ebp]
	push	ecx
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 8

; 332  :         throw localized_message;

	mov	edx, DWORD PTR _localized_message$[ebp]
	mov	DWORD PTR $T1[ebp], edx
	push	OFFSET __TI2CPA_W
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@ThrowQSVIn:

; 333  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
??$ThrowQSVInitError@K@?A0x7e09c670@@YAXPB_W0K@Z ENDP	; `anonymous namespace'::ThrowQSVInitError<unsigned long>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\utilities.h
;	COMDAT ??$clamp@HHH@@YAHHHH@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
_t$ = 8							; size = 4
_u$ = 12						; size = 4
_v$ = 16						; size = 4
??$clamp@HHH@@YAHHHH@Z PROC				; clamp<int,int,int>, COMDAT

; 59   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 60   :     if (t < u)

	mov	eax, DWORD PTR _t$[ebp]
	cmp	eax, DWORD PTR _u$[ebp]
	jge	SHORT $LN1@clamp

; 61   :         return u;

	mov	eax, DWORD PTR _u$[ebp]
	jmp	SHORT $LN2@clamp
$LN1@clamp:

; 62   :     return t > v ? v : t;

	mov	ecx, DWORD PTR _t$[ebp]
	cmp	ecx, DWORD PTR _v$[ebp]
	jle	SHORT $LN4@clamp
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR tv66[ebp], edx
	jmp	SHORT $LN5@clamp
$LN4@clamp:
	mov	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR tv66[ebp], eax
$LN5@clamp:
	mov	eax, DWORD PTR tv66[ebp]
$LN2@clamp:

; 63   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$clamp@HHH@@YAHHHH@Z ENDP				; clamp<int,int,int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\utilities.h
;	COMDAT ??$clamp@GHH@@YAGGHH@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
_t$ = 8							; size = 2
_u$ = 12						; size = 4
_v$ = 16						; size = 4
??$clamp@GHH@@YAGGHH@Z PROC				; clamp<unsigned short,int,int>, COMDAT

; 59   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 60   :     if (t < u)

	movzx	eax, WORD PTR _t$[ebp]
	cmp	eax, DWORD PTR _u$[ebp]
	jge	SHORT $LN1@clamp

; 61   :         return u;

	mov	ax, WORD PTR _u$[ebp]
	jmp	SHORT $LN2@clamp
$LN1@clamp:

; 62   :     return t > v ? v : t;

	movzx	ecx, WORD PTR _t$[ebp]
	cmp	ecx, DWORD PTR _v$[ebp]
	jle	SHORT $LN4@clamp
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR tv69[ebp], edx
	jmp	SHORT $LN5@clamp
$LN4@clamp:
	movzx	eax, WORD PTR _t$[ebp]
	mov	DWORD PTR tv69[ebp], eax
$LN5@clamp:
	mov	ax, WORD PTR tv69[ebp]
$LN2@clamp:

; 63   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$clamp@GHH@@YAGGHH@Z ENDP				; clamp<unsigned short,int,int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xutility
;	COMDAT ??$begin@PB_W$08@std@@YAPAPB_WAAY08PB_W@Z
_TEXT	SEGMENT
__Array$ = 8						; size = 4
??$begin@PB_W$08@std@@YAPAPB_WAAY08PB_W@Z PROC		; std::begin<wchar_t const *,9>, COMDAT

; 1214 : 	{	// get beginning of array

	push	ebp
	mov	ebp, esp

; 1215 : 	return (_Array);

	mov	eax, DWORD PTR __Array$[ebp]

; 1216 : 	}

	pop	ebp
	ret	0
??$begin@PB_W$08@std@@YAPAPB_WAAY08PB_W@Z ENDP		; std::begin<wchar_t const *,9>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xutility
;	COMDAT ??$end@PB_W$08@std@@YAPAPB_WAAY08PB_W@Z
_TEXT	SEGMENT
__Array$ = 8						; size = 4
??$end@PB_W$08@std@@YAPAPB_WAAY08PB_W@Z PROC		; std::end<wchar_t const *,9>, COMDAT

; 1221 : 	{	// get end of array

	push	ebp
	mov	ebp, esp

; 1222 : 	return (_Array + _Size);

	mov	eax, DWORD PTR __Array$[ebp]
	add	eax, 36					; 00000024H

; 1223 : 	}

	pop	ebp
	ret	0
??$end@PB_W$08@std@@YAPAPB_WAAY08PB_W@Z ENDP		; std::end<wchar_t const *,9>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xutility
;	COMDAT ??$distance@PAPB_W@std@@YAHPAPB_W0@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$distance@PAPB_W@std@@YAHPAPB_W0@Z PROC		; std::distance<wchar_t const * *>, COMDAT

; 756  : 	{	// return distance between iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 757  : 	typename iterator_traits<_InIt>::difference_type _Off = 0;

	mov	DWORD PTR __Off$[ebp], 0

; 758  : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??$_Iter_cat@PAPB_W@std@@YA?AUrandom_access_iterator_tag@0@ABQAPB_W@Z ; std::_Iter_cat<wchar_t const * *>
	add	esp, 8
	mov	dl, BYTE PTR [eax]
	movzx	eax, dl
	push	eax
	lea	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Distance2@PAPB_WH@std@@YAXPAPB_W0AAHUrandom_access_iterator_tag@0@@Z ; std::_Distance2<wchar_t const * *,int>
	add	esp, 16					; 00000010H

; 759  : 	return (_Off);

	mov	eax, DWORD PTR __Off$[ebp]

; 760  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$distance@PAPB_W@std@@YAHPAPB_W0@Z ENDP		; std::distance<wchar_t const * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\utilities.h
;	COMDAT ??$zero@UmfxFrameSurface1@@@@YAXAAUmfxFrameSurface1@@I@Z
_TEXT	SEGMENT
_t$ = 8							; size = 4
_size$ = 12						; size = 4
??$zero@UmfxFrameSurface1@@@@YAXAAUmfxFrameSurface1@@I@Z PROC ; zero<mfxFrameSurface1>, COMDAT

; 25   : {

	push	ebp
	mov	ebp, esp

; 26   :     memset(&t, 0, size);

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 27   : }

	pop	ebp
	ret	0
??$zero@UmfxFrameSurface1@@@@YAXAAUmfxFrameSurface1@@I@Z ENDP ; zero<mfxFrameSurface1>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\utilities.h
;	COMDAT ??$zero@UmfxBitstream@@@@YAXAAUmfxBitstream@@I@Z
_TEXT	SEGMENT
_t$ = 8							; size = 4
_size$ = 12						; size = 4
??$zero@UmfxBitstream@@@@YAXAAUmfxBitstream@@I@Z PROC	; zero<mfxBitstream>, COMDAT

; 25   : {

	push	ebp
	mov	ebp, esp

; 26   :     memset(&t, 0, size);

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 27   : }

	pop	ebp
	ret	0
??$zero@UmfxBitstream@@@@YAXAAUmfxBitstream@@I@Z ENDP	; zero<mfxBitstream>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\utilities.h
;	COMDAT ??$zero@UmfxFrameData@@@@YAXAAUmfxFrameData@@I@Z
_TEXT	SEGMENT
_t$ = 8							; size = 4
_size$ = 12						; size = 4
??$zero@UmfxFrameData@@@@YAXAAUmfxFrameData@@I@Z PROC	; zero<mfxFrameData>, COMDAT

; 25   : {

	push	ebp
	mov	ebp, esp

; 26   :     memset(&t, 0, size);

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 27   : }

	pop	ebp
	ret	0
??$zero@UmfxFrameData@@@@YAXAAUmfxFrameData@@I@Z ENDP	; zero<mfxFrameData>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??$lock_mutex@U?$IPCLockedSignalledType@H@@@@YA?AU?$IPCMutexLock@U?$IPCLockedSignalledType@H@@@@AAU?$IPCLockedSignalledType@H@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_t$ = 12						; size = 4
??$lock_mutex@U?$IPCLockedSignalledType@H@@@@YA?AU?$IPCMutexLock@U?$IPCLockedSignalledType@H@@@@AAU?$IPCLockedSignalledType@H@@@Z PROC ; lock_mutex<IPCLockedSignalledType<int> >, COMDAT

; 143  : IPCMutexLock<T> lock_mutex(T &t) { return IPCMutexLock<T>(t); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$IPCMutexLock@U?$IPCLockedSignalledType@H@@@@QAE@AAU?$IPCLockedSignalledType@H@@@Z ; IPCMutexLock<IPCLockedSignalledType<int> >::IPCMutexLock<IPCLockedSignalledType<int> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	ebp
	ret	0
??$lock_mutex@U?$IPCLockedSignalledType@H@@@@YA?AU?$IPCMutexLock@U?$IPCLockedSignalledType@H@@@@AAU?$IPCLockedSignalledType@H@@@Z ENDP ; lock_mutex<IPCLockedSignalledType<int> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\algorithm
;	COMDAT ??$search@PAEPBE@std@@YAPAEPAE0PBE1@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
??$search@PAEPBE@std@@YAPAEPAE0PBE1@Z PROC		; std::search<unsigned char *,unsigned char const *>, COMDAT

; 654  : 	{	// find first [_First2, _Last2) match

	push	ebp
	mov	ebp, esp
	push	ecx

; 655  : 	return (_STD search(_First1, _Last1, _First2, _Last2,
; 656  : 		equal_to<>()));

	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	movzx	ecx, BYTE PTR $T1[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First2$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last1$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	call	??$search@PAEPBEU?$equal_to@X@std@@@std@@YAPAEPAE0PBE1U?$equal_to@X@0@@Z ; std::search<unsigned char *,unsigned char const *,std::equal_to<void> >
	add	esp, 20					; 00000014H

; 657  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$search@PAEPBE@std@@YAPAEPAE0PBE1@Z ENDP		; std::search<unsigned char *,unsigned char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ??$msFromTimestamp@_J@?A0x7e09c670@@YA_J_J@Z
_TEXT	SEGMENT
_t$ = 8							; size = 8
??$msFromTimestamp@_J@?A0x7e09c670@@YA_J_J@Z PROC	; `anonymous namespace'::msFromTimestamp<__int64>, COMDAT

; 141  :     {

	push	ebp
	mov	ebp, esp

; 142  :         return t/MFX_TIME_FACTOR;

	push	0
	push	90					; 0000005aH
	mov	eax, DWORD PTR _t$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	__alldiv

; 143  :     }

	pop	ebp
	ret	0
??$msFromTimestamp@_J@?A0x7e09c670@@YA_J_J@Z ENDP	; `anonymous namespace'::msFromTimestamp<__int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ??$msFromTimestamp@_K@?A0x7e09c670@@YA_K_K@Z
_TEXT	SEGMENT
_t$ = 8							; size = 8
??$msFromTimestamp@_K@?A0x7e09c670@@YA_K_K@Z PROC	; `anonymous namespace'::msFromTimestamp<unsigned __int64>, COMDAT

; 141  :     {

	push	ebp
	mov	ebp, esp

; 142  :         return t/MFX_TIME_FACTOR;

	push	0
	push	90					; 0000005aH
	mov	eax, DWORD PTR _t$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	__aulldiv

; 143  :     }

	pop	ebp
	ret	0
??$msFromTimestamp@_K@?A0x7e09c670@@YA_K_K@Z ENDP	; `anonymous namespace'::msFromTimestamp<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\algorithm
;	COMDAT ??$find_if_not@PAEV<lambda_4f23e6955dca7f806ec2428e9267999f>@@@std@@YAPAEPAE0V<lambda_4f23e6955dca7f806ec2428e9267999f>@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$find_if_not@PAEV<lambda_4f23e6955dca7f806ec2428e9267999f>@@@std@@YAPAEPAE0V<lambda_4f23e6955dca7f806ec2428e9267999f>@@@Z PROC ; std::find_if_not<unsigned char *,<lambda_4f23e6955dca7f806ec2428e9267999f> >, COMDAT

; 300  : 	{	// find first element that satisfies !_Pred

	push	ebp
	mov	ebp, esp

; 301  : 	_DEBUG_RANGE(_First, _Last);
; 302  : 	_DEBUG_POINTER(_Pred);
; 303  : 	return (_Rechecked(_First,
; 304  : 		_Find_if_not(_Unchecked(_First), _Unchecked(_Last), _Pred)));

	movzx	eax, BYTE PTR __Pred$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Unchecked@PAE@std@@YAPAEPAE@Z	; std::_Unchecked<unsigned char *>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Unchecked@PAE@std@@YAPAEPAE@Z	; std::_Unchecked<unsigned char *>
	add	esp, 4
	push	eax
	call	??$_Find_if_not@PAEV<lambda_4f23e6955dca7f806ec2428e9267999f>@@@std@@YAPAEPAE0V<lambda_4f23e6955dca7f806ec2428e9267999f>@@@Z ; std::_Find_if_not<unsigned char *,<lambda_4f23e6955dca7f806ec2428e9267999f> >
	add	esp, 12					; 0000000cH
	push	eax
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Rechecked@PAEPAE@std@@YAAAPAEAAPAEPAE@Z ; std::_Rechecked<unsigned char *,unsigned char *>
	add	esp, 8
	mov	eax, DWORD PTR [eax]

; 305  : 	}

	pop	ebp
	ret	0
??$find_if_not@PAEV<lambda_4f23e6955dca7f806ec2428e9267999f>@@@std@@YAPAEPAE0V<lambda_4f23e6955dca7f806ec2428e9267999f>@@@Z ENDP ; std::find_if_not<unsigned char *,<lambda_4f23e6955dca7f806ec2428e9267999f> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??$lock_mutex@U?$IPCLockedSignalledArray@I@@@@YA?AU?$IPCMutexLock@U?$IPCLockedSignalledArray@I@@@@AAU?$IPCLockedSignalledArray@I@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_t$ = 12						; size = 4
??$lock_mutex@U?$IPCLockedSignalledArray@I@@@@YA?AU?$IPCMutexLock@U?$IPCLockedSignalledArray@I@@@@AAU?$IPCLockedSignalledArray@I@@@Z PROC ; lock_mutex<IPCLockedSignalledArray<unsigned int> >, COMDAT

; 143  : IPCMutexLock<T> lock_mutex(T &t) { return IPCMutexLock<T>(t); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$IPCMutexLock@U?$IPCLockedSignalledArray@I@@@@QAE@AAU?$IPCLockedSignalledArray@I@@@Z ; IPCMutexLock<IPCLockedSignalledArray<unsigned int> >::IPCMutexLock<IPCLockedSignalledArray<unsigned int> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	ebp
	ret	0
??$lock_mutex@U?$IPCLockedSignalledArray@I@@@@YA?AU?$IPCMutexLock@U?$IPCLockedSignalledArray@I@@@@AAU?$IPCLockedSignalledArray@I@@@Z ENDP ; lock_mutex<IPCLockedSignalledArray<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??$lock_mutex@U?$IPCLockedSignalledArray@Uqueued_frame@@@@@@YA?AU?$IPCMutexLock@U?$IPCLockedSignalledArray@Uqueued_frame@@@@@@AAU?$IPCLockedSignalledArray@Uqueued_frame@@@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_t$ = 12						; size = 4
??$lock_mutex@U?$IPCLockedSignalledArray@Uqueued_frame@@@@@@YA?AU?$IPCMutexLock@U?$IPCLockedSignalledArray@Uqueued_frame@@@@@@AAU?$IPCLockedSignalledArray@Uqueued_frame@@@@@Z PROC ; lock_mutex<IPCLockedSignalledArray<queued_frame> >, COMDAT

; 143  : IPCMutexLock<T> lock_mutex(T &t) { return IPCMutexLock<T>(t); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$IPCMutexLock@U?$IPCLockedSignalledArray@Uqueued_frame@@@@@@QAE@AAU?$IPCLockedSignalledArray@Uqueued_frame@@@@@Z ; IPCMutexLock<IPCLockedSignalledArray<queued_frame> >::IPCMutexLock<IPCLockedSignalledArray<queued_frame> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	ebp
	ret	0
??$lock_mutex@U?$IPCLockedSignalledArray@Uqueued_frame@@@@@@YA?AU?$IPCMutexLock@U?$IPCLockedSignalledArray@Uqueued_frame@@@@@@AAU?$IPCLockedSignalledArray@Uqueued_frame@@@@@Z ENDP ; lock_mutex<IPCLockedSignalledArray<queued_frame> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ??$timestampFromMS@K@?A0x7e09c670@@YAKK@Z
_TEXT	SEGMENT
_t$ = 8							; size = 4
??$timestampFromMS@K@?A0x7e09c670@@YAKK@Z PROC		; `anonymous namespace'::timestampFromMS<unsigned long>, COMDAT

; 135  :     {

	push	ebp
	mov	ebp, esp

; 136  :         return t*MFX_TIME_FACTOR;

	imul	eax, DWORD PTR _t$[ebp], 90

; 137  :     }

	pop	ebp
	ret	0
??$timestampFromMS@K@?A0x7e09c670@@YAKK@Z ENDP		; `anonymous namespace'::timestampFromMS<unsigned long>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\encoder_qsv.cpp
;	COMDAT ??$timestampFromMS@_K@?A0x7e09c670@@YA_K_K@Z
_TEXT	SEGMENT
_t$ = 8							; size = 8
??$timestampFromMS@_K@?A0x7e09c670@@YA_K_K@Z PROC	; `anonymous namespace'::timestampFromMS<unsigned __int64>, COMDAT

; 135  :     {

	push	ebp
	mov	ebp, esp

; 136  :         return t*MFX_TIME_FACTOR;

	push	0
	push	90					; 0000005aH
	mov	eax, DWORD PTR _t$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	__allmul

; 137  :     }

	pop	ebp
	ret	0
??$timestampFromMS@_K@?A0x7e09c670@@YA_K_K@Z ENDP	; `anonymous namespace'::timestampFromMS<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z PROC ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ENDP ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z PROC ; std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 900  : 	{	// test for allocator inequality

	push	ebp
	mov	ebp, esp
	push	ecx

; 901  : 	return (!(_Left == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	push	ecx
	call	??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ; std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t> >
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 902  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ENDP ; std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@std@@@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEPAPAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@1@0PAPAX@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Alval$ = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@std@@@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEPAPAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@1@0PAPAX@Z PROC ; std::vector<void *,std::allocator<void *> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<void *> > > >, COMDAT
; _this$ = ecx

; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());

	lea	eax, DWORD PTR __Alval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAX@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<void *,std::allocator<void *> > >::_Getal

; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));

	lea	ecx, DWORD PTR __Alval$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@std@@PAPAXU?$_Wrap_alloc@V?$allocator@PAX@std@@@2@@std@@YAPAPAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@0@0PAPAXAAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@@Z ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<void *> > >,void * *,std::_Wrap_alloc<std::allocator<void *> > >
	add	esp, 16					; 00000010H

; 1641 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@std@@@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEPAPAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@1@0PAPAX@Z ENDP ; std::vector<void *,std::allocator<void *> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<void *> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$?9V?$allocator@PAX@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@0@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9V?$allocator@PAX@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@0@Z PROC ; std::operator!=<std::allocator<void *>,std::allocator<void *> >, COMDAT

; 900  : 	{	// test for allocator inequality

	push	ebp
	mov	ebp, esp
	push	ecx

; 901  : 	return (!(_Left == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	push	ecx
	call	??$?8V?$allocator@PAX@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@0@Z ; std::operator==<std::allocator<void *>,std::allocator<void *> >
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 902  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$?9V?$allocator@PAX@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@0@Z ENDP ; std::operator!=<std::allocator<void *>,std::allocator<void *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xutility
;	COMDAT ??$_Copy_impl@PAPAXPAPAX@std@@YAPAPAXPAPAX00@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_impl@PAPAXPAPAX@std@@YAPAPAXPAPAX00@Z PROC	; std::_Copy_impl<void * *,void * *>, COMDAT

; 2064 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 2065 : 	return (_Copy_impl(_First, _Last,
; 2066 : 		_Dest, _Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAXPAX@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAX0@Z ; std::_Ptr_cat<void *,void *>
	add	esp, 8
	mov	BYTE PTR $T1[ebp], al
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_impl@PAPAXPAPAX@std@@YAPAPAXPAPAX00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_impl<void * *,void * *>
	add	esp, 16					; 00000010H

; 2067 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_impl@PAPAXPAPAX@std@@YAPAPAXPAPAX00@Z ENDP	; std::_Copy_impl<void * *,void * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ??$_Ucopy@PAPAX@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEPAPAXPAPAX00@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Alval$ = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAPAX@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEPAPAXPAPAX00@Z PROC ; std::vector<void *,std::allocator<void *> >::_Ucopy<void * *>, COMDAT
; _this$ = ecx

; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());

	lea	eax, DWORD PTR __Alval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAX@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<void *,std::allocator<void *> > >::_Getal

; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));

	lea	ecx, DWORD PTR __Alval$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninitialized_copy@PAPAXPAPAXU?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@@std@@YAPAPAXPAPAX00AAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@@Z ; std::_Uninitialized_copy<void * *,void * *,std::_Wrap_alloc<std::allocator<void *> > >
	add	esp, 16					; 00000010H

; 1641 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAPAX@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEPAPAXPAPAX00@Z ENDP ; std::vector<void *,std::allocator<void *> >::_Ucopy<void * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstddef
;	COMDAT ??$addressof@QAX@std@@YAPBQAXABQAX@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@QAX@std@@YAPBQAXABQAX@Z PROC		; std::addressof<void * const>, COMDAT

; 92   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 96   : 	}

	pop	ebp
	ret	0
??$addressof@QAX@std@@YAPBQAXABQAX@Z ENDP		; std::addressof<void * const>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$construct@PAXAAPAX@?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QAEXPAPAXAAPAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAXAAPAX@?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QAEXPAPAXAAPAX@Z PROC ; std::_Wrap_alloc<std::allocator<void *> >::construct<void *,void * &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@AAPAX@std@@YAAAPAXAAPAX@Z	; std::forward<void * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PAXAAPAX@?$allocator_traits@V?$allocator@PAX@std@@@std@@SAXAAV?$allocator@PAX@1@PAPAXAAPAX@Z ; std::allocator_traits<std::allocator<void *> >::construct<void *,void * &>
	add	esp, 12					; 0000000cH

; 873  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PAXAAPAX@?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QAEXPAPAXAAPAX@Z ENDP ; std::_Wrap_alloc<std::allocator<void *> >::construct<void *,void * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$construct@PAXABQAX@?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QAEXPAPAXABQAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAXABQAX@?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QAEXPAPAXABQAX@Z PROC ; std::_Wrap_alloc<std::allocator<void *> >::construct<void *,void * const &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@ABQAX@std@@YAABQAXABQAX@Z	; std::forward<void * const &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PAXABQAX@?$allocator_traits@V?$allocator@PAX@std@@@std@@SAXAAV?$allocator@PAX@1@PAPAXABQAX@Z ; std::allocator_traits<std::allocator<void *> >::construct<void *,void * const &>
	add	esp, 12					; 0000000cH

; 873  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PAXABQAX@?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QAEXPAPAXABQAX@Z ENDP ; std::_Wrap_alloc<std::allocator<void *> >::construct<void *,void * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z
_TEXT	SEGMENT
__Ans$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z PROC ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 2366 : 	{	// return string + NTCS

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 2367 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;

	lea	ecx, DWORD PTR __Ans$[ebp]
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >

; 2368 : 	_Ans.reserve(_Left.size() + _Traits::length(_Right));

	mov	ecx, DWORD PTR __Left$[ebp]
	call	?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size
	mov	esi, eax
	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	call	?length@?$char_traits@_W@std@@SAIPB_W@Z	; std::char_traits<wchar_t>::length
	add	esp, 4
	add	esi, eax
	push	esi
	lea	ecx, DWORD PTR __Ans$[ebp]
	call	?reserve@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::reserve

; 2369 : 	_Ans += _Left;

	mov	ecx, DWORD PTR __Left$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Ans$[ebp]
	call	??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator+=

; 2370 : 	_Ans += _Right;

	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Ans$[ebp]
	call	??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator+=

; 2371 : 	return (_Ans);

	lea	eax, DWORD PTR __Ans$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	lea	ecx, DWORD PTR __Ans$[ebp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2372 : 	}

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??$as@Uinit_request@@@NamedSharedMemory@@QAEAAUinit_request@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$as@Uinit_request@@@NamedSharedMemory@@QAEAAUinit_request@@XZ PROC ; NamedSharedMemory::as<init_request>, COMDAT
; _this$ = ecx

; 62   :     T &as() { return *reinterpret_cast<T*>(memory); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+32]
	mov	esp, ebp
	pop	ebp
	ret	0
??$as@Uinit_request@@@NamedSharedMemory@@QAEAAUinit_request@@XZ ENDP ; NamedSharedMemory::as<init_request>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$move@AAUNamedSharedMemory@@@std@@YA$$QAUNamedSharedMemory@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUNamedSharedMemory@@@std@@YA$$QAUNamedSharedMemory@@AAU1@@Z PROC ; std::move<NamedSharedMemory &>, COMDAT

; 1519 : 	{	// forward _Arg as movable

	push	ebp
	mov	ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

	pop	ebp
	ret	0
??$move@AAUNamedSharedMemory@@@std@@YA$$QAUNamedSharedMemory@@AAU1@@Z ENDP ; std::move<NamedSharedMemory &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??$as@H@NamedSharedMemory@@QAEAAHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$as@H@NamedSharedMemory@@QAEAAHXZ PROC		; NamedSharedMemory::as<int>, COMDAT
; _this$ = ecx

; 62   :     T &as() { return *reinterpret_cast<T*>(memory); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+32]
	mov	esp, ebp
	pop	ebp
	ret	0
??$as@H@NamedSharedMemory@@QAEAAHXZ ENDP		; NamedSharedMemory::as<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??$as@Uinit_response@@@NamedSharedMemory@@QAEAAUinit_response@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$as@Uinit_response@@@NamedSharedMemory@@QAEAAUinit_response@@XZ PROC ; NamedSharedMemory::as<init_response>, COMDAT
; _this$ = ecx

; 62   :     T &as() { return *reinterpret_cast<T*>(memory); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+32]
	mov	esp, ebp
	pop	ebp
	ret	0
??$as@Uinit_response@@@NamedSharedMemory@@QAEAAUinit_response@@XZ ENDP ; NamedSharedMemory::as<init_response>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??$as@Uspspps_size@@@NamedSharedMemory@@QAEAAUspspps_size@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$as@Uspspps_size@@@NamedSharedMemory@@QAEAAUspspps_size@@XZ PROC ; NamedSharedMemory::as<spspps_size>, COMDAT
; _this$ = ecx

; 62   :     T &as() { return *reinterpret_cast<T*>(memory); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+32]
	mov	esp, ebp
	pop	ebp
	ret	0
??$as@Uspspps_size@@@NamedSharedMemory@@QAEAAUspspps_size@@XZ ENDP ; NamedSharedMemory::as<spspps_size>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z	; std::forward<wchar_t * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>
	add	esp, 12					; 0000000cH

; 873  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::destroy<wchar_t *>, COMDAT
; _this$ = ecx

; 877  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t> >::destroy<wchar_t *>
	add	esp, 8

; 880  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::destroy<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstddef
;	COMDAT ??$addressof@_W@std@@YAPA_WAA_W@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@_W@std@@YAPA_WAA_W@Z PROC			; std::addressof<wchar_t>, COMDAT

; 92   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 96   : 	}

	pop	ebp
	ret	0
??$addressof@_W@std@@YAPA_WAA_W@Z ENDP			; std::addressof<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@@std@@YAXPAPAX0AAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@@std@@YAXPAPAX0AAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<void *> > >, COMDAT

; 95   : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAXPAX@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAX0@Z ; std::_Ptr_cat<void *,void *>
	add	esp, 8
	mov	BYTE PTR $T1[ebp], al
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@@std@@YAXPAPAX0AAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<void *> > >
	add	esp, 16					; 00000010H

; 97   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@@std@@YAXPAPAX0AAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ??$_Umove@PAPAX@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEPAPAXPAPAX00@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Alval$ = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAX@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEPAPAXPAPAX00@Z PROC ; std::vector<void *,std::allocator<void *> >::_Umove<void * *>, COMDAT
; _this$ = ecx

; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());

	lea	eax, DWORD PTR __Alval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAX@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<void *,std::allocator<void *> > >::_Getal

; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));

	lea	ecx, DWORD PTR __Alval$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninitialized_move@PAPAXPAPAXU?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@@std@@YAPAPAXPAPAX00AAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@@Z ; std::_Uninitialized_move<void * *,void * *,std::_Wrap_alloc<std::allocator<void *> > >
	add	esp, 16					; 00000010H

; 1649 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAPAX@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEPAPAXPAPAX00@Z ENDP ; std::vector<void *,std::allocator<void *> >::_Umove<void * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$_Allocate@PAX@std@@YAPAPAXIPAPAX@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAX@std@@YAPAPAXIPAPAX@Z PROC		; std::_Allocate<void *>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAX@std@@YAPAPAXIPAPAX@Z ENDP		; std::_Allocate<void *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@_W@std@@YAPA_WIPA_W@Z PROC			; std::_Allocate<wchar_t>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], 2147483647	; 7fffffffH
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 1
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@_W@std@@YAPA_WIPA_W@Z ENDP			; std::_Allocate<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator+=, COMDAT
; _this$ = ecx

; 1023 : 		{	// append _Right

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1024 : 		return (append(_Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append

; 1025 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator+=, COMDAT
; _this$ = ecx

; 1028 : 		{	// append [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		return (append(_Ptr));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append

; 1030 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?reserve@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Size$1 = -8						; size = 4
_this$ = -4						; size = 4
__Newcap$ = 8						; size = 4
?reserve@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::reserve, COMDAT
; _this$ = ecx

; 1782 : 		{	// determine new minimum length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Newcap$[ebp]
	ja	SHORT $LN3@reserve
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	cmp	eax, DWORD PTR __Newcap$[ebp]
	je	SHORT $LN3@reserve

; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR __Size$1[ebp], edx

; 1786 : 			if (_Grow(_Newcap, true))

	push	1
	mov	eax, DWORD PTR __Newcap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@reserve

; 1787 : 				_Eos(_Size);

	mov	edx, DWORD PTR __Size$1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos
$LN3@reserve:

; 1788 : 			}
; 1789 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?reserve@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??0?$IPCMutexLock@U?$IPCLockedSignalledType@H@@@@QAE@AAU?$IPCLockedSignalledType@H@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_t$ = 8							; size = 4
??0?$IPCMutexLock@U?$IPCLockedSignalledType@H@@@@QAE@AAU?$IPCLockedSignalledType@H@@@Z PROC ; IPCMutexLock<IPCLockedSignalledType<int> >::IPCMutexLock<IPCLockedSignalledType<int> >, COMDAT
; _this$ = ecx

; 137  :     IPCMutexLock(T &t) : t(t), enabled(true) { t.lock(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+4], 1
	mov	ecx, DWORD PTR _t$[ebp]
	add	ecx, 48					; 00000030H
	call	?lock@IPCMutex@@QAEXXZ			; IPCMutex::lock
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$IPCMutexLock@U?$IPCLockedSignalledType@H@@@@QAE@AAU?$IPCLockedSignalledType@H@@@Z ENDP ; IPCMutexLock<IPCLockedSignalledType<int> >::IPCMutexLock<IPCLockedSignalledType<int> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??0?$IPCMutexLock@U?$IPCLockedSignalledArray@I@@@@QAE@AAU?$IPCLockedSignalledArray@I@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_t$ = 8							; size = 4
??0?$IPCMutexLock@U?$IPCLockedSignalledArray@I@@@@QAE@AAU?$IPCLockedSignalledArray@I@@@Z PROC ; IPCMutexLock<IPCLockedSignalledArray<unsigned int> >::IPCMutexLock<IPCLockedSignalledArray<unsigned int> >, COMDAT
; _this$ = ecx

; 137  :     IPCMutexLock(T &t) : t(t), enabled(true) { t.lock(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+4], 1
	mov	ecx, DWORD PTR _t$[ebp]
	add	ecx, 56					; 00000038H
	call	?lock@IPCMutex@@QAEXXZ			; IPCMutex::lock
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$IPCMutexLock@U?$IPCLockedSignalledArray@I@@@@QAE@AAU?$IPCLockedSignalledArray@I@@@Z ENDP ; IPCMutexLock<IPCLockedSignalledArray<unsigned int> >::IPCMutexLock<IPCLockedSignalledArray<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\qsvhelper\windowsstuff.h
;	COMDAT ??0?$IPCMutexLock@U?$IPCLockedSignalledArray@Uqueued_frame@@@@@@QAE@AAU?$IPCLockedSignalledArray@Uqueued_frame@@@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_t$ = 8							; size = 4
??0?$IPCMutexLock@U?$IPCLockedSignalledArray@Uqueued_frame@@@@@@QAE@AAU?$IPCLockedSignalledArray@Uqueued_frame@@@@@Z PROC ; IPCMutexLock<IPCLockedSignalledArray<queued_frame> >::IPCMutexLock<IPCLockedSignalledArray<queued_frame> >, COMDAT
; _this$ = ecx

; 137  :     IPCMutexLock(T &t) : t(t), enabled(true) { t.lock(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+4], 1
	mov	ecx, DWORD PTR _t$[ebp]
	add	ecx, 56					; 00000038H
	call	?lock@IPCMutex@@QAEXXZ			; IPCMutex::lock
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$IPCMutexLock@U?$IPCLockedSignalledArray@Uqueued_frame@@@@@@QAE@AAU?$IPCLockedSignalledArray@Uqueued_frame@@@@@Z ENDP ; IPCMutexLock<IPCLockedSignalledArray<queued_frame> >::IPCMutexLock<IPCLockedSignalledArray<queued_frame> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT
; _this$ = ecx

; 1038 : 		{	// append _Right

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1039 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append

; 1040 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT
; _this$ = ecx

; 1085 : 		{	// append [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@_W@std@@SAIPB_W@Z	; std::char_traits<wchar_t>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append

; 1088 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT
; _this$ = ecx

; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1045 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN4@append

; 1046 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran
$LN4@append:

; 1047 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1048 : 		if (_Num < _Count)

	mov	eax, DWORD PTR __Num$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN3@append

; 1049 : 			_Count = _Num;	// trim _Count to size

	mov	ecx, DWORD PTR __Num$[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN3@append:

; 1050 : 		if (npos - this->_Mysize <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	or	eax, -1
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN2@append

; 1051 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen
$LN2@append:

; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@append
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], edx
	push	0
	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@append

; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
	mov	ecx, DWORD PTR __Roff$[ebp]
	lea	edx, DWORD PTR [eax+ecx*2]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	lea	eax, DWORD PTR [eax+edx*2]
	push	eax
	call	?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy
	add	esp, 12					; 0000000cH

; 1057 : 			_Eos(_Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos
$LN1@append:

; 1058 : 			}
; 1059 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@append:

; 1060 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT
; _this$ = ecx

; 1063 : 		{	// append [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@append

; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	sar	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
	jmp	SHORT $LN5@append
$LN3@append:

; 1072 : 		if (npos - this->_Mysize <= _Count)

	mov	eax, DWORD PTR _this$[ebp]
	or	ecx, -1
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Count$[ebp]
	ja	SHORT $LN2@append

; 1073 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen
$LN2@append:

; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@append
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], eax
	push	0
	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@append

; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+16]
	lea	edx, DWORD PTR [eax+ecx*2]
	push	edx
	call	?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy
	add	esp, 12					; 0000000cH

; 1079 : 			_Eos(_Num);

	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos
$LN1@append:

; 1080 : 			}
; 1081 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN5@append:

; 1082 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z PROC ; std::operator==<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2488 : 	{	// test for string vs. NTCS equality

	push	ebp
	mov	ebp, esp
	push	ecx

; 2489 : 	return (_Left.compare(_Right) == 0);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	call	?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
	test	eax, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv68[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv68[ebp]

; 2490 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ENDP ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xutility
;	COMDAT ??$_Iter_cat@PAPB_W@std@@YA?AUrandom_access_iterator_tag@0@ABQAPB_W@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAPB_W@std@@YA?AUrandom_access_iterator_tag@0@ABQAPB_W@Z PROC ; std::_Iter_cat<wchar_t const * *>, COMDAT

; 405  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 406  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 407  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	cl, BYTE PTR __Cat$[ebp]
	mov	BYTE PTR [eax], cl
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 408  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_cat@PAPB_W@std@@YA?AUrandom_access_iterator_tag@0@ABQAPB_W@Z ENDP ; std::_Iter_cat<wchar_t const * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xutility
;	COMDAT ??$_Distance2@PAPB_WH@std@@YAXPAPB_W0AAHUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Distance2@PAPB_WH@std@@YAXPAPB_W0AAHUrandom_access_iterator_tag@0@@Z PROC ; std::_Distance2<wchar_t const * *,int>, COMDAT

; 741  : 	{	// add to _Off distance between random-access iterators

	push	ebp
	mov	ebp, esp

; 742  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 743  : 	if (_First != _Last)
; 744  : 		{	// check for null pointers
; 745  : 		_DEBUG_POINTER(_First);
; 746  : 		_DEBUG_POINTER(_Last);
; 747  : 		}
; 748  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 749  : 
; 750  : 	_Off += _Last - _First;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	ecx, DWORD PTR __Off$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR [edx], eax

; 751  : 	}

	pop	ebp
	ret	0
??$_Distance2@PAPB_WH@std@@YAXPAPB_W0AAHUrandom_access_iterator_tag@0@@Z ENDP ; std::_Distance2<wchar_t const * *,int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\algorithm
;	COMDAT ??$search@PAEPBEU?$equal_to@X@std@@@std@@YAPAEPAE0PBE1U?$equal_to@X@0@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$search@PAEPBEU?$equal_to@X@std@@@std@@YAPAEPAE0PBE1U?$equal_to@X@0@@Z PROC ; std::search<unsigned char *,unsigned char const *,std::equal_to<void> >, COMDAT

; 639  : 	{	// find first [_First2, _Last2) satisfying _Pred

	push	ebp
	mov	ebp, esp

; 640  : 	_DEBUG_RANGE(_First1, _Last1);
; 641  : 	_DEBUG_RANGE(_First2, _Last2);
; 642  : 	_DEBUG_POINTER(_Pred);
; 643  : 	return (_Rechecked(_First1,
; 644  : 		_Search(_Unchecked(_First1), _Unchecked(_Last1),
; 645  : 			_Unchecked(_First2), _Unchecked(_Last2), _Pred,
; 646  : 			_Dist_type(_First1), _Dist_type(_First2))));

	mov	eax, DWORD PTR __First2$[ebp]
	push	eax
	call	??$_Dist_type@PBE@std@@YAPAHPBE@Z	; std::_Dist_type<unsigned char const *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __First1$[ebp]
	push	ecx
	call	??$_Dist_type@PAE@std@@YAPAHPAE@Z	; std::_Dist_type<unsigned char *>
	add	esp, 4
	push	eax
	movzx	edx, BYTE PTR __Pred$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last2$[ebp]
	push	eax
	call	??$_Unchecked@PBE@std@@YAPBEPBE@Z	; std::_Unchecked<unsigned char const *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	call	??$_Unchecked@PBE@std@@YAPBEPBE@Z	; std::_Unchecked<unsigned char const *>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Last1$[ebp]
	push	edx
	call	??$_Unchecked@PAE@std@@YAPAEPAE@Z	; std::_Unchecked<unsigned char *>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	??$_Unchecked@PAE@std@@YAPAEPAE@Z	; std::_Unchecked<unsigned char *>
	add	esp, 4
	push	eax
	call	??$_Search@PAEPBEHHU?$equal_to@X@std@@@std@@YAPAEPAE0PBE1U?$equal_to@X@0@PAH3@Z ; std::_Search<unsigned char *,unsigned char const *,int,int,std::equal_to<void> >
	add	esp, 28					; 0000001cH
	push	eax
	lea	ecx, DWORD PTR __First1$[ebp]
	push	ecx
	call	??$_Rechecked@PAEPAE@std@@YAAAPAEAAPAEPAE@Z ; std::_Rechecked<unsigned char *,unsigned char *>
	add	esp, 8
	mov	eax, DWORD PTR [eax]

; 647  : 	}

	pop	ebp
	ret	0
??$search@PAEPBEU?$equal_to@X@std@@@std@@YAPAEPAE0PBE1U?$equal_to@X@0@@Z ENDP ; std::search<unsigned char *,unsigned char const *,std::equal_to<void> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xutility
;	COMDAT ??$_Unchecked@PAE@std@@YAPAEPAE@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAE@std@@YAPAEPAE@Z PROC			; std::_Unchecked<unsigned char *>, COMDAT

; 280  : 	{	// construct unchecked from checked, generic

	push	ebp
	mov	ebp, esp

; 281  : 	return (_Src);

	mov	eax, DWORD PTR __Src$[ebp]

; 282  : 	}

	pop	ebp
	ret	0
??$_Unchecked@PAE@std@@YAPAEPAE@Z ENDP			; std::_Unchecked<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\algorithm
;	COMDAT ??$_Find_if_not@PAEV<lambda_4f23e6955dca7f806ec2428e9267999f>@@@std@@YAPAEPAE0V<lambda_4f23e6955dca7f806ec2428e9267999f>@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Find_if_not@PAEV<lambda_4f23e6955dca7f806ec2428e9267999f>@@@std@@YAPAEPAE0V<lambda_4f23e6955dca7f806ec2428e9267999f>@@@Z PROC ; std::_Find_if_not<unsigned char *,<lambda_4f23e6955dca7f806ec2428e9267999f> >, COMDAT

; 290  : 	{	// find first element that satisfies !_Pred

	push	ebp
	mov	ebp, esp

; 291  : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN4@Find_if_no
$LN3@Find_if_no:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 1
	mov	DWORD PTR __First$[ebp], eax
$LN4@Find_if_no:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN2@Find_if_no

; 292  : 		if (!_Pred(*_First))

	mov	edx, DWORD PTR __First$[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	lea	ecx, DWORD PTR __Pred$[ebp]
	call	??R<lambda_4f23e6955dca7f806ec2428e9267999f>@@QBE_NE@Z ; <lambda_4f23e6955dca7f806ec2428e9267999f>::operator()
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@Find_if_no

; 293  : 			break;

	jmp	SHORT $LN2@Find_if_no
$LN1@Find_if_no:

; 294  : 	return (_First);

	jmp	SHORT $LN3@Find_if_no
$LN2@Find_if_no:
	mov	eax, DWORD PTR __First$[ebp]

; 295  : 	}

	pop	ebp
	ret	0
??$_Find_if_not@PAEV<lambda_4f23e6955dca7f806ec2428e9267999f>@@@std@@YAPAEPAE0V<lambda_4f23e6955dca7f806ec2428e9267999f>@@@Z ENDP ; std::_Find_if_not<unsigned char *,<lambda_4f23e6955dca7f806ec2428e9267999f> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xutility
;	COMDAT ??$_Rechecked@PAEPAE@std@@YAAAPAEAAPAEPAE@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAEPAE@std@@YAAAPAEAAPAEPAE@Z PROC	; std::_Rechecked<unsigned char *,unsigned char *>, COMDAT

; 288  : 	{	// reset checked from unchecked, generic

	push	ebp
	mov	ebp, esp

; 289  : 	_Dest = _Src;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR __Src$[ebp]
	mov	DWORD PTR [eax], ecx

; 290  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 291  : 	}

	pop	ebp
	ret	0
??$_Rechecked@PAEPAE@std@@YAAAPAEAAPAEPAE@Z ENDP	; std::_Rechecked<unsigned char *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z
_TEXT	SEGMENT
$T1 = -2						; size = 1
$T2 = -1						; size = 1
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z PROC ; std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 892  : 	{	// test for allocator equality

	push	ebp
	mov	ebp, esp
	push	ecx

; 893  : 	return (static_cast<_Ty>(_Left) == static_cast<_Other>(_Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0?$allocator@_W@std@@QAE@ABV01@@Z	; std::allocator<wchar_t>::allocator<wchar_t>
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@_W@std@@QAE@ABV01@@Z	; std::allocator<wchar_t>::allocator<wchar_t>
	push	eax
	call	??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z ; std::operator==<wchar_t,wchar_t>
	add	esp, 8

; 894  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ENDP ; std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@std@@PAPAXU?$_Wrap_alloc@V?$allocator@PAX@std@@@2@@std@@YAPAPAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@0@0PAPAXAAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@std@@PAPAXU?$_Wrap_alloc@V?$allocator@PAX@std@@@2@@std@@YAPAPAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@0@0PAPAXAAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@@Z PROC ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<void *> > >,void * *,std::_Wrap_alloc<std::allocator<void *> > >, COMDAT

; 424  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp

; 425  : 	return (_Rechecked(_Dest,
; 426  : 		_Uninit_copy(_Unchecked(_First), _Unchecked(_Last),
; 427  : 			_Unchecked(_Dest), _Al)));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Unchecked@PAPAX@std@@YAPAPAXPAPAX@Z	; std::_Unchecked<void * *>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@std@@YAPBQAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<void *> > >
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@std@@YAPBQAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<void *> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBQAXPAPAXU?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@@std@@YAPAPAXPBQAX0PAPAXAAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@@Z ; std::_Uninit_copy<void * const *,void * *,std::_Wrap_alloc<std::allocator<void *> > >
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Rechecked@PAPAXPAPAX@std@@YAAAPAPAXAAPAPAXPAPAX@Z ; std::_Rechecked<void * *,void * *>
	add	esp, 8
	mov	eax, DWORD PTR [eax]

; 428  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@std@@PAPAXU?$_Wrap_alloc@V?$allocator@PAX@std@@@2@@std@@YAPAPAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@0@0PAPAXAAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@@Z ENDP ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<void *> > >,void * *,std::_Wrap_alloc<std::allocator<void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$?8V?$allocator@PAX@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@0@Z
_TEXT	SEGMENT
$T1 = -2						; size = 1
$T2 = -1						; size = 1
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8V?$allocator@PAX@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@0@Z PROC ; std::operator==<std::allocator<void *>,std::allocator<void *> >, COMDAT

; 892  : 	{	// test for allocator equality

	push	ebp
	mov	ebp, esp
	push	ecx

; 893  : 	return (static_cast<_Ty>(_Left) == static_cast<_Other>(_Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0?$allocator@PAX@std@@QAE@ABV01@@Z	; std::allocator<void *>::allocator<void *>
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@PAX@std@@QAE@ABV01@@Z	; std::allocator<void *>::allocator<void *>
	push	eax
	call	??$?8PAXPAX@std@@YA_NABV?$allocator@PAX@0@0@Z ; std::operator==<void *,void *>
	add	esp, 8

; 894  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$?8V?$allocator@PAX@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@0@Z ENDP ; std::operator==<std::allocator<void *>,std::allocator<void *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAXPAX@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAX0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAXPAX@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAX0@Z PROC ; std::_Ptr_cat<void *,void *>, COMDAT

; 444  : 	{	// return pointer category from pointers

	push	ebp
	mov	ebp, esp
	push	ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 447  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAXPAX@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAX0@Z ENDP ; std::_Ptr_cat<void *,void *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xutility
;	COMDAT ??$_Copy_impl@PAPAXPAPAX@std@@YAPAPAXPAPAX00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_impl@PAPAXPAPAX@std@@YAPAPAXPAPAX00U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Copy_impl<void * *,void * *>, COMDAT

; 2053 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to scalars

	push	ebp
	mov	ebp, esp
	push	ecx

; 2054 : 	ptrdiff_t _Count = _Last - _First;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 2055 : 	_CSTD memmove(&*_Dest, &*_First,
; 2056 : 		_Count * sizeof (*_First));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH

; 2057 : 	return (_Dest + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]

; 2058 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_impl@PAPAXPAPAX@std@@YAPAPAXPAPAX00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_impl<void * *,void * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAPAXPAPAXU?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@@std@@YAPAPAXPAPAX00AAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAPAXPAPAXU?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@@std@@YAPAPAXPAPAX00AAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@@Z PROC ; std::_Uninitialized_copy<void * *,void * *,std::_Wrap_alloc<std::allocator<void *> > >, COMDAT

; 424  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp

; 425  : 	return (_Rechecked(_Dest,
; 426  : 		_Uninit_copy(_Unchecked(_First), _Unchecked(_Last),
; 427  : 			_Unchecked(_Dest), _Al)));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Unchecked@PAPAX@std@@YAPAPAXPAPAX@Z	; std::_Unchecked<void * *>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??$_Unchecked@PAPAX@std@@YAPAPAXPAPAX@Z	; std::_Unchecked<void * *>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked@PAPAX@std@@YAPAPAXPAPAX@Z	; std::_Unchecked<void * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAPAXPAPAXU?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@@std@@YAPAPAXPAPAX00AAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@@Z ; std::_Uninit_copy<void * *,void * *,std::_Wrap_alloc<std::allocator<void *> > >
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Rechecked@PAPAXPAPAX@std@@YAAAPAPAXAAPAPAXPAPAX@Z ; std::_Rechecked<void * *,void * *>
	add	esp, 8
	mov	eax, DWORD PTR [eax]

; 428  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_copy@PAPAXPAPAXU?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@@std@@YAPAPAXPAPAX00AAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@@Z ENDP ; std::_Uninitialized_copy<void * *,void * *,std::_Wrap_alloc<std::allocator<void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$forward@AAPAX@std@@YAAAPAXAAPAX@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAX@std@@YAAAPAXAAPAX@Z PROC		; std::forward<void * &>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@AAPAX@std@@YAAAPAXAAPAX@Z ENDP		; std::forward<void * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$construct@PAXAAPAX@?$allocator_traits@V?$allocator@PAX@std@@@std@@SAXAAV?$allocator@PAX@1@PAPAXAAPAX@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAXAAPAX@?$allocator_traits@V?$allocator@PAX@std@@@std@@SAXAAV?$allocator@PAX@1@PAPAXAAPAX@Z PROC ; std::allocator_traits<std::allocator<void *> >::construct<void *,void * &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

	push	ebp
	mov	ebp, esp

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@AAPAX@std@@YAAAPAXAAPAX@Z	; std::forward<void * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PAXAAPAX@?$allocator@PAX@std@@QAEXPAPAXAAPAX@Z ; std::allocator<void *>::construct<void *,void * &>

; 724  : 		}

	pop	ebp
	ret	0
??$construct@PAXAAPAX@?$allocator_traits@V?$allocator@PAX@std@@@std@@SAXAAV?$allocator@PAX@1@PAPAXAAPAX@Z ENDP ; std::allocator_traits<std::allocator<void *> >::construct<void *,void * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$forward@ABQAX@std@@YAABQAXABQAX@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAX@std@@YAABQAXABQAX@Z PROC		; std::forward<void * const &>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@ABQAX@std@@YAABQAXABQAX@Z ENDP		; std::forward<void * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$construct@PAXABQAX@?$allocator_traits@V?$allocator@PAX@std@@@std@@SAXAAV?$allocator@PAX@1@PAPAXABQAX@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAXABQAX@?$allocator_traits@V?$allocator@PAX@std@@@std@@SAXAAV?$allocator@PAX@1@PAPAXABQAX@Z PROC ; std::allocator_traits<std::allocator<void *> >::construct<void *,void * const &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

	push	ebp
	mov	ebp, esp

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@ABQAX@std@@YAABQAXABQAX@Z	; std::forward<void * const &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@PAX@std@@QAEXPAPAXABQAX@Z ; std::allocator<void *>::construct

; 724  : 		}

	pop	ebp
	ret	0
??$construct@PAXABQAX@?$allocator_traits@V?$allocator@PAX@std@@@std@@SAXAAV?$allocator@PAX@1@PAPAXABQAX@Z ENDP ; std::allocator_traits<std::allocator<void *> >::construct<void *,void * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z PROC		; std::operator==<wchar_t,wchar_t>, COMDAT

; 660  : 	{	// test for allocator equality

	push	ebp
	mov	ebp, esp

; 661  : 	return (true);

	mov	al, 1

; 662  : 	}

	pop	ebp
	ret	0
??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z ENDP		; std::operator==<wchar_t,wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z PROC		; std::forward<wchar_t * &>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ENDP		; std::forward<wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z PROC ; std::allocator_traits<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

	push	ebp
	mov	ebp, esp

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z	; std::forward<wchar_t * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>

; 724  : 		}

	pop	ebp
	ret	0
??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z ENDP ; std::allocator_traits<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z PROC ; std::allocator_traits<std::allocator<wchar_t> >::destroy<wchar_t *>, COMDAT

; 728  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z ; std::allocator<wchar_t>::destroy<wchar_t *>

; 731  : 		}

	pop	ebp
	ret	0
??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z ENDP ; std::allocator_traits<std::allocator<wchar_t> >::destroy<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@@std@@YAXPAPAX0AAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@@std@@YAXPAPAX0AAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<void *> > >, COMDAT

; 89   : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 90   : 	}

	pop	ebp
	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@@std@@YAXPAPAX0AAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAXPAPAXU?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@@std@@YAPAPAXPAPAX00AAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAXPAPAXU?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@@std@@YAPAPAXPAPAX00AAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@@Z PROC ; std::_Uninitialized_move<void * *,void * *,std::_Wrap_alloc<std::allocator<void *> > >, COMDAT

; 492  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp

; 493  : 	return (_Rechecked(_Dest,
; 494  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 495  : 			_Unchecked(_Dest), _Al)));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Unchecked@PAPAX@std@@YAPAPAXPAPAX@Z	; std::_Unchecked<void * *>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??$_Unchecked@PAPAX@std@@YAPAPAXPAPAX@Z	; std::_Unchecked<void * *>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked@PAPAX@std@@YAPAPAXPAPAX@Z	; std::_Unchecked<void * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PAPAXPAPAXU?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@@std@@YAPAPAXPAPAX00AAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@@Z ; std::_Uninit_move<void * *,void * *,std::_Wrap_alloc<std::allocator<void *> > >
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Rechecked@PAPAXPAPAX@std@@YAAAPAPAXAAPAPAXPAPAX@Z ; std::_Rechecked<void * *,void * *>
	add	esp, 8
	mov	eax, DWORD PTR [eax]

; 496  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_move@PAPAXPAPAXU?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@@std@@YAPAPAXPAPAX00AAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@@Z ENDP ; std::_Uninitialized_move<void * *,void * *,std::_Wrap_alloc<std::allocator<void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?construct@?$allocator@PAX@std@@QAEXPAPAXABQAX@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv68 = -8						; size = 4
$T1 = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAX@std@@QAEXPAPAXABQAX@Z PROC	; std::allocator<void *>::construct, COMDAT
; _this$ = ecx

; 592  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR $T1[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR tv68[ebp], ecx
	jmp	SHORT $LN1@construct
$LN3@construct:
	mov	DWORD PTR tv68[ebp], 0
$LN1@construct:

; 594  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@PAX@std@@QAEXPAPAXABQAX@Z ENDP	; std::allocator<void *>::construct
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xutility
;	COMDAT ??$_Unchecked@PBE@std@@YAPBEPBE@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PBE@std@@YAPBEPBE@Z PROC			; std::_Unchecked<unsigned char const *>, COMDAT

; 280  : 	{	// construct unchecked from checked, generic

	push	ebp
	mov	ebp, esp

; 281  : 	return (_Src);

	mov	eax, DWORD PTR __Src$[ebp]

; 282  : 	}

	pop	ebp
	ret	0
??$_Unchecked@PBE@std@@YAPBEPBE@Z ENDP			; std::_Unchecked<unsigned char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xutility
;	COMDAT ??$_Dist_type@PAE@std@@YAPAHPAE@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@PAE@std@@YAPAHPAE@Z PROC			; std::_Dist_type<unsigned char *>, COMDAT

; 705  : 	{	// return distance type from arbitrary argument

	push	ebp
	mov	ebp, esp

; 706  : 	return (0);

	xor	eax, eax

; 707  : 	}

	pop	ebp
	ret	0
??$_Dist_type@PAE@std@@YAPAHPAE@Z ENDP			; std::_Dist_type<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xutility
;	COMDAT ??$_Dist_type@PBE@std@@YAPAHPBE@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@PBE@std@@YAPAHPBE@Z PROC			; std::_Dist_type<unsigned char const *>, COMDAT

; 705  : 	{	// return distance type from arbitrary argument

	push	ebp
	mov	ebp, esp

; 706  : 	return (0);

	xor	eax, eax

; 707  : 	}

	pop	ebp
	ret	0
??$_Dist_type@PBE@std@@YAPAHPBE@Z ENDP			; std::_Dist_type<unsigned char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\algorithm
;	COMDAT ??$_Search@PAEPBEHHU?$equal_to@X@std@@@std@@YAPAEPAE0PBE1U?$equal_to@X@0@PAH3@Z
_TEXT	SEGMENT
__Count2$ = -16						; size = 4
__Mid1$1 = -12						; size = 4
__Mid2$2 = -8						; size = 4
__Count1$ = -4						; size = 4
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Pred$ = 24						; size = 1
___formal$ = 28						; size = 4
___formal$ = 32						; size = 4
??$_Search@PAEPBEHHU?$equal_to@X@std@@@std@@YAPAEPAE0PBE1U?$equal_to@X@0@PAH3@Z PROC ; std::_Search<unsigned char *,unsigned char const *,int,int,std::equal_to<void> >, COMDAT

; 616  : 	{	// find first [_First2, _Last2) satisfying _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 617  : 	_Diff1 _Count1 = 0;

	mov	DWORD PTR __Count1$[ebp], 0

; 618  : 	_Distance(_First1, _Last1, _Count1);

	lea	eax, DWORD PTR __Count1$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last1$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	call	??$_Distance@PAEH@std@@YAXPAE0AAH@Z	; std::_Distance<unsigned char *,int>
	add	esp, 12					; 0000000cH

; 619  : 	_Diff2 _Count2 = 0;

	mov	DWORD PTR __Count2$[ebp], 0

; 620  : 	_Distance(_First2, _Last2, _Count2);

	lea	eax, DWORD PTR __Count2$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	call	??$_Distance@PBEH@std@@YAXPBE0AAH@Z	; std::_Distance<unsigned char const *,int>
	add	esp, 12					; 0000000cH

; 621  : 
; 622  : 	for (; _Count2 <= _Count1; ++_First1, --_Count1)

	jmp	SHORT $LN9@Search
$LN8@Search:
	mov	eax, DWORD PTR __First1$[ebp]
	add	eax, 1
	mov	DWORD PTR __First1$[ebp], eax
	mov	ecx, DWORD PTR __Count1$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count1$[ebp], ecx
$LN9@Search:
	mov	edx, DWORD PTR __Count2$[ebp]
	cmp	edx, DWORD PTR __Count1$[ebp]
	jg	SHORT $LN7@Search

; 623  : 		{	// room for match, try it
; 624  : 		_FwdIt1 _Mid1 = _First1;

	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR __Mid1$1[ebp], eax

; 625  : 		for (_FwdIt2 _Mid2 = _First2; ; ++_Mid1, ++_Mid2)

	mov	ecx, DWORD PTR __First2$[ebp]
	mov	DWORD PTR __Mid2$2[ebp], ecx
	jmp	SHORT $LN6@Search
$LN5@Search:
	mov	edx, DWORD PTR __Mid1$1[ebp]
	add	edx, 1
	mov	DWORD PTR __Mid1$1[ebp], edx
	mov	eax, DWORD PTR __Mid2$2[ebp]
	add	eax, 1
	mov	DWORD PTR __Mid2$2[ebp], eax
$LN6@Search:

; 626  : 			if (_Mid2 == _Last2)

	mov	ecx, DWORD PTR __Mid2$2[ebp]
	cmp	ecx, DWORD PTR __Last2$[ebp]
	jne	SHORT $LN3@Search

; 627  : 				return (_First1);

	mov	eax, DWORD PTR __First1$[ebp]
	jmp	SHORT $LN10@Search
	jmp	SHORT $LN2@Search
$LN3@Search:

; 628  : 			else if (!_Pred(*_Mid1, *_Mid2))

	mov	edx, DWORD PTR __Mid2$2[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid1$1[ebp]
	push	eax
	lea	ecx, DWORD PTR __Pred$[ebp]
	call	??$?RAAEABE@?$equal_to@X@std@@QBE_NAAEABE@Z ; std::equal_to<void>::operator()<unsigned char &,unsigned char const &>
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@Search

; 629  : 				break;

	jmp	SHORT $LN4@Search
$LN2@Search:

; 630  : 		}

	jmp	SHORT $LN5@Search
$LN4@Search:
	jmp	SHORT $LN8@Search
$LN7@Search:

; 631  : 	return (_Last1);

	mov	eax, DWORD PTR __Last1$[ebp]
$LN10@Search:

; 632  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Search@PAEPBEHHU?$equal_to@X@std@@@std@@YAPAEPAE0PBE1U?$equal_to@X@0@PAH3@Z ENDP ; std::_Search<unsigned char *,unsigned char const *,int,int,std::equal_to<void> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@std@@YAPBQAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@std@@YAPBQAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<void *> > >, COMDAT

; 264  : 	{	// convert to unchecked

	push	ebp
	mov	ebp, esp

; 265  : 	return (_Iter._Unchecked());

	lea	ecx, DWORD PTR __Iter$[ebp]
	call	?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@std@@QBEPBQAXXZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<void *> > >::_Unchecked

; 266  : 	}

	pop	ebp
	ret	0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@std@@YAPBQAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xutility
;	COMDAT ??$_Unchecked@PAPAX@std@@YAPAPAXPAPAX@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAPAX@std@@YAPAPAXPAPAX@Z PROC		; std::_Unchecked<void * *>, COMDAT

; 280  : 	{	// construct unchecked from checked, generic

	push	ebp
	mov	ebp, esp

; 281  : 	return (_Src);

	mov	eax, DWORD PTR __Src$[ebp]

; 282  : 	}

	pop	ebp
	ret	0
??$_Unchecked@PAPAX@std@@YAPAPAXPAPAX@Z ENDP		; std::_Unchecked<void * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PBQAXPAPAXU?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@@std@@YAPAPAXPBQAX0PAPAXAAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_copy@PBQAXPAPAXU?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@@std@@YAPAPAXPBQAX0PAPAXAAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@@Z PROC ; std::_Uninit_copy<void * const *,void * *,std::_Wrap_alloc<std::allocator<void *> > >, COMDAT

; 414  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 415  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 416  : 		_Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAXPAX@std@@YA?AU_Scalar_ptr_iterator_tag@0@PBQAXPAPAX@Z ; std::_Ptr_cat<void *,void *>
	add	esp, 8
	mov	BYTE PTR $T1[ebp], al
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Uninit_copy@QAXPAX@std@@YAPAPAXPBQAX0PAPAXAAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<void * const,void *>
	add	esp, 20					; 00000014H

; 417  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PBQAXPAPAXU?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@@std@@YAPAPAXPBQAX0PAPAXAAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@@Z ENDP ; std::_Uninit_copy<void * const *,void * *,std::_Wrap_alloc<std::allocator<void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xutility
;	COMDAT ??$_Rechecked@PAPAXPAPAX@std@@YAAAPAPAXAAPAPAXPAPAX@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAPAXPAPAX@std@@YAAAPAPAXAAPAPAXPAPAX@Z PROC ; std::_Rechecked<void * *,void * *>, COMDAT

; 288  : 	{	// reset checked from unchecked, generic

	push	ebp
	mov	ebp, esp

; 289  : 	_Dest = _Src;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR __Src$[ebp]
	mov	DWORD PTR [eax], ecx

; 290  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 291  : 	}

	pop	ebp
	ret	0
??$_Rechecked@PAPAXPAPAX@std@@YAAAPAPAXAAPAPAXPAPAX@Z ENDP ; std::_Rechecked<void * *,void * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$?8PAXPAX@std@@YA_NABV?$allocator@PAX@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?8PAXPAX@std@@YA_NABV?$allocator@PAX@0@0@Z PROC	; std::operator==<void *,void *>, COMDAT

; 660  : 	{	// test for allocator equality

	push	ebp
	mov	ebp, esp

; 661  : 	return (true);

	mov	al, 1

; 662  : 	}

	pop	ebp
	ret	0
??$?8PAXPAX@std@@YA_NABV?$allocator@PAX@0@0@Z ENDP	; std::operator==<void *,void *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PAPAXPAPAXU?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@@std@@YAPAPAXPAPAX00AAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_copy@PAPAXPAPAXU?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@@std@@YAPAPAXPAPAX00AAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@@Z PROC ; std::_Uninit_copy<void * *,void * *,std::_Wrap_alloc<std::allocator<void *> > >, COMDAT

; 414  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 415  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 416  : 		_Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAXPAX@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAX0@Z ; std::_Ptr_cat<void *,void *>
	add	esp, 8
	mov	BYTE PTR $T1[ebp], al
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Uninit_copy@PAXPAX@std@@YAPAPAXPAPAX00AAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<void *,void *>
	add	esp, 20					; 00000014H

; 417  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAPAXPAPAXU?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@@std@@YAPAPAXPAPAX00AAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@@Z ENDP ; std::_Uninit_copy<void * *,void * *,std::_Wrap_alloc<std::allocator<void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$construct@PAXAAPAX@?$allocator@PAX@std@@QAEXPAPAXAAPAX@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv70 = -8						; size = 4
$T1 = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAXAAPAX@?$allocator@PAX@std@@QAEXPAPAXAAPAX@Z PROC ; std::allocator<void *>::construct<void *,void * &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@AAPAX@std@@YAAAPAXAAPAX@Z	; std::forward<void * &>
	add	esp, 4
	mov	edx, DWORD PTR $T1[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR tv70[ebp], ecx
	jmp	SHORT $LN1@construct
$LN3@construct:
	mov	DWORD PTR tv70[ebp], 0
$LN1@construct:

; 601  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PAXAAPAX@?$allocator@PAX@std@@QAEXPAPAXAAPAX@Z ENDP ; std::allocator<void *>::construct<void *,void * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv70 = -8						; size = 4
$T1 = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z PROC ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z	; std::forward<wchar_t * &>
	add	esp, 4
	mov	edx, DWORD PTR $T1[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR tv70[ebp], ecx
	jmp	SHORT $LN1@construct
$LN3@construct:
	mov	DWORD PTR tv70[ebp], 0
$LN1@construct:

; 601  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z ENDP ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z PROC	; std::allocator<wchar_t>::destroy<wchar_t *>, COMDAT
; _this$ = ecx

; 605  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z ENDP	; std::allocator<wchar_t>::destroy<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAPAXPAPAXU?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@@std@@YAPAPAXPAPAX00AAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_move@PAPAXPAPAXU?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@@std@@YAPAPAXPAPAX00AAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@@Z PROC ; std::_Uninit_move<void * *,void * *,std::_Wrap_alloc<std::allocator<void *> > >, COMDAT

; 482  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 483  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAXPAX@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAX0@Z ; std::_Ptr_cat<void *,void *>
	add	esp, 8
	mov	BYTE PTR $T1[ebp], al
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Val_type@PAPAX@std@@YAPAPAXPAPAX@Z	; std::_Val_type<void * *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninit_move@PAXPAXPAX@std@@YAPAPAXPAPAX00AAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<void *,void *,void *>
	add	esp, 24					; 00000018H

; 485  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_move@PAPAXPAPAXU?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@@std@@YAPAPAXPAPAX00AAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@@Z ENDP ; std::_Uninit_move<void * *,void * *,std::_Wrap_alloc<std::allocator<void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@std@@QBEPBQAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@std@@QBEPBQAXXZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<void *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 60   : 		{	// make an unchecked iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 61   : 		return (_Unchecked_type(this->_Ptr));

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 62   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@@std@@QBEPBQAXXZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<void *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xutility
;	COMDAT ??$_Distance@PAEH@std@@YAXPAE0AAH@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
??$_Distance@PAEH@std@@YAXPAE0AAH@Z PROC		; std::_Distance<unsigned char *,int>, COMDAT

; 765  : 	{	// add to _Off distance between iterators

	push	ebp
	mov	ebp, esp
	push	ecx

; 766  : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??$_Iter_cat@PAE@std@@YA?AUrandom_access_iterator_tag@0@ABQAE@Z ; std::_Iter_cat<unsigned char *>
	add	esp, 8
	mov	dl, BYTE PTR [eax]
	movzx	eax, dl
	push	eax
	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Distance2@PAEH@std@@YAXPAE0AAHUrandom_access_iterator_tag@0@@Z ; std::_Distance2<unsigned char *,int>
	add	esp, 16					; 00000010H

; 767  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Distance@PAEH@std@@YAXPAE0AAH@Z ENDP		; std::_Distance<unsigned char *,int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xutility
;	COMDAT ??$_Distance@PBEH@std@@YAXPBE0AAH@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
??$_Distance@PBEH@std@@YAXPBE0AAH@Z PROC		; std::_Distance<unsigned char const *,int>, COMDAT

; 765  : 	{	// add to _Off distance between iterators

	push	ebp
	mov	ebp, esp
	push	ecx

; 766  : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??$_Iter_cat@PBE@std@@YA?AUrandom_access_iterator_tag@0@ABQBE@Z ; std::_Iter_cat<unsigned char const *>
	add	esp, 8
	mov	dl, BYTE PTR [eax]
	movzx	eax, dl
	push	eax
	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Distance2@PBEH@std@@YAXPBE0AAHUrandom_access_iterator_tag@0@@Z ; std::_Distance2<unsigned char const *,int>
	add	esp, 16					; 00000010H

; 767  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Distance@PBEH@std@@YAXPBE0AAH@Z ENDP		; std::_Distance<unsigned char const *,int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstddef
;	COMDAT ??$?RAAEABE@?$equal_to@X@std@@QBE_NAAEABE@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?RAAEABE@?$equal_to@X@std@@QBE_NAAEABE@Z PROC	; std::equal_to<void>::operator()<unsigned char &,unsigned char const &>, COMDAT
; _this$ = ecx

; 248  : 		auto operator()(_Ty1&& _Left, _Ty2&& _Right) const

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 249  : 		-> decltype(static_cast<_Ty1&&>(_Left)
; 250  : 			== static_cast<_Ty2&&>(_Right))
; 251  : 		{	// transparently apply operator== to operands
; 252  : 		return (static_cast<_Ty1&&>(_Left)
; 253  : 			== static_cast<_Ty2&&>(_Right));

	mov	eax, DWORD PTR __Left$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR __Right$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv67[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv67[ebp]

; 254  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$?RAAEABE@?$equal_to@X@std@@QBE_NAAEABE@Z ENDP	; std::equal_to<void>::operator()<unsigned char &,unsigned char const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAXPAX@std@@YA?AU_Scalar_ptr_iterator_tag@0@PBQAXPAPAX@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAXPAX@std@@YA?AU_Scalar_ptr_iterator_tag@0@PBQAXPAPAX@Z PROC ; std::_Ptr_cat<void *,void *>, COMDAT

; 453  : 	{	// return pointer category from pointers

	push	ebp
	mov	ebp, esp
	push	ecx

; 454  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 455  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 456  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAXPAX@std@@YA?AU_Scalar_ptr_iterator_tag@0@PBQAXPAPAX@Z ENDP ; std::_Ptr_cat<void *,void *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@QAXPAX@std@@YAPAPAXPBQAX0PAPAXAAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@QAXPAX@std@@YAPAPAXPBQAX0PAPAXAAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<void * const,void *>, COMDAT

; 401  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	push	ecx

; 402  : 	_DEBUG_RANGE(_First, _Last);
; 403  : 	_DEBUG_POINTER(_Dest);
; 404  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [eax+ecx*4]

; 407  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@QAXPAX@std@@YAPAPAXPBQAX0PAPAXAAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<void * const,void *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PAXPAX@std@@YAPAPAXPAPAX00AAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@PAXPAX@std@@YAPAPAXPAPAX00AAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<void *,void *>, COMDAT

; 401  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	push	ecx

; 402  : 	_DEBUG_RANGE(_First, _Last);
; 403  : 	_DEBUG_POINTER(_Dest);
; 404  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [eax+ecx*4]

; 407  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAXPAX@std@@YAPAPAXPAPAX00AAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<void *,void *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xutility
;	COMDAT ??$_Val_type@PAPAX@std@@YAPAPAXPAPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAPAX@std@@YAPAPAXPAPAX@Z PROC		; std::_Val_type<void * *>, COMDAT

; 645  : 	{	// return value type from arbitrary argument

	push	ebp
	mov	ebp, esp

; 646  : 	return (0);

	xor	eax, eax

; 647  : 	}

	pop	ebp
	ret	0
??$_Val_type@PAPAX@std@@YAPAPAXPAPAX@Z ENDP		; std::_Val_type<void * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAXPAXPAX@std@@YAPAPAXPAPAX00AAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAXPAXPAX@std@@YAPAPAXPAPAX00AAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<void *,void *,void *>, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	push	ecx

; 470  : 	_DEBUG_RANGE(_First, _Last);
; 471  : 	_DEBUG_POINTER(_Dest);
; 472  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [eax+ecx*4]

; 475  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_move@PAXPAXPAX@std@@YAPAPAXPAPAX00AAU?$_Wrap_alloc@V?$allocator@PAX@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<void *,void *,void *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xutility
;	COMDAT ??$_Iter_cat@PAE@std@@YA?AUrandom_access_iterator_tag@0@ABQAE@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAE@std@@YA?AUrandom_access_iterator_tag@0@ABQAE@Z PROC ; std::_Iter_cat<unsigned char *>, COMDAT

; 405  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 406  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 407  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	cl, BYTE PTR __Cat$[ebp]
	mov	BYTE PTR [eax], cl
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 408  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_cat@PAE@std@@YA?AUrandom_access_iterator_tag@0@ABQAE@Z ENDP ; std::_Iter_cat<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xutility
;	COMDAT ??$_Distance2@PAEH@std@@YAXPAE0AAHUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Distance2@PAEH@std@@YAXPAE0AAHUrandom_access_iterator_tag@0@@Z PROC ; std::_Distance2<unsigned char *,int>, COMDAT

; 741  : 	{	// add to _Off distance between random-access iterators

	push	ebp
	mov	ebp, esp

; 742  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 743  : 	if (_First != _Last)
; 744  : 		{	// check for null pointers
; 745  : 		_DEBUG_POINTER(_First);
; 746  : 		_DEBUG_POINTER(_Last);
; 747  : 		}
; 748  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 749  : 
; 750  : 	_Off += _Last - _First;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Off$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR [edx], eax

; 751  : 	}

	pop	ebp
	ret	0
??$_Distance2@PAEH@std@@YAXPAE0AAHUrandom_access_iterator_tag@0@@Z ENDP ; std::_Distance2<unsigned char *,int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xutility
;	COMDAT ??$_Iter_cat@PBE@std@@YA?AUrandom_access_iterator_tag@0@ABQBE@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PBE@std@@YA?AUrandom_access_iterator_tag@0@ABQBE@Z PROC ; std::_Iter_cat<unsigned char const *>, COMDAT

; 405  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 406  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 407  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	cl, BYTE PTR __Cat$[ebp]
	mov	BYTE PTR [eax], cl
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 408  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_cat@PBE@std@@YA?AUrandom_access_iterator_tag@0@ABQBE@Z ENDP ; std::_Iter_cat<unsigned char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xutility
;	COMDAT ??$_Distance2@PBEH@std@@YAXPBE0AAHUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Distance2@PBEH@std@@YAXPBE0AAHUrandom_access_iterator_tag@0@@Z PROC ; std::_Distance2<unsigned char const *,int>, COMDAT

; 741  : 	{	// add to _Off distance between random-access iterators

	push	ebp
	mov	ebp, esp

; 742  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 743  : 	if (_First != _Last)
; 744  : 		{	// check for null pointers
; 745  : 		_DEBUG_POINTER(_First);
; 746  : 		_DEBUG_POINTER(_Last);
; 747  : 		}
; 748  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 749  : 
; 750  : 	_Off += _Last - _First;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Off$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR [edx], eax

; 751  : 	}

	pop	ebp
	ret	0
??$_Distance2@PBEH@std@@YAXPBE0AAHUrandom_access_iterator_tag@0@@Z ENDP ; std::_Distance2<unsigned char const *,int>
_TEXT	ENDS
END

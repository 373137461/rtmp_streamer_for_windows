; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

	TITLE	F:\songmm_moon_stone_obs\OBS\Source\Service.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

EXTRN	__imp_??0XConfig@@QAE@PA_W@Z:PROC
EXTRN	__imp_?IsOpen@XConfig@@QBE_NXZ:PROC
EXTRN	__imp_?GetElementByID@XConfig@@QAEPAVXElement@@K@Z:PROC
	ORG $+3
$SG4294768020 DB 's', 00H, 'e', 00H, 'r', 00H, 'v', 00H, 'i', 00H, 'c', 00H
	DB	'e', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG4294768021 DB '%', 00H, 's', 00H, '\', 00H, 's', 00H, 'e', 00H, 'r', 00H
	DB	'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '.', 00H, 'x'
	DB	00H, 'c', 00H, 'o', 00H, 'n', 00H, 'f', 00H, 'i', 00H, 'g', 00H
	DB	00H, 00H
$SG4294768016 DB '%', 00H, 's', 00H, '\', 00H, 's', 00H, 'e', 00H, 'r', 00H
	DB	'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '.', 00H, 'x'
	DB	00H, 'c', 00H, 'o', 00H, 'n', 00H, 'f', 00H, 'i', 00H, 'g', 00H
	DB	00H, 00H
$SG4294768017 DB '%', 00H, 's', 00H, '/', 00H, '*', 00H, '.', 00H, 'x', 00H
	DB	'c', 00H, 'o', 00H, 'n', 00H, 'f', 00H, 'i', 00H, 'g', 00H, 00H
	DB	00H
	ORG $+2
$SG4294768018 DB '%', 00H, 's', 00H, '/', 00H, 's', 00H, 'e', 00H, 'r', 00H
	DB	'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '/', 00H, 00H
	DB	00H
	ORG $+2
$SG4294768019 DB 'i', 00H, 'd', 00H, 00H, 00H
	ORG $+2
$SG4294768012 DB '%', 00H, 's', 00H, '/', 00H, '*', 00H, '.', 00H, 'x', 00H
	DB	'c', 00H, 'o', 00H, 'n', 00H, 'f', 00H, 'i', 00H, 'g', 00H, 00H
	DB	00H
	ORG $+2
$SG4294768013 DB '%', 00H, 's', 00H, '/', 00H, 's', 00H, 'e', 00H, 'r', 00H
	DB	'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '/', 00H, 00H
	DB	00H
	ORG $+2
$SG4294768014 DB 'i', 00H, 'd', 00H, 00H, 00H
	ORG $+2
$SG4294768015 DB 's', 00H, 'e', 00H, 'r', 00H, 'v', 00H, 'i', 00H, 'c', 00H
	DB	'e', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG4294768008 DB 'C', 00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, ' ', 00H
	DB	'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'n'
	DB	00H, 'd', 00H, ' ', 00H, 'a', 00H, 'n', 00H, 'y', 00H, ' ', 00H
	DB	's', 00H, 'e', 00H, 'r', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e'
	DB	00H, 's', 00H, ' ', 00H, 'i', 00H, 'n', 00H, ' ', 00H, 's', 00H
	DB	'e', 00H, 'r', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 's'
	DB	00H, '.', 00H, 'x', 00H, 'c', 00H, 'o', 00H, 'n', 00H, 'f', 00H
	DB	'i', 00H, 'g', 00H, 00H, 00H
$SG4294768009 DB 's', 00H, 'e', 00H, 'r', 00H, 'v', 00H, 'i', 00H, 'c', 00H
	DB	'e', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG4294768011 DB '%', 00H, 's', 00H, '\', 00H, 's', 00H, 'e', 00H, 'r', 00H
	DB	'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '.', 00H, 'x'
	DB	00H, 'c', 00H, 'o', 00H, 'n', 00H, 'f', 00H, 'i', 00H, 'g', 00H
	DB	00H, 00H
$SG4294768010 DB 'C', 00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, ' ', 00H
	DB	'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'p', 00H, 'e'
	DB	00H, 'n', 00H, ' ', 00H, 's', 00H, 'e', 00H, 'r', 00H, 'v', 00H
	DB	'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '.', 00H, 'x', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 'f', 00H, 'i', 00H, 'g', 00H, 00H, 00H
$SG4294768004 DB 'S', 00H, 'e', 00H, 'r', 00H, 'v', 00H, 'i', 00H, 'c', 00H
	DB	'e', 00H, 00H, 00H
$SG4294768005 DB 'C', 00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, ' ', 00H
	DB	'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'p', 00H, 'e'
	DB	00H, 'n', 00H, ' ', 00H, 's', 00H, 'e', 00H, 'r', 00H, 'v', 00H
	DB	'i', 00H, 'c', 00H, 'e', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, ' ', 00H, '''', 00H, '%', 00H, 's', 00H, '''', 00H
	DB	00H, 00H
	ORG $+2
$SG4294768006 DB '%', 00H, 's', 00H, '/', 00H, 's', 00H, 'e', 00H, 'r', 00H
	DB	'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '/', 00H, '%'
	DB	00H, 's', 00H, 00H, 00H
	ORG $+2
$SG4294768007 DB 'i', 00H, 'd', 00H, 00H, 00H
	ORG $+2
$SG4294768001 DB 'P', 00H, 'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 's', 00H
	DB	'h', 00H, 00H, 00H
$SG4294768002 DB 'S', 00H, 'e', 00H, 'r', 00H, 'v', 00H, 'i', 00H, 'c', 00H
	DB	'e', 00H, 'F', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 00H, 00H
$SG4294768003 DB 'P', 00H, 'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 's', 00H
	DB	'h', 00H, 00H, 00H
PUBLIC	??0ServiceIdentifier@@QAE@ABU0@@Z		; ServiceIdentifier::ServiceIdentifier
PUBLIC	??$construct@UServiceIdentifier@@U1@@?$allocator@UServiceIdentifier@@@std@@QAEXPAUServiceIdentifier@@$$QAU2@@Z ; std::allocator<ServiceIdentifier>::construct<ServiceIdentifier,ServiceIdentifier>
PUBLIC	??$construct@UServiceIdentifier@@U1@@?$allocator_traits@V?$allocator@UServiceIdentifier@@@std@@@std@@SAXAAV?$allocator@UServiceIdentifier@@@1@PAUServiceIdentifier@@$$QAU3@@Z ; std::allocator_traits<std::allocator<ServiceIdentifier> >::construct<ServiceIdentifier,ServiceIdentifier>
PUBLIC	??$construct@UServiceIdentifier@@U1@@?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@QAEXPAUServiceIdentifier@@$$QAU2@@Z ; std::_Wrap_alloc<std::allocator<ServiceIdentifier> >::construct<ServiceIdentifier,ServiceIdentifier>
PUBLIC	??_GServiceIdentifier@@QAEPAXI@Z		; ServiceIdentifier::`scalar deleting destructor'
PUBLIC	??$_Uninit_move@PAUServiceIdentifier@@PAU1@V?$allocator@UServiceIdentifier@@@std@@U1@@std@@YAPAUServiceIdentifier@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<ServiceIdentifier *,ServiceIdentifier *,std::allocator<ServiceIdentifier>,ServiceIdentifier>
PUBLIC	??$_Val_type@PAUServiceIdentifier@@@std@@YAPAUServiceIdentifier@@PAU1@@Z ; std::_Val_type<ServiceIdentifier *>
PUBLIC	??$destroy@UServiceIdentifier@@@?$allocator@UServiceIdentifier@@@std@@QAEXPAUServiceIdentifier@@@Z ; std::allocator<ServiceIdentifier>::destroy<ServiceIdentifier>
PUBLIC	??$_Rechecked@PAUServiceIdentifier@@PAU1@@std@@YAAAPAUServiceIdentifier@@AAPAU1@PAU1@@Z ; std::_Rechecked<ServiceIdentifier *,ServiceIdentifier *>
PUBLIC	??$_Uninit_move@PAUServiceIdentifier@@PAU1@U?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@@std@@YAPAUServiceIdentifier@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@0@@Z ; std::_Uninit_move<ServiceIdentifier *,ServiceIdentifier *,std::_Wrap_alloc<std::allocator<ServiceIdentifier> > >
PUBLIC	??$_Unchecked@PAUServiceIdentifier@@@std@@YAPAUServiceIdentifier@@PAU1@@Z ; std::_Unchecked<ServiceIdentifier *>
PUBLIC	??$destroy@UServiceIdentifier@@@?$allocator_traits@V?$allocator@UServiceIdentifier@@@std@@@std@@SAXAAV?$allocator@UServiceIdentifier@@@1@PAUServiceIdentifier@@@Z ; std::allocator_traits<std::allocator<ServiceIdentifier> >::destroy<ServiceIdentifier>
PUBLIC	??$construct@UServiceIdentifier@@HVString@@@?$allocator@UServiceIdentifier@@@std@@QAEXPAUServiceIdentifier@@$$QAH$$QAVString@@@Z ; std::allocator<ServiceIdentifier>::construct<ServiceIdentifier,int,String>
PUBLIC	??$_Uninitialized_move@PAUServiceIdentifier@@PAU1@U?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@@std@@YAPAUServiceIdentifier@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@0@@Z ; std::_Uninitialized_move<ServiceIdentifier *,ServiceIdentifier *,std::_Wrap_alloc<std::allocator<ServiceIdentifier> > >
PUBLIC	??$destroy@UServiceIdentifier@@@?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@QAEXPAUServiceIdentifier@@@Z ; std::_Wrap_alloc<std::allocator<ServiceIdentifier> >::destroy<ServiceIdentifier>
PUBLIC	??$construct@UServiceIdentifier@@HVString@@@?$allocator_traits@V?$allocator@UServiceIdentifier@@@std@@@std@@SAXAAV?$allocator@UServiceIdentifier@@@1@PAUServiceIdentifier@@$$QAH$$QAVString@@@Z ; std::allocator_traits<std::allocator<ServiceIdentifier> >::construct<ServiceIdentifier,int,String>
PUBLIC	??$_Allocate@UServiceIdentifier@@@std@@YAPAUServiceIdentifier@@IPAU1@@Z ; std::_Allocate<ServiceIdentifier>
PUBLIC	??$_Umove@PAUServiceIdentifier@@@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IAEPAUServiceIdentifier@@PAU2@00@Z ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::_Umove<ServiceIdentifier *>
PUBLIC	??$forward@U?$default_delete@VXConfig@@@std@@@std@@YA$$QAU?$default_delete@VXConfig@@@0@AAU10@@Z ; std::forward<std::default_delete<XConfig> >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@@std@@YAXPAUServiceIdentifier@@0AAU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ServiceIdentifier> > >
PUBLIC	??$_Ptr_cat@UServiceIdentifier@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUServiceIdentifier@@0@Z ; std::_Ptr_cat<ServiceIdentifier,ServiceIdentifier>
PUBLIC	??$forward@AAPAVXElement@@@std@@YAAAPAVXElement@@AAPAV1@@Z ; std::forward<XElement * &>
PUBLIC	??$?0V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$TX@?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$T@std@@QAE@$$QAV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@1@$$QA$$T@Z ; std::pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,std::nullptr_t>::pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,std::nullptr_t><std::unique_ptr<XConfig,std::default_delete<XConfig> >,std::nullptr_t,void>
PUBLIC	??$forward@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@@std@@YA$$QAV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@0@AAV10@@Z ; std::forward<std::unique_ptr<XConfig,std::default_delete<XConfig> > >
PUBLIC	??$construct@UServiceIdentifier@@HVString@@@?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@QAEXPAUServiceIdentifier@@$$QAH$$QAVString@@@Z ; std::_Wrap_alloc<std::allocator<ServiceIdentifier> >::construct<ServiceIdentifier,int,String>
PUBLIC	??$forward@VString@@@std@@YA$$QAVString@@AAV1@@Z ; std::forward<String>
PUBLIC	??$forward@H@std@@YA$$QAHAAH@Z			; std::forward<int>
PUBLIC	?max_size@?$allocator@UServiceIdentifier@@@std@@QBEIXZ ; std::allocator<ServiceIdentifier>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@UServiceIdentifier@@@std@@@std@@SAIABV?$allocator@UServiceIdentifier@@@2@@Z ; std::allocator_traits<std::allocator<ServiceIdentifier> >::max_size
PUBLIC	?allocate@?$allocator@UServiceIdentifier@@@std@@QAEPAUServiceIdentifier@@I@Z ; std::allocator<ServiceIdentifier>::allocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<ServiceIdentifier> >::max_size
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@QAEPAUServiceIdentifier@@I@Z ; std::_Wrap_alloc<std::allocator<ServiceIdentifier> >::allocate
PUBLIC	?capacity@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@QBEIXZ ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::capacity
PUBLIC	??0?$_Unique_ptr_base@VXConfig@@U?$default_delete@VXConfig@@@std@@$00@std@@QAE@PAVXConfig@@U?$default_delete@VXConfig@@@1@@Z ; std::_Unique_ptr_base<XConfig,std::default_delete<XConfig>,1>::_Unique_ptr_base<XConfig,std::default_delete<XConfig>,1>
PUBLIC	?release@?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QAEPAVXConfig@@XZ ; std::unique_ptr<XConfig,std::default_delete<XConfig> >::release
PUBLIC	?_Xlen@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IBEXXZ ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::_Xlen
PUBLIC	?_Reallocate@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IAEXI@Z ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::_Reallocate
PUBLIC	?_Grow_to@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IBEII@Z ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::_Grow_to
PUBLIC	?max_size@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@QBEIXZ ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::max_size
PUBLIC	?size@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@QBEIXZ ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::size
PUBLIC	?_Unused_capacity@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@QBEIXZ ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::_Unused_capacity
PUBLIC	??0?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QAE@$$QAV01@@Z ; std::unique_ptr<XConfig,std::default_delete<XConfig> >::unique_ptr<XConfig,std::default_delete<XConfig> >
PUBLIC	??0?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QAE@PAVXConfig@@@Z ; std::unique_ptr<XConfig,std::default_delete<XConfig> >::unique_ptr<XConfig,std::default_delete<XConfig> >
PUBLIC	?_Orphan_range@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IBEXPAUServiceIdentifier@@0@Z ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::_Orphan_range
PUBLIC	?_Reserve@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IAEXI@Z ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::_Reserve
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@@std@@YAXPAUServiceIdentifier@@0AAU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ServiceIdentifier> > >
PUBLIC	??$addressof@VXConfig@@@std@@YAPAVXConfig@@AAV1@@Z ; std::addressof<XConfig>
PUBLIC	??$forward@PAVXElement@@@std@@YA$$QAPAVXElement@@AAPAV1@@Z ; std::forward<XElement *>
PUBLIC	??$forward@UServiceIdentifier@@@std@@YA$$QAUServiceIdentifier@@AAU1@@Z ; std::forward<ServiceIdentifier>
PUBLIC	??$?0V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@X@?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@@std@@QAE@$$QAV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@1@$$QAPAVXElement@@@Z ; std::pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,XElement *>::pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,XElement *><std::unique_ptr<XConfig,std::default_delete<XConfig> >,XElement *,void>
PUBLIC	??$?0V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@AAPAVXElement@@X@?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@@std@@QAE@$$QAV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@1@AAPAVXElement@@@Z ; std::pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,XElement *>::pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,XElement *><std::unique_ptr<XConfig,std::default_delete<XConfig> >,XElement * &,void>
PUBLIC	??$move@AAV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@@std@@YA$$QAV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@0@AAV10@@Z ; std::move<std::unique_ptr<XConfig,std::default_delete<XConfig> > &>
PUBLIC	??$?0V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$TX@?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@@std@@QAE@$$QAU?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$T@1@@Z ; std::pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,XElement *>::pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,XElement *><std::unique_ptr<XConfig,std::default_delete<XConfig> >,std::nullptr_t,void>
PUBLIC	??$make_unique@VXConfig@@$$$V@std@@YA?AV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@0@XZ ; std::make_unique<XConfig>
PUBLIC	??$make_pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$T@std@@YA?AU?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$T@0@$$QAV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@0@$$QA$$T@Z ; std::make_pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,std::nullptr_t>
PUBLIC	??$emplace_back@HVString@@@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@QAEX$$QAH$$QAVString@@@Z ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::emplace_back<int,String>
PUBLIC	?deallocate@?$allocator@UServiceIdentifier@@@std@@QAEXPAUServiceIdentifier@@I@Z ; std::allocator<ServiceIdentifier>::deallocate
PUBLIC	??0?$default_delete@VXConfig@@@std@@QAE@XZ	; std::default_delete<XConfig>::default_delete<XConfig>
PUBLIC	?_Local@?$_Func_class@_NUServiceIdentifier@@PAVXElement@@@std@@ABE_NXZ ; std::_Func_class<bool,ServiceIdentifier,XElement *>::_Local
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UServiceIdentifier@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<ServiceIdentifier> >::_Vector_val<std::_Simple_types<ServiceIdentifier> >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@QAEXPAUServiceIdentifier@@I@Z ; std::_Wrap_alloc<std::allocator<ServiceIdentifier> >::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<ServiceIdentifier> >::_Wrap_alloc<std::allocator<ServiceIdentifier> >
PUBLIC	?_Destroy@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IAEXPAUServiceIdentifier@@0@Z ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::_Destroy
PUBLIC	?pointer_to@?$pointer_traits@PAVXConfig@@@std@@SAPAVXConfig@@AAV3@@Z ; std::pointer_traits<XConfig *>::pointer_to
PUBLIC	??0?$_Unique_ptr_base@VXConfig@@U?$default_delete@VXConfig@@@std@@$00@std@@QAE@PAVXConfig@@@Z ; std::_Unique_ptr_base<XConfig,std::default_delete<XConfig>,1>::_Unique_ptr_base<XConfig,std::default_delete<XConfig>,1>
PUBLIC	??D?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QBEAAVXConfig@@XZ ; std::unique_ptr<XConfig,std::default_delete<XConfig> >::operator*
PUBLIC	?_Tidy@?$_Func_class@_NUServiceIdentifier@@PAVXElement@@@std@@IAEXXZ ; std::_Func_class<bool,ServiceIdentifier,XElement *>::_Tidy
PUBLIC	??1?$_Func_class@_NUServiceIdentifier@@PAVXElement@@@std@@QAE@XZ ; std::_Func_class<bool,ServiceIdentifier,XElement *>::~_Func_class<bool,ServiceIdentifier,XElement *>
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<ServiceIdentifier,std::allocator<ServiceIdentifier> > >::_Getal
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@@std@@QAE@ABV?$allocator@UServiceIdentifier@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<ServiceIdentifier,std::allocator<ServiceIdentifier> > >::_Vector_alloc<0,std::_Vec_base_types<ServiceIdentifier,std::allocator<ServiceIdentifier> > >
PUBLIC	??0?$allocator@UServiceIdentifier@@@std@@QAE@XZ	; std::allocator<ServiceIdentifier>::allocator<ServiceIdentifier>
PUBLIC	?_Tidy@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IAEXXZ ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::_Tidy
PUBLIC	??C?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QBEPAVXConfig@@XZ ; std::unique_ptr<XConfig,std::default_delete<XConfig> >::operator->
PUBLIC	??0?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QAE@XZ ; std::unique_ptr<XConfig,std::default_delete<XConfig> >::unique_ptr<XConfig,std::default_delete<XConfig> >
PUBLIC	??R?$_Func_class@_NUServiceIdentifier@@PAVXElement@@@std@@QBE_NUServiceIdentifier@@PAVXElement@@@Z ; std::_Func_class<bool,ServiceIdentifier,XElement *>::operator()
PUBLIC	??1?$function@$$A6A_NUServiceIdentifier@@PAVXElement@@@Z@std@@QAE@XZ ; std::function<bool __cdecl(ServiceIdentifier,XElement *)>::~function<bool __cdecl(ServiceIdentifier,XElement *)>
PUBLIC	??1?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@QAE@XZ ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::~vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >
PUBLIC	??0?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@QAE@XZ ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >
PUBLIC	??1?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$T@std@@QAE@XZ ; std::pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,std::nullptr_t>::~pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,std::nullptr_t>
PUBLIC	?LoadService@@YA?AU?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@@std@@ABUServiceIdentifier@@PAVString@@@Z ; LoadService
PUBLIC	?EnumerateServices@@YAXV?$function@$$A6A_NUServiceIdentifier@@PAVXElement@@@Z@std@@@Z ; EnumerateServices
PUBLIC	??0ServiceIdentifier@@QAE@HVString@@@Z		; ServiceIdentifier::ServiceIdentifier
PUBLIC	?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z	; std::_Container_base0::_Swap_all
PUBLIC	?LoadService@@YA?AU?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@@std@@PAVString@@@Z ; LoadService
PUBLIC	?GetCurrentService@@YA?AUServiceIdentifier@@XZ	; GetCurrentService
	ALIGN	4

__Tuple_alloc DB 01H DUP (?)
	ALIGN	4

_ignore	DB	01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
	ALIGN	4

_piecewise_construct DB 01H DUP (?)
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Reallocate@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?_Reallocate@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IAEXI@Z$2
__catchsym$?_Reallocate@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IAEXI@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IAEXI@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Uninit_move@PAUServiceIdentifier@@PAU1@V?$allocator@UServiceIdentifier@@@std@@U1@@std@@YAPAUServiceIdentifier@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAUServiceIdentifier@@PAU1@V?$allocator@UServiceIdentifier@@@std@@U1@@std@@YAPAUServiceIdentifier@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAUServiceIdentifier@@PAU1@V?$allocator@UServiceIdentifier@@@std@@U1@@std@@YAPAUServiceIdentifier@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Uninit_move@PAUServiceIdentifier@@PAU1@V?$allocator@UServiceIdentifier@@@std@@U1@@std@@YAPAUServiceIdentifier@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_move@PAUServiceIdentifier@@PAU1@V?$allocator@UServiceIdentifier@@@std@@U1@@std@@YAPAUServiceIdentifier@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAUServiceIdentifier@@PAU1@V?$allocator@UServiceIdentifier@@@std@@U1@@std@@YAPAUServiceIdentifier@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
__catchsym$??$_Uninit_move@PAUServiceIdentifier@@PAU1@V?$allocator@UServiceIdentifier@@@std@@U1@@std@@YAPAUServiceIdentifier@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAUServiceIdentifier@@PAU1@V?$allocator@UServiceIdentifier@@@std@@U1@@std@@YAPAUServiceIdentifier@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
_ignore$initializer$ DD FLAT:??__Eignore@std@@YAXXZ
__Tuple_alloc$initializer$ DD FLAT:??__E_Tuple_alloc@std@@YAXXZ
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\service.cpp
;	COMDAT ?GetCurrentService@@YA?AUServiceIdentifier@@XZ
_TEXT	SEGMENT
_serviceFile$ = -12					; size = 8
_serviceID$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetCurrentService@@YA?AUServiceIdentifier@@XZ PROC	; GetCurrentService, COMDAT

; 184  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 185  :     int serviceID = AppConfig->GetInt(L"Publish", L"Service", 0);

	push	0
	push	OFFSET $SG4294768004
	push	OFFSET $SG4294768003
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _serviceID$[ebp], eax

; 186  :     String serviceFile = AppConfig->GetString(L"Publish", L"ServiceFile");

	push	0
	push	OFFSET $SG4294768002
	push	OFFSET $SG4294768001
	lea	eax, DWORD PTR _serviceFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetString@ConfigFile@@QAE?AVString@@PB_W00@Z

; 187  :     return { serviceID, serviceFile };

	sub	esp, 8
	mov	ecx, esp
	lea	edx, DWORD PTR _serviceFile$[ebp]
	push	edx
	call	DWORD PTR __imp_??0String@@QAE@ABV0@@Z
	mov	eax, DWORD PTR _serviceID$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0ServiceIdentifier@@QAE@HVString@@@Z	; ServiceIdentifier::ServiceIdentifier
	lea	ecx, DWORD PTR _serviceFile$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 188  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCurrentService@@YA?AUServiceIdentifier@@XZ ENDP	; GetCurrentService
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\service.cpp
;	COMDAT ?LoadService@@YA?AU?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@@std@@PAVString@@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_failReason$ = 12					; size = 4
?LoadService@@YA?AU?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@@std@@PAVString@@@Z PROC ; LoadService, COMDAT

; 179  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 180  :     return LoadService(GetCurrentService(), failReason);

	mov	eax, DWORD PTR _failReason$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	?GetCurrentService@@YA?AUServiceIdentifier@@XZ ; GetCurrentService
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	?LoadService@@YA?AU?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@@std@@ABUServiceIdentifier@@PAVString@@@Z ; LoadService
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ServiceIdentifier@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 181  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?LoadService@@YA?AU?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@@std@@PAVString@@@Z ENDP ; LoadService
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 70   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xutility
;	COMDAT ?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z PROC	; std::_Container_base0::_Swap_all, COMDAT
; _this$ = ecx

; 47   : 		{	// swap all iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 48   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z ENDP	; std::_Container_base0::_Swap_all
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3451 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\tuple
;	COMDAT ??__Eignore@std@@YAXXZ
text$di	SEGMENT
??__Eignore@std@@YAXXZ PROC				; std::`dynamic initializer for 'ignore'', COMDAT

; 59   : const _Ignore ignore;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET _ignore
	call	??0_Ignore@std@@QAE@XZ			; std::_Ignore::_Ignore
	pop	ebp
	ret	0
??__Eignore@std@@YAXXZ ENDP				; std::`dynamic initializer for 'ignore''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\tuple
;	COMDAT ??__E_Tuple_alloc@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__E_Tuple_alloc@std@@YAXXZ PROC			; std::`dynamic initializer for '_Tuple_alloc'', COMDAT

; 66   : const _Tuple_alloc_t _Tuple_alloc = _Tuple_alloc_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__E_Tuple_alloc@std@@YAXXZ ENDP			; std::`dynamic initializer for '_Tuple_alloc''
text$di	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ??0ServiceIdentifier@@QAE@HVString@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_id$ = 8						; size = 4
_file$ = 12						; size = 8
??0ServiceIdentifier@@QAE@HVString@@@Z PROC		; ServiceIdentifier::ServiceIdentifier, COMDAT
; _this$ = ecx

; 554  :     ServiceIdentifier(int id, String file) : id(id), file(file) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _id$[ebp]
	mov	DWORD PTR [eax], ecx
	lea	edx, DWORD PTR _file$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??0String@@QAE@ABV0@@Z
	lea	ecx, DWORD PTR _file$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0ServiceIdentifier@@QAE@HVString@@@Z ENDP		; ServiceIdentifier::ServiceIdentifier
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\service.cpp
;	COMDAT ?EnumerateBuiltinServices@@YA_NAAV?$function@$$A6A_NUServiceIdentifier@@PAVXElement@@@Z@std@@@Z
_TEXT	SEGMENT
_serverData$ = -40					; size = 12
$T1 = -28						; size = 8
_numServices$2 = -20					; size = 4
_service$3 = -16					; size = 4
_services$4 = -12					; size = 4
_i$5 = -8						; size = 4
$T6 = -3						; size = 1
$T7 = -2						; size = 1
$T8 = -1						; size = 1
_func$ = 8						; size = 4
?EnumerateBuiltinServices@@YA_NAAV?$function@$$A6A_NUServiceIdentifier@@PAVXElement@@@Z@std@@@Z PROC ; EnumerateBuiltinServices, COMDAT

; 81   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	esi

; 82   : 
; 83   :     XConfig serverData;

	lea	ecx, DWORD PTR _serverData$[ebp]
	call	DWORD PTR __imp_??0XConfig@@QAE@XZ

; 84   :     if (serverData.Open(FormattedString(L"%s\\services.xconfig", API->GetAppPath())))

	mov	eax, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+136]
	call	edx
	push	eax
	push	OFFSET $SG4294768016
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	lea	ecx, DWORD PTR _serverData$[ebp]
	call	DWORD PTR __imp_?Open@XConfig@@QAE_NPB_W@Z
	mov	BYTE PTR $T8[ebp], al
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	movzx	ecx, BYTE PTR $T8[ebp]
	test	ecx, ecx
	je	$LN7@EnumerateB

; 85   :     {
; 86   :         XElement *services = serverData.GetElement(TEXT("services"));

	push	OFFSET $SG4294768015
	lea	ecx, DWORD PTR _serverData$[ebp]
	call	DWORD PTR __imp_?GetElement@XConfig@@QAEPAVXElement@@PB_W@Z
	mov	DWORD PTR _services$4[ebp], eax

; 87   :         if (services)

	cmp	DWORD PTR _services$4[ebp], 0
	je	$LN7@EnumerateB

; 88   :         {
; 89   :             auto numServices = services->NumElements();

	push	0
	mov	ecx, DWORD PTR _services$4[ebp]
	call	DWORD PTR __imp_?NumElements@XElement@@QAEKPB_W@Z
	mov	DWORD PTR _numServices$2[ebp], eax

; 90   : 
; 91   :             for (decltype(numServices) i = 0; i < numServices; i++)

	mov	DWORD PTR _i$5[ebp], 0
	jmp	SHORT $LN5@EnumerateB
$LN4@EnumerateB:
	mov	edx, DWORD PTR _i$5[ebp]
	add	edx, 1
	mov	DWORD PTR _i$5[ebp], edx
$LN5@EnumerateB:
	mov	eax, DWORD PTR _i$5[ebp]
	cmp	eax, DWORD PTR _numServices$2[ebp]
	jae	SHORT $LN7@EnumerateB

; 92   :             {
; 93   :                 auto service = services->GetElementByID(i);

	mov	ecx, DWORD PTR _i$5[ebp]
	push	ecx
	mov	ecx, DWORD PTR _services$4[ebp]
	call	DWORD PTR __imp_?GetElementByID@XElement@@QBEPAV1@K@Z
	mov	DWORD PTR _service$3[ebp], eax

; 94   :                 if (!service)

	cmp	DWORD PTR _service$3[ebp], 0
	jne	SHORT $LN2@EnumerateB

; 95   :                     continue;

	jmp	SHORT $LN4@EnumerateB
$LN2@EnumerateB:

; 96   : 
; 97   :                 if (!func({ service->GetInt(L"id"), String() }, service))

	mov	edx, DWORD PTR _service$3[ebp]
	push	edx
	sub	esp, 12					; 0000000cH
	mov	esi, esp
	sub	esp, 8
	mov	ecx, esp
	call	DWORD PTR __imp_??0String@@QAE@XZ
	push	0
	push	OFFSET $SG4294768014
	mov	ecx, DWORD PTR _service$3[ebp]
	call	DWORD PTR __imp_?GetInt@XElement@@QBEHPB_WH@Z
	push	eax
	mov	ecx, esi
	call	??0ServiceIdentifier@@QAE@HVString@@@Z	; ServiceIdentifier::ServiceIdentifier
	mov	ecx, DWORD PTR _func$[ebp]
	call	??R?$_Func_class@_NUServiceIdentifier@@PAVXElement@@@std@@QBE_NUServiceIdentifier@@PAVXElement@@@Z ; std::_Func_class<bool,ServiceIdentifier,XElement *>::operator()
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@EnumerateB

; 98   :                     return false;

	mov	BYTE PTR $T7[ebp], 0
	lea	ecx, DWORD PTR _serverData$[ebp]
	call	DWORD PTR __imp_??1XConfig@@QAE@XZ
	mov	al, BYTE PTR $T7[ebp]
	jmp	SHORT $LN8@EnumerateB
$LN1@EnumerateB:

; 99   :             }

	jmp	SHORT $LN4@EnumerateB
$LN7@EnumerateB:

; 100  :         }
; 101  :     }
; 102  :     return true;

	mov	BYTE PTR $T6[ebp], 1
	lea	ecx, DWORD PTR _serverData$[ebp]
	call	DWORD PTR __imp_??1XConfig@@QAE@XZ
	mov	al, BYTE PTR $T6[ebp]
$LN8@EnumerateB:

; 103  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?EnumerateBuiltinServices@@YA_NAAV?$function@$$A6A_NUServiceIdentifier@@PAVXElement@@@Z@std@@@Z ENDP ; EnumerateBuiltinServices
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\service.cpp
;	COMDAT ?EnumerateUserServices@@YAXAAV?$function@$$A6A_NUServiceIdentifier@@PAVXElement@@@Z@std@@@Z
_TEXT	SEGMENT
$T1 = -572						; size = 8
$T2 = -564						; size = 8
_service$3 = -556					; size = 12
_servicesDir$ = -544					; size = 8
_find$4 = -536						; size = 4
_findData$ = -532					; size = 528
__$ArrayPad$ = -4					; size = 4
_func$ = 8						; size = 4
?EnumerateUserServices@@YAXAAV?$function@$$A6A_NUServiceIdentifier@@PAVXElement@@@Z@std@@@Z PROC ; EnumerateUserServices, COMDAT

; 106  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 572				; 0000023cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 107  :     OSFindData findData;
; 108  :     String servicesDir = FormattedString(L"%s/services/", API->GetAppDataPath());

	mov	eax, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+96]
	call	edx
	push	eax
	push	OFFSET $SG4294768013
	lea	eax, DWORD PTR _servicesDir$[ebp]
	push	eax
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 12					; 0000000cH

; 109  :     if (HANDLE find = OSFindFirstFile(FormattedString(L"%s/*.xconfig", servicesDir.Array()), findData))

	lea	ecx, DWORD PTR _findData$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _servicesDir$[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET $SG4294768012
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?OSFindFirstFile@@YGPAXPB_WAAUOSFindData@@@Z
	mov	DWORD PTR _find$4[ebp], eax
	lea	ecx, DWORD PTR $T2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	cmp	DWORD PTR _find$4[ebp], 0
	je	$LN6@EnumerateU
$LN5@EnumerateU:

; 110  :     {
; 111  :         do
; 112  :         {
; 113  :             if (findData.bDirectory)

	cmp	DWORD PTR _findData$[ebp+520], 0
	je	SHORT $LN2@EnumerateU

; 114  :                 continue;

	jmp	$LN4@EnumerateU
$LN2@EnumerateU:

; 115  : 
; 116  :             XConfig service(servicesDir + findData.fileName);

	lea	eax, DWORD PTR _findData$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _servicesDir$[ebp]
	call	DWORD PTR __imp_??HString@@QBE?AV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	lea	ecx, DWORD PTR _service$3[ebp]
	call	DWORD PTR __imp_??0XConfig@@QAE@PA_W@Z
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 117  :             if (!service.IsOpen())

	lea	ecx, DWORD PTR _service$3[ebp]
	call	DWORD PTR __imp_?IsOpen@XConfig@@QBE_NXZ
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN1@EnumerateU

; 118  :                 continue;

	lea	ecx, DWORD PTR _service$3[ebp]
	call	DWORD PTR __imp_??1XConfig@@QAE@XZ
	jmp	SHORT $LN4@EnumerateU
$LN1@EnumerateU:

; 119  : 
; 120  :             func({ 0, findData.fileName }, service.GetElementByID(0));

	push	0
	lea	ecx, DWORD PTR _service$3[ebp]
	call	DWORD PTR __imp_?GetElementByID@XConfig@@QAEPAVXElement@@K@Z
	push	eax
	sub	esp, 12					; 0000000cH
	mov	esi, esp
	sub	esp, 8
	mov	ecx, esp
	lea	eax, DWORD PTR _findData$[ebp]
	push	eax
	call	DWORD PTR __imp_??0String@@QAE@PB_W@Z
	push	0
	mov	ecx, esi
	call	??0ServiceIdentifier@@QAE@HVString@@@Z	; ServiceIdentifier::ServiceIdentifier
	mov	ecx, DWORD PTR _func$[ebp]
	call	??R?$_Func_class@_NUServiceIdentifier@@PAVXElement@@@std@@QBE_NUServiceIdentifier@@PAVXElement@@@Z ; std::_Func_class<bool,ServiceIdentifier,XElement *>::operator()

; 121  :         } while (OSFindNextFile(find, findData));

	lea	ecx, DWORD PTR _service$3[ebp]
	call	DWORD PTR __imp_??1XConfig@@QAE@XZ
$LN4@EnumerateU:
	lea	ecx, DWORD PTR _findData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _find$4[ebp]
	push	edx
	call	DWORD PTR __imp_?OSFindNextFile@@YGHPAXAAUOSFindData@@@Z
	test	eax, eax
	jne	$LN5@EnumerateU

; 122  : 
; 123  :         OSFindClose(find);

	mov	eax, DWORD PTR _find$4[ebp]
	push	eax
	call	DWORD PTR __imp_?OSFindClose@@YGXPAX@Z
$LN6@EnumerateU:

; 124  :     }
; 125  : }

	lea	ecx, DWORD PTR _servicesDir$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?EnumerateUserServices@@YAXAAV?$function@$$A6A_NUServiceIdentifier@@PAVXElement@@@Z@std@@@Z ENDP ; EnumerateUserServices
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\service.cpp
;	COMDAT ?EnumerateServices@@YAXV?$function@$$A6A_NUServiceIdentifier@@PAVXElement@@@Z@std@@@Z
_TEXT	SEGMENT
_func$ = 8						; size = 24
?EnumerateServices@@YAXV?$function@$$A6A_NUServiceIdentifier@@PAVXElement@@@Z@std@@@Z PROC ; EnumerateServices, COMDAT

; 128  : {

	push	ebp
	mov	ebp, esp

; 129  :     if (!EnumerateBuiltinServices(func))

	lea	eax, DWORD PTR _func$[ebp]
	push	eax
	call	?EnumerateBuiltinServices@@YA_NAAV?$function@$$A6A_NUServiceIdentifier@@PAVXElement@@@Z@std@@@Z ; EnumerateBuiltinServices
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@EnumerateS

; 130  :         return;

	lea	ecx, DWORD PTR _func$[ebp]
	call	??1?$function@$$A6A_NUServiceIdentifier@@PAVXElement@@@Z@std@@QAE@XZ ; std::function<bool __cdecl(ServiceIdentifier,XElement *)>::~function<bool __cdecl(ServiceIdentifier,XElement *)>
	jmp	SHORT $LN2@EnumerateS
$LN1@EnumerateS:

; 131  : 
; 132  :     EnumerateUserServices(func);

	lea	edx, DWORD PTR _func$[ebp]
	push	edx
	call	?EnumerateUserServices@@YAXAAV?$function@$$A6A_NUServiceIdentifier@@PAVXElement@@@Z@std@@@Z ; EnumerateUserServices
	add	esp, 4

; 133  : }

	lea	ecx, DWORD PTR _func$[ebp]
	call	??1?$function@$$A6A_NUServiceIdentifier@@PAVXElement@@@Z@std@@QAE@XZ ; std::function<bool __cdecl(ServiceIdentifier,XElement *)>::~function<bool __cdecl(ServiceIdentifier,XElement *)>
$LN2@EnumerateS:
	pop	ebp
	ret	0
?EnumerateServices@@YAXV?$function@$$A6A_NUServiceIdentifier@@PAVXElement@@@Z@std@@@Z ENDP ; EnumerateServices
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\service.cpp
;	COMDAT ?LoadService@@YA?AU?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@@std@@ABUServiceIdentifier@@PAVString@@@Z
_TEXT	SEGMENT
$T1 = -104						; size = 8
$T2 = -96						; size = 8
$T3 = -88						; size = 8
$T4 = -80						; size = 8
$T5 = -72						; size = 8
$T6 = -64						; size = 8
$T7 = -56						; size = 8
_service$8 = -48					; size = 4
$T9 = -44						; size = 4
$T10 = -40						; size = 4
$T11 = -36						; size = 4
_numServices$12 = -32					; size = 4
tv94 = -28						; size = 4
_fail$ = -24						; size = 4
_curService$13 = -20					; size = 4
_services$14 = -16					; size = 4
_i$15 = -12						; size = 4
_serverData$ = -8					; size = 4
$T16 = -2						; size = 1
$T17 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
_sid$ = 12						; size = 4
_failReason$ = 16					; size = 4
?LoadService@@YA?AU?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@@std@@ABUServiceIdentifier@@PAVString@@@Z PROC ; LoadService, COMDAT

; 136  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H

; 137  :     auto fail = [&](CTSTR reason)
; 138  :     {
; 139  :         if (failReason)
; 140  :             *failReason = reason;
; 141  :         return make_pair(std::unique_ptr<XConfig>(), nullptr);
; 142  :     };

	lea	eax, DWORD PTR _failReason$[ebp]
	push	eax
	lea	ecx, DWORD PTR _fail$[ebp]
	call	??0<lambda_c2800ca3190b25d5e8b9cf08fb3c61da>@@QAE@AAPAVString@@@Z ; <lambda_c2800ca3190b25d5e8b9cf08fb3c61da>::<lambda_c2800ca3190b25d5e8b9cf08fb3c61da>

; 143  : 
; 144  :     auto serverData = make_unique<XConfig>();

	lea	ecx, DWORD PTR _serverData$[ebp]
	push	ecx
	call	??$make_unique@VXConfig@@$$$V@std@@YA?AV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@0@XZ ; std::make_unique<XConfig>
	add	esp, 4

; 145  : 
; 146  :     if (sid.file.IsEmpty())

	mov	ecx, DWORD PTR _sid$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_?IsEmpty@String@@QBEHXZ
	test	eax, eax
	je	$LN11@LoadServic

; 147  :     {
; 148  :         if (!serverData->Open(FormattedString(L"%s\\services.xconfig", API->GetAppPath())))

	mov	edx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+136]
	call	eax
	push	eax
	push	OFFSET $SG4294768011
	lea	ecx, DWORD PTR $T7[ebp]
	push	ecx
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	lea	ecx, DWORD PTR _serverData$[ebp]
	call	??C?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QBEPAVXConfig@@XZ ; std::unique_ptr<XConfig,std::default_delete<XConfig> >::operator->
	mov	ecx, eax
	call	DWORD PTR __imp_?Open@XConfig@@QAE_NPB_W@Z
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN14@LoadServic
	mov	DWORD PTR tv94[ebp], 1
	jmp	SHORT $LN15@LoadServic
$LN14@LoadServic:
	mov	DWORD PTR tv94[ebp], 0
$LN15@LoadServic:
	mov	al, BYTE PTR tv94[ebp]
	mov	BYTE PTR $T17[ebp], al
	lea	ecx, DWORD PTR $T7[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	movzx	ecx, BYTE PTR $T17[ebp]
	test	ecx, ecx
	je	SHORT $LN10@LoadServic

; 149  :             return fail(L"Could not open services.xconfig");

	push	OFFSET $SG4294768010
	lea	edx, DWORD PTR $T6[ebp]
	push	edx
	lea	ecx, DWORD PTR _fail$[ebp]
	call	??R<lambda_c2800ca3190b25d5e8b9cf08fb3c61da>@@QBE?AU?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$T@std@@PB_W@Z ; <lambda_c2800ca3190b25d5e8b9cf08fb3c61da>::operator()
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??$?0V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$TX@?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@@std@@QAE@$$QAU?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$T@1@@Z ; std::pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,XElement *>::pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,XElement *><std::unique_ptr<XConfig,std::default_delete<XConfig> >,std::nullptr_t,void>
	lea	ecx, DWORD PTR $T6[ebp]
	call	??1?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$T@std@@QAE@XZ
	lea	ecx, DWORD PTR _serverData$[ebp]
	call	??1?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QAE@XZ ; std::unique_ptr<XConfig,std::default_delete<XConfig> >::~unique_ptr<XConfig,std::default_delete<XConfig> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN12@LoadServic
$LN10@LoadServic:

; 150  : 
; 151  :         XElement *services = serverData->GetElement(TEXT("services"));

	push	OFFSET $SG4294768009
	lea	ecx, DWORD PTR _serverData$[ebp]
	call	??C?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QBEPAVXConfig@@XZ ; std::unique_ptr<XConfig,std::default_delete<XConfig> >::operator->
	mov	ecx, eax
	call	DWORD PTR __imp_?GetElement@XConfig@@QAEPAVXElement@@PB_W@Z
	mov	DWORD PTR _services$14[ebp], eax

; 152  :         if (!services)

	cmp	DWORD PTR _services$14[ebp], 0
	jne	SHORT $LN9@LoadServic

; 153  :             return fail(L"Could not find any services in services.xconfig");

	push	OFFSET $SG4294768008
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	lea	ecx, DWORD PTR _fail$[ebp]
	call	??R<lambda_c2800ca3190b25d5e8b9cf08fb3c61da>@@QBE?AU?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$T@std@@PB_W@Z ; <lambda_c2800ca3190b25d5e8b9cf08fb3c61da>::operator()
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??$?0V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$TX@?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@@std@@QAE@$$QAU?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$T@1@@Z ; std::pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,XElement *>::pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,XElement *><std::unique_ptr<XConfig,std::default_delete<XConfig> >,std::nullptr_t,void>
	lea	ecx, DWORD PTR $T5[ebp]
	call	??1?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$T@std@@QAE@XZ
	lea	ecx, DWORD PTR _serverData$[ebp]
	call	??1?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QAE@XZ ; std::unique_ptr<XConfig,std::default_delete<XConfig> >::~unique_ptr<XConfig,std::default_delete<XConfig> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN12@LoadServic
$LN9@LoadServic:

; 154  : 
; 155  :         XElement *service = NULL;

	mov	DWORD PTR _service$8[ebp], 0

; 156  :         auto numServices = services->NumElements();

	push	0
	mov	ecx, DWORD PTR _services$14[ebp]
	call	DWORD PTR __imp_?NumElements@XElement@@QAEKPB_W@Z
	mov	DWORD PTR _numServices$12[ebp], eax

; 157  :         for (decltype(numServices) i = 0; i < numServices; i++)

	mov	DWORD PTR _i$15[ebp], 0
	jmp	SHORT $LN8@LoadServic
$LN7@LoadServic:
	mov	ecx, DWORD PTR _i$15[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$15[ebp], ecx
$LN8@LoadServic:
	mov	edx, DWORD PTR _i$15[ebp]
	cmp	edx, DWORD PTR _numServices$12[ebp]
	jae	SHORT $LN6@LoadServic

; 158  :         {
; 159  :             XElement *curService = services->GetElementByID(i);

	mov	eax, DWORD PTR _i$15[ebp]
	push	eax
	mov	ecx, DWORD PTR _services$14[ebp]
	call	DWORD PTR __imp_?GetElementByID@XElement@@QBEPAV1@K@Z
	mov	DWORD PTR _curService$13[ebp], eax

; 160  :             if (!curService)

	cmp	DWORD PTR _curService$13[ebp], 0
	jne	SHORT $LN5@LoadServic

; 161  :                 continue;

	jmp	SHORT $LN7@LoadServic
$LN5@LoadServic:

; 162  : 
; 163  :             if (curService->GetInt(L"id") == sid.id)

	push	0
	push	OFFSET $SG4294768007
	mov	ecx, DWORD PTR _curService$13[ebp]
	call	DWORD PTR __imp_?GetInt@XElement@@QBEHPB_WH@Z
	mov	ecx, DWORD PTR _sid$[ebp]
	cmp	eax, DWORD PTR [ecx]
	jne	SHORT $LN4@LoadServic

; 164  :                 return { move(serverData), curService };

	lea	edx, DWORD PTR _curService$13[ebp]
	push	edx
	lea	eax, DWORD PTR _serverData$[ebp]
	push	eax
	call	??$move@AAV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@@std@@YA$$QAV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@0@AAV10@@Z ; std::move<std::unique_ptr<XConfig,std::default_delete<XConfig> > &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??$?0V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@AAPAVXElement@@X@?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@@std@@QAE@$$QAV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@1@AAPAVXElement@@@Z ; std::pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,XElement *>::pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,XElement *><std::unique_ptr<XConfig,std::default_delete<XConfig> >,XElement * &,void>
	lea	ecx, DWORD PTR _serverData$[ebp]
	call	??1?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QAE@XZ ; std::unique_ptr<XConfig,std::default_delete<XConfig> >::~unique_ptr<XConfig,std::default_delete<XConfig> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN12@LoadServic
$LN4@LoadServic:

; 165  :         }

	jmp	SHORT $LN7@LoadServic
$LN6@LoadServic:

; 166  :     }
; 167  :     else

	jmp	$LN3@LoadServic
$LN11@LoadServic:

; 168  :     {
; 169  :         if (serverData->Open(FormattedString(L"%s/services/%s", API->GetAppDataPath(), sid.file.Array())))

	mov	ecx, DWORD PTR _sid$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	mov	ecx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+96]
	call	eax
	push	eax
	push	OFFSET $SG4294768006
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 16					; 00000010H
	mov	ecx, eax
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	lea	ecx, DWORD PTR _serverData$[ebp]
	call	??C?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QBEPAVXConfig@@XZ ; std::unique_ptr<XConfig,std::default_delete<XConfig> >::operator->
	mov	ecx, eax
	call	DWORD PTR __imp_?Open@XConfig@@QAE_NPB_W@Z
	mov	BYTE PTR $T16[ebp], al
	lea	ecx, DWORD PTR $T4[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	movzx	edx, BYTE PTR $T16[ebp]
	test	edx, edx
	je	SHORT $LN2@LoadServic

; 170  :             return { move(serverData), serverData->GetElementByID(sid.id) };

	mov	eax, DWORD PTR _sid$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR _serverData$[ebp]
	call	??C?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QBEPAVXConfig@@XZ ; std::unique_ptr<XConfig,std::default_delete<XConfig> >::operator->
	mov	ecx, eax
	call	DWORD PTR __imp_?GetElementByID@XConfig@@QAEPAVXElement@@K@Z
	mov	DWORD PTR $T11[ebp], eax
	lea	edx, DWORD PTR $T11[ebp]
	push	edx
	lea	eax, DWORD PTR _serverData$[ebp]
	push	eax
	call	??$move@AAV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@@std@@YA$$QAV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@0@AAV10@@Z ; std::move<std::unique_ptr<XConfig,std::default_delete<XConfig> > &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??$?0V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@X@?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@@std@@QAE@$$QAV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@1@$$QAPAVXElement@@@Z ; std::pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,XElement *>::pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,XElement *><std::unique_ptr<XConfig,std::default_delete<XConfig> >,XElement *,void>
	lea	ecx, DWORD PTR _serverData$[ebp]
	call	??1?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QAE@XZ ; std::unique_ptr<XConfig,std::default_delete<XConfig> >::~unique_ptr<XConfig,std::default_delete<XConfig> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN12@LoadServic

; 171  :         else

	jmp	SHORT $LN3@LoadServic
$LN2@LoadServic:

; 172  :             return fail(FormattedString(L"Could not open service file '%s'", sid.file.Array()));

	mov	ecx, DWORD PTR _sid$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET $SG4294768005
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	lea	ecx, DWORD PTR _fail$[ebp]
	call	??R<lambda_c2800ca3190b25d5e8b9cf08fb3c61da>@@QBE?AU?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$T@std@@PB_W@Z ; <lambda_c2800ca3190b25d5e8b9cf08fb3c61da>::operator()
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??$?0V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$TX@?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@@std@@QAE@$$QAU?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$T@1@@Z ; std::pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,XElement *>::pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,XElement *><std::unique_ptr<XConfig,std::default_delete<XConfig> >,std::nullptr_t,void>
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$T@std@@QAE@XZ
	lea	ecx, DWORD PTR $T2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _serverData$[ebp]
	call	??1?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QAE@XZ ; std::unique_ptr<XConfig,std::default_delete<XConfig> >::~unique_ptr<XConfig,std::default_delete<XConfig> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN12@LoadServic
$LN3@LoadServic:

; 173  :     }
; 174  : 
; 175  :     return make_pair(std::unique_ptr<XConfig>(), nullptr);

	mov	DWORD PTR $T10[ebp], 0
	lea	eax, DWORD PTR $T10[ebp]
	push	eax
	lea	ecx, DWORD PTR $T9[ebp]
	call	??0?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QAE@XZ ; std::unique_ptr<XConfig,std::default_delete<XConfig> >::unique_ptr<XConfig,std::default_delete<XConfig> >
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??$make_pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$T@std@@YA?AU?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$T@0@$$QAV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@0@$$QA$$T@Z ; std::make_pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,std::nullptr_t>
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??$?0V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$TX@?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@@std@@QAE@$$QAU?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$T@1@@Z ; std::pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,XElement *>::pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,XElement *><std::unique_ptr<XConfig,std::default_delete<XConfig> >,std::nullptr_t,void>
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$T@std@@QAE@XZ
	lea	ecx, DWORD PTR $T9[ebp]
	call	??1?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QAE@XZ ; std::unique_ptr<XConfig,std::default_delete<XConfig> >::~unique_ptr<XConfig,std::default_delete<XConfig> >
	lea	ecx, DWORD PTR _serverData$[ebp]
	call	??1?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QAE@XZ ; std::unique_ptr<XConfig,std::default_delete<XConfig> >::~unique_ptr<XConfig,std::default_delete<XConfig> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN12@LoadServic:

; 176  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?LoadService@@YA?AU?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@@std@@ABUServiceIdentifier@@PAVString@@@Z ENDP ; LoadService
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\service.cpp
;	COMDAT ??0<lambda_c2800ca3190b25d5e8b9cf08fb3c61da>@@QAE@AAPAVString@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___failReason$ = 8					; size = 4
??0<lambda_c2800ca3190b25d5e8b9cf08fb3c61da>@@QAE@AAPAVString@@@Z PROC ; <lambda_c2800ca3190b25d5e8b9cf08fb3c61da>::<lambda_c2800ca3190b25d5e8b9cf08fb3c61da>, COMDAT
; _this$ = ecx

; 142  :     };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___failReason$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0<lambda_c2800ca3190b25d5e8b9cf08fb3c61da>@@QAE@AAPAVString@@@Z ENDP ; <lambda_c2800ca3190b25d5e8b9cf08fb3c61da>::<lambda_c2800ca3190b25d5e8b9cf08fb3c61da>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\service.cpp
;	COMDAT ??R<lambda_c2800ca3190b25d5e8b9cf08fb3c61da>@@QBE?AU?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$T@std@@PB_W@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_reason$ = 12						; size = 4
??R<lambda_c2800ca3190b25d5e8b9cf08fb3c61da>@@QBE?AU?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$T@std@@PB_W@Z PROC ; <lambda_c2800ca3190b25d5e8b9cf08fb3c61da>::operator(), COMDAT
; _this$ = ecx

; 138  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 139  :         if (failReason)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN1@operator

; 140  :             *failReason = reason;

	mov	edx, DWORD PTR _reason$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z
$LN1@operator:

; 141  :         return make_pair(std::unique_ptr<XConfig>(), nullptr);

	mov	DWORD PTR $T2[ebp], 0
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QAE@XZ ; std::unique_ptr<XConfig,std::default_delete<XConfig> >::unique_ptr<XConfig,std::default_delete<XConfig> >
	push	eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??$make_pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$T@std@@YA?AU?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$T@0@$$QAV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@0@$$QA$$T@Z ; std::make_pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,std::nullptr_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QAE@XZ ; std::unique_ptr<XConfig,std::default_delete<XConfig> >::~unique_ptr<XConfig,std::default_delete<XConfig> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 142  :     };

	mov	esp, ebp
	pop	ebp
	ret	8
??R<lambda_c2800ca3190b25d5e8b9cf08fb3c61da>@@QBE?AU?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$T@std@@PB_W@Z ENDP ; <lambda_c2800ca3190b25d5e8b9cf08fb3c61da>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$T@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$T@std@@QAE@XZ PROC ; std::pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,std::nullptr_t>::~pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,std::nullptr_t>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QAE@XZ ; std::unique_ptr<XConfig,std::default_delete<XConfig> >::~unique_ptr<XConfig,std::default_delete<XConfig> >
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$T@std@@QAE@XZ ENDP ; std::pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,std::nullptr_t>::~pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ??0?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
??0?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@QAE@XZ PROC ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >, COMDAT
; _this$ = ecx

; 680  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@UServiceIdentifier@@@std@@QAE@XZ ; std::allocator<ServiceIdentifier>::allocator<ServiceIdentifier>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@@std@@QAE@ABV?$allocator@UServiceIdentifier@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<ServiceIdentifier,std::allocator<ServiceIdentifier> > >::_Vector_alloc<0,std::_Vec_base_types<ServiceIdentifier,std::allocator<ServiceIdentifier> > >

; 681  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@QAE@XZ ENDP ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ??1?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@QAE@XZ PROC ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::~vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 945  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IAEXXZ ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::_Tidy

; 946  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@QAE@XZ ENDP ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::~vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??1?$function@$$A6A_NUServiceIdentifier@@PAVXElement@@@Z@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$function@$$A6A_NUServiceIdentifier@@PAVXElement@@@Z@std@@QAE@XZ PROC ; std::function<bool __cdecl(ServiceIdentifier,XElement *)>::~function<bool __cdecl(ServiceIdentifier,XElement *)>, COMDAT
; _this$ = ecx

; 628  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 629  : 		this->_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Func_class@_NUServiceIdentifier@@PAVXElement@@@std@@IAEXXZ ; std::_Func_class<bool,ServiceIdentifier,XElement *>::_Tidy

; 630  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Func_class@_NUServiceIdentifier@@PAVXElement@@@std@@QAE@XZ ; std::_Func_class<bool,ServiceIdentifier,XElement *>::~_Func_class<bool,ServiceIdentifier,XElement *>
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$function@$$A6A_NUServiceIdentifier@@PAVXElement@@@Z@std@@QAE@XZ ENDP ; std::function<bool __cdecl(ServiceIdentifier,XElement *)>::~function<bool __cdecl(ServiceIdentifier,XElement *)>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??R?$_Func_class@_NUServiceIdentifier@@PAVXElement@@@std@@QBE_NUServiceIdentifier@@PAVXElement@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
_<_Args_0>$ = 8						; size = 12
_<_Args_1>$ = 20					; size = 4
??R?$_Func_class@_NUServiceIdentifier@@PAVXElement@@@std@@QBE_NUServiceIdentifier@@PAVXElement@@@Z PROC ; std::_Func_class<bool,ServiceIdentifier,XElement *>::operator(), COMDAT
; _this$ = ecx

; 312  : 		{	// call through stored object

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 313  : 		if (_Impl == 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN1@operator

; 314  : 			_Xbad_function_call();

	call	?_Xbad_function_call@std@@YAXXZ		; std::_Xbad_function_call
$LN1@operator:

; 315  : 		return (_Impl->_Do_call(_STD forward<_Types>(_Args)...));

	lea	ecx, DWORD PTR _<_Args_1>$[ebp]
	push	ecx
	call	??$forward@PAVXElement@@@std@@YA$$QAPAVXElement@@AAPAV1@@Z ; std::forward<XElement *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR _<_Args_0>$[ebp]
	push	edx
	call	??$forward@UServiceIdentifier@@@std@@YA$$QAUServiceIdentifier@@AAU1@@Z ; std::forward<ServiceIdentifier>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+16]
	mov	edx, DWORD PTR [eax+8]
	call	edx
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _<_Args_0>$[ebp]
	call	??1ServiceIdentifier@@QAE@XZ
	mov	al, BYTE PTR $T1[ebp]
$LN3@operator:

; 316  : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??R?$_Func_class@_NUServiceIdentifier@@PAVXElement@@@std@@QBE_NUServiceIdentifier@@PAVXElement@@@Z ENDP ; std::_Func_class<bool,ServiceIdentifier,XElement *>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ??0?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QAE@XZ PROC ; std::unique_ptr<XConfig,std::default_delete<XConfig> >::unique_ptr<XConfig,std::default_delete<XConfig> >, COMDAT
; _this$ = ecx

; 1345 : 		{	// default construct

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Unique_ptr_base@VXConfig@@U?$default_delete@VXConfig@@@std@@$00@std@@QAE@PAVXConfig@@@Z ; std::_Unique_ptr_base<XConfig,std::default_delete<XConfig>,1>::_Unique_ptr_base<XConfig,std::default_delete<XConfig>,1>

; 1346 : 		static_assert(!is_pointer<_Dx>::value,
; 1347 : 			"unique_ptr constructed with null deleter pointer");
; 1348 : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QAE@XZ ENDP ; std::unique_ptr<XConfig,std::default_delete<XConfig> >::unique_ptr<XConfig,std::default_delete<XConfig> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ??C?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QBEPAVXConfig@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??C?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QBEPAVXConfig@@XZ PROC ; std::unique_ptr<XConfig,std::default_delete<XConfig> >::operator->, COMDAT
; _this$ = ecx

; 1457 : 		{	// return pointer to class object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1458 : 		return (_STD pointer_traits<pointer>::pointer_to(**this));

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QBEAAVXConfig@@XZ ; std::unique_ptr<XConfig,std::default_delete<XConfig> >::operator*
	push	eax
	call	?pointer_to@?$pointer_traits@PAVXConfig@@@std@@SAPAVXConfig@@AAV3@@Z ; std::pointer_traits<XConfig *>::pointer_to
	add	esp, 4

; 1459 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??C?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QBEPAVXConfig@@XZ ENDP ; std::unique_ptr<XConfig,std::default_delete<XConfig> >::operator->
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ?_Tidy@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Tidy@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IAEXXZ PROC ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1623 : 		if (this->_Myfirst != pointer())

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Tidy

; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IAEXPAUServiceIdentifier@@0@Z ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::_Destroy

; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax]
	mov	eax, ecx
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<ServiceIdentifier,std::allocator<ServiceIdentifier> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@QAEXPAUServiceIdentifier@@I@Z ; std::_Wrap_alloc<std::allocator<ServiceIdentifier> >::deallocate

; 1629 : 			this->_Myfirst = pointer();

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 0

; 1630 : 			this->_Mylast = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 1631 : 			this->_Myend = pointer();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
$LN2@Tidy:

; 1632 : 			}
; 1633 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IAEXXZ ENDP ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??0?$allocator@UServiceIdentifier@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@UServiceIdentifier@@@std@@QAE@XZ PROC	; std::allocator<ServiceIdentifier>::allocator<ServiceIdentifier>, COMDAT
; _this$ = ecx

; 552  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@UServiceIdentifier@@@std@@QAE@XZ ENDP	; std::allocator<ServiceIdentifier>::allocator<ServiceIdentifier>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@@std@@QAE@ABV?$allocator@UServiceIdentifier@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@@std@@QAE@ABV?$allocator@UServiceIdentifier@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<ServiceIdentifier,std::allocator<ServiceIdentifier> > >::_Vector_alloc<0,std::_Vec_base_types<ServiceIdentifier,std::allocator<ServiceIdentifier> > >, COMDAT
; _this$ = ecx

; 588  : 	_Vector_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@U?$_Simple_types@UServiceIdentifier@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<ServiceIdentifier> >::_Vector_val<std::_Simple_types<ServiceIdentifier> >

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@@std@@QAE@ABV?$allocator@UServiceIdentifier@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<ServiceIdentifier,std::allocator<ServiceIdentifier> > >::_Vector_alloc<0,std::_Vec_base_types<ServiceIdentifier,std::allocator<ServiceIdentifier> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<ServiceIdentifier,std::allocator<ServiceIdentifier> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<ServiceIdentifier> >::_Wrap_alloc<std::allocator<ServiceIdentifier> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<ServiceIdentifier,std::allocator<ServiceIdentifier> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??1?$_Func_class@_NUServiceIdentifier@@PAVXElement@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Func_class@_NUServiceIdentifier@@PAVXElement@@@std@@QAE@XZ PROC ; std::_Func_class<bool,ServiceIdentifier,XElement *>::~_Func_class<bool,ServiceIdentifier,XElement *>, COMDAT
; _this$ = ecx

; 324  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 325  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Func_class@_NUServiceIdentifier@@PAVXElement@@@std@@IAEXXZ ; std::_Func_class<bool,ServiceIdentifier,XElement *>::_Tidy

; 326  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Func_class@_NUServiceIdentifier@@PAVXElement@@@std@@QAE@XZ ENDP ; std::_Func_class<bool,ServiceIdentifier,XElement *>::~_Func_class<bool,ServiceIdentifier,XElement *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ?_Tidy@?$_Func_class@_NUServiceIdentifier@@PAVXElement@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv77 = -1						; size = 1
?_Tidy@?$_Func_class@_NUServiceIdentifier@@PAVXElement@@@std@@IAEXXZ PROC ; std::_Func_class<bool,ServiceIdentifier,XElement *>::_Tidy, COMDAT
; _this$ = ecx

; 446  : 		{	// clean up

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 447  : 		if (_Impl != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN2@Tidy

; 448  : 			{	// destroy callable object and maybe delete it
; 449  : 			_Impl->_Delete_this(!_Local());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Local@?$_Func_class@_NUServiceIdentifier@@PAVXElement@@@std@@ABE_NXZ ; std::_Func_class<bool,ServiceIdentifier,XElement *>::_Local
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN4@Tidy
	mov	BYTE PTR tv77[ebp], 1
	jmp	SHORT $LN5@Tidy
$LN4@Tidy:
	mov	BYTE PTR tv77[ebp], 0
$LN5@Tidy:
	movzx	edx, BYTE PTR tv77[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+16]
	mov	edx, DWORD PTR [eax+16]
	call	edx

; 450  : 			_Impl = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0
$LN2@Tidy:

; 451  : 			}
; 452  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$_Func_class@_NUServiceIdentifier@@PAVXElement@@@std@@IAEXXZ ENDP ; std::_Func_class<bool,ServiceIdentifier,XElement *>::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ??D?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QBEAAVXConfig@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QBEAAVXConfig@@XZ PROC ; std::unique_ptr<XConfig,std::default_delete<XConfig> >::operator*, COMDAT
; _this$ = ecx

; 1452 : 		{	// return reference to object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1453 : 		return (*this->_Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 1454 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??D?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QBEAAVXConfig@@XZ ENDP ; std::unique_ptr<XConfig,std::default_delete<XConfig> >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ??0?$_Unique_ptr_base@VXConfig@@U?$default_delete@VXConfig@@@std@@$00@std@@QAE@PAVXConfig@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0?$_Unique_ptr_base@VXConfig@@U?$default_delete@VXConfig@@@std@@$00@std@@QAE@PAVXConfig@@@Z PROC ; std::_Unique_ptr_base<XConfig,std::default_delete<XConfig>,1>::_Unique_ptr_base<XConfig,std::default_delete<XConfig>,1>, COMDAT
; _this$ = ecx

; 1295 : 		{	// construct with pointer and deleter

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$default_delete@VXConfig@@@std@@QAE@XZ ; std::default_delete<XConfig>::default_delete<XConfig>
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [eax], ecx

; 1296 : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Unique_ptr_base@VXConfig@@U?$default_delete@VXConfig@@@std@@$00@std@@QAE@PAVXConfig@@@Z ENDP ; std::_Unique_ptr_base<XConfig,std::default_delete<XConfig>,1>::_Unique_ptr_base<XConfig,std::default_delete<XConfig>,1>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PAVXConfig@@@std@@SAPAVXConfig@@AAV3@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?pointer_to@?$pointer_traits@PAVXConfig@@@std@@SAPAVXConfig@@AAV3@@Z PROC ; std::pointer_traits<XConfig *>::pointer_to, COMDAT

; 233  : 		{	// convert raw reference to pointer

	push	ebp
	mov	ebp, esp

; 234  : 		return (_STD addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$addressof@VXConfig@@@std@@YAPAVXConfig@@AAV1@@Z ; std::addressof<XConfig>
	add	esp, 4

; 235  : 		}

	pop	ebp
	ret	0
?pointer_to@?$pointer_traits@PAVXConfig@@@std@@SAPAVXConfig@@AAV3@@Z ENDP ; std::pointer_traits<XConfig *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ?_Destroy@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IAEXPAUServiceIdentifier@@0@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Alval$ = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IAEXPAUServiceIdentifier@@0@Z PROC ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::_Destroy, COMDAT
; _this$ = ecx

; 1565 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1566 : 		_Alty _Alval(this->_Getal());

	lea	eax, DWORD PTR __Alval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<ServiceIdentifier,std::allocator<ServiceIdentifier> > >::_Getal

; 1567 : 		_Destroy_range(_First, _Last, _Alval);

	lea	ecx, DWORD PTR __Alval$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@@std@@YAXPAUServiceIdentifier@@0AAU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ServiceIdentifier> > >
	add	esp, 12					; 0000000cH

; 1568 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IAEXPAUServiceIdentifier@@0@Z ENDP ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<ServiceIdentifier> >::_Wrap_alloc<std::allocator<ServiceIdentifier> >, COMDAT
; _this$ = ecx

; 801  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@UServiceIdentifier@@@std@@QAE@XZ ; std::allocator<ServiceIdentifier>::allocator<ServiceIdentifier>

; 802  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<ServiceIdentifier> >::_Wrap_alloc<std::allocator<ServiceIdentifier> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@QAEXPAUServiceIdentifier@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@QAEXPAUServiceIdentifier@@I@Z PROC ; std::_Wrap_alloc<std::allocator<ServiceIdentifier> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@UServiceIdentifier@@@std@@QAEXPAUServiceIdentifier@@I@Z ; std::allocator<ServiceIdentifier>::deallocate

; 859  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@QAEXPAUServiceIdentifier@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<ServiceIdentifier> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UServiceIdentifier@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_val@U?$_Simple_types@UServiceIdentifier@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<ServiceIdentifier> >::_Vector_val<std::_Simple_types<ServiceIdentifier> >, COMDAT
; _this$ = ecx

; 480  : 	_Vector_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 483  : 		_Mylast = pointer();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 485  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Vector_val@U?$_Simple_types@UServiceIdentifier@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<ServiceIdentifier> >::_Vector_val<std::_Simple_types<ServiceIdentifier> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ?_Local@?$_Func_class@_NUServiceIdentifier@@PAVXElement@@@std@@ABE_NXZ
_TEXT	SEGMENT
tv67 = -8						; size = 4
_this$ = -4						; size = 4
?_Local@?$_Func_class@_NUServiceIdentifier@@PAVXElement@@@std@@ABE_NXZ PROC ; std::_Func_class<bool,ServiceIdentifier,XElement *>::_Local, COMDAT
; _this$ = ecx

; 515  : 		{	// test for locally stored copy of object

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 516  : 		return ((void *)_Impl == (void *)&_Space);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+16], eax
	jne	SHORT $LN3@Local
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@Local
$LN3@Local:
	mov	DWORD PTR tv67[ebp], 0
$LN4@Local:
	mov	al, BYTE PTR tv67[ebp]

; 517  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Local@?$_Func_class@_NUServiceIdentifier@@PAVXElement@@@std@@ABE_NXZ ENDP ; std::_Func_class<bool,ServiceIdentifier,XElement *>::_Local
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ??0?$default_delete@VXConfig@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$default_delete@VXConfig@@@std@@QAE@XZ PROC		; std::default_delete<XConfig>::default_delete<XConfig>, COMDAT
; _this$ = ecx

; 1185 : 	default_delete() _NOEXCEPT

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1186 : 		{	// default construct
; 1187 : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$default_delete@VXConfig@@@std@@QAE@XZ ENDP		; std::default_delete<XConfig>::default_delete<XConfig>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@UServiceIdentifier@@@std@@QAEXPAUServiceIdentifier@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UServiceIdentifier@@@std@@QAEXPAUServiceIdentifier@@I@Z PROC ; std::allocator<ServiceIdentifier>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 573  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 574  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@UServiceIdentifier@@@std@@QAEXPAUServiceIdentifier@@I@Z ENDP ; std::allocator<ServiceIdentifier>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ??$emplace_back@HVString@@@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@QAEX$$QAH$$QAVString@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
_<_Val_0>$ = 8						; size = 4
_<_Val_1>$ = 12						; size = 4
??$emplace_back@HVString@@@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@QAEX$$QAH$$QAVString@@@Z PROC ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::emplace_back<int,String>, COMDAT
; _this$ = ecx

; 893  : 		void emplace_back(_Valty&&... _Val)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 894  : 		{	// insert by moving into element at end
; 895  : 		if (this->_Mylast == this->_Myend)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN1@emplace_ba

; 896  : 			_Reserve(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reserve@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IAEXI@Z ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::_Reserve
$LN1@emplace_ba:

; 897  : 		_Orphan_range(this->_Mylast, this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IBEXPAUServiceIdentifier@@0@Z ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::_Orphan_range

; 898  : 		this->_Getal().construct(this->_Mylast,
; 899  : 			_STD forward<_Valty>(_Val)...);

	mov	ecx, DWORD PTR _<_Val_1>$[ebp]
	push	ecx
	call	??$forward@VString@@@std@@YA$$QAVString@@AAV1@@Z ; std::forward<String>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _<_Val_0>$[ebp]
	push	edx
	call	??$forward@H@std@@YA$$QAHAAH@Z		; std::forward<int>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<ServiceIdentifier,std::allocator<ServiceIdentifier> > >::_Getal
	mov	ecx, eax
	call	??$construct@UServiceIdentifier@@HVString@@@?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@QAEXPAUServiceIdentifier@@$$QAH$$QAVString@@@Z ; std::_Wrap_alloc<std::allocator<ServiceIdentifier> >::construct<ServiceIdentifier,int,String>

; 900  : 		++this->_Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 901  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$emplace_back@HVString@@@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@QAEX$$QAH$$QAVString@@@Z ENDP ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::emplace_back<int,String>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\utility
;	COMDAT ??$make_pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$T@std@@YA?AU?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$T@0@$$QAV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@0@$$QA$$T@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Val1$ = 12						; size = 4
__Val2$ = 16						; size = 4
??$make_pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$T@std@@YA?AU?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$T@0@$$QAV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@0@$$QA$$T@Z PROC ; std::make_pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,std::nullptr_t>, COMDAT

; 268  : 	{	// return pair composed from arguments

	push	ebp
	mov	ebp, esp

; 269  : 	typedef pair<typename _Unrefwrap<_Ty1>::type,
; 270  : 		typename _Unrefwrap<_Ty2>::type> _Mypair;
; 271  : 	return (_Mypair(_STD forward<_Ty1>(_Val1),

	mov	eax, DWORD PTR __Val2$[ebp]
	push	eax
	call	??$forward@$$T@std@@YA$$QA$$TAA$$T@Z	; std::forward<std::nullptr_t>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Val1$[ebp]
	push	ecx
	call	??$forward@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@@std@@YA$$QAV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@0@AAV10@@Z ; std::forward<std::unique_ptr<XConfig,std::default_delete<XConfig> > >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??$?0V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$TX@?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$T@std@@QAE@$$QAV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@1@$$QA$$T@Z ; std::pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,std::nullptr_t>::pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,std::nullptr_t><std::unique_ptr<XConfig,std::default_delete<XConfig> >,std::nullptr_t,void>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 272  : 		_STD forward<_Ty2>(_Val2)));
; 273  : 	}

	pop	ebp
	ret	0
??$make_pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$T@std@@YA?AU?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$T@0@$$QAV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@0@$$QA$$T@Z ENDP ; std::make_pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ??$make_unique@VXConfig@@$$$V@std@@YA?AV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@0@XZ
_TEXT	SEGMENT
tv71 = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
??$make_unique@VXConfig@@$$$V@std@@YA?AV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@0@XZ PROC ; std::make_unique<XConfig>, COMDAT

; 1638 : 	{	// make a unique_ptr

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1639 : 	return (unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...)));

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN3@make_uniqu
	mov	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??0XConfig@@QAE@XZ
	mov	DWORD PTR tv71[ebp], eax
	jmp	SHORT $LN4@make_uniqu
$LN3@make_uniqu:
	mov	DWORD PTR tv71[ebp], 0
$LN4@make_uniqu:
	mov	eax, DWORD PTR tv71[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QAE@PAVXConfig@@@Z ; std::unique_ptr<XConfig,std::default_delete<XConfig> >::unique_ptr<XConfig,std::default_delete<XConfig> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1640 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$make_unique@VXConfig@@$$$V@std@@YA?AV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@0@XZ ENDP ; std::make_unique<XConfig>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\utility
;	COMDAT ??$?0V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$TX@?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@@std@@QAE@$$QAU?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$T@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??$?0V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$TX@?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@@std@@QAE@$$QAU?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$T@1@@Z PROC ; std::pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,XElement *>::pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,XElement *><std::unique_ptr<XConfig,std::default_delete<XConfig> >,std::nullptr_t,void>, COMDAT
; _this$ = ecx

; 157  : 		{	// construct from moved compatible pair

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	call	??$forward@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@@std@@YA$$QAV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@0@AAV10@@Z ; std::forward<std::unique_ptr<XConfig,std::default_delete<XConfig> > >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QAE@$$QAV01@@Z ; std::unique_ptr<XConfig,std::default_delete<XConfig> >::unique_ptr<XConfig,std::default_delete<XConfig> >
	mov	ecx, DWORD PTR __Right$[ebp]
	add	ecx, 4
	push	ecx
	call	??$forward@$$T@std@@YA$$QA$$TAA$$T@Z	; std::forward<std::nullptr_t>
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx+4], eax

; 158  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$TX@?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@@std@@QAE@$$QAU?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$T@1@@Z ENDP ; std::pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,XElement *>::pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,XElement *><std::unique_ptr<XConfig,std::default_delete<XConfig> >,std::nullptr_t,void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$move@AAV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@@std@@YA$$QAV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@@std@@YA$$QAV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@0@AAV10@@Z PROC ; std::move<std::unique_ptr<XConfig,std::default_delete<XConfig> > &>, COMDAT

; 1519 : 	{	// forward _Arg as movable

	push	ebp
	mov	ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

	pop	ebp
	ret	0
??$move@AAV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@@std@@YA$$QAV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@0@AAV10@@Z ENDP ; std::move<std::unique_ptr<XConfig,std::default_delete<XConfig> > &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\utility
;	COMDAT ??$?0V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@AAPAVXElement@@X@?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@@std@@QAE@$$QAV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@1@AAPAVXElement@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@AAPAVXElement@@X@?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@@std@@QAE@$$QAV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@1@AAPAVXElement@@@Z PROC ; std::pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,XElement *>::pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,XElement *><std::unique_ptr<XConfig,std::default_delete<XConfig> >,XElement * &,void>, COMDAT
; _this$ = ecx

; 144  : 		{	// construct from moved values

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Val1$[ebp]
	push	eax
	call	??$forward@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@@std@@YA$$QAV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@0@AAV10@@Z ; std::forward<std::unique_ptr<XConfig,std::default_delete<XConfig> > >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QAE@$$QAV01@@Z ; std::unique_ptr<XConfig,std::default_delete<XConfig> >::unique_ptr<XConfig,std::default_delete<XConfig> >
	mov	ecx, DWORD PTR __Val2$[ebp]
	push	ecx
	call	??$forward@AAPAVXElement@@@std@@YAAAPAVXElement@@AAPAV1@@Z ; std::forward<XElement * &>
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx+4], eax

; 145  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??$?0V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@AAPAVXElement@@X@?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@@std@@QAE@$$QAV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@1@AAPAVXElement@@@Z ENDP ; std::pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,XElement *>::pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,XElement *><std::unique_ptr<XConfig,std::default_delete<XConfig> >,XElement * &,void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\utility
;	COMDAT ??$?0V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@X@?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@@std@@QAE@$$QAV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@1@$$QAPAVXElement@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@X@?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@@std@@QAE@$$QAV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@1@$$QAPAVXElement@@@Z PROC ; std::pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,XElement *>::pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,XElement *><std::unique_ptr<XConfig,std::default_delete<XConfig> >,XElement *,void>, COMDAT
; _this$ = ecx

; 144  : 		{	// construct from moved values

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Val1$[ebp]
	push	eax
	call	??$forward@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@@std@@YA$$QAV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@0@AAV10@@Z ; std::forward<std::unique_ptr<XConfig,std::default_delete<XConfig> > >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QAE@$$QAV01@@Z ; std::unique_ptr<XConfig,std::default_delete<XConfig> >::unique_ptr<XConfig,std::default_delete<XConfig> >
	mov	ecx, DWORD PTR __Val2$[ebp]
	push	ecx
	call	??$forward@PAVXElement@@@std@@YA$$QAPAVXElement@@AAPAV1@@Z ; std::forward<XElement *>
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx+4], eax

; 145  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??$?0V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@X@?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@PAVXElement@@@std@@QAE@$$QAV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@1@$$QAPAVXElement@@@Z ENDP ; std::pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,XElement *>::pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,XElement *><std::unique_ptr<XConfig,std::default_delete<XConfig> >,XElement *,void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$forward@UServiceIdentifier@@@std@@YA$$QAUServiceIdentifier@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UServiceIdentifier@@@std@@YA$$QAUServiceIdentifier@@AAU1@@Z PROC ; std::forward<ServiceIdentifier>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@UServiceIdentifier@@@std@@YA$$QAUServiceIdentifier@@AAU1@@Z ENDP ; std::forward<ServiceIdentifier>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$forward@PAVXElement@@@std@@YA$$QAPAVXElement@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@PAVXElement@@@std@@YA$$QAPAVXElement@@AAPAV1@@Z PROC ; std::forward<XElement *>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@PAVXElement@@@std@@YA$$QAPAVXElement@@AAPAV1@@Z ENDP ; std::forward<XElement *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstddef
;	COMDAT ??$addressof@VXConfig@@@std@@YAPAVXConfig@@AAV1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@VXConfig@@@std@@YAPAVXConfig@@AAV1@@Z PROC	; std::addressof<XConfig>, COMDAT

; 92   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 96   : 	}

	pop	ebp
	ret	0
??$addressof@VXConfig@@@std@@YAPAVXConfig@@AAV1@@Z ENDP	; std::addressof<XConfig>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@@std@@YAXPAUServiceIdentifier@@0AAU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@@std@@YAXPAUServiceIdentifier@@0AAU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ServiceIdentifier> > >, COMDAT

; 95   : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@UServiceIdentifier@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUServiceIdentifier@@0@Z ; std::_Ptr_cat<ServiceIdentifier,ServiceIdentifier>
	add	esp, 8
	mov	BYTE PTR $T1[ebp], al
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@@std@@YAXPAUServiceIdentifier@@0AAU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ServiceIdentifier> > >
	add	esp, 16					; 00000010H

; 97   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@@std@@YAXPAUServiceIdentifier@@0AAU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ServiceIdentifier> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ?_Reserve@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IAEXI@Z PROC ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::_Reserve, COMDAT
; _this$ = ecx

; 1612 : 		{	// ensure room for _Count new elements, grow exponentially

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1613 : 		if (_Unused_capacity() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Unused_capacity@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@QBEIXZ ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::_Unused_capacity
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN4@Reserve

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@QBEIXZ ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@QBEIXZ ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN1@Reserve

; 1616 : 				_Xlen();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IBEXXZ ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::_Xlen
$LN1@Reserve:

; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@QBEIXZ ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::size
	add	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow_to@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IBEII@Z ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::_Grow_to
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reallocate@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IAEXI@Z ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::_Reallocate
$LN4@Reserve:

; 1618 : 			}
; 1619 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Reserve@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IAEXI@Z ENDP ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IBEXPAUServiceIdentifier@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IBEXPAUServiceIdentifier@@0@Z PROC ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1780 : 		{	// orphan iterators within specified (inclusive) range

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1781 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Orphan_range@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IBEXPAUServiceIdentifier@@0@Z ENDP ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ??0?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QAE@PAVXConfig@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QAE@PAVXConfig@@@Z PROC ; std::unique_ptr<XConfig,std::default_delete<XConfig> >::unique_ptr<XConfig,std::default_delete<XConfig> >, COMDAT
; _this$ = ecx

; 1365 : 		{	// construct with pointer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Unique_ptr_base@VXConfig@@U?$default_delete@VXConfig@@@std@@$00@std@@QAE@PAVXConfig@@@Z ; std::_Unique_ptr_base<XConfig,std::default_delete<XConfig>,1>::_Unique_ptr_base<XConfig,std::default_delete<XConfig>,1>

; 1366 : 		static_assert(!is_pointer<_Dx>::value,
; 1367 : 			"unique_ptr constructed with null deleter pointer");
; 1368 : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QAE@PAVXConfig@@@Z ENDP ; std::unique_ptr<XConfig,std::default_delete<XConfig> >::unique_ptr<XConfig,std::default_delete<XConfig> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ??0?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QAE@$$QAV01@@Z PROC ; std::unique_ptr<XConfig,std::default_delete<XConfig> >::unique_ptr<XConfig,std::default_delete<XConfig> >, COMDAT
; _this$ = ecx

; 1388 : 		{	// construct by moving _Right

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?get_deleter@?$_Unique_ptr_base@VXConfig@@U?$default_delete@VXConfig@@@std@@$00@std@@QAEAAU?$default_delete@VXConfig@@@2@XZ ; std::_Unique_ptr_base<XConfig,std::default_delete<XConfig>,1>::get_deleter
	push	eax
	call	??$forward@U?$default_delete@VXConfig@@@std@@@std@@YA$$QAU?$default_delete@VXConfig@@@0@AAU10@@Z ; std::forward<std::default_delete<XConfig> >
	add	esp, 4
	mov	al, BYTE PTR [eax]
	movzx	ecx, al
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?release@?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QAEPAVXConfig@@XZ ; std::unique_ptr<XConfig,std::default_delete<XConfig> >::release
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Unique_ptr_base@VXConfig@@U?$default_delete@VXConfig@@@std@@$00@std@@QAE@PAVXConfig@@U?$default_delete@VXConfig@@@1@@Z ; std::_Unique_ptr_base<XConfig,std::default_delete<XConfig>,1>::_Unique_ptr_base<XConfig,std::default_delete<XConfig>,1>

; 1389 : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QAE@$$QAV01@@Z ENDP ; std::unique_ptr<XConfig,std::default_delete<XConfig> >::unique_ptr<XConfig,std::default_delete<XConfig> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Unused_capacity@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@QBEIXZ PROC ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1014 : 		{	// micro-optimization for capacity() - size()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1015 : 		return (this->_Myend - this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx

; 1016 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Unused_capacity@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@QBEIXZ ENDP ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ?size@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@QBEIXZ PROC ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::size, COMDAT
; _this$ = ecx

; 1147 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, DWORD PTR [ecx]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx

; 1149 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@QBEIXZ ENDP ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ?max_size@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@QBEIXZ PROC ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::max_size, COMDAT
; _this$ = ecx

; 1152 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1153 : 		return (this->_Getal().max_size());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<ServiceIdentifier,std::allocator<ServiceIdentifier> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<ServiceIdentifier> >::max_size

; 1154 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@QBEIXZ ENDP ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -12						; size = 4
_this$ = -8						; size = 4
__Capacity$ = -4					; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IBEII@Z PROC ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::_Grow_to, COMDAT
; _this$ = ecx

; 1571 : 		{	// grow by 50% or at least to _Count

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1572 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@QBEIXZ ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@QBEIXZ ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN4@Grow_to
	mov	DWORD PTR tv73[ebp], 0
	jmp	SHORT $LN5@Grow_to
$LN4@Grow_to:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv73[ebp], edx
$LN5@Grow_to:
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1576 : 		if (_Capacity < _Count)

	mov	ecx, DWORD PTR __Capacity$[ebp]
	cmp	ecx, DWORD PTR __Count$[ebp]
	jae	SHORT $LN1@Grow_to

; 1577 : 			_Capacity = _Count;

	mov	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx
$LN1@Grow_to:

; 1578 : 		return (_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]

; 1579 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Grow_to@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IBEII@Z ENDP ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -32						; size = 4
__Ptr$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?_Reallocate@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IAEXI@Z PROC ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::_Reallocate, COMDAT
; _this$ = ecx

; 1587 : 		{	// move to array of exactly _Count elements

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Reallocate@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<ServiceIdentifier,std::allocator<ServiceIdentifier> > >::_Getal
	mov	ecx, eax
	call	?allocate@?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@QAEPAUServiceIdentifier@@I@Z ; std::_Wrap_alloc<std::allocator<ServiceIdentifier> >::allocate
	mov	DWORD PTR __Ptr$[ebp], eax

; 1589 : 
; 1590 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);

	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUServiceIdentifier@@@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IAEPAUServiceIdentifier@@PAU2@00@Z ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::_Umove<ServiceIdentifier *>
	jmp	SHORT $LN5@Reallocate
__catch$?_Reallocate@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IAEXI@Z$0:

; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<ServiceIdentifier,std::allocator<ServiceIdentifier> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@QAEXPAUServiceIdentifier@@I@Z ; std::_Wrap_alloc<std::allocator<ServiceIdentifier> >::deallocate

; 1594 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1595 : 		_CATCH_END

	mov	eax, $LN8@Reallocate
	ret	0
$LN5@Reallocate:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Reallocate@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IAEXI@Z$1
$LN8@Reallocate:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Reallocate@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IAEXI@Z$1:

; 1596 : 
; 1597 : 		size_type _Size = size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@QBEIXZ ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::size
	mov	DWORD PTR __Size$[ebp], eax

; 1598 : 		if (this->_Myfirst != pointer())

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN1@Reallocate

; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IAEXPAUServiceIdentifier@@0@Z ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::_Destroy

; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<ServiceIdentifier,std::allocator<ServiceIdentifier> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@QAEXPAUServiceIdentifier@@I@Z ; std::_Wrap_alloc<std::allocator<ServiceIdentifier> >::deallocate
$LN1@Reallocate:

; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1606 : 		this->_Myend = _Ptr + _Count;

	imul	edx, DWORD PTR __Count$[ebp], 12
	add	edx, DWORD PTR __Ptr$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 1607 : 		this->_Mylast = _Ptr + _Size;

	imul	ecx, DWORD PTR __Size$[ebp], 12
	add	ecx, DWORD PTR __Ptr$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 1608 : 		this->_Myfirst = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [eax], ecx
$LN4@Reallocate:

; 1609 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IAEXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Reallocate@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Reallocate@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IAEXI@Z ENDP ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::_Reallocate
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ?_Xlen@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IBEXXZ PROC ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::_Xlen, COMDAT
; _this$ = ecx

; 1753 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1754 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 1755 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IBEXXZ ENDP ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ?release@?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QAEPAVXConfig@@XZ
_TEXT	SEGMENT
__Ans$ = -8						; size = 4
_this$ = -4						; size = 4
?release@?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QAEPAVXConfig@@XZ PROC ; std::unique_ptr<XConfig,std::default_delete<XConfig> >::release, COMDAT
; _this$ = ecx

; 1472 : 		{	// yield ownership of pointer

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1473 : 		pointer _Ans = this->_Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Ans$[ebp], ecx

; 1474 : 		this->_Myptr = pointer();

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 0

; 1475 : 		return (_Ans);

	mov	eax, DWORD PTR __Ans$[ebp]

; 1476 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?release@?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QAEPAVXConfig@@XZ ENDP ; std::unique_ptr<XConfig,std::default_delete<XConfig> >::release
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ??0?$_Unique_ptr_base@VXConfig@@U?$default_delete@VXConfig@@@std@@$00@std@@QAE@PAVXConfig@@U?$default_delete@VXConfig@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Dt$ = 12						; size = 1
??0?$_Unique_ptr_base@VXConfig@@U?$default_delete@VXConfig@@@std@@$00@std@@QAE@PAVXConfig@@U?$default_delete@VXConfig@@@1@@Z PROC ; std::_Unique_ptr_base<XConfig,std::default_delete<XConfig>,1>::_Unique_ptr_base<XConfig,std::default_delete<XConfig>,1>, COMDAT
; _this$ = ecx

; 1290 : 		{	// construct with pointer and deleter

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [eax], ecx

; 1291 : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Unique_ptr_base@VXConfig@@U?$default_delete@VXConfig@@@std@@$00@std@@QAE@PAVXConfig@@U?$default_delete@VXConfig@@@1@@Z ENDP ; std::_Unique_ptr_base<XConfig,std::default_delete<XConfig>,1>::_Unique_ptr_base<XConfig,std::default_delete<XConfig>,1>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ?capacity@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@QBEIXZ PROC ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::capacity, COMDAT
; _this$ = ecx

; 1009 : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1010 : 		return (this->_Myend - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx

; 1011 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@QBEIXZ ENDP ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@QAEPAUServiceIdentifier@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@QAEPAUServiceIdentifier@@I@Z PROC ; std::_Wrap_alloc<std::allocator<ServiceIdentifier> >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 847  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@UServiceIdentifier@@@std@@QAEPAUServiceIdentifier@@I@Z ; std::allocator<ServiceIdentifier>::allocate

; 848  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@QAEPAUServiceIdentifier@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<ServiceIdentifier> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<ServiceIdentifier> >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 884  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@UServiceIdentifier@@@std@@@std@@SAIABV?$allocator@UServiceIdentifier@@@2@@Z ; std::allocator_traits<std::allocator<ServiceIdentifier> >::max_size
	add	esp, 4

; 885  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<ServiceIdentifier> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@UServiceIdentifier@@@std@@QAEPAUServiceIdentifier@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UServiceIdentifier@@@std@@QAEPAUServiceIdentifier@@I@Z PROC ; std::allocator<ServiceIdentifier>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 578  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@UServiceIdentifier@@@std@@YAPAUServiceIdentifier@@IPAU1@@Z ; std::_Allocate<ServiceIdentifier>
	add	esp, 8

; 579  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@UServiceIdentifier@@@std@@QAEPAUServiceIdentifier@@I@Z ENDP ; std::allocator<ServiceIdentifier>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@UServiceIdentifier@@@std@@@std@@SAIABV?$allocator@UServiceIdentifier@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@UServiceIdentifier@@@std@@@std@@SAIABV?$allocator@UServiceIdentifier@@@2@@Z PROC ; std::allocator_traits<std::allocator<ServiceIdentifier> >::max_size, COMDAT

; 734  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 735  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@UServiceIdentifier@@@std@@QBEIXZ ; std::allocator<ServiceIdentifier>::max_size

; 736  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@UServiceIdentifier@@@std@@@std@@SAIABV?$allocator@UServiceIdentifier@@@2@@Z ENDP ; std::allocator_traits<std::allocator<ServiceIdentifier> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@UServiceIdentifier@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@UServiceIdentifier@@@std@@QBEIXZ PROC ; std::allocator<ServiceIdentifier>::max_size, COMDAT
; _this$ = ecx

; 611  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 357913941				; 15555555H

; 613  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@UServiceIdentifier@@@std@@QBEIXZ ENDP ; std::allocator<ServiceIdentifier>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$forward@H@std@@YA$$QAHAAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@H@std@@YA$$QAHAAH@Z PROC			; std::forward<int>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@H@std@@YA$$QAHAAH@Z ENDP			; std::forward<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$forward@VString@@@std@@YA$$QAVString@@AAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@VString@@@std@@YA$$QAVString@@AAV1@@Z PROC	; std::forward<String>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@VString@@@std@@YA$$QAVString@@AAV1@@Z ENDP	; std::forward<String>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$construct@UServiceIdentifier@@HVString@@@?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@QAEXPAUServiceIdentifier@@$$QAH$$QAVString@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
_<_Args_1>$ = 16					; size = 4
??$construct@UServiceIdentifier@@HVString@@@?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@QAEXPAUServiceIdentifier@@$$QAH$$QAVString@@@Z PROC ; std::_Wrap_alloc<std::allocator<ServiceIdentifier> >::construct<ServiceIdentifier,int,String>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_1>$[ebp]
	push	eax
	call	??$forward@VString@@@std@@YA$$QAVString@@AAV1@@Z ; std::forward<String>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@H@std@@YA$$QAHAAH@Z		; std::forward<int>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??$construct@UServiceIdentifier@@HVString@@@?$allocator_traits@V?$allocator@UServiceIdentifier@@@std@@@std@@SAXAAV?$allocator@UServiceIdentifier@@@1@PAUServiceIdentifier@@$$QAH$$QAVString@@@Z ; std::allocator_traits<std::allocator<ServiceIdentifier> >::construct<ServiceIdentifier,int,String>
	add	esp, 16					; 00000010H

; 873  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$construct@UServiceIdentifier@@HVString@@@?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@QAEXPAUServiceIdentifier@@$$QAH$$QAVString@@@Z ENDP ; std::_Wrap_alloc<std::allocator<ServiceIdentifier> >::construct<ServiceIdentifier,int,String>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$forward@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@@std@@YA$$QAV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@@std@@YA$$QAV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@0@AAV10@@Z PROC ; std::forward<std::unique_ptr<XConfig,std::default_delete<XConfig> > >, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@@std@@YA$$QAV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::unique_ptr<XConfig,std::default_delete<XConfig> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\utility
;	COMDAT ??$?0V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$TX@?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$T@std@@QAE@$$QAV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@1@$$QA$$T@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$TX@?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$T@std@@QAE@$$QAV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@1@$$QA$$T@Z PROC ; std::pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,std::nullptr_t>::pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,std::nullptr_t><std::unique_ptr<XConfig,std::default_delete<XConfig> >,std::nullptr_t,void>, COMDAT
; _this$ = ecx

; 144  : 		{	// construct from moved values

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Val1$[ebp]
	push	eax
	call	??$forward@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@@std@@YA$$QAV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@0@AAV10@@Z ; std::forward<std::unique_ptr<XConfig,std::default_delete<XConfig> > >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@QAE@$$QAV01@@Z ; std::unique_ptr<XConfig,std::default_delete<XConfig> >::unique_ptr<XConfig,std::default_delete<XConfig> >
	mov	ecx, DWORD PTR __Val2$[ebp]
	push	ecx
	call	??$forward@$$T@std@@YA$$QA$$TAA$$T@Z	; std::forward<std::nullptr_t>
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx+4], eax

; 145  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??$?0V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$TX@?$pair@V?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@std@@$$T@std@@QAE@$$QAV?$unique_ptr@VXConfig@@U?$default_delete@VXConfig@@@std@@@1@$$QA$$T@Z ENDP ; std::pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,std::nullptr_t>::pair<std::unique_ptr<XConfig,std::default_delete<XConfig> >,std::nullptr_t><std::unique_ptr<XConfig,std::default_delete<XConfig> >,std::nullptr_t,void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$forward@AAPAVXElement@@@std@@YAAAPAVXElement@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAVXElement@@@std@@YAAAPAVXElement@@AAPAV1@@Z PROC ; std::forward<XElement * &>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@AAPAVXElement@@@std@@YAAAPAVXElement@@AAPAV1@@Z ENDP ; std::forward<XElement * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xutility
;	COMDAT ??$_Ptr_cat@UServiceIdentifier@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUServiceIdentifier@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UServiceIdentifier@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUServiceIdentifier@@0@Z PROC ; std::_Ptr_cat<ServiceIdentifier,ServiceIdentifier>, COMDAT

; 444  : 	{	// return pointer category from pointers

	push	ebp
	mov	ebp, esp
	push	ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 447  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@UServiceIdentifier@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUServiceIdentifier@@0@Z ENDP ; std::_Ptr_cat<ServiceIdentifier,ServiceIdentifier>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@@std@@YAXPAUServiceIdentifier@@0AAU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@@std@@YAXPAUServiceIdentifier@@0AAU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ServiceIdentifier> > >, COMDAT

; 80   : 	{	// destroy [_First, _Last), arbitrary type

	push	ebp
	mov	ebp, esp

; 81   : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Destroy_ra
$LN2@Destroy_ra:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Destroy_ra

; 82   : 		_Al.destroy(_First);

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@UServiceIdentifier@@@?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@QAEXPAUServiceIdentifier@@@Z ; std::_Wrap_alloc<std::allocator<ServiceIdentifier> >::destroy<ServiceIdentifier>
	jmp	SHORT $LN2@Destroy_ra
$LN4@Destroy_ra:

; 83   : 	}

	pop	ebp
	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@@std@@YAXPAUServiceIdentifier@@0AAU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ServiceIdentifier> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$forward@U?$default_delete@VXConfig@@@std@@@std@@YA$$QAU?$default_delete@VXConfig@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$default_delete@VXConfig@@@std@@@std@@YA$$QAU?$default_delete@VXConfig@@@0@AAU10@@Z PROC ; std::forward<std::default_delete<XConfig> >, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@U?$default_delete@VXConfig@@@std@@@std@@YA$$QAU?$default_delete@VXConfig@@@0@AAU10@@Z ENDP ; std::forward<std::default_delete<XConfig> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ??$_Umove@PAUServiceIdentifier@@@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IAEPAUServiceIdentifier@@PAU2@00@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Alval$ = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUServiceIdentifier@@@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IAEPAUServiceIdentifier@@PAU2@00@Z PROC ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::_Umove<ServiceIdentifier *>, COMDAT
; _this$ = ecx

; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());

	lea	eax, DWORD PTR __Alval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<ServiceIdentifier,std::allocator<ServiceIdentifier> > >::_Getal

; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));

	lea	ecx, DWORD PTR __Alval$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninitialized_move@PAUServiceIdentifier@@PAU1@U?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@@std@@YAPAUServiceIdentifier@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@0@@Z ; std::_Uninitialized_move<ServiceIdentifier *,ServiceIdentifier *,std::_Wrap_alloc<std::allocator<ServiceIdentifier> > >
	add	esp, 16					; 00000010H

; 1649 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAUServiceIdentifier@@@?$vector@UServiceIdentifier@@V?$allocator@UServiceIdentifier@@@std@@@std@@IAEPAUServiceIdentifier@@PAU2@00@Z ENDP ; std::vector<ServiceIdentifier,std::allocator<ServiceIdentifier> >::_Umove<ServiceIdentifier *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$_Allocate@UServiceIdentifier@@@std@@YAPAUServiceIdentifier@@IPAU1@@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UServiceIdentifier@@@std@@YAPAUServiceIdentifier@@IPAU1@@Z PROC ; std::_Allocate<ServiceIdentifier>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], 357913941	; 15555555H
	ja	SHORT $LN1@Allocate
	imul	eax, DWORD PTR __Count$[ebp], 12
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@UServiceIdentifier@@@std@@YAPAUServiceIdentifier@@IPAU1@@Z ENDP ; std::_Allocate<ServiceIdentifier>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$construct@UServiceIdentifier@@HVString@@@?$allocator_traits@V?$allocator@UServiceIdentifier@@@std@@@std@@SAXAAV?$allocator@UServiceIdentifier@@@1@PAUServiceIdentifier@@$$QAH$$QAVString@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
??$construct@UServiceIdentifier@@HVString@@@?$allocator_traits@V?$allocator@UServiceIdentifier@@@std@@@std@@SAXAAV?$allocator@UServiceIdentifier@@@1@PAUServiceIdentifier@@$$QAH$$QAVString@@@Z PROC ; std::allocator_traits<std::allocator<ServiceIdentifier> >::construct<ServiceIdentifier,int,String>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

	push	ebp
	mov	ebp, esp

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_1>$[ebp]
	push	eax
	call	??$forward@VString@@@std@@YA$$QAVString@@AAV1@@Z ; std::forward<String>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@H@std@@YA$$QAHAAH@Z		; std::forward<int>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@UServiceIdentifier@@HVString@@@?$allocator@UServiceIdentifier@@@std@@QAEXPAUServiceIdentifier@@$$QAH$$QAVString@@@Z ; std::allocator<ServiceIdentifier>::construct<ServiceIdentifier,int,String>

; 724  : 		}

	pop	ebp
	ret	0
??$construct@UServiceIdentifier@@HVString@@@?$allocator_traits@V?$allocator@UServiceIdentifier@@@std@@@std@@SAXAAV?$allocator@UServiceIdentifier@@@1@PAUServiceIdentifier@@$$QAH$$QAVString@@@Z ENDP ; std::allocator_traits<std::allocator<ServiceIdentifier> >::construct<ServiceIdentifier,int,String>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$destroy@UServiceIdentifier@@@?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@QAEXPAUServiceIdentifier@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@UServiceIdentifier@@@?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@QAEXPAUServiceIdentifier@@@Z PROC ; std::_Wrap_alloc<std::allocator<ServiceIdentifier> >::destroy<ServiceIdentifier>, COMDAT
; _this$ = ecx

; 877  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@UServiceIdentifier@@@?$allocator_traits@V?$allocator@UServiceIdentifier@@@std@@@std@@SAXAAV?$allocator@UServiceIdentifier@@@1@PAUServiceIdentifier@@@Z ; std::allocator_traits<std::allocator<ServiceIdentifier> >::destroy<ServiceIdentifier>
	add	esp, 8

; 880  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@UServiceIdentifier@@@?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@QAEXPAUServiceIdentifier@@@Z ENDP ; std::_Wrap_alloc<std::allocator<ServiceIdentifier> >::destroy<ServiceIdentifier>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUServiceIdentifier@@PAU1@U?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@@std@@YAPAUServiceIdentifier@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUServiceIdentifier@@PAU1@U?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@@std@@YAPAUServiceIdentifier@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@0@@Z PROC ; std::_Uninitialized_move<ServiceIdentifier *,ServiceIdentifier *,std::_Wrap_alloc<std::allocator<ServiceIdentifier> > >, COMDAT

; 492  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp

; 493  : 	return (_Rechecked(_Dest,
; 494  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 495  : 			_Unchecked(_Dest), _Al)));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Unchecked@PAUServiceIdentifier@@@std@@YAPAUServiceIdentifier@@PAU1@@Z ; std::_Unchecked<ServiceIdentifier *>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??$_Unchecked@PAUServiceIdentifier@@@std@@YAPAUServiceIdentifier@@PAU1@@Z ; std::_Unchecked<ServiceIdentifier *>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked@PAUServiceIdentifier@@@std@@YAPAUServiceIdentifier@@PAU1@@Z ; std::_Unchecked<ServiceIdentifier *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PAUServiceIdentifier@@PAU1@U?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@@std@@YAPAUServiceIdentifier@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@0@@Z ; std::_Uninit_move<ServiceIdentifier *,ServiceIdentifier *,std::_Wrap_alloc<std::allocator<ServiceIdentifier> > >
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Rechecked@PAUServiceIdentifier@@PAU1@@std@@YAAAPAUServiceIdentifier@@AAPAU1@PAU1@@Z ; std::_Rechecked<ServiceIdentifier *,ServiceIdentifier *>
	add	esp, 8
	mov	eax, DWORD PTR [eax]

; 496  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_move@PAUServiceIdentifier@@PAU1@U?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@@std@@YAPAUServiceIdentifier@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<ServiceIdentifier *,ServiceIdentifier *,std::_Wrap_alloc<std::allocator<ServiceIdentifier> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$construct@UServiceIdentifier@@HVString@@@?$allocator@UServiceIdentifier@@@std@@QAEXPAUServiceIdentifier@@$$QAH$$QAVString@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv87 = -8						; size = 4
$T1 = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
_<_Args_1>$ = 16					; size = 4
??$construct@UServiceIdentifier@@HVString@@@?$allocator@UServiceIdentifier@@@std@@QAEXPAUServiceIdentifier@@$$QAH$$QAVString@@@Z PROC ; std::allocator<ServiceIdentifier>::construct<ServiceIdentifier,int,String>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	12					; 0000000cH
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR _<_Args_1>$[ebp]
	push	ecx
	call	??$forward@VString@@@std@@YA$$QAVString@@AAV1@@Z ; std::forward<String>
	add	esp, -4					; fffffffcH
	mov	ecx, esp
	push	eax
	call	DWORD PTR __imp_??0String@@QAE@ABV0@@Z
	mov	edx, DWORD PTR _<_Args_0>$[ebp]
	push	edx
	call	??$forward@H@std@@YA$$QAHAAH@Z		; std::forward<int>
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR $T1[ebp]
	call	??0ServiceIdentifier@@QAE@HVString@@@Z	; ServiceIdentifier::ServiceIdentifier
	mov	DWORD PTR tv87[ebp], eax
	jmp	SHORT $LN1@construct
$LN3@construct:
	mov	DWORD PTR tv87[ebp], 0
$LN1@construct:

; 601  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$construct@UServiceIdentifier@@HVString@@@?$allocator@UServiceIdentifier@@@std@@QAEXPAUServiceIdentifier@@$$QAH$$QAVString@@@Z ENDP ; std::allocator<ServiceIdentifier>::construct<ServiceIdentifier,int,String>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$destroy@UServiceIdentifier@@@?$allocator_traits@V?$allocator@UServiceIdentifier@@@std@@@std@@SAXAAV?$allocator@UServiceIdentifier@@@1@PAUServiceIdentifier@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@UServiceIdentifier@@@?$allocator_traits@V?$allocator@UServiceIdentifier@@@std@@@std@@SAXAAV?$allocator@UServiceIdentifier@@@1@PAUServiceIdentifier@@@Z PROC ; std::allocator_traits<std::allocator<ServiceIdentifier> >::destroy<ServiceIdentifier>, COMDAT

; 728  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@UServiceIdentifier@@@?$allocator@UServiceIdentifier@@@std@@QAEXPAUServiceIdentifier@@@Z ; std::allocator<ServiceIdentifier>::destroy<ServiceIdentifier>

; 731  : 		}

	pop	ebp
	ret	0
??$destroy@UServiceIdentifier@@@?$allocator_traits@V?$allocator@UServiceIdentifier@@@std@@@std@@SAXAAV?$allocator@UServiceIdentifier@@@1@PAUServiceIdentifier@@@Z ENDP ; std::allocator_traits<std::allocator<ServiceIdentifier> >::destroy<ServiceIdentifier>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xutility
;	COMDAT ??$_Unchecked@PAUServiceIdentifier@@@std@@YAPAUServiceIdentifier@@PAU1@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAUServiceIdentifier@@@std@@YAPAUServiceIdentifier@@PAU1@@Z PROC ; std::_Unchecked<ServiceIdentifier *>, COMDAT

; 280  : 	{	// construct unchecked from checked, generic

	push	ebp
	mov	ebp, esp

; 281  : 	return (_Src);

	mov	eax, DWORD PTR __Src$[ebp]

; 282  : 	}

	pop	ebp
	ret	0
??$_Unchecked@PAUServiceIdentifier@@@std@@YAPAUServiceIdentifier@@PAU1@@Z ENDP ; std::_Unchecked<ServiceIdentifier *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAUServiceIdentifier@@PAU1@U?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@@std@@YAPAUServiceIdentifier@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_move@PAUServiceIdentifier@@PAU1@U?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@@std@@YAPAUServiceIdentifier@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@0@@Z PROC ; std::_Uninit_move<ServiceIdentifier *,ServiceIdentifier *,std::_Wrap_alloc<std::allocator<ServiceIdentifier> > >, COMDAT

; 482  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 483  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@UServiceIdentifier@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUServiceIdentifier@@0@Z ; std::_Ptr_cat<ServiceIdentifier,ServiceIdentifier>
	add	esp, 8
	mov	BYTE PTR $T1[ebp], al
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Val_type@PAUServiceIdentifier@@@std@@YAPAUServiceIdentifier@@PAU1@@Z ; std::_Val_type<ServiceIdentifier *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninit_move@PAUServiceIdentifier@@PAU1@V?$allocator@UServiceIdentifier@@@std@@U1@@std@@YAPAUServiceIdentifier@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<ServiceIdentifier *,ServiceIdentifier *,std::allocator<ServiceIdentifier>,ServiceIdentifier>
	add	esp, 24					; 00000018H

; 485  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_move@PAUServiceIdentifier@@PAU1@U?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@@std@@YAPAUServiceIdentifier@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@0@@Z ENDP ; std::_Uninit_move<ServiceIdentifier *,ServiceIdentifier *,std::_Wrap_alloc<std::allocator<ServiceIdentifier> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xutility
;	COMDAT ??$_Rechecked@PAUServiceIdentifier@@PAU1@@std@@YAAAPAUServiceIdentifier@@AAPAU1@PAU1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAUServiceIdentifier@@PAU1@@std@@YAAAPAUServiceIdentifier@@AAPAU1@PAU1@@Z PROC ; std::_Rechecked<ServiceIdentifier *,ServiceIdentifier *>, COMDAT

; 288  : 	{	// reset checked from unchecked, generic

	push	ebp
	mov	ebp, esp

; 289  : 	_Dest = _Src;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR __Src$[ebp]
	mov	DWORD PTR [eax], ecx

; 290  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 291  : 	}

	pop	ebp
	ret	0
??$_Rechecked@PAUServiceIdentifier@@PAU1@@std@@YAAAPAUServiceIdentifier@@AAPAU1@PAU1@@Z ENDP ; std::_Rechecked<ServiceIdentifier *,ServiceIdentifier *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$destroy@UServiceIdentifier@@@?$allocator@UServiceIdentifier@@@std@@QAEXPAUServiceIdentifier@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@UServiceIdentifier@@@?$allocator@UServiceIdentifier@@@std@@QAEXPAUServiceIdentifier@@@Z PROC ; std::allocator<ServiceIdentifier>::destroy<ServiceIdentifier>, COMDAT
; _this$ = ecx

; 605  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();

	push	0
	mov	ecx, DWORD PTR __Ptr$[ebp]
	call	??_GServiceIdentifier@@QAEPAXI@Z

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@UServiceIdentifier@@@?$allocator@UServiceIdentifier@@@std@@QAEXPAUServiceIdentifier@@@Z ENDP ; std::allocator<ServiceIdentifier>::destroy<ServiceIdentifier>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xutility
;	COMDAT ??$_Val_type@PAUServiceIdentifier@@@std@@YAPAUServiceIdentifier@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUServiceIdentifier@@@std@@YAPAUServiceIdentifier@@PAU1@@Z PROC ; std::_Val_type<ServiceIdentifier *>, COMDAT

; 645  : 	{	// return value type from arbitrary argument

	push	ebp
	mov	ebp, esp

; 646  : 	return (0);

	xor	eax, eax

; 647  : 	}

	pop	ebp
	ret	0
??$_Val_type@PAUServiceIdentifier@@@std@@YAPAUServiceIdentifier@@PAU1@@Z ENDP ; std::_Val_type<ServiceIdentifier *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAUServiceIdentifier@@PAU1@V?$allocator@UServiceIdentifier@@@std@@U1@@std@@YAPAUServiceIdentifier@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUServiceIdentifier@@PAU1@V?$allocator@UServiceIdentifier@@@std@@U1@@std@@YAPAUServiceIdentifier@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<ServiceIdentifier *,ServiceIdentifier *,std::allocator<ServiceIdentifier>,ServiceIdentifier>, COMDAT

; 437  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_move@PAUServiceIdentifier@@PAU1@V?$allocator@UServiceIdentifier@@@std@@U1@@std@@YAPAUServiceIdentifier@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 438  : 	_DEBUG_RANGE(_First, _Last);
; 439  : 	_DEBUG_POINTER(_Dest);
; 440  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 441  : 
; 442  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 443  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_mov
$LN5@Uninit_mov:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_mov:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_mov

; 444  : 		_Al.construct(_Dest, (_Valty&&)*_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@UServiceIdentifier@@U1@@?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@QAEXPAUServiceIdentifier@@$$QAU2@@Z ; std::_Wrap_alloc<std::allocator<ServiceIdentifier> >::construct<ServiceIdentifier,ServiceIdentifier>
	jmp	SHORT $LN5@Uninit_mov
$LN4@Uninit_mov:
	jmp	SHORT $LN10@Uninit_mov
__catch$??$_Uninit_move@PAUServiceIdentifier@@PAU1@V?$allocator@UServiceIdentifier@@@std@@U1@@std@@YAPAUServiceIdentifier@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 445  : 	_CATCH_ALL
; 446  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_mov
$LN2@Uninit_mov:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_mov:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_mov

; 447  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@UServiceIdentifier@@@?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@QAEXPAUServiceIdentifier@@@Z ; std::_Wrap_alloc<std::allocator<ServiceIdentifier> >::destroy<ServiceIdentifier>
	jmp	SHORT $LN2@Uninit_mov
$LN1@Uninit_mov:

; 448  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 449  : 	_CATCH_END

	mov	eax, $LN13@Uninit_mov
	ret	0
$LN10@Uninit_mov:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$??$_Uninit_move@PAUServiceIdentifier@@PAU1@V?$allocator@UServiceIdentifier@@@std@@U1@@std@@YAPAUServiceIdentifier@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1
$LN13@Uninit_mov:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_move@PAUServiceIdentifier@@PAU1@V?$allocator@UServiceIdentifier@@@std@@U1@@std@@YAPAUServiceIdentifier@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1:

; 450  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_mov:

; 451  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_move@PAUServiceIdentifier@@PAU1@V?$allocator@UServiceIdentifier@@@std@@U1@@std@@YAPAUServiceIdentifier@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAUServiceIdentifier@@PAU1@V?$allocator@UServiceIdentifier@@@std@@U1@@std@@YAPAUServiceIdentifier@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAUServiceIdentifier@@PAU1@V?$allocator@UServiceIdentifier@@@std@@U1@@std@@YAPAUServiceIdentifier@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<ServiceIdentifier *,ServiceIdentifier *,std::allocator<ServiceIdentifier>,ServiceIdentifier>
; Function compile flags: /Odtp
;	COMDAT ??_GServiceIdentifier@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GServiceIdentifier@@QAEPAXI@Z PROC			; ServiceIdentifier::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ServiceIdentifier@@QAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GServiceIdentifier@@QAEPAXI@Z ENDP			; ServiceIdentifier::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$construct@UServiceIdentifier@@U1@@?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@QAEXPAUServiceIdentifier@@$$QAU2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UServiceIdentifier@@U1@@?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@QAEXPAUServiceIdentifier@@$$QAU2@@Z PROC ; std::_Wrap_alloc<std::allocator<ServiceIdentifier> >::construct<ServiceIdentifier,ServiceIdentifier>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@UServiceIdentifier@@@std@@YA$$QAUServiceIdentifier@@AAU1@@Z ; std::forward<ServiceIdentifier>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@UServiceIdentifier@@U1@@?$allocator_traits@V?$allocator@UServiceIdentifier@@@std@@@std@@SAXAAV?$allocator@UServiceIdentifier@@@1@PAUServiceIdentifier@@$$QAU3@@Z ; std::allocator_traits<std::allocator<ServiceIdentifier> >::construct<ServiceIdentifier,ServiceIdentifier>
	add	esp, 12					; 0000000cH

; 873  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@UServiceIdentifier@@U1@@?$_Wrap_alloc@V?$allocator@UServiceIdentifier@@@std@@@std@@QAEXPAUServiceIdentifier@@$$QAU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<ServiceIdentifier> >::construct<ServiceIdentifier,ServiceIdentifier>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$construct@UServiceIdentifier@@U1@@?$allocator_traits@V?$allocator@UServiceIdentifier@@@std@@@std@@SAXAAV?$allocator@UServiceIdentifier@@@1@PAUServiceIdentifier@@$$QAU3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UServiceIdentifier@@U1@@?$allocator_traits@V?$allocator@UServiceIdentifier@@@std@@@std@@SAXAAV?$allocator@UServiceIdentifier@@@1@PAUServiceIdentifier@@$$QAU3@@Z PROC ; std::allocator_traits<std::allocator<ServiceIdentifier> >::construct<ServiceIdentifier,ServiceIdentifier>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

	push	ebp
	mov	ebp, esp

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@UServiceIdentifier@@@std@@YA$$QAUServiceIdentifier@@AAU1@@Z ; std::forward<ServiceIdentifier>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@UServiceIdentifier@@U1@@?$allocator@UServiceIdentifier@@@std@@QAEXPAUServiceIdentifier@@$$QAU2@@Z ; std::allocator<ServiceIdentifier>::construct<ServiceIdentifier,ServiceIdentifier>

; 724  : 		}

	pop	ebp
	ret	0
??$construct@UServiceIdentifier@@U1@@?$allocator_traits@V?$allocator@UServiceIdentifier@@@std@@@std@@SAXAAV?$allocator@UServiceIdentifier@@@1@PAUServiceIdentifier@@$$QAU3@@Z ENDP ; std::allocator_traits<std::allocator<ServiceIdentifier> >::construct<ServiceIdentifier,ServiceIdentifier>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$construct@UServiceIdentifier@@U1@@?$allocator@UServiceIdentifier@@@std@@QAEXPAUServiceIdentifier@@$$QAU2@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv73 = -8						; size = 4
$T1 = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UServiceIdentifier@@U1@@?$allocator@UServiceIdentifier@@@std@@QAEXPAUServiceIdentifier@@$$QAU2@@Z PROC ; std::allocator<ServiceIdentifier>::construct<ServiceIdentifier,ServiceIdentifier>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	12					; 0000000cH
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@UServiceIdentifier@@@std@@YA$$QAUServiceIdentifier@@AAU1@@Z ; std::forward<ServiceIdentifier>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR $T1[ebp]
	call	??0ServiceIdentifier@@QAE@ABU0@@Z
	mov	DWORD PTR tv73[ebp], eax
	jmp	SHORT $LN1@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN1@construct:

; 601  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@UServiceIdentifier@@U1@@?$allocator@UServiceIdentifier@@@std@@QAEXPAUServiceIdentifier@@$$QAU2@@Z ENDP ; std::allocator<ServiceIdentifier>::construct<ServiceIdentifier,ServiceIdentifier>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0ServiceIdentifier@@QAE@ABU0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0ServiceIdentifier@@QAE@ABU0@@Z PROC			; ServiceIdentifier::ServiceIdentifier, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??0String@@QAE@ABV0@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0ServiceIdentifier@@QAE@ABU0@@Z ENDP			; ServiceIdentifier::ServiceIdentifier
_TEXT	ENDS
END

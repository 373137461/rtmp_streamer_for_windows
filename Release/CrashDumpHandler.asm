; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

	TITLE	F:\songmm_moon_stone_obs\OBS\Source\CrashDumpHandler.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

EXTRN	__imp__GetSystemTime@4:PROC
EXTRN	__imp__LocalFree@4:PROC
EXTRN	__imp_?WriteStr@XFile@@QAEHPB_W@Z:PROC
EXTRN	__imp_?WriteStr@XFile@@QAEHPBD@Z:PROC
EXTRN	__imp_?FlushFileBuffers@XFile@@QAEXXZ:PROC
EXTRN	__imp_?Close@XFile@@QAEXXZ:PROC
EXTRN	__imp__RegCloseKey@4:PROC
EXTRN	__imp__GetCurrentProcessId@0:PROC
EXTRN	__imp__DeleteFileW@4:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__GetCurrentThreadId@0:PROC
EXTRN	__imp__IsDebuggerPresent@0:PROC
EXTRN	__imp_?tsprintf_s@@YAHPA_WIPB_WZZ:PROC
EXTRN	__imp_?scpy@@YGXPA_WPB_W@Z:PROC
EXTRN	__imp__ShellExecuteW@24:PROC
EXTRN	__imp__LocalAlloc@8:PROC
EXTRN	__imp__CreateFileW@28:PROC
EXTRN	__imp__GetFileAttributesW@4:PROC
EXTRN	__imp__GetVersionExW@4:PROC
EXTRN	__imp_?scpy_n@@YGXPA_WPB_WI@Z:PROC
EXTRN	__imp__RegOpenKeyW@12:PROC
EXTRN	__imp__RegQueryValueExW@24:PROC
EXTRN	__imp_?slwr@@YGXPA_W@Z:PROC
EXTRN	__imp__GetCurrentThread@0:PROC
EXTRN	__imp__GetCurrentProcess@0:PROC
EXTRN	__imp__FreeLibrary@4:PROC
EXTRN	__imp_?srchr@@YGPA_WPB_W_W@Z:PROC
EXTRN	__imp__GetThreadContext@8:PROC
;	COMDAT ?inExceptionHandler@?1??OBSExceptionHandler@@YGJPAU_EXCEPTION_POINTERS@@@Z@4HA
_BSS	SEGMENT
?inExceptionHandler@?1??OBSExceptionHandler@@YGJPAU_EXCEPTION_POINTERS@@@Z@4HA DD 01H DUP (?) ; `OBSExceptionHandler'::`2'::inExceptionHandler
_BSS	ENDS
$SG4294929707 DB '%', 00H, '0', 00H, '8', 00H, '.', 00H, '8', 00H, 'I', 00H
	DB	'6', 00H, '4', 00H, 'X', 00H, '-', 00H, '%', 00H, '0', 00H, '8'
	DB	00H, '.', 00H, '8', 00H, 'I', 00H, '6', 00H, '4', 00H, 'X', 00H
	DB	' ', 00H, '%', 00H, 's', 00H, 0dH, 00H, 0aH, 00H, 00H, 00H
	ORG $+2
$SG4294929706 DB 'D', 00H, 'B', 00H, 'G', 00H, 'H', 00H, 'E', 00H, 'L', 00H
	DB	'P', 00H, 00H, 00H
$SG4294929705 DB 'EnumerateLoadedModulesW64', 00H
	ORG $+2
$SG4294929704 DB 'SymSetOptions', 00H
	ORG $+2
$SG4294929703 DB 'SymInitialize', 00H
	ORG $+2
$SG4294929702 DB 'SymFunctionTableAccess64', 00H
	ORG $+3
$SG4294929701 DB 'SymGetModuleBase64', 00H
	ORG $+1
$SG4294929700 DB 'StackWalk64', 00H
$SG4294929699 DB 'SymFromAddrW', 00H
	ORG $+3
$SG4294929698 DB 'SymCleanup', 00H
	ORG $+1
$SG4294929697 DB 'SymGetModuleInfo64', 00H
	ORG $+1
$SG4294929696 DB 'MiniDumpWriteDump', 00H
	ORG $+2
$SG4294929695 DB '%', 00H, 's', 00H, '\', 00H, 'c', 00H, 'r', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'D', 00H, 'u', 00H, 'm', 00H, 'p', 00H, 's'
	DB	00H, '\', 00H, 'O', 00H, 'B', 00H, 'S', 00H, 'C', 00H, 'r', 00H
	DB	'a', 00H, 's', 00H, 'h', 00H, 'L', 00H, 'o', 00H, 'g', 00H, '%'
	DB	00H, '.', 00H, '4', 00H, 'd', 00H, '-', 00H, '%', 00H, '.', 00H
	DB	'2', 00H, 'd', 00H, '-', 00H, '%', 00H, '.', 00H, '2', 00H, 'd'
	DB	00H, '_', 00H, '%', 00H, 'd', 00H, '.', 00H, 't', 00H, 'x', 00H
	DB	't', 00H, 00H, 00H
	ORG $+2
$SG4294929694 DB 'H', 00H, 'A', 00H, 'R', 00H, 'D', 00H, 'W', 00H, 'A', 00H
	DB	'R', 00H, 'E', 00H, '\', 00H, 'D', 00H, 'E', 00H, 'S', 00H, 'C'
	DB	00H, 'R', 00H, 'I', 00H, 'P', 00H, 'T', 00H, 'I', 00H, 'O', 00H
	DB	'N', 00H, '\', 00H, 'S', 00H, 'y', 00H, 's', 00H, 't', 00H, 'e'
	DB	00H, 'm', 00H, '\', 00H, 'C', 00H, 'e', 00H, 'n', 00H, 't', 00H
	DB	'r', 00H, 'a', 00H, 'l', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'c'
	DB	00H, 'e', 00H, 's', 00H, 's', 00H, 'o', 00H, 'r', 00H, '\', 00H
	DB	'0', 00H, 00H, 00H
	ORG $+2
$SG4294929693 DB 'P', 00H, 'r', 00H, 'o', 00H, 'c', 00H, 'e', 00H, 's', 00H
	DB	's', 00H, 'o', 00H, 'r', 00H, 'N', 00H, 'a', 00H, 'm', 00H, 'e'
	DB	00H, 'S', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H
	DB	00H, 00H
$SG4294929692 DB '<', 00H, 'u', 00H, 'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H
	DB	'e', 00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'q', 00H, 'u'
	DB	00H, 'e', 00H, 'r', 00H, 'y', 00H, '>', 00H, 00H, 00H
$SG4294929691 DB '<', 00H, 'u', 00H, 'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H
	DB	'e', 00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'q', 00H, 'u'
	DB	00H, 'e', 00H, 'r', 00H, 'y', 00H, '>', 00H, 00H, 00H
$SG4294929690 DB '<', 00H, 'u', 00H, 'n', 00H, 'k', 00H, 'n', 00H, 'o', 00H
	DB	'w', 00H, 'n', 00H, '>', 00H, 00H, 00H
$SG4294929689 DB 'p', 00H, 'l', 00H, 'u', 00H, 'g', 00H, 'i', 00H, 'n', 00H
	DB	's', 00H, '\', 00H, 00H, 00H
	ORG $+2
$SG4294929688 DB 'O', 00H, 'B', 00H, 'S', 00H, ' ', 00H, 'h', 00H, 'a', 00H
	DB	's', 00H, ' ', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'u'
	DB	00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 'a', 00H, 'n', 00H, ' ', 00H, 'u', 00H, 'n', 00H, 'h'
	DB	00H, 'a', 00H, 'n', 00H, 'd', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 'e', 00H, 'x', 00H, 'c', 00H, 'e', 00H, 'p', 00H, 't'
	DB	00H, 'i', 00H, 'o', 00H, 'n', 00H, ' ', 00H, 'a', 00H, 'n', 00H
	DB	'd', 00H, ' ', 00H, 'h', 00H, 'a', 00H, 's', 00H, ' ', 00H, 't'
	DB	00H, 'e', 00H, 'r', 00H, 'm', 00H, 'i', 00H, 'n', 00H, 'a', 00H
	DB	't', 00H, 'e', 00H, 'd', 00H, '.', 00H, ' ', 00H, 'I', 00H, 'f'
	DB	00H, ' ', 00H, 'y', 00H, 'o', 00H, 'u', 00H, ' ', 00H, 'a', 00H
	DB	'r', 00H, 'e', 00H, ' ', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e'
	DB	00H, ' ', 00H, 't', 00H, 'o', 00H, 0dH, 00H, 0aH, 00H, 'r', 00H
	DB	'e', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'd', 00H, 'u', 00H, 'c'
	DB	00H, 'e', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'i', 00H, 's', 00H
	DB	' ', 00H, 'c', 00H, 'r', 00H, 'a', 00H, 's', 00H, 'h', 00H, ','
	DB	00H, ' ', 00H, 'p', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 's', 00H
	DB	'e', 00H, ' ', 00H, 's', 00H, 'u', 00H, 'b', 00H, 'm', 00H, 'i'
	DB	00H, 't', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'i', 00H, 's', 00H
	DB	' ', 00H, 'c', 00H, 'r', 00H, 'a', 00H, 's', 00H, 'h', 00H, ' '
	DB	00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o', 00H, 'r', 00H, 't', 00H
	DB	' ', 00H, 'o', 00H, 'n', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'e'
	DB	00H, ' ', 00H, 'f', 00H, 'o', 00H, 'r', 00H, 'u', 00H, 'm', 00H
	DB	's', 00H, ' ', 00H, 'a', 00H, 't', 00H, 0dH, 00H, 0aH, 00H, 'h'
	DB	00H, 't', 00H, 't', 00H, 'p', 00H, 's', 00H, ':', 00H, '/', 00H
	DB	'/', 00H, 'o', 00H, 'b', 00H, 's', 00H, 'p', 00H, 'r', 00H, 'o'
	DB	00H, 'j', 00H, 'e', 00H, 'c', 00H, 't', 00H, '.', 00H, 'c', 00H
	DB	'o', 00H, 'm', 00H, '/', 00H, ' ', 00H, '-', 00H, ' ', 00H, 'i'
	DB	00H, 'n', 00H, 'c', 00H, 'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H
	DB	' ', 00H, 't', 00H, 'h', 00H, 'e', 00H, ' ', 00H, 'c', 00H, 'o'
	DB	00H, 'n', 00H, 't', 00H, 'e', 00H, 'n', 00H, 't', 00H, 's', 00H
	DB	' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'i'
	DB	00H, 's', 00H, ' ', 00H, 'c', 00H, 'r', 00H, 'a', 00H, 's', 00H
	DB	'h', 00H, ' ', 00H, 'l', 00H, 'o', 00H, 'g', 00H, ' ', 00H, 'a'
	DB	00H, 'n', 00H, 'd', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'e', 00H
	DB	0dH, 00H, 0aH, 00H, 'm', 00H, 'i', 00H, 'n', 00H, 'i', 00H, 'd'
	DB	00H, 'u', 00H, 'm', 00H, 'p', 00H, ' ', 00H, '.', 00H, 'd', 00H
	DB	'm', 00H, 'p', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l', 00H, 'e'
	DB	00H, ' ', 00H, '(', 00H, 'i', 00H, 'f', 00H, ' ', 00H, 'a', 00H
	DB	'v', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'a', 00H, 'b', 00H, 'l'
	DB	00H, 'e', 00H, ')', 00H, ' ', 00H, 'a', 00H, 's', 00H, ' ', 00H
	DB	'w', 00H, 'e', 00H, 'l', 00H, 'l', 00H, ' ', 00H, 'a', 00H, 's'
	DB	00H, ' ', 00H, 'y', 00H, 'o', 00H, 'u', 00H, 'r', 00H, ' ', 00H
	DB	'r', 00H, 'e', 00H, 'g', 00H, 'u', 00H, 'l', 00H, 'a', 00H, 'r'
	DB	00H, ' ', 00H, 'O', 00H, 'B', 00H, 'S', 00H, ' ', 00H, 'l', 00H
	DB	'o', 00H, 'g', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l', 00H, 'e'
	DB	00H, 's', 00H, ' ', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 0dH, 00H
	DB	0aH, 00H, 'a', 00H, ' ', 00H, 'd', 00H, 'e', 00H, 's', 00H, 'c'
	DB	00H, 'r', 00H, 'i', 00H, 'p', 00H, 't', 00H, 'i', 00H, 'o', 00H
	DB	'n', 00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 'w', 00H, 'h'
	DB	00H, 'a', 00H, 't', 00H, ' ', 00H, 'y', 00H, 'o', 00H, 'u', 00H
	DB	' ', 00H, 'w', 00H, 'e', 00H, 'r', 00H, 'e', 00H, ' ', 00H, 'd'
	DB	00H, 'o', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'a', 00H
	DB	't', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'e', 00H, ' ', 00H, 't'
	DB	00H, 'i', 00H, 'm', 00H, 'e', 00H, ' ', 00H, 'o', 00H, 'f', 00H
	DB	' ', 00H, 't', 00H, 'h', 00H, 'e', 00H, ' ', 00H, 'c', 00H, 'r'
	DB	00H, 'a', 00H, 's', 00H, 'h', 00H, '.', 00H, 0dH, 00H, 0aH, 00H
	DB	0dH, 00H, 0aH, 00H, 'T', 00H, 'h', 00H, 'i', 00H, 's', 00H, ' '
	DB	00H, 'c', 00H, 'r', 00H, 'a', 00H, 's', 00H, 'h', 00H, ' ', 00H
	DB	'a', 00H, 'p', 00H, 'p', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 's'
	DB	00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'h', 00H, 'a', 00H
	DB	'v', 00H, 'e', 00H, ' ', 00H, 'o', 00H, 'c', 00H, 'c', 00H, 'u'
	DB	00H, 'r', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'i', 00H, 'n', 00H
	DB	' ', 00H, 't', 00H, 'h', 00H, 'e', 00H, ' ', 00H, '''', 00H, 00H
	DB	00H
$SG4294929687 DB '''', 00H, ' ', 00H, 'm', 00H, 'o', 00H, 'd', 00H, 'u', 00H
	DB	'l', 00H, 'e', 00H, '.', 00H, 0dH, 00H, 0aH, 00H, 0dH, 00H, 0aH
	DB	00H, 00H, 00H
$SG4294929681 DB '<', 00H, 'u', 00H, 'n', 00H, 'k', 00H, 'n', 00H, 'o', 00H
	DB	'w', 00H, 'n', 00H, '>', 00H, 00H, 00H
$SG4294929686 DB '*', 00H, '*', 00H, '*', 00H, '*', 00H, ' ', 00H, 'U', 00H
	DB	'N', 00H, 'H', 00H, 'A', 00H, 'N', 00H, 'D', 00H, 'L', 00H, 'E'
	DB	00H, 'D', 00H, ' ', 00H, 'E', 00H, 'X', 00H, 'C', 00H, 'E', 00H
	DB	'P', 00H, 'T', 00H, 'I', 00H, 'O', 00H, 'N', 00H, ':', 00H, ' '
	DB	00H, '%', 00H, 'x', 00H, 0dH, 00H, 0aH, 00H, 'F', 00H, 'a', 00H
	DB	'u', 00H, 'l', 00H, 't', 00H, ' ', 00H, 'a', 00H, 'd', 00H, 'd'
	DB	00H, 'r', 00H, 'e', 00H, 's', 00H, 's', 00H, ':', 00H, ' ', 00H
	DB	'%', 00H, 'I', 00H, '6', 00H, '4', 00H, 'p', 00H, ' ', 00H, '('
	DB	00H, '%', 00H, 's', 00H, ')', 00H, 0dH, 00H, 0aH, 00H, 00H, 00H
$SG4294929678 DB 0dH, 00H, 0aH, 00H, 'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H
	DB	'o', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'r', 00H, 'e', 00H, 'a'
	DB	00H, 'd', 00H, ' ', 00H, 's', 00H, 't', 00H, 'a', 00H, 'c', 00H
	DB	'k', 00H, ' ', 00H, 't', 00H, 'r', 00H, 'a', 00H, 'c', 00H, 'e'
	DB	00H, ':', 00H, 0dH, 00H, 0aH, 00H, 00H, 00H
$SG4294929685 DB 'O', 00H, 'B', 00H, 'S', 00H, ' ', 00H, 'v', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, 'i', 00H, 'o', 00H, 'n', 00H, ':', 00H, ' '
	DB	00H, 'O', 00H, 'p', 00H, 'e', 00H, 'n', 00H, ' ', 00H, 'B', 00H
	DB	'r', 00H, 'o', 00H, 'a', 00H, 'd', 00H, 'c', 00H, 'a', 00H, 's'
	DB	00H, 't', 00H, 'e', 00H, 'r', 00H, ' ', 00H, 'S', 00H, 'o', 00H
	DB	'f', 00H, 't', 00H, 'w', 00H, 'a', 00H, 'r', 00H, 'e', 00H, ' '
	DB	00H, 'v', 00H, '0', 00H, '.', 00H, '6', 00H, '5', 00H, '7', 00H
	DB	'b', 00H, 0dH, 00H, 0aH, 00H, 00H, 00H
	ORG $+2
$SG4294929676 DB '<', 00H, 'u', 00H, 'n', 00H, 'k', 00H, 'n', 00H, 'o', 00H
	DB	'w', 00H, 'n', 00H, '>', 00H, 00H, 00H
$SG4294929684 DB 'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H
	DB	's', 00H, ' ', 00H, 'v', 00H, 'e', 00H, 'r', 00H, 's', 00H, 'i'
	DB	00H, 'o', 00H, 'n', 00H, ':', 00H, ' ', 00H, '%', 00H, 'd', 00H
	DB	'.', 00H, '%', 00H, 'd', 00H, ' ', 00H, '(', 00H, 'B', 00H, 'u'
	DB	00H, 'i', 00H, 'l', 00H, 'd', 00H, ' ', 00H, '%', 00H, 'd', 00H
	DB	')', 00H, ' ', 00H, '%', 00H, 's', 00H, 0dH, 00H, 0aH, 00H, 'C'
	DB	00H, 'P', 00H, 'U', 00H, ':', 00H, ' ', 00H, '%', 00H, 's', 00H
	DB	0dH, 00H, 0aH, 00H, 0dH, 00H, 0aH, 00H, 00H, 00H
$SG4294929683 DB 'C', 00H, 'r', 00H, 'a', 00H, 's', 00H, 'h', 00H, 'i', 00H
	DB	'n', 00H, 'g', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'r', 00H, 'e'
	DB	00H, 'a', 00H, 'd', 00H, ' ', 00H, 's', 00H, 't', 00H, 'a', 00H
	DB	'c', 00H, 'k', 00H, ' ', 00H, 't', 00H, 'r', 00H, 'a', 00H, 'c'
	DB	00H, 'e', 00H, ':', 00H, 0dH, 00H, 0aH, 00H, 00H, 00H
	ORG $+2
$SG4294929671 DB '<', 00H, 'u', 00H, 'n', 00H, 'k', 00H, 'n', 00H, 'o', 00H
	DB	'w', 00H, 'n', 00H, '>', 00H, 00H, 00H
$SG4294929682 DB 'S', 00H, 't', 00H, 'a', 00H, 'c', 00H, 'k', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, 'E', 00H, 'I', 00H, 'P', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'A', 00H
	DB	'r', 00H, 'g', 00H, '0', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, 'A', 00H, 'r', 00H, 'g', 00H, '1', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'A', 00H, 'r', 00H, 'g'
	DB	00H, '2', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	'A', 00H, 'r', 00H, 'g', 00H, '3', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, 'A', 00H, 'd', 00H, 'd', 00H, 'r', 00H
	DB	'e', 00H, 's', 00H, 's', 00H, 0dH, 00H, 0aH, 00H, 00H, 00H
$SG4294929680 DB '%', 00H, '0', 00H, '8', 00H, '.', 00H, '8', 00H, 'I', 00H
	DB	'6', 00H, '4', 00H, 'X', 00H, ' ', 00H, '%', 00H, '0', 00H, '8'
	DB	00H, '.', 00H, '8', 00H, 'I', 00H, '6', 00H, '4', 00H, 'X', 00H
	DB	' ', 00H, '%', 00H, '0', 00H, '8', 00H, '.', 00H, '8', 00H, 'X'
	DB	00H, ' ', 00H, '%', 00H, '0', 00H, '8', 00H, '.', 00H, '8', 00H
	DB	'X', 00H, ' ', 00H, '%', 00H, '0', 00H, '8', 00H, '.', 00H, '8'
	DB	00H, 'X', 00H, ' ', 00H, '%', 00H, '0', 00H, '8', 00H, '.', 00H
	DB	'8', 00H, 'X', 00H, ' ', 00H, '%', 00H, 's', 00H, '!', 00H, '%'
	DB	00H, 's', 00H, '+', 00H, '0', 00H, 'x', 00H, '%', 00H, 'I', 00H
	DB	'6', 00H, '4', 00H, 'x', 00H, 0dH, 00H, 0aH, 00H, 00H, 00H
$SG4294929679 DB '%', 00H, '0', 00H, '8', 00H, '.', 00H, '8', 00H, 'I', 00H
	DB	'6', 00H, '4', 00H, 'X', 00H, ' ', 00H, '%', 00H, '0', 00H, '8'
	DB	00H, '.', 00H, '8', 00H, 'I', 00H, '6', 00H, '4', 00H, 'X', 00H
	DB	' ', 00H, '%', 00H, '0', 00H, '8', 00H, '.', 00H, '8', 00H, 'X'
	DB	00H, ' ', 00H, '%', 00H, '0', 00H, '8', 00H, '.', 00H, '8', 00H
	DB	'X', 00H, ' ', 00H, '%', 00H, '0', 00H, '8', 00H, '.', 00H, '8'
	DB	00H, 'X', 00H, ' ', 00H, '%', 00H, '0', 00H, '8', 00H, '.', 00H
	DB	'8', 00H, 'X', 00H, ' ', 00H, '%', 00H, 's', 00H, '!', 00H, '0'
	DB	00H, 'x', 00H, '%', 00H, 'I', 00H, '6', 00H, '4', 00H, 'x', 00H
	DB	0dH, 00H, 0aH, 00H, 00H, 00H
	ORG $+2
$SG4294929665 DB 0dH, 0aH, 'List of loaded modules:', 0dH, 0aH, 00H
$SG4294929677 DB 'S', 00H, 't', 00H, 'a', 00H, 'c', 00H, 'k', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, 'E', 00H, 'I', 00H, 'P', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'A', 00H
	DB	'r', 00H, 'g', 00H, '0', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, 'A', 00H, 'r', 00H, 'g', 00H, '1', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'A', 00H, 'r', 00H, 'g'
	DB	00H, '2', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	'A', 00H, 'r', 00H, 'g', 00H, '3', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, 'A', 00H, 'd', 00H, 'd', 00H, 'r', 00H
	DB	'e', 00H, 's', 00H, 's', 00H, 0dH, 00H, 0aH, 00H, 00H, 00H
$SG4294929675 DB '%', 00H, '0', 00H, '8', 00H, '.', 00H, '8', 00H, 'I', 00H
	DB	'6', 00H, '4', 00H, 'X', 00H, ' ', 00H, '%', 00H, '0', 00H, '8'
	DB	00H, '.', 00H, '8', 00H, 'I', 00H, '6', 00H, '4', 00H, 'X', 00H
	DB	' ', 00H, '%', 00H, '0', 00H, '8', 00H, '.', 00H, '8', 00H, 'X'
	DB	00H, ' ', 00H, '%', 00H, '0', 00H, '8', 00H, '.', 00H, '8', 00H
	DB	'X', 00H, ' ', 00H, '%', 00H, '0', 00H, '8', 00H, '.', 00H, '8'
	DB	00H, 'X', 00H, ' ', 00H, '%', 00H, '0', 00H, '8', 00H, '.', 00H
	DB	'8', 00H, 'X', 00H, ' ', 00H, '%', 00H, 's', 00H, '!', 00H, '%'
	DB	00H, 's', 00H, '+', 00H, '0', 00H, 'x', 00H, '%', 00H, 'I', 00H
	DB	'6', 00H, '4', 00H, 'x', 00H, 0dH, 00H, 0aH, 00H, 00H, 00H
$SG4294929674 DB '%', 00H, '0', 00H, '8', 00H, '.', 00H, '8', 00H, 'I', 00H
	DB	'6', 00H, '4', 00H, 'X', 00H, ' ', 00H, '%', 00H, '0', 00H, '8'
	DB	00H, '.', 00H, '8', 00H, 'I', 00H, '6', 00H, '4', 00H, 'X', 00H
	DB	' ', 00H, '%', 00H, '0', 00H, '8', 00H, '.', 00H, '8', 00H, 'X'
	DB	00H, ' ', 00H, '%', 00H, '0', 00H, '8', 00H, '.', 00H, '8', 00H
	DB	'X', 00H, ' ', 00H, '%', 00H, '0', 00H, '8', 00H, '.', 00H, '8'
	DB	00H, 'X', 00H, ' ', 00H, '%', 00H, '0', 00H, '8', 00H, '.', 00H
	DB	'8', 00H, 'X', 00H, ' ', 00H, '%', 00H, 's', 00H, '!', 00H, '0'
	DB	00H, 'x', 00H, '%', 00H, 'I', 00H, '6', 00H, '4', 00H, 'x', 00H
	DB	0dH, 00H, 0aH, 00H, 00H, 00H
	ORG $+2
$SG4294929673 DB 0dH, 00H, 0aH, 00H, 'E', 00H, 'n', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'r', 00H, 'e'
	DB	00H, 'a', 00H, 'd', 00H, ' ', 00H, 's', 00H, 't', 00H, 'a', 00H
	DB	'c', 00H, 'k', 00H, ' ', 00H, 't', 00H, 'r', 00H, 'a', 00H, 'c'
	DB	00H, 'e', 00H, ':', 00H, 0dH, 00H, 0aH, 00H, 00H, 00H
	ORG $+2
$SG4294929664 DB 'Base Address      Module', 0dH, 0aH, 00H
	ORG $+1
$SG4294929672 DB 'S', 00H, 't', 00H, 'a', 00H, 'c', 00H, 'k', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, 'E', 00H, 'I', 00H, 'P', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'A', 00H
	DB	'r', 00H, 'g', 00H, '0', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, 'A', 00H, 'r', 00H, 'g', 00H, '1', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'A', 00H, 'r', 00H, 'g'
	DB	00H, '2', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	'A', 00H, 'r', 00H, 'g', 00H, '3', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, 'A', 00H, 'd', 00H, 'd', 00H, 'r', 00H
	DB	'e', 00H, 's', 00H, 's', 00H, 0dH, 00H, 0aH, 00H, 00H, 00H
$SG4294929670 DB '%', 00H, '0', 00H, '8', 00H, '.', 00H, '8', 00H, 'I', 00H
	DB	'6', 00H, '4', 00H, 'X', 00H, ' ', 00H, '%', 00H, '0', 00H, '8'
	DB	00H, '.', 00H, '8', 00H, 'I', 00H, '6', 00H, '4', 00H, 'X', 00H
	DB	' ', 00H, '%', 00H, '0', 00H, '8', 00H, '.', 00H, '8', 00H, 'X'
	DB	00H, ' ', 00H, '%', 00H, '0', 00H, '8', 00H, '.', 00H, '8', 00H
	DB	'X', 00H, ' ', 00H, '%', 00H, '0', 00H, '8', 00H, '.', 00H, '8'
	DB	00H, 'X', 00H, ' ', 00H, '%', 00H, '0', 00H, '8', 00H, '.', 00H
	DB	'8', 00H, 'X', 00H, ' ', 00H, '%', 00H, 's', 00H, '!', 00H, '%'
	DB	00H, 's', 00H, '+', 00H, '0', 00H, 'x', 00H, '%', 00H, 'I', 00H
	DB	'6', 00H, '4', 00H, 'x', 00H, 0dH, 00H, 0aH, 00H, 00H, 00H
$SG4294929669 DB '%', 00H, '0', 00H, '8', 00H, '.', 00H, '8', 00H, 'I', 00H
	DB	'6', 00H, '4', 00H, 'X', 00H, ' ', 00H, '%', 00H, '0', 00H, '8'
	DB	00H, '.', 00H, '8', 00H, 'I', 00H, '6', 00H, '4', 00H, 'X', 00H
	DB	' ', 00H, '%', 00H, '0', 00H, '8', 00H, '.', 00H, '8', 00H, 'X'
	DB	00H, ' ', 00H, '%', 00H, '0', 00H, '8', 00H, '.', 00H, '8', 00H
	DB	'X', 00H, ' ', 00H, '%', 00H, '0', 00H, '8', 00H, '.', 00H, '8'
	DB	00H, 'X', 00H, ' ', 00H, '%', 00H, '0', 00H, '8', 00H, '.', 00H
	DB	'8', 00H, 'X', 00H, ' ', 00H, '%', 00H, 's', 00H, '!', 00H, '0'
	DB	00H, 'x', 00H, '%', 00H, 'I', 00H, '6', 00H, '4', 00H, 'x', 00H
	DB	0dH, 00H, 0aH, 00H, 00H, 00H
	ORG $+3
$SG4294929668 DB '%', 00H, 's', 00H, '\', 00H, 'c', 00H, 'r', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'D', 00H, 'u', 00H, 'm', 00H, 'p', 00H, 's'
	DB	00H, '\', 00H, 'O', 00H, 'B', 00H, 'S', 00H, 'C', 00H, 'r', 00H
	DB	'a', 00H, 's', 00H, 'h', 00H, 'D', 00H, 'u', 00H, 'm', 00H, 'p'
	DB	00H, '%', 00H, '.', 00H, '4', 00H, 'd', 00H, '-', 00H, '%', 00H
	DB	'.', 00H, '2', 00H, 'd', 00H, '-', 00H, '%', 00H, '.', 00H, '2'
	DB	00H, 'd', 00H, '_', 00H, '%', 00H, 'd', 00H, '.', 00H, 'd', 00H
	DB	'm', 00H, 'p', 00H, 00H, 00H
$SG4294929667 DB 0dH, 00H, 0aH, 00H, 'A', 00H, ' ', 00H, 'm', 00H, 'i', 00H
	DB	'n', 00H, 'i', 00H, 'd', 00H, 'u', 00H, 'm', 00H, 'p', 00H, ' '
	DB	00H, 'w', 00H, 'a', 00H, 's', 00H, ' ', 00H, 's', 00H, 'a', 00H
	DB	'v', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 't', 00H, 'o', 00H, ' '
	DB	00H, '%', 00H, 's', 00H, '.', 00H, 0dH, 00H, 0aH, 00H, 'P', 00H
	DB	'l', 00H, 'e', 00H, 'a', 00H, 's', 00H, 'e', 00H, ' ', 00H, 'i'
	DB	00H, 'n', 00H, 'c', 00H, 'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H
	DB	' ', 00H, 't', 00H, 'h', 00H, 'i', 00H, 's', 00H, ' ', 00H, 'f'
	DB	00H, 'i', 00H, 'l', 00H, 'e', 00H, ' ', 00H, 'w', 00H, 'h', 00H
	DB	'e', 00H, 'n', 00H, ' ', 00H, 'p', 00H, 'o', 00H, 's', 00H, 't'
	DB	00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'a', 00H, ' ', 00H
	DB	'c', 00H, 'r', 00H, 'a', 00H, 's', 00H, 'h', 00H, ' ', 00H, 'r'
	DB	00H, 'e', 00H, 'p', 00H, 'o', 00H, 'r', 00H, 't', 00H, '.', 00H
	DB	0dH, 00H, 0aH, 00H, 00H, 00H
	ORG $+2
$SG4294929666 DB 0dH, 00H, 0aH, 00H, 'A', 00H, ' ', 00H, 'm', 00H, 'i', 00H
	DB	'n', 00H, 'i', 00H, 'd', 00H, 'u', 00H, 'm', 00H, 'p', 00H, ' '
	DB	00H, 'c', 00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, ' ', 00H
	DB	'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'b', 00H, 'e', 00H, ' '
	DB	00H, 'c', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 't', 00H, 'e', 00H
	DB	'd', 00H, '.', 00H, ' ', 00H, 'P', 00H, 'l', 00H, 'e', 00H, 'a'
	DB	00H, 's', 00H, 'e', 00H, ' ', 00H, 'c', 00H, 'h', 00H, 'e', 00H
	DB	'c', 00H, 'k', 00H, ' ', 00H, 'd', 00H, 'b', 00H, 'g', 00H, 'h'
	DB	00H, 'e', 00H, 'l', 00H, 'p', 00H, '.', 00H, 'd', 00H, 'l', 00H
	DB	'l', 00H, ' ', 00H, 'i', 00H, 's', 00H, ' ', 00H, 'p', 00H, 'r'
	DB	00H, 'e', 00H, 's', 00H, 'e', 00H, 'n', 00H, 't', 00H, '.', 00H
	DB	0dH, 00H, 0aH, 00H, 00H, 00H
	ORG $+2
$SG4294929663 DB 'W', 00H, 'o', 00H, 'o', 00H, 'p', 00H, 's', 00H, '!', 00H
	DB	' ', 00H, 'O', 00H, 'B', 00H, 'S', 00H, ' ', 00H, 'h', 00H, 'a'
	DB	00H, 's', 00H, ' ', 00H, 'c', 00H, 'r', 00H, 'a', 00H, 's', 00H
	DB	'h', 00H, 'e', 00H, 'd', 00H, '.', 00H, ' ', 00H, 'W', 00H, 'o'
	DB	00H, 'u', 00H, 'l', 00H, 'd', 00H, ' ', 00H, 'y', 00H, 'o', 00H
	DB	'u', 00H, ' ', 00H, 'l', 00H, 'i', 00H, 'k', 00H, 'e', 00H, ' '
	DB	00H, 't', 00H, 'o', 00H, ' ', 00H, 'v', 00H, 'i', 00H, 'e', 00H
	DB	'w', 00H, ' ', 00H, 'a', 00H, ' ', 00H, 'c', 00H, 'r', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 'p', 00H
	DB	'o', 00H, 'r', 00H, 't', 00H, '?', 00H, 00H, 00H
PUBLIC	?OBSExceptionHandler@@YGJPAU_EXCEPTION_POINTERS@@@Z ; OBSExceptionHandler
PUBLIC	?RecordAllLoadedModules@@YGHPB_W_KKPAX@Z	; RecordAllLoadedModules
PUBLIC	?EnumerateLoadedModulesProcInfo@@YGHPB_W_KKPAX@Z ; EnumerateLoadedModulesProcInfo
PUBLIC	_IsolationAwareLoadLibraryW@4
	ALIGN	4

__Tuple_alloc DB 01H DUP (?)
	ALIGN	4

_ignore	DB	01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
	ALIGN	4

_piecewise_construct DB 01H DUP (?)
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$_IsolationAwareLoadLibraryW@4 DD 0fffffffeH
	DD	00H
	DD	0ffffffb8H
	DD	00H
	DD	0fffffffeH
	DD	00H
	DD	FLAT:$LN19@IsolationA
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
_ignore$initializer$ DD FLAT:??__Eignore@std@@YAXXZ
__Tuple_alloc$initializer$ DD FLAT:??__E_Tuple_alloc@std@@YAXXZ
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\8.1\include\um\winbase.inl
;	COMDAT _IsolationAwareLoadLibraryW@4
_TEXT	SEGMENT
_dwLastError$2 = -56					; size = 4
_fActivateActCtxSuccess$ = -52				; size = 4
_fPreserveLastError$3 = -48				; size = 4
_ulpCookie$ = -44					; size = 4
tv77 = -40						; size = 4
tv74 = -36						; size = 4
tv68 = -32						; size = 4
_moduleResult$ = -28					; size = 4
__$SEHRec$ = -24					; size = 24
_lpLibFileName$ = 8					; size = 4
_IsolationAwareLoadLibraryW@4 PROC			; COMDAT

; 124  : {

	push	ebp
	mov	ebp, esp
	push	-2					; fffffffeH
	push	OFFSET __sehtable$_IsolationAwareLoadLibraryW@4
	push	OFFSET __except_handler4
	mov	eax, DWORD PTR fs:0
	push	eax
	add	esp, -40				; ffffffd8H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	DWORD PTR __$SEHRec$[ebp+16], eax
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, eax

; 125  :     HMODULE moduleResult = NULL;

	mov	DWORD PTR _moduleResult$[ebp], 0

; 126  :     ULONG_PTR ulpCookie = 0;

	mov	DWORD PTR _ulpCookie$[ebp], 0

; 127  :     const BOOL fActivateActCtxSuccess =
; 128  : #ifdef _M_IX86
; 129  :         IsolationAwarePrivateT_SqbjaYRiRY ||
; 130  : #endif
; 131  :         IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);

	cmp	DWORD PTR _IsolationAwarePrivateT_SqbjaYRiRY, 0
	jne	SHORT $LN7@IsolationA
	lea	eax, DWORD PTR _ulpCookie$[ebp]
	push	eax
	call	_IsolationAwarePrivatenPgViNgRzlnPgpgk@4
	test	eax, eax
	jne	SHORT $LN7@IsolationA
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN8@IsolationA
$LN7@IsolationA:
	mov	DWORD PTR tv68[ebp], 1
$LN8@IsolationA:
	mov	ecx, DWORD PTR tv68[ebp]
	mov	DWORD PTR _fActivateActCtxSuccess$[ebp], ecx

; 132  :     if (!fActivateActCtxSuccess)

	cmp	DWORD PTR _fActivateActCtxSuccess$[ebp], 0
	jne	SHORT $LN4@IsolationA

; 133  :         return moduleResult;

	mov	eax, DWORD PTR _moduleResult$[ebp]
	jmp	$LN13@IsolationA
$LN4@IsolationA:

; 134  :     __try

	mov	DWORD PTR __$SEHRec$[ebp+20], 0

; 135  :     {
; 136  :         moduleResult = LoadLibraryW(lpLibFileName);

	mov	edx, DWORD PTR _lpLibFileName$[ebp]
	push	edx
	call	DWORD PTR __imp__LoadLibraryW@4
	mov	DWORD PTR _moduleResult$[ebp], eax

; 137  :     }
; 138  :     __finally

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
	call	$LN16@IsolationA
	jmp	SHORT $LN17@IsolationA
$LN14@IsolationA:
$LN19@IsolationA:
$LN16@IsolationA:

; 139  :     {
; 140  : #ifdef _M_IX86
; 141  :         if (!IsolationAwarePrivateT_SqbjaYRiRY)

	cmp	DWORD PTR _IsolationAwarePrivateT_SqbjaYRiRY, 0
	jne	SHORT $LN15@IsolationA

; 142  : #endif
; 143  :         {
; 144  :             const BOOL fPreserveLastError = (moduleResult == NULL);

	cmp	DWORD PTR _moduleResult$[ebp], 0
	jne	SHORT $LN9@IsolationA
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN10@IsolationA
$LN9@IsolationA:
	mov	DWORD PTR tv74[ebp], 0
$LN10@IsolationA:
	mov	eax, DWORD PTR tv74[ebp]
	mov	DWORD PTR _fPreserveLastError$3[ebp], eax

; 145  :             const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;

	cmp	DWORD PTR _fPreserveLastError$3[ebp], 0
	je	SHORT $LN11@IsolationA
	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR tv77[ebp], eax
	jmp	SHORT $LN12@IsolationA
$LN11@IsolationA:
	mov	DWORD PTR tv77[ebp], 0
$LN12@IsolationA:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR _dwLastError$2[ebp], ecx

; 146  :             (void)IsolationAwareDeactivateActCtx(0, ulpCookie);

	mov	edx, DWORD PTR _ulpCookie$[ebp]
	push	edx
	push	0
	call	_IsolationAwareDeactivateActCtx@8

; 147  :             if (fPreserveLastError)

	cmp	DWORD PTR _fPreserveLastError$3[ebp], 0
	je	SHORT $LN15@IsolationA

; 148  :                 SetLastError(dwLastError);

	mov	eax, DWORD PTR _dwLastError$2[ebp]
	push	eax
	call	DWORD PTR __imp__SetLastError@4
$LN15@IsolationA:
$LN18@IsolationA:
	ret	0
$LN17@IsolationA:

; 149  :         }
; 150  :     }
; 151  :     return moduleResult;

	mov	eax, DWORD PTR _moduleResult$[ebp]
$LN13@IsolationA:

; 152  : }

	mov	ecx, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_IsolationAwareLoadLibraryW@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 70   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3451 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\tuple
;	COMDAT ??__Eignore@std@@YAXXZ
text$di	SEGMENT
??__Eignore@std@@YAXXZ PROC				; std::`dynamic initializer for 'ignore'', COMDAT

; 59   : const _Ignore ignore;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET _ignore
	call	??0_Ignore@std@@QAE@XZ			; std::_Ignore::_Ignore
	pop	ebp
	ret	0
??__Eignore@std@@YAXXZ ENDP				; std::`dynamic initializer for 'ignore''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\tuple
;	COMDAT ??__E_Tuple_alloc@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__E_Tuple_alloc@std@@YAXXZ PROC			; std::`dynamic initializer for '_Tuple_alloc'', COMDAT

; 66   : const _Tuple_alloc_t _Tuple_alloc = _Tuple_alloc_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__E_Tuple_alloc@std@@YAXXZ ENDP			; std::`dynamic initializer for '_Tuple_alloc''
text$di	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\crashdumphandler.cpp
;	COMDAT ?EnumerateLoadedModulesProcInfo@@YGHPB_W_KKPAX@Z
_TEXT	SEGMENT
tv90 = -20						; size = 8
tv89 = -12						; size = 4
tv76 = -8						; size = 4
_moduleInfo$ = -4					; size = 4
_ModuleName$ = 8					; size = 4
_ModuleBase$ = 12					; size = 8
_ModuleSize$ = 20					; size = 4
_UserContext$ = 24					; size = 4
?EnumerateLoadedModulesProcInfo@@YGHPB_W_KKPAX@Z PROC	; EnumerateLoadedModulesProcInfo, COMDAT

; 25   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 26   :     moduleinfo_t *moduleInfo = (moduleinfo_t *)UserContext;

	mov	eax, DWORD PTR _UserContext$[ebp]
	mov	DWORD PTR _moduleInfo$[ebp], eax

; 27   :     if (moduleInfo->faultAddress >= ModuleBase && moduleInfo->faultAddress <= ModuleBase + ModuleSize)

	mov	ecx, DWORD PTR _moduleInfo$[ebp]
	mov	DWORD PTR tv76[ebp], ecx
	mov	edx, DWORD PTR tv76[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _ModuleBase$[ebp+4]
	jb	SHORT $LN1@EnumerateL
	ja	SHORT $LN4@EnumerateL
	mov	ecx, DWORD PTR tv76[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _ModuleBase$[ebp]
	jb	SHORT $LN1@EnumerateL
$LN4@EnumerateL:
	mov	eax, DWORD PTR _ModuleSize$[ebp]
	xor	ecx, ecx
	add	eax, DWORD PTR _ModuleBase$[ebp]
	adc	ecx, DWORD PTR _ModuleBase$[ebp+4]
	mov	edx, DWORD PTR _moduleInfo$[ebp]
	mov	DWORD PTR tv89[ebp], edx
	mov	DWORD PTR tv90[ebp], eax
	mov	DWORD PTR tv90[ebp+4], ecx
	mov	eax, DWORD PTR tv89[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR tv90[ebp+4]
	ja	SHORT $LN1@EnumerateL
	jb	SHORT $LN5@EnumerateL
	mov	edx, DWORD PTR tv89[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR tv90[ebp]
	ja	SHORT $LN1@EnumerateL
$LN5@EnumerateL:

; 28   :     {
; 29   :         scpy_n(moduleInfo->moduleName, ModuleName, _countof(moduleInfo->moduleName)-1);

	push	259					; 00000103H
	mov	ecx, DWORD PTR _ModuleName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _moduleInfo$[ebp]
	add	edx, 8
	push	edx
	call	DWORD PTR __imp_?scpy_n@@YGXPA_WPB_WI@Z

; 30   :         return FALSE;

	xor	eax, eax
	jmp	SHORT $LN2@EnumerateL
$LN1@EnumerateL:

; 31   :     }
; 32   :     return TRUE;

	mov	eax, 1
$LN2@EnumerateL:

; 33   : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?EnumerateLoadedModulesProcInfo@@YGHPB_W_KKPAX@Z ENDP	; EnumerateLoadedModulesProcInfo
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\crashdumphandler.cpp
;	COMDAT ?RecordAllLoadedModules@@YGHPB_W_KKPAX@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_str$ = -4						; size = 4
_ModuleName$ = 8					; size = 4
_ModuleBase$ = 12					; size = 8
_ModuleSize$ = 20					; size = 4
_UserContext$ = 24					; size = 4
?RecordAllLoadedModules@@YGHPB_W_KKPAX@Z PROC		; RecordAllLoadedModules, COMDAT

; 36   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   :     String &str = *(String*)UserContext;

	mov	eax, DWORD PTR _UserContext$[ebp]
	mov	DWORD PTR _str$[ebp], eax

; 38   : 
; 39   : #ifdef _WIN64
; 40   :     str << FormattedString(TEXT("%016I64X-%016I64X %s\r\n"), ModuleBase, ModuleBase+ModuleSize, ModuleName);
; 41   : #else
; 42   :     str << FormattedString(TEXT("%08.8I64X-%08.8I64X %s\r\n"), ModuleBase, ModuleBase+ModuleSize, ModuleName);

	mov	ecx, DWORD PTR _ModuleName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ModuleSize$[ebp]
	xor	eax, eax
	add	edx, DWORD PTR _ModuleBase$[ebp]
	adc	eax, DWORD PTR _ModuleBase$[ebp+4]
	push	eax
	push	edx
	mov	ecx, DWORD PTR _ModuleBase$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _ModuleBase$[ebp]
	push	edx
	push	OFFSET $SG4294929707
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 28					; 0000001cH
	push	eax
	mov	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 43   : #endif
; 44   :     return TRUE;

	mov	eax, 1

; 45   : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?RecordAllLoadedModules@@YGHPB_W_KKPAX@Z ENDP		; RecordAllLoadedModules
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\crashdumphandler.cpp
;	COMDAT ?OBSExceptionHandler@@YGJPAU_EXCEPTION_POINTERS@@@Z
_TEXT	SEGMENT
$T1 = -3620						; size = 8
$T2 = -3612						; size = 8
$T3 = -3604						; size = 8
$T4 = -3596						; size = 8
$T5 = -3588						; size = 8
$T6 = -3580						; size = 8
$T7 = -3572						; size = 8
$T8 = -3564						; size = 8
$T9 = -3556						; size = 8
_miniInfo$ = -3548					; size = 12
_crashMessage$ = -3536					; size = 8
_dumpFlags$10 = -3528					; size = 4
_strModuleInfo$ = -3524					; size = 8
_isPlugin$ = -3516					; size = 4
$T11 = -3512						; size = 4
_fnSymGetModuleInfo64$ = -3508				; size = 4
$T12 = -3504						; size = 4
_dwSize$13 = -3500					; size = 4
_fnMiniDumpWriteDump$ = -3496				; size = 4
_fnSymSetOptions$ = -3492				; size = 4
_key$ = -3488						; size = 4
_fnSymCleanup$ = -3484					; size = 4
_fnSymInitialize$ = -3480				; size = 4
_cpuInfo$ = -3476					; size = 8
_hFile$14 = -3468					; size = 4
_fnSymFunctionTableAccess64$ = -3464			; size = 4
_fnSymFromAddr$ = -3460					; size = 4
_fnSymGetModuleBase64$ = -3456				; size = 4
_hEncodeThread$15 = -3452				; size = 4
_fnStackWalk64$ = -3448					; size = 4
_fnOffset$ = -3444					; size = 8
_hVideoThread$16 = -3436				; size = 4
_i$ = -3432						; size = 4
_crashDumpLog$ = -3428					; size = 24
_imageType$ = -3404					; size = 4
_fnEnumerateLoadedModules64$ = -3400			; size = 4
_InstructionPtr$ = -3396				; size = 8
_symInfo$ = -3388					; size = 4
_hDbgHelp$ = -3384					; size = 4
_hProcess$ = -3380					; size = 4
_p$ = -3376						; size = 4
_osInfo$ = -3372					; size = 284
_frame$ = -3088						; size = 264
_context$ = -2824					; size = 716
_moduleInfo$ = -2108					; size = 528
_timeInfo$ = -1580					; size = 16
_searchPath$ = -1564					; size = 520
_logPath$ = -1044					; size = 520
_dumpPath$17 = -524					; size = 520
__$ArrayPad$ = -4					; size = 4
_exceptionInfo$ = 8					; size = 4
?OBSExceptionHandler@@YGJPAU_EXCEPTION_POINTERS@@@Z PROC ; OBSExceptionHandler, COMDAT

; 48   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 3620				; 00000e24H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 49   :     HANDLE  hProcess;
; 50   : 
; 51   :     HMODULE hDbgHelp;
; 52   : 
; 53   :     MINIDUMP_EXCEPTION_INFORMATION miniInfo;
; 54   : 
; 55   :     STACKFRAME64        frame = {0};

	xorpd	xmm0, xmm0
	movlpd	QWORD PTR _frame$[ebp], xmm0
	push	256					; 00000100H
	push	0
	lea	eax, DWORD PTR _frame$[ebp+8]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 56   :     CONTEXT             context = *exceptionInfo->ContextRecord;

	mov	edx, DWORD PTR _exceptionInfo$[ebp]
	mov	ecx, 179				; 000000b3H
	mov	esi, DWORD PTR [edx+4]
	lea	edi, DWORD PTR _context$[ebp]
	rep movsd

; 57   :     SYMBOL_INFO         *symInfo;
; 58   :     DWORD64             fnOffset;
; 59   :     TCHAR               logPath[MAX_PATH];
; 60   : 
; 61   :     OSVERSIONINFOEX     osInfo;
; 62   :     SYSTEMTIME          timeInfo;
; 63   : 
; 64   :     ENUMERATELOADEDMODULES64    fnEnumerateLoadedModules64;
; 65   :     SYMSETOPTIONS               fnSymSetOptions;
; 66   :     SYMINITIALIZE               fnSymInitialize;
; 67   :     STACKWALK64                 fnStackWalk64;
; 68   :     SYMFUNCTIONTABLEACCESS64    fnSymFunctionTableAccess64;
; 69   :     SYMGETMODULEBASE64          fnSymGetModuleBase64;
; 70   :     SYMFROMADDR                 fnSymFromAddr;
; 71   :     SYMCLEANUP                  fnSymCleanup;
; 72   :     MINIDUMPWRITEDUMP           fnMiniDumpWriteDump;
; 73   :     SYMGETMODULEINFO64          fnSymGetModuleInfo64;
; 74   : 
; 75   :     DWORD                       i;
; 76   :     DWORD64                     InstructionPtr;
; 77   :     DWORD                       imageType;
; 78   : 
; 79   :     TCHAR                       searchPath[MAX_PATH], *p;
; 80   : 
; 81   :     static BOOL                 inExceptionHandler = FALSE;
; 82   : 
; 83   :     moduleinfo_t                moduleInfo;
; 84   : 
; 85   :     //always break into a debugger if one is present
; 86   :     if (IsDebuggerPresent ())

	call	DWORD PTR __imp__IsDebuggerPresent@0
	test	eax, eax
	je	SHORT $LN43@OBSExcepti

; 87   :         return EXCEPTION_CONTINUE_SEARCH;

	xor	eax, eax
	jmp	$LN44@OBSExcepti
$LN43@OBSExcepti:

; 88   : 
; 89   :     //exception codes < 0x80000000 are typically informative only and not crash worthy
; 90   :     //0xe06d7363 indicates a c++ exception was thrown, let's just hope it was caught.
; 91   :     //this is no longer needed since we're an unhandled handler vs a vectored handler
; 92   :     
; 93   :     /*if (exceptionInfo->ExceptionRecord->ExceptionCode < 0x80000000 || exceptionInfo->ExceptionRecord->ExceptionCode == 0xe06d7363 ||
; 94   :         exceptionInfo->ExceptionRecord->ExceptionCode == 0x800706b5)
; 95   :         return EXCEPTION_CONTINUE_SEARCH;*/
; 96   : 
; 97   :     //uh oh, we're crashing inside ourselves... this is really bad!
; 98   :     if (inExceptionHandler)

	cmp	DWORD PTR ?inExceptionHandler@?1??OBSExceptionHandler@@YGJPAU_EXCEPTION_POINTERS@@@Z@4HA, 0
	je	SHORT $LN42@OBSExcepti

; 99   :         return EXCEPTION_CONTINUE_SEARCH;

	xor	eax, eax
	jmp	$LN44@OBSExcepti
$LN42@OBSExcepti:

; 100  : 
; 101  :     inExceptionHandler = TRUE;

	mov	DWORD PTR ?inExceptionHandler@?1??OBSExceptionHandler@@YGJPAU_EXCEPTION_POINTERS@@@Z@4HA, 1

; 102  : 
; 103  :     //load dbghelp dynamically
; 104  :     hDbgHelp = LoadLibrary (TEXT("DBGHELP"));

	push	OFFSET $SG4294929706
	call	_IsolationAwareLoadLibraryW@4
	mov	DWORD PTR _hDbgHelp$[ebp], eax

; 105  : 
; 106  :     if (!hDbgHelp)

	cmp	DWORD PTR _hDbgHelp$[ebp], 0
	jne	SHORT $LN41@OBSExcepti

; 107  :         return EXCEPTION_CONTINUE_SEARCH;

	xor	eax, eax
	jmp	$LN44@OBSExcepti
$LN41@OBSExcepti:

; 108  : 
; 109  :     fnEnumerateLoadedModules64 = (ENUMERATELOADEDMODULES64)GetProcAddress (hDbgHelp, "EnumerateLoadedModulesW64");

	push	OFFSET $SG4294929705
	mov	eax, DWORD PTR _hDbgHelp$[ebp]
	push	eax
	call	DWORD PTR __imp__GetProcAddress@8
	mov	DWORD PTR _fnEnumerateLoadedModules64$[ebp], eax

; 110  :     fnSymSetOptions = (SYMSETOPTIONS)GetProcAddress (hDbgHelp, "SymSetOptions");

	push	OFFSET $SG4294929704
	mov	ecx, DWORD PTR _hDbgHelp$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetProcAddress@8
	mov	DWORD PTR _fnSymSetOptions$[ebp], eax

; 111  :     fnSymInitialize = (SYMINITIALIZE)GetProcAddress (hDbgHelp, "SymInitialize");

	push	OFFSET $SG4294929703
	mov	edx, DWORD PTR _hDbgHelp$[ebp]
	push	edx
	call	DWORD PTR __imp__GetProcAddress@8
	mov	DWORD PTR _fnSymInitialize$[ebp], eax

; 112  :     fnSymFunctionTableAccess64 = (SYMFUNCTIONTABLEACCESS64)GetProcAddress (hDbgHelp, "SymFunctionTableAccess64");

	push	OFFSET $SG4294929702
	mov	eax, DWORD PTR _hDbgHelp$[ebp]
	push	eax
	call	DWORD PTR __imp__GetProcAddress@8
	mov	DWORD PTR _fnSymFunctionTableAccess64$[ebp], eax

; 113  :     fnSymGetModuleBase64 = (SYMGETMODULEBASE64)GetProcAddress (hDbgHelp, "SymGetModuleBase64");

	push	OFFSET $SG4294929701
	mov	ecx, DWORD PTR _hDbgHelp$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetProcAddress@8
	mov	DWORD PTR _fnSymGetModuleBase64$[ebp], eax

; 114  :     fnStackWalk64 = (STACKWALK64)GetProcAddress (hDbgHelp, "StackWalk64");

	push	OFFSET $SG4294929700
	mov	edx, DWORD PTR _hDbgHelp$[ebp]
	push	edx
	call	DWORD PTR __imp__GetProcAddress@8
	mov	DWORD PTR _fnStackWalk64$[ebp], eax

; 115  :     fnSymFromAddr = (SYMFROMADDR)GetProcAddress (hDbgHelp, "SymFromAddrW");

	push	OFFSET $SG4294929699
	mov	eax, DWORD PTR _hDbgHelp$[ebp]
	push	eax
	call	DWORD PTR __imp__GetProcAddress@8
	mov	DWORD PTR _fnSymFromAddr$[ebp], eax

; 116  :     fnSymCleanup = (SYMCLEANUP)GetProcAddress (hDbgHelp, "SymCleanup");

	push	OFFSET $SG4294929698
	mov	ecx, DWORD PTR _hDbgHelp$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetProcAddress@8
	mov	DWORD PTR _fnSymCleanup$[ebp], eax

; 117  :     fnSymGetModuleInfo64 = (SYMGETMODULEINFO64)GetProcAddress (hDbgHelp, "SymGetModuleInfo64");

	push	OFFSET $SG4294929697
	mov	edx, DWORD PTR _hDbgHelp$[ebp]
	push	edx
	call	DWORD PTR __imp__GetProcAddress@8
	mov	DWORD PTR _fnSymGetModuleInfo64$[ebp], eax

; 118  :     fnMiniDumpWriteDump = (MINIDUMPWRITEDUMP)GetProcAddress (hDbgHelp, "MiniDumpWriteDump");

	push	OFFSET $SG4294929696
	mov	eax, DWORD PTR _hDbgHelp$[ebp]
	push	eax
	call	DWORD PTR __imp__GetProcAddress@8
	mov	DWORD PTR _fnMiniDumpWriteDump$[ebp], eax

; 119  : 
; 120  :     if (!fnEnumerateLoadedModules64 || !fnSymSetOptions || !fnSymInitialize || !fnSymFunctionTableAccess64 ||
; 121  :         !fnSymGetModuleBase64 || !fnStackWalk64 || !fnSymFromAddr || !fnSymCleanup || !fnSymGetModuleInfo64)

	cmp	DWORD PTR _fnEnumerateLoadedModules64$[ebp], 0
	je	SHORT $LN39@OBSExcepti
	cmp	DWORD PTR _fnSymSetOptions$[ebp], 0
	je	SHORT $LN39@OBSExcepti
	cmp	DWORD PTR _fnSymInitialize$[ebp], 0
	je	SHORT $LN39@OBSExcepti
	cmp	DWORD PTR _fnSymFunctionTableAccess64$[ebp], 0
	je	SHORT $LN39@OBSExcepti
	cmp	DWORD PTR _fnSymGetModuleBase64$[ebp], 0
	je	SHORT $LN39@OBSExcepti
	cmp	DWORD PTR _fnStackWalk64$[ebp], 0
	je	SHORT $LN39@OBSExcepti
	cmp	DWORD PTR _fnSymFromAddr$[ebp], 0
	je	SHORT $LN39@OBSExcepti
	cmp	DWORD PTR _fnSymCleanup$[ebp], 0
	je	SHORT $LN39@OBSExcepti
	cmp	DWORD PTR _fnSymGetModuleInfo64$[ebp], 0
	jne	SHORT $LN40@OBSExcepti
$LN39@OBSExcepti:

; 122  :     {
; 123  :         FreeLibrary (hDbgHelp);

	mov	ecx, DWORD PTR _hDbgHelp$[ebp]
	push	ecx
	call	DWORD PTR __imp__FreeLibrary@4

; 124  :         return EXCEPTION_CONTINUE_SEARCH;

	xor	eax, eax
	jmp	$LN44@OBSExcepti
$LN40@OBSExcepti:

; 125  :     }
; 126  : 
; 127  :     hProcess = GetCurrentProcess();

	call	DWORD PTR __imp__GetCurrentProcess@0
	mov	DWORD PTR _hProcess$[ebp], eax

; 128  : 
; 129  :     fnSymSetOptions (SYMOPT_UNDNAME | SYMOPT_FAIL_CRITICAL_ERRORS | SYMOPT_LOAD_ANYTHING);

	push	578					; 00000242H
	call	DWORD PTR _fnSymSetOptions$[ebp]

; 130  : 
; 131  :     GetModuleFileName (NULL, searchPath, _countof(searchPath)-1);

	push	259					; 00000103H
	lea	edx, DWORD PTR _searchPath$[ebp]
	push	edx
	push	0
	call	DWORD PTR __imp__GetModuleFileNameW@12

; 132  :     p = srchr (searchPath, '\\');

	push	92					; 0000005cH
	lea	eax, DWORD PTR _searchPath$[ebp]
	push	eax
	call	DWORD PTR __imp_?srchr@@YGPA_WPB_W_W@Z
	mov	DWORD PTR _p$[ebp], eax

; 133  :     if (p)

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN38@OBSExcepti

; 134  :         *p = 0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _p$[ebp]
	mov	WORD PTR [edx], cx
$LN38@OBSExcepti:

; 135  : 
; 136  :     //create a log file
; 137  :     GetSystemTime (&timeInfo);

	lea	eax, DWORD PTR _timeInfo$[ebp]
	push	eax
	call	DWORD PTR __imp__GetSystemTime@4

; 138  :     for (i = 1;;)

	mov	DWORD PTR _i$[ebp], 1
$LN37@OBSExcepti:

; 139  :     {
; 140  :         tsprintf_s (logPath, _countof(logPath)-1, TEXT("%s\\crashDumps\\OBSCrashLog%.4d-%.2d-%.2d_%d.txt"), lpAppDataPath, timeInfo.wYear, timeInfo.wMonth, timeInfo.wDay, i);

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	movzx	edx, WORD PTR _timeInfo$[ebp+6]
	push	edx
	movzx	eax, WORD PTR _timeInfo$[ebp+2]
	push	eax
	movzx	ecx, WORD PTR _timeInfo$[ebp]
	push	ecx
	push	OFFSET ?lpAppDataPath@@3PA_WA		; lpAppDataPath
	push	OFFSET $SG4294929695
	push	259					; 00000103H
	lea	edx, DWORD PTR _logPath$[ebp]
	push	edx
	call	DWORD PTR __imp_?tsprintf_s@@YAHPA_WIPB_WZZ
	add	esp, 32					; 00000020H

; 141  :         if (GetFileAttributes(logPath) == INVALID_FILE_ATTRIBUTES)

	lea	eax, DWORD PTR _logPath$[ebp]
	push	eax
	call	DWORD PTR __imp__GetFileAttributesW@4
	cmp	eax, -1
	jne	SHORT $LN35@OBSExcepti

; 142  :             break;

	jmp	SHORT $LN36@OBSExcepti
$LN35@OBSExcepti:

; 143  :         i++;

	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx

; 144  :     }

	jmp	SHORT $LN37@OBSExcepti
$LN36@OBSExcepti:

; 145  : 
; 146  :     XFile   crashDumpLog;

	lea	ecx, DWORD PTR _crashDumpLog$[ebp]
	call	DWORD PTR __imp_??0XFile@@QAE@XZ

; 147  : 
; 148  :     if (!crashDumpLog.Open(logPath, XFILE_WRITE, XFILE_CREATENEW))

	push	1
	push	2
	lea	edx, DWORD PTR _logPath$[ebp]
	push	edx
	lea	ecx, DWORD PTR _crashDumpLog$[ebp]
	call	DWORD PTR __imp_?Open@XFile@@QAEHPB_WKK@Z
	test	eax, eax
	jne	SHORT $LN34@OBSExcepti

; 149  :     {
; 150  :         FreeLibrary (hDbgHelp);

	mov	eax, DWORD PTR _hDbgHelp$[ebp]
	push	eax
	call	DWORD PTR __imp__FreeLibrary@4

; 151  :         return EXCEPTION_CONTINUE_SEARCH;

	mov	DWORD PTR $T11[ebp], 0
	lea	ecx, DWORD PTR _crashDumpLog$[ebp]
	call	DWORD PTR __imp_??1XFile@@QAE@XZ
	mov	eax, DWORD PTR $T11[ebp]
	jmp	$LN44@OBSExcepti
$LN34@OBSExcepti:

; 152  :     }
; 153  : 
; 154  :     //initialize debug symbols
; 155  :     fnSymInitialize (hProcess, NULL, TRUE);

	push	1
	push	0
	mov	ecx, DWORD PTR _hProcess$[ebp]
	push	ecx
	call	DWORD PTR _fnSymInitialize$[ebp]

; 156  : 
; 157  : #ifdef _WIN64
; 158  :     InstructionPtr = context.Rip;
; 159  :     frame.AddrPC.Offset = InstructionPtr;
; 160  :     frame.AddrFrame.Offset = context.Rbp;
; 161  :     frame.AddrStack.Offset = context.Rsp;
; 162  :     imageType = IMAGE_FILE_MACHINE_AMD64;
; 163  : #else
; 164  :     InstructionPtr = context.Eip;

	mov	edx, DWORD PTR _context$[ebp+184]
	xor	eax, eax
	mov	DWORD PTR _InstructionPtr$[ebp], edx
	mov	DWORD PTR _InstructionPtr$[ebp+4], eax

; 165  :     frame.AddrPC.Offset = InstructionPtr;

	mov	ecx, DWORD PTR _InstructionPtr$[ebp]
	mov	DWORD PTR _frame$[ebp], ecx
	mov	edx, DWORD PTR _InstructionPtr$[ebp+4]
	mov	DWORD PTR _frame$[ebp+4], edx

; 166  :     frame.AddrFrame.Offset = context.Ebp;

	mov	eax, DWORD PTR _context$[ebp+180]
	xor	ecx, ecx
	mov	DWORD PTR _frame$[ebp+32], eax
	mov	DWORD PTR _frame$[ebp+36], ecx

; 167  :     frame.AddrStack.Offset = context.Esp;

	mov	edx, DWORD PTR _context$[ebp+196]
	xor	eax, eax
	mov	DWORD PTR _frame$[ebp+48], edx
	mov	DWORD PTR _frame$[ebp+52], eax

; 168  :     imageType = IMAGE_FILE_MACHINE_I386;

	mov	DWORD PTR _imageType$[ebp], 332		; 0000014cH

; 169  : #endif
; 170  : 
; 171  :     frame.AddrFrame.Mode = AddrModeFlat;

	mov	DWORD PTR _frame$[ebp+44], 3

; 172  :     frame.AddrPC.Mode = AddrModeFlat;

	mov	DWORD PTR _frame$[ebp+12], 3

; 173  :     frame.AddrStack.Mode = AddrModeFlat;

	mov	DWORD PTR _frame$[ebp+60], 3

; 174  : 
; 175  :     symInfo = (SYMBOL_INFO *)LocalAlloc (LPTR, sizeof(*symInfo) + 256);

	push	344					; 00000158H
	push	64					; 00000040H
	call	DWORD PTR __imp__LocalAlloc@8
	mov	DWORD PTR _symInfo$[ebp], eax

; 176  :     symInfo->SizeOfStruct = sizeof(SYMBOL_INFO);

	mov	ecx, DWORD PTR _symInfo$[ebp]
	mov	DWORD PTR [ecx], 88			; 00000058H

; 177  :     symInfo->MaxNameLen = 256;

	mov	edx, DWORD PTR _symInfo$[ebp]
	mov	DWORD PTR [edx+80], 256			; 00000100H

; 178  :     fnOffset = 0;

	xorpd	xmm0, xmm0
	movlpd	QWORD PTR _fnOffset$[ebp], xmm0

; 179  : 
; 180  :     //get os info
; 181  :     memset (&osInfo, 0, sizeof(osInfo));

	push	284					; 0000011cH
	push	0
	lea	eax, DWORD PTR _osInfo$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 182  :     osInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

	mov	DWORD PTR _osInfo$[ebp], 284		; 0000011cH

; 183  : 
; 184  :     if (!GetVersionEx ((OSVERSIONINFO *)&osInfo))

	lea	ecx, DWORD PTR _osInfo$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetVersionExW@4
	test	eax, eax
	jne	SHORT $LN33@OBSExcepti

; 185  :     {
; 186  :         osInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

	mov	DWORD PTR _osInfo$[ebp], 276		; 00000114H

; 187  :         GetVersionEx ((OSVERSIONINFO *)&osInfo);

	lea	edx, DWORD PTR _osInfo$[ebp]
	push	edx
	call	DWORD PTR __imp__GetVersionExW@4
$LN33@OBSExcepti:

; 188  :     }
; 189  : 
; 190  :     String cpuInfo;

	lea	ecx, DWORD PTR _cpuInfo$[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 191  :     HKEY key;
; 192  : 
; 193  :     // get cpu info
; 194  :     if(RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0"), &key) == ERROR_SUCCESS)

	lea	eax, DWORD PTR _key$[ebp]
	push	eax
	push	OFFSET $SG4294929694
	push	-2147483646				; 80000002H
	call	DWORD PTR __imp__RegOpenKeyW@12
	test	eax, eax
	jne	SHORT $LN32@OBSExcepti

; 195  :     {
; 196  :         DWORD dwSize = 1024;

	mov	DWORD PTR _dwSize$13[ebp], 1024		; 00000400H

; 197  :         cpuInfo.SetLength(dwSize);

	mov	ecx, DWORD PTR _dwSize$13[ebp]
	push	ecx
	lea	ecx, DWORD PTR _cpuInfo$[ebp]
	call	DWORD PTR __imp_?SetLength@String@@QAEAAV1@I@Z

; 198  :         if (RegQueryValueEx(key, TEXT("ProcessorNameString"), NULL, NULL, (LPBYTE)cpuInfo.Array(), &dwSize) != ERROR_SUCCESS)

	lea	edx, DWORD PTR _dwSize$13[ebp]
	push	edx
	lea	ecx, DWORD PTR _cpuInfo$[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	0
	push	0
	push	OFFSET $SG4294929693
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	DWORD PTR __imp__RegQueryValueExW@24
	test	eax, eax
	je	SHORT $LN31@OBSExcepti

; 199  :             cpuInfo = TEXT("<unable to query>");

	push	OFFSET $SG4294929692
	lea	ecx, DWORD PTR _cpuInfo$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z
$LN31@OBSExcepti:

; 200  :         RegCloseKey(key);

	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	call	DWORD PTR __imp__RegCloseKey@4

; 201  :     }
; 202  :     else

	jmp	SHORT $LN30@OBSExcepti
$LN32@OBSExcepti:

; 203  :         cpuInfo = TEXT("<unable to query>");

	push	OFFSET $SG4294929691
	lea	ecx, DWORD PTR _cpuInfo$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z
$LN30@OBSExcepti:

; 204  : 
; 205  :     //determine which module the crash occured in
; 206  :     scpy (moduleInfo.moduleName, TEXT("<unknown>"));

	push	OFFSET $SG4294929690
	lea	edx, DWORD PTR _moduleInfo$[ebp+8]
	push	edx
	call	DWORD PTR __imp_?scpy@@YGXPA_WPB_W@Z

; 207  :     moduleInfo.faultAddress = InstructionPtr;

	mov	eax, DWORD PTR _InstructionPtr$[ebp]
	mov	DWORD PTR _moduleInfo$[ebp], eax
	mov	ecx, DWORD PTR _InstructionPtr$[ebp+4]
	mov	DWORD PTR _moduleInfo$[ebp+4], ecx

; 208  :     fnEnumerateLoadedModules64 (hProcess, (PENUMLOADED_MODULES_CALLBACK64)EnumerateLoadedModulesProcInfo, (VOID *)&moduleInfo);

	lea	edx, DWORD PTR _moduleInfo$[ebp]
	push	edx
	push	OFFSET ?EnumerateLoadedModulesProcInfo@@YGHPB_W_KKPAX@Z ; EnumerateLoadedModulesProcInfo
	mov	eax, DWORD PTR _hProcess$[ebp]
	push	eax
	call	DWORD PTR _fnEnumerateLoadedModules64$[ebp]

; 209  :     slwr (moduleInfo.moduleName);

	lea	ecx, DWORD PTR _moduleInfo$[ebp+8]
	push	ecx
	call	DWORD PTR __imp_?slwr@@YGXPA_W@Z

; 210  : 
; 211  :     BOOL isPlugin = FALSE;

	mov	DWORD PTR _isPlugin$[ebp], 0

; 212  : 
; 213  :     if (sstr (moduleInfo.moduleName, TEXT("plugins\\")))

	push	OFFSET $SG4294929689
	lea	edx, DWORD PTR _moduleInfo$[ebp+8]
	push	edx
	call	DWORD PTR __imp_?sstr@@YGPA_WPB_W0@Z
	test	eax, eax
	je	SHORT $LN29@OBSExcepti

; 214  :         isPlugin = TRUE;

	mov	DWORD PTR _isPlugin$[ebp], 1
$LN29@OBSExcepti:

; 215  : 
; 216  :     String strModuleInfo;

	lea	ecx, DWORD PTR _strModuleInfo$[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 217  :     String crashMessage;

	lea	ecx, DWORD PTR _crashMessage$[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 218  : 
; 219  :     fnEnumerateLoadedModules64(hProcess, (PENUMLOADED_MODULES_CALLBACK64)RecordAllLoadedModules, (VOID *)&strModuleInfo);

	lea	eax, DWORD PTR _strModuleInfo$[ebp]
	push	eax
	push	OFFSET ?RecordAllLoadedModules@@YGHPB_W_KKPAX@Z ; RecordAllLoadedModules
	mov	ecx, DWORD PTR _hProcess$[ebp]
	push	ecx
	call	DWORD PTR _fnEnumerateLoadedModules64$[ebp]

; 220  : 
; 221  :     crashMessage << 
; 222  :         TEXT("OBS has encountered an unhandled exception and has terminated. If you are able to\r\n")
; 223  :         TEXT("reproduce this crash, please submit this crash report on the forums at\r\n")
; 224  :         TEXT("https://obsproject.com/ - include the contents of this crash log and the\r\n")
; 225  :         TEXT("minidump .dmp file (if available) as well as your regular OBS log files and\r\n")
; 226  :         TEXT("a description of what you were doing at the time of the crash.\r\n")
; 227  :         TEXT("\r\n")
; 228  :         TEXT("This crash appears to have occured in the '") << moduleInfo.moduleName << TEXT("' module.\r\n\r\n");

	push	OFFSET $SG4294929687
	lea	edx, DWORD PTR _moduleInfo$[ebp+8]
	push	edx
	push	OFFSET $SG4294929688
	lea	ecx, DWORD PTR _crashMessage$[ebp]
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z

; 229  : 
; 230  :     crashDumpLog.WriteStr(crashMessage.Array());

	lea	ecx, DWORD PTR _crashMessage$[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	lea	ecx, DWORD PTR _crashDumpLog$[ebp]
	call	DWORD PTR __imp_?WriteStr@XFile@@QAEHPB_W@Z

; 231  : 
; 232  :     crashDumpLog.WriteStr(FormattedString(TEXT("**** UNHANDLED EXCEPTION: %x\r\nFault address: %I64p (%s)\r\n"), exceptionInfo->ExceptionRecord->ExceptionCode, InstructionPtr, moduleInfo.moduleName));

	lea	eax, DWORD PTR _moduleInfo$[ebp+8]
	push	eax
	mov	ecx, DWORD PTR _InstructionPtr$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _InstructionPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR _exceptionInfo$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	push	edx
	push	OFFSET $SG4294929686
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 24					; 00000018H
	mov	ecx, eax
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	lea	ecx, DWORD PTR _crashDumpLog$[ebp]
	call	DWORD PTR __imp_?WriteStr@XFile@@QAEHPB_W@Z
	lea	ecx, DWORD PTR $T5[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 233  : 
; 234  :     crashDumpLog.WriteStr(TEXT("OBS version: ") OBS_VERSION_STRING TEXT("\r\n"));

	push	OFFSET $SG4294929685
	lea	ecx, DWORD PTR _crashDumpLog$[ebp]
	call	DWORD PTR __imp_?WriteStr@XFile@@QAEHPB_W@Z

; 235  :     crashDumpLog.WriteStr(FormattedString(TEXT("Windows version: %d.%d (Build %d) %s\r\nCPU: %s\r\n\r\n"), osInfo.dwMajorVersion, osInfo.dwMinorVersion, osInfo.dwBuildNumber, osInfo.szCSDVersion, cpuInfo.Array()));

	lea	ecx, DWORD PTR _cpuInfo$[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	lea	ecx, DWORD PTR _osInfo$[ebp+20]
	push	ecx
	mov	edx, DWORD PTR _osInfo$[ebp+12]
	push	edx
	mov	eax, DWORD PTR _osInfo$[ebp+8]
	push	eax
	mov	ecx, DWORD PTR _osInfo$[ebp+4]
	push	ecx
	push	OFFSET $SG4294929684
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 28					; 0000001cH
	mov	ecx, eax
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	lea	ecx, DWORD PTR _crashDumpLog$[ebp]
	call	DWORD PTR __imp_?WriteStr@XFile@@QAEHPB_W@Z
	lea	ecx, DWORD PTR $T3[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 236  : 
; 237  :     crashDumpLog.WriteStr(TEXT("Crashing thread stack trace:\r\n"));

	push	OFFSET $SG4294929683
	lea	ecx, DWORD PTR _crashDumpLog$[ebp]
	call	DWORD PTR __imp_?WriteStr@XFile@@QAEHPB_W@Z

; 238  : #ifdef _WIN64
; 239  :     crashDumpLog.WriteStr(TEXT("Stack            EIP              Arg0             Arg1             Arg2             Arg3             Address\r\n"));
; 240  : #else
; 241  :     crashDumpLog.WriteStr(TEXT("Stack    EIP      Arg0     Arg1     Arg2     Arg3     Address\r\n"));

	push	OFFSET $SG4294929682
	lea	ecx, DWORD PTR _crashDumpLog$[ebp]
	call	DWORD PTR __imp_?WriteStr@XFile@@QAEHPB_W@Z

; 242  : #endif
; 243  :     crashDumpLog.FlushFileBuffers();

	lea	ecx, DWORD PTR _crashDumpLog$[ebp]
	call	DWORD PTR __imp_?FlushFileBuffers@XFile@@QAEXXZ
$LN28@OBSExcepti:

; 244  : 
; 245  :     while (fnStackWalk64 (imageType, hProcess, GetCurrentThread(), &frame, &context, NULL, (PFUNCTION_TABLE_ACCESS_ROUTINE64)fnSymFunctionTableAccess64, (PGET_MODULE_BASE_ROUTINE64)fnSymGetModuleBase64, NULL))

	push	0
	mov	eax, DWORD PTR _fnSymGetModuleBase64$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fnSymFunctionTableAccess64$[ebp]
	push	ecx
	push	0
	lea	edx, DWORD PTR _context$[ebp]
	push	edx
	lea	eax, DWORD PTR _frame$[ebp]
	push	eax
	call	DWORD PTR __imp__GetCurrentThread@0
	push	eax
	mov	ecx, DWORD PTR _hProcess$[ebp]
	push	ecx
	mov	edx, DWORD PTR _imageType$[ebp]
	push	edx
	call	DWORD PTR _fnStackWalk64$[ebp]
	test	eax, eax
	je	$LN27@OBSExcepti

; 246  :     {
; 247  :         scpy (moduleInfo.moduleName, TEXT("<unknown>"));

	push	OFFSET $SG4294929681
	lea	eax, DWORD PTR _moduleInfo$[ebp+8]
	push	eax
	call	DWORD PTR __imp_?scpy@@YGXPA_WPB_W@Z

; 248  :         moduleInfo.faultAddress = frame.AddrPC.Offset;

	mov	ecx, DWORD PTR _frame$[ebp]
	mov	DWORD PTR _moduleInfo$[ebp], ecx
	mov	edx, DWORD PTR _frame$[ebp+4]
	mov	DWORD PTR _moduleInfo$[ebp+4], edx

; 249  :         fnEnumerateLoadedModules64 (hProcess, (PENUMLOADED_MODULES_CALLBACK64)EnumerateLoadedModulesProcInfo, (VOID *)&moduleInfo);

	lea	eax, DWORD PTR _moduleInfo$[ebp]
	push	eax
	push	OFFSET ?EnumerateLoadedModulesProcInfo@@YGHPB_W_KKPAX@Z ; EnumerateLoadedModulesProcInfo
	mov	ecx, DWORD PTR _hProcess$[ebp]
	push	ecx
	call	DWORD PTR _fnEnumerateLoadedModules64$[ebp]

; 250  :         slwr (moduleInfo.moduleName);

	lea	edx, DWORD PTR _moduleInfo$[ebp+8]
	push	edx
	call	DWORD PTR __imp_?slwr@@YGXPA_W@Z

; 251  : 
; 252  :         p = srchr (moduleInfo.moduleName, '\\');

	push	92					; 0000005cH
	lea	eax, DWORD PTR _moduleInfo$[ebp+8]
	push	eax
	call	DWORD PTR __imp_?srchr@@YGPA_WPB_W_W@Z
	mov	DWORD PTR _p$[ebp], eax

; 253  :         if (p)

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN26@OBSExcepti

; 254  :             p++;

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 2
	mov	DWORD PTR _p$[ebp], ecx

; 255  :         else

	jmp	SHORT $LN25@OBSExcepti
$LN26@OBSExcepti:

; 256  :             p = moduleInfo.moduleName;

	lea	edx, DWORD PTR _moduleInfo$[ebp+8]
	mov	DWORD PTR _p$[ebp], edx
$LN25@OBSExcepti:

; 257  : 
; 258  : #ifdef _WIN64
; 259  :         if (fnSymFromAddr (hProcess, frame.AddrPC.Offset, &fnOffset, symInfo) && !(symInfo->Flags & SYMFLAG_EXPORT))
; 260  :         {
; 261  :             crashDumpLog.WriteStr(FormattedString(TEXT("%016I64X %016I64X %016I64X %016I64X %016I64X %016I64X %s!%s+0x%I64x\r\n"),
; 262  :                 frame.AddrStack.Offset,
; 263  :                 frame.AddrPC.Offset,
; 264  :                 frame.Params[0],
; 265  :                 frame.Params[1],
; 266  :                 frame.Params[2],
; 267  :                 frame.Params[3],
; 268  :                 p,
; 269  :                 symInfo->Name,
; 270  :                 fnOffset));
; 271  :         }
; 272  :         else
; 273  :         {
; 274  :             crashDumpLog.WriteStr(FormattedString(TEXT("%016I64X %016I64X %016I64X %016I64X %016I64X %016I64X %s!0x%I64x\r\n"),
; 275  :                 frame.AddrStack.Offset,
; 276  :                 frame.AddrPC.Offset,
; 277  :                 frame.Params[0],
; 278  :                 frame.Params[1],
; 279  :                 frame.Params[2],
; 280  :                 frame.Params[3],
; 281  :                 p,
; 282  :                 frame.AddrPC.Offset));
; 283  :         }
; 284  : #else
; 285  :         if (fnSymFromAddr (hProcess, frame.AddrPC.Offset, &fnOffset, symInfo) && !(symInfo->Flags & SYMFLAG_EXPORT))

	mov	eax, DWORD PTR _symInfo$[ebp]
	push	eax
	lea	ecx, DWORD PTR _fnOffset$[ebp]
	push	ecx
	mov	edx, DWORD PTR _frame$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _frame$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hProcess$[ebp]
	push	ecx
	call	DWORD PTR _fnSymFromAddr$[ebp]
	test	eax, eax
	je	$LN24@OBSExcepti
	mov	edx, DWORD PTR _symInfo$[ebp]
	mov	eax, DWORD PTR [edx+40]
	and	eax, 512				; 00000200H
	jne	$LN24@OBSExcepti

; 286  :         {
; 287  :             crashDumpLog.WriteStr(FormattedString(TEXT("%08.8I64X %08.8I64X %08.8X %08.8X %08.8X %08.8X %s!%s+0x%I64x\r\n"),
; 288  :                 frame.AddrStack.Offset,
; 289  :                 frame.AddrPC.Offset,
; 290  :                 (DWORD)frame.Params[0],
; 291  :                 (DWORD)frame.Params[1],
; 292  :                 (DWORD)frame.Params[2],
; 293  :                 (DWORD)frame.Params[3],
; 294  :                 p,
; 295  :                 symInfo->Name,
; 296  :                 fnOffset));

	mov	ecx, DWORD PTR _fnOffset$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _fnOffset$[ebp]
	push	edx
	mov	eax, DWORD PTR _symInfo$[ebp]
	add	eax, 84					; 00000054H
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, 8
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _frame$[ebp+eax+88]
	push	ecx
	mov	edx, 8
	shl	edx, 1
	mov	eax, DWORD PTR _frame$[ebp+edx+88]
	push	eax
	mov	ecx, 8
	shl	ecx, 0
	mov	edx, DWORD PTR _frame$[ebp+ecx+88]
	push	edx
	mov	eax, 8
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _frame$[ebp+ecx+88]
	push	edx
	mov	eax, DWORD PTR _frame$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _frame$[ebp]
	push	ecx
	mov	edx, DWORD PTR _frame$[ebp+52]
	push	edx
	mov	eax, DWORD PTR _frame$[ebp+48]
	push	eax
	push	OFFSET $SG4294929680
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 56					; 00000038H
	mov	ecx, eax
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	lea	ecx, DWORD PTR _crashDumpLog$[ebp]
	call	DWORD PTR __imp_?WriteStr@XFile@@QAEHPB_W@Z
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 297  :         }
; 298  :         else

	jmp	$LN23@OBSExcepti
$LN24@OBSExcepti:

; 299  :         {
; 300  :             crashDumpLog.WriteStr(FormattedString(TEXT("%08.8I64X %08.8I64X %08.8X %08.8X %08.8X %08.8X %s!0x%I64x\r\n"),
; 301  :                 frame.AddrStack.Offset,
; 302  :                 frame.AddrPC.Offset,
; 303  :                 (DWORD)frame.Params[0],
; 304  :                 (DWORD)frame.Params[1],
; 305  :                 (DWORD)frame.Params[2],
; 306  :                 (DWORD)frame.Params[3],
; 307  :                 p,
; 308  :                 frame.AddrPC.Offset
; 309  :                 ));

	mov	edx, DWORD PTR _frame$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _frame$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, 8
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _frame$[ebp+eax+88]
	push	ecx
	mov	edx, 8
	shl	edx, 1
	mov	eax, DWORD PTR _frame$[ebp+edx+88]
	push	eax
	mov	ecx, 8
	shl	ecx, 0
	mov	edx, DWORD PTR _frame$[ebp+ecx+88]
	push	edx
	mov	eax, 8
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _frame$[ebp+ecx+88]
	push	edx
	mov	eax, DWORD PTR _frame$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _frame$[ebp]
	push	ecx
	mov	edx, DWORD PTR _frame$[ebp+52]
	push	edx
	mov	eax, DWORD PTR _frame$[ebp+48]
	push	eax
	push	OFFSET $SG4294929679
	lea	ecx, DWORD PTR $T7[ebp]
	push	ecx
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 52					; 00000034H
	mov	ecx, eax
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	lea	ecx, DWORD PTR _crashDumpLog$[ebp]
	call	DWORD PTR __imp_?WriteStr@XFile@@QAEHPB_W@Z
	lea	ecx, DWORD PTR $T7[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN23@OBSExcepti:

; 310  :         }
; 311  : #endif
; 312  : 
; 313  :         crashDumpLog.FlushFileBuffers();

	lea	ecx, DWORD PTR _crashDumpLog$[ebp]
	call	DWORD PTR __imp_?FlushFileBuffers@XFile@@QAEXXZ

; 314  :     }

	jmp	$LN28@OBSExcepti
$LN27@OBSExcepti:

; 315  : 
; 316  :     //if we manually crashed due to a deadlocked thread, record some extra info
; 317  :     if (exceptionInfo->ExceptionRecord->ExceptionCode == EXCEPTION_BREAKPOINT)

	mov	edx, DWORD PTR _exceptionInfo$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax], -2147483645		; 80000003H
	jne	$LN22@OBSExcepti

; 318  :     {
; 319  :         HANDLE hVideoThread = NULL, hEncodeThread = NULL;

	mov	DWORD PTR _hVideoThread$16[ebp], 0
	mov	DWORD PTR _hEncodeThread$15[ebp], 0

; 320  :         if (App)

	cmp	DWORD PTR ?App@@3PAVOBS@@A, 0		; App
	je	SHORT $LN21@OBSExcepti

; 321  :             App->GetThreadHandles (&hVideoThread, &hEncodeThread);

	lea	ecx, DWORD PTR _hEncodeThread$15[ebp]
	push	ecx
	lea	edx, DWORD PTR _hVideoThread$16[ebp]
	push	edx
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?GetThreadHandles@OBS@@QAEXPAPAX0@Z	; OBS::GetThreadHandles
$LN21@OBSExcepti:

; 322  : 
; 323  :         if (hVideoThread)

	cmp	DWORD PTR _hVideoThread$16[ebp], 0
	je	$LN20@OBSExcepti

; 324  :         {
; 325  :             crashDumpLog.WriteStr(TEXT("\r\nVideo thread stack trace:\r\n"));

	push	OFFSET $SG4294929678
	lea	ecx, DWORD PTR _crashDumpLog$[ebp]
	call	DWORD PTR __imp_?WriteStr@XFile@@QAEHPB_W@Z

; 326  : #ifdef _WIN64
; 327  :             crashDumpLog.WriteStr(TEXT("Stack            EIP              Arg0             Arg1             Arg2             Arg3             Address\r\n"));
; 328  : #else
; 329  :             crashDumpLog.WriteStr(TEXT("Stack    EIP      Arg0     Arg1     Arg2     Arg3     Address\r\n"));

	push	OFFSET $SG4294929677
	lea	ecx, DWORD PTR _crashDumpLog$[ebp]
	call	DWORD PTR __imp_?WriteStr@XFile@@QAEHPB_W@Z

; 330  : #endif
; 331  :             crashDumpLog.FlushFileBuffers();

	lea	ecx, DWORD PTR _crashDumpLog$[ebp]
	call	DWORD PTR __imp_?FlushFileBuffers@XFile@@QAEXXZ

; 332  : 
; 333  :             context.ContextFlags = CONTEXT_ALL;

	mov	DWORD PTR _context$[ebp], 65599		; 0001003fH

; 334  :             GetThreadContext (hVideoThread, &context);

	lea	eax, DWORD PTR _context$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hVideoThread$16[ebp]
	push	ecx
	call	DWORD PTR __imp__GetThreadContext@8

; 335  :             ZeroMemory (&frame, sizeof(frame));

	push	264					; 00000108H
	push	0
	lea	edx, DWORD PTR _frame$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 336  : #ifdef _WIN64
; 337  :             InstructionPtr = context.Rip;
; 338  :             frame.AddrPC.Offset = InstructionPtr;
; 339  :             frame.AddrFrame.Offset = context.Rbp;
; 340  :             frame.AddrStack.Offset = context.Rsp;
; 341  :             imageType = IMAGE_FILE_MACHINE_AMD64;
; 342  : #else
; 343  :             InstructionPtr = context.Eip;

	mov	eax, DWORD PTR _context$[ebp+184]
	xor	ecx, ecx
	mov	DWORD PTR _InstructionPtr$[ebp], eax
	mov	DWORD PTR _InstructionPtr$[ebp+4], ecx

; 344  :             frame.AddrPC.Offset = InstructionPtr;

	mov	edx, DWORD PTR _InstructionPtr$[ebp]
	mov	DWORD PTR _frame$[ebp], edx
	mov	eax, DWORD PTR _InstructionPtr$[ebp+4]
	mov	DWORD PTR _frame$[ebp+4], eax

; 345  :             frame.AddrFrame.Offset = context.Ebp;

	mov	ecx, DWORD PTR _context$[ebp+180]
	xor	edx, edx
	mov	DWORD PTR _frame$[ebp+32], ecx
	mov	DWORD PTR _frame$[ebp+36], edx

; 346  :             frame.AddrStack.Offset = context.Esp;

	mov	eax, DWORD PTR _context$[ebp+196]
	xor	ecx, ecx
	mov	DWORD PTR _frame$[ebp+48], eax
	mov	DWORD PTR _frame$[ebp+52], ecx

; 347  :             imageType = IMAGE_FILE_MACHINE_I386;

	mov	DWORD PTR _imageType$[ebp], 332		; 0000014cH

; 348  : #endif
; 349  : 
; 350  :             frame.AddrFrame.Mode = AddrModeFlat;

	mov	DWORD PTR _frame$[ebp+44], 3

; 351  :             frame.AddrPC.Mode = AddrModeFlat;

	mov	DWORD PTR _frame$[ebp+12], 3

; 352  :             frame.AddrStack.Mode = AddrModeFlat;

	mov	DWORD PTR _frame$[ebp+60], 3
$LN19@OBSExcepti:

; 353  :             while (fnStackWalk64 (imageType, hProcess, hVideoThread, &frame, &context, NULL, (PFUNCTION_TABLE_ACCESS_ROUTINE64)fnSymFunctionTableAccess64, (PGET_MODULE_BASE_ROUTINE64)fnSymGetModuleBase64, NULL))

	push	0
	mov	edx, DWORD PTR _fnSymGetModuleBase64$[ebp]
	push	edx
	mov	eax, DWORD PTR _fnSymFunctionTableAccess64$[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR _context$[ebp]
	push	ecx
	lea	edx, DWORD PTR _frame$[ebp]
	push	edx
	mov	eax, DWORD PTR _hVideoThread$16[ebp]
	push	eax
	mov	ecx, DWORD PTR _hProcess$[ebp]
	push	ecx
	mov	edx, DWORD PTR _imageType$[ebp]
	push	edx
	call	DWORD PTR _fnStackWalk64$[ebp]
	test	eax, eax
	je	$LN20@OBSExcepti

; 354  :             {
; 355  :                 scpy (moduleInfo.moduleName, TEXT("<unknown>"));

	push	OFFSET $SG4294929676
	lea	eax, DWORD PTR _moduleInfo$[ebp+8]
	push	eax
	call	DWORD PTR __imp_?scpy@@YGXPA_WPB_W@Z

; 356  :                 moduleInfo.faultAddress = frame.AddrPC.Offset;

	mov	ecx, DWORD PTR _frame$[ebp]
	mov	DWORD PTR _moduleInfo$[ebp], ecx
	mov	edx, DWORD PTR _frame$[ebp+4]
	mov	DWORD PTR _moduleInfo$[ebp+4], edx

; 357  :                 fnEnumerateLoadedModules64 (hProcess, (PENUMLOADED_MODULES_CALLBACK64)EnumerateLoadedModulesProcInfo, (VOID *)&moduleInfo);

	lea	eax, DWORD PTR _moduleInfo$[ebp]
	push	eax
	push	OFFSET ?EnumerateLoadedModulesProcInfo@@YGHPB_W_KKPAX@Z ; EnumerateLoadedModulesProcInfo
	mov	ecx, DWORD PTR _hProcess$[ebp]
	push	ecx
	call	DWORD PTR _fnEnumerateLoadedModules64$[ebp]

; 358  :                 slwr (moduleInfo.moduleName);

	lea	edx, DWORD PTR _moduleInfo$[ebp+8]
	push	edx
	call	DWORD PTR __imp_?slwr@@YGXPA_W@Z

; 359  : 
; 360  :                 p = srchr (moduleInfo.moduleName, '\\');

	push	92					; 0000005cH
	lea	eax, DWORD PTR _moduleInfo$[ebp+8]
	push	eax
	call	DWORD PTR __imp_?srchr@@YGPA_WPB_W_W@Z
	mov	DWORD PTR _p$[ebp], eax

; 361  :                 if (p)

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN17@OBSExcepti

; 362  :                     p++;

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 2
	mov	DWORD PTR _p$[ebp], ecx

; 363  :                 else

	jmp	SHORT $LN16@OBSExcepti
$LN17@OBSExcepti:

; 364  :                     p = moduleInfo.moduleName;

	lea	edx, DWORD PTR _moduleInfo$[ebp+8]
	mov	DWORD PTR _p$[ebp], edx
$LN16@OBSExcepti:

; 365  : 
; 366  : #ifdef _WIN64
; 367  :                 if (fnSymFromAddr (hProcess, frame.AddrPC.Offset, &fnOffset, symInfo) && !(symInfo->Flags & SYMFLAG_EXPORT))
; 368  :                 {
; 369  :                     crashDumpLog.WriteStr(FormattedString(TEXT("%016I64X %016I64X %016I64X %016I64X %016I64X %016I64X %s!%s+0x%I64x\r\n"),
; 370  :                         frame.AddrStack.Offset,
; 371  :                         frame.AddrPC.Offset,
; 372  :                         frame.Params[0],
; 373  :                         frame.Params[1],
; 374  :                         frame.Params[2],
; 375  :                         frame.Params[3],
; 376  :                         p,
; 377  :                         symInfo->Name,
; 378  :                         fnOffset));
; 379  :                 }
; 380  :                 else
; 381  :                 {
; 382  :                     crashDumpLog.WriteStr(FormattedString(TEXT("%016I64X %016I64X %016I64X %016I64X %016I64X %016I64X %s!0x%I64x\r\n"),
; 383  :                         frame.AddrStack.Offset,
; 384  :                         frame.AddrPC.Offset,
; 385  :                         frame.Params[0],
; 386  :                         frame.Params[1],
; 387  :                         frame.Params[2],
; 388  :                         frame.Params[3],
; 389  :                         p,
; 390  :                         frame.AddrPC.Offset));
; 391  :                 }
; 392  : #else
; 393  :                 if (fnSymFromAddr (hProcess, frame.AddrPC.Offset, &fnOffset, symInfo) && !(symInfo->Flags & SYMFLAG_EXPORT))

	mov	eax, DWORD PTR _symInfo$[ebp]
	push	eax
	lea	ecx, DWORD PTR _fnOffset$[ebp]
	push	ecx
	mov	edx, DWORD PTR _frame$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _frame$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hProcess$[ebp]
	push	ecx
	call	DWORD PTR _fnSymFromAddr$[ebp]
	test	eax, eax
	je	$LN15@OBSExcepti
	mov	edx, DWORD PTR _symInfo$[ebp]
	mov	eax, DWORD PTR [edx+40]
	and	eax, 512				; 00000200H
	jne	$LN15@OBSExcepti

; 394  :                 {
; 395  :                     crashDumpLog.WriteStr(FormattedString(TEXT("%08.8I64X %08.8I64X %08.8X %08.8X %08.8X %08.8X %s!%s+0x%I64x\r\n"),
; 396  :                         frame.AddrStack.Offset,
; 397  :                         frame.AddrPC.Offset,
; 398  :                         (DWORD)frame.Params[0],
; 399  :                         (DWORD)frame.Params[1],
; 400  :                         (DWORD)frame.Params[2],
; 401  :                         (DWORD)frame.Params[3],
; 402  :                         p,
; 403  :                         symInfo->Name,
; 404  :                         fnOffset));

	mov	ecx, DWORD PTR _fnOffset$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _fnOffset$[ebp]
	push	edx
	mov	eax, DWORD PTR _symInfo$[ebp]
	add	eax, 84					; 00000054H
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, 8
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _frame$[ebp+eax+88]
	push	ecx
	mov	edx, 8
	shl	edx, 1
	mov	eax, DWORD PTR _frame$[ebp+edx+88]
	push	eax
	mov	ecx, 8
	shl	ecx, 0
	mov	edx, DWORD PTR _frame$[ebp+ecx+88]
	push	edx
	mov	eax, 8
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _frame$[ebp+ecx+88]
	push	edx
	mov	eax, DWORD PTR _frame$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _frame$[ebp]
	push	ecx
	mov	edx, DWORD PTR _frame$[ebp+52]
	push	edx
	mov	eax, DWORD PTR _frame$[ebp+48]
	push	eax
	push	OFFSET $SG4294929675
	lea	ecx, DWORD PTR $T9[ebp]
	push	ecx
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 56					; 00000038H
	mov	ecx, eax
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	lea	ecx, DWORD PTR _crashDumpLog$[ebp]
	call	DWORD PTR __imp_?WriteStr@XFile@@QAEHPB_W@Z
	lea	ecx, DWORD PTR $T9[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 405  :                 }
; 406  :                 else

	jmp	$LN14@OBSExcepti
$LN15@OBSExcepti:

; 407  :                 {
; 408  :                     crashDumpLog.WriteStr(FormattedString(TEXT("%08.8I64X %08.8I64X %08.8X %08.8X %08.8X %08.8X %s!0x%I64x\r\n"),
; 409  :                         frame.AddrStack.Offset,
; 410  :                         frame.AddrPC.Offset,
; 411  :                         (DWORD)frame.Params[0],
; 412  :                         (DWORD)frame.Params[1],
; 413  :                         (DWORD)frame.Params[2],
; 414  :                         (DWORD)frame.Params[3],
; 415  :                         p,
; 416  :                         frame.AddrPC.Offset
; 417  :                         ));

	mov	edx, DWORD PTR _frame$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _frame$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, 8
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _frame$[ebp+eax+88]
	push	ecx
	mov	edx, 8
	shl	edx, 1
	mov	eax, DWORD PTR _frame$[ebp+edx+88]
	push	eax
	mov	ecx, 8
	shl	ecx, 0
	mov	edx, DWORD PTR _frame$[ebp+ecx+88]
	push	edx
	mov	eax, 8
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _frame$[ebp+ecx+88]
	push	edx
	mov	eax, DWORD PTR _frame$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _frame$[ebp]
	push	ecx
	mov	edx, DWORD PTR _frame$[ebp+52]
	push	edx
	mov	eax, DWORD PTR _frame$[ebp+48]
	push	eax
	push	OFFSET $SG4294929674
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 52					; 00000034H
	mov	ecx, eax
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	lea	ecx, DWORD PTR _crashDumpLog$[ebp]
	call	DWORD PTR __imp_?WriteStr@XFile@@QAEHPB_W@Z
	lea	ecx, DWORD PTR $T4[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN14@OBSExcepti:

; 418  :                 }
; 419  : #endif
; 420  : 
; 421  :                 crashDumpLog.FlushFileBuffers();

	lea	ecx, DWORD PTR _crashDumpLog$[ebp]
	call	DWORD PTR __imp_?FlushFileBuffers@XFile@@QAEXXZ

; 422  :             }

	jmp	$LN19@OBSExcepti
$LN20@OBSExcepti:

; 423  :         }
; 424  : 
; 425  :         if (hEncodeThread)

	cmp	DWORD PTR _hEncodeThread$15[ebp], 0
	je	$LN22@OBSExcepti

; 426  :         {
; 427  :             crashDumpLog.WriteStr(TEXT("\r\nEncode thread stack trace:\r\n"));

	push	OFFSET $SG4294929673
	lea	ecx, DWORD PTR _crashDumpLog$[ebp]
	call	DWORD PTR __imp_?WriteStr@XFile@@QAEHPB_W@Z

; 428  : #ifdef _WIN64
; 429  :             crashDumpLog.WriteStr(TEXT("Stack            EIP              Arg0             Arg1             Arg2             Arg3             Address\r\n"));
; 430  : #else
; 431  :             crashDumpLog.WriteStr(TEXT("Stack    EIP      Arg0     Arg1     Arg2     Arg3     Address\r\n"));

	push	OFFSET $SG4294929672
	lea	ecx, DWORD PTR _crashDumpLog$[ebp]
	call	DWORD PTR __imp_?WriteStr@XFile@@QAEHPB_W@Z

; 432  : #endif
; 433  :             crashDumpLog.FlushFileBuffers();

	lea	ecx, DWORD PTR _crashDumpLog$[ebp]
	call	DWORD PTR __imp_?FlushFileBuffers@XFile@@QAEXXZ

; 434  : 
; 435  :             context.ContextFlags = CONTEXT_ALL;

	mov	DWORD PTR _context$[ebp], 65599		; 0001003fH

; 436  :             GetThreadContext (hEncodeThread, &context);

	lea	edx, DWORD PTR _context$[ebp]
	push	edx
	mov	eax, DWORD PTR _hEncodeThread$15[ebp]
	push	eax
	call	DWORD PTR __imp__GetThreadContext@8

; 437  :             ZeroMemory (&frame, sizeof(frame));

	push	264					; 00000108H
	push	0
	lea	ecx, DWORD PTR _frame$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 438  : #ifdef _WIN64
; 439  :             InstructionPtr = context.Rip;
; 440  :             frame.AddrPC.Offset = InstructionPtr;
; 441  :             frame.AddrFrame.Offset = context.Rbp;
; 442  :             frame.AddrStack.Offset = context.Rsp;
; 443  :             imageType = IMAGE_FILE_MACHINE_AMD64;
; 444  : #else
; 445  :             InstructionPtr = context.Eip;

	mov	edx, DWORD PTR _context$[ebp+184]
	xor	eax, eax
	mov	DWORD PTR _InstructionPtr$[ebp], edx
	mov	DWORD PTR _InstructionPtr$[ebp+4], eax

; 446  :             frame.AddrPC.Offset = InstructionPtr;

	mov	ecx, DWORD PTR _InstructionPtr$[ebp]
	mov	DWORD PTR _frame$[ebp], ecx
	mov	edx, DWORD PTR _InstructionPtr$[ebp+4]
	mov	DWORD PTR _frame$[ebp+4], edx

; 447  :             frame.AddrFrame.Offset = context.Ebp;

	mov	eax, DWORD PTR _context$[ebp+180]
	xor	ecx, ecx
	mov	DWORD PTR _frame$[ebp+32], eax
	mov	DWORD PTR _frame$[ebp+36], ecx

; 448  :             frame.AddrStack.Offset = context.Esp;

	mov	edx, DWORD PTR _context$[ebp+196]
	xor	eax, eax
	mov	DWORD PTR _frame$[ebp+48], edx
	mov	DWORD PTR _frame$[ebp+52], eax

; 449  :             imageType = IMAGE_FILE_MACHINE_I386;

	mov	DWORD PTR _imageType$[ebp], 332		; 0000014cH

; 450  : #endif
; 451  : 
; 452  :             frame.AddrFrame.Mode = AddrModeFlat;

	mov	DWORD PTR _frame$[ebp+44], 3

; 453  :             frame.AddrPC.Mode = AddrModeFlat;

	mov	DWORD PTR _frame$[ebp+12], 3

; 454  :             frame.AddrStack.Mode = AddrModeFlat;

	mov	DWORD PTR _frame$[ebp+60], 3
$LN12@OBSExcepti:

; 455  :             while (fnStackWalk64 (imageType, hProcess, hEncodeThread, &frame, &context, NULL, (PFUNCTION_TABLE_ACCESS_ROUTINE64)fnSymFunctionTableAccess64, (PGET_MODULE_BASE_ROUTINE64)fnSymGetModuleBase64, NULL))

	push	0
	mov	ecx, DWORD PTR _fnSymGetModuleBase64$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fnSymFunctionTableAccess64$[ebp]
	push	edx
	push	0
	lea	eax, DWORD PTR _context$[ebp]
	push	eax
	lea	ecx, DWORD PTR _frame$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hEncodeThread$15[ebp]
	push	edx
	mov	eax, DWORD PTR _hProcess$[ebp]
	push	eax
	mov	ecx, DWORD PTR _imageType$[ebp]
	push	ecx
	call	DWORD PTR _fnStackWalk64$[ebp]
	test	eax, eax
	je	$LN22@OBSExcepti

; 456  :             {
; 457  :                 scpy (moduleInfo.moduleName, TEXT("<unknown>"));

	push	OFFSET $SG4294929671
	lea	edx, DWORD PTR _moduleInfo$[ebp+8]
	push	edx
	call	DWORD PTR __imp_?scpy@@YGXPA_WPB_W@Z

; 458  :                 moduleInfo.faultAddress = frame.AddrPC.Offset;

	mov	eax, DWORD PTR _frame$[ebp]
	mov	DWORD PTR _moduleInfo$[ebp], eax
	mov	ecx, DWORD PTR _frame$[ebp+4]
	mov	DWORD PTR _moduleInfo$[ebp+4], ecx

; 459  :                 fnEnumerateLoadedModules64 (hProcess, (PENUMLOADED_MODULES_CALLBACK64)EnumerateLoadedModulesProcInfo, (VOID *)&moduleInfo);

	lea	edx, DWORD PTR _moduleInfo$[ebp]
	push	edx
	push	OFFSET ?EnumerateLoadedModulesProcInfo@@YGHPB_W_KKPAX@Z ; EnumerateLoadedModulesProcInfo
	mov	eax, DWORD PTR _hProcess$[ebp]
	push	eax
	call	DWORD PTR _fnEnumerateLoadedModules64$[ebp]

; 460  :                 slwr (moduleInfo.moduleName);

	lea	ecx, DWORD PTR _moduleInfo$[ebp+8]
	push	ecx
	call	DWORD PTR __imp_?slwr@@YGXPA_W@Z

; 461  : 
; 462  :                 p = srchr (moduleInfo.moduleName, '\\');

	push	92					; 0000005cH
	lea	edx, DWORD PTR _moduleInfo$[ebp+8]
	push	edx
	call	DWORD PTR __imp_?srchr@@YGPA_WPB_W_W@Z
	mov	DWORD PTR _p$[ebp], eax

; 463  :                 if (p)

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN10@OBSExcepti

; 464  :                     p++;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 2
	mov	DWORD PTR _p$[ebp], eax

; 465  :                 else

	jmp	SHORT $LN9@OBSExcepti
$LN10@OBSExcepti:

; 466  :                     p = moduleInfo.moduleName;

	lea	ecx, DWORD PTR _moduleInfo$[ebp+8]
	mov	DWORD PTR _p$[ebp], ecx
$LN9@OBSExcepti:

; 467  : 
; 468  : #ifdef _WIN64
; 469  :                 if (fnSymFromAddr (hProcess, frame.AddrPC.Offset, &fnOffset, symInfo) && !(symInfo->Flags & SYMFLAG_EXPORT))
; 470  :                 {
; 471  :                     crashDumpLog.WriteStr(FormattedString(TEXT("%016I64X %016I64X %016I64X %016I64X %016I64X %016I64X %s!%s+0x%I64x\r\n"),
; 472  :                         frame.AddrStack.Offset,
; 473  :                         frame.AddrPC.Offset,
; 474  :                         frame.Params[0],
; 475  :                         frame.Params[1],
; 476  :                         frame.Params[2],
; 477  :                         frame.Params[3],
; 478  :                         p,
; 479  :                         symInfo->Name,
; 480  :                         fnOffset));
; 481  :                 }
; 482  :                 else
; 483  :                 {
; 484  :                     crashDumpLog.WriteStr(FormattedString(TEXT("%016I64X %016I64X %016I64X %016I64X %016I64X %016I64X %s!0x%I64x\r\n"),
; 485  :                         frame.AddrStack.Offset,
; 486  :                         frame.AddrPC.Offset,
; 487  :                         frame.Params[0],
; 488  :                         frame.Params[1],
; 489  :                         frame.Params[2],
; 490  :                         frame.Params[3],
; 491  :                         p,
; 492  :                         frame.AddrPC.Offset));
; 493  :                 }
; 494  : #else
; 495  :                 if (fnSymFromAddr (hProcess, frame.AddrPC.Offset, &fnOffset, symInfo) && !(symInfo->Flags & SYMFLAG_EXPORT))

	mov	edx, DWORD PTR _symInfo$[ebp]
	push	edx
	lea	eax, DWORD PTR _fnOffset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _frame$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _frame$[ebp]
	push	edx
	mov	eax, DWORD PTR _hProcess$[ebp]
	push	eax
	call	DWORD PTR _fnSymFromAddr$[ebp]
	test	eax, eax
	je	$LN8@OBSExcepti
	mov	ecx, DWORD PTR _symInfo$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	and	edx, 512				; 00000200H
	jne	$LN8@OBSExcepti

; 496  :                 {
; 497  :                     crashDumpLog.WriteStr(FormattedString(TEXT("%08.8I64X %08.8I64X %08.8X %08.8X %08.8X %08.8X %s!%s+0x%I64x\r\n"),
; 498  :                         frame.AddrStack.Offset,
; 499  :                         frame.AddrPC.Offset,
; 500  :                         (DWORD)frame.Params[0],
; 501  :                         (DWORD)frame.Params[1],
; 502  :                         (DWORD)frame.Params[2],
; 503  :                         (DWORD)frame.Params[3],
; 504  :                         p,
; 505  :                         symInfo->Name,
; 506  :                         fnOffset));

	mov	eax, DWORD PTR _fnOffset$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _fnOffset$[ebp]
	push	ecx
	mov	edx, DWORD PTR _symInfo$[ebp]
	add	edx, 84					; 00000054H
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, 8
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _frame$[ebp+edx+88]
	push	eax
	mov	ecx, 8
	shl	ecx, 1
	mov	edx, DWORD PTR _frame$[ebp+ecx+88]
	push	edx
	mov	eax, 8
	shl	eax, 0
	mov	ecx, DWORD PTR _frame$[ebp+eax+88]
	push	ecx
	mov	edx, 8
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _frame$[ebp+eax+88]
	push	ecx
	mov	edx, DWORD PTR _frame$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _frame$[ebp]
	push	eax
	mov	ecx, DWORD PTR _frame$[ebp+52]
	push	ecx
	mov	edx, DWORD PTR _frame$[ebp+48]
	push	edx
	push	OFFSET $SG4294929670
	lea	eax, DWORD PTR $T8[ebp]
	push	eax
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 56					; 00000038H
	mov	ecx, eax
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	lea	ecx, DWORD PTR _crashDumpLog$[ebp]
	call	DWORD PTR __imp_?WriteStr@XFile@@QAEHPB_W@Z
	lea	ecx, DWORD PTR $T8[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 507  :                 }
; 508  :                 else

	jmp	$LN7@OBSExcepti
$LN8@OBSExcepti:

; 509  :                 {
; 510  :                     crashDumpLog.WriteStr(FormattedString(TEXT("%08.8I64X %08.8I64X %08.8X %08.8X %08.8X %08.8X %s!0x%I64x\r\n"),
; 511  :                         frame.AddrStack.Offset,
; 512  :                         frame.AddrPC.Offset,
; 513  :                         (DWORD)frame.Params[0],
; 514  :                         (DWORD)frame.Params[1],
; 515  :                         (DWORD)frame.Params[2],
; 516  :                         (DWORD)frame.Params[3],
; 517  :                         p,
; 518  :                         frame.AddrPC.Offset
; 519  :                         ));

	mov	ecx, DWORD PTR _frame$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _frame$[ebp]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, 8
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _frame$[ebp+edx+88]
	push	eax
	mov	ecx, 8
	shl	ecx, 1
	mov	edx, DWORD PTR _frame$[ebp+ecx+88]
	push	edx
	mov	eax, 8
	shl	eax, 0
	mov	ecx, DWORD PTR _frame$[ebp+eax+88]
	push	ecx
	mov	edx, 8
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _frame$[ebp+eax+88]
	push	ecx
	mov	edx, DWORD PTR _frame$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _frame$[ebp]
	push	eax
	mov	ecx, DWORD PTR _frame$[ebp+52]
	push	ecx
	mov	edx, DWORD PTR _frame$[ebp+48]
	push	edx
	push	OFFSET $SG4294929669
	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 52					; 00000034H
	mov	ecx, eax
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	lea	ecx, DWORD PTR _crashDumpLog$[ebp]
	call	DWORD PTR __imp_?WriteStr@XFile@@QAEHPB_W@Z
	lea	ecx, DWORD PTR $T6[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN7@OBSExcepti:

; 520  :                 }
; 521  : #endif
; 522  : 
; 523  :                 crashDumpLog.FlushFileBuffers();

	lea	ecx, DWORD PTR _crashDumpLog$[ebp]
	call	DWORD PTR __imp_?FlushFileBuffers@XFile@@QAEXXZ

; 524  :             }

	jmp	$LN12@OBSExcepti
$LN22@OBSExcepti:

; 525  :         }
; 526  : 
; 527  :     }
; 528  : 
; 529  :     //generate a minidump if possible
; 530  :     if (fnMiniDumpWriteDump)

	cmp	DWORD PTR _fnMiniDumpWriteDump$[ebp], 0
	je	$LN6@OBSExcepti

; 531  :     {
; 532  :         TCHAR     dumpPath[MAX_PATH];
; 533  :         HANDLE    hFile;
; 534  : 
; 535  :         tsprintf_s (dumpPath, _countof(dumpPath)-1, TEXT("%s\\crashDumps\\OBSCrashDump%.4d-%.2d-%.2d_%d.dmp"), lpAppDataPath, timeInfo.wYear, timeInfo.wMonth, timeInfo.wDay, i);

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	movzx	edx, WORD PTR _timeInfo$[ebp+6]
	push	edx
	movzx	eax, WORD PTR _timeInfo$[ebp+2]
	push	eax
	movzx	ecx, WORD PTR _timeInfo$[ebp]
	push	ecx
	push	OFFSET ?lpAppDataPath@@3PA_WA		; lpAppDataPath
	push	OFFSET $SG4294929668
	push	259					; 00000103H
	lea	edx, DWORD PTR _dumpPath$17[ebp]
	push	edx
	call	DWORD PTR __imp_?tsprintf_s@@YAHPA_WIPB_WZZ
	add	esp, 32					; 00000020H

; 536  : 
; 537  :         hFile = CreateFile (dumpPath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

	push	0
	push	128					; 00000080H
	push	2
	push	0
	push	0
	push	1073741824				; 40000000H
	lea	eax, DWORD PTR _dumpPath$17[ebp]
	push	eax
	call	DWORD PTR __imp__CreateFileW@28
	mov	DWORD PTR _hFile$14[ebp], eax

; 538  :         if (hFile != INVALID_HANDLE_VALUE)

	cmp	DWORD PTR _hFile$14[ebp], -1
	je	$LN5@OBSExcepti

; 539  :         {
; 540  :             MINIDUMP_TYPE dumpFlags = (MINIDUMP_TYPE)(MiniDumpWithIndirectlyReferencedMemory | MiniDumpWithUnloadedModules | MiniDumpWithProcessThreadData);

	mov	DWORD PTR _dumpFlags$10[ebp], 352	; 00000160H

; 541  : 
; 542  :             miniInfo.ClientPointers = TRUE;

	mov	DWORD PTR _miniInfo$[ebp+8], 1

; 543  :             miniInfo.ExceptionPointers = exceptionInfo;

	mov	ecx, DWORD PTR _exceptionInfo$[ebp]
	mov	DWORD PTR _miniInfo$[ebp+4], ecx

; 544  :             miniInfo.ThreadId = GetCurrentThreadId ();

	call	DWORD PTR __imp__GetCurrentThreadId@0
	mov	DWORD PTR _miniInfo$[ebp], eax

; 545  : 
; 546  :             if (fnMiniDumpWriteDump (hProcess, GetCurrentProcessId(), hFile, dumpFlags, &miniInfo, NULL, NULL))

	push	0
	push	0
	lea	edx, DWORD PTR _miniInfo$[ebp]
	push	edx
	mov	eax, DWORD PTR _dumpFlags$10[ebp]
	push	eax
	mov	ecx, DWORD PTR _hFile$14[ebp]
	push	ecx
	call	DWORD PTR __imp__GetCurrentProcessId@0
	push	eax
	mov	edx, DWORD PTR _hProcess$[ebp]
	push	edx
	call	DWORD PTR _fnMiniDumpWriteDump$[ebp]
	test	eax, eax
	je	SHORT $LN4@OBSExcepti

; 547  :             {
; 548  :                 crashDumpLog.WriteStr(FormattedString(TEXT("\r\nA minidump was saved to %s.\r\nPlease include this file when posting a crash report.\r\n"), dumpPath));

	lea	eax, DWORD PTR _dumpPath$17[ebp]
	push	eax
	push	OFFSET $SG4294929667
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	lea	ecx, DWORD PTR _crashDumpLog$[ebp]
	call	DWORD PTR __imp_?WriteStr@XFile@@QAEHPB_W@Z
	lea	ecx, DWORD PTR $T2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 549  :             }
; 550  :             else

	jmp	SHORT $LN5@OBSExcepti
$LN4@OBSExcepti:

; 551  :             {
; 552  :                 CloseHandle (hFile);

	mov	edx, DWORD PTR _hFile$14[ebp]
	push	edx
	call	DWORD PTR __imp__CloseHandle@4

; 553  :                 DeleteFile (dumpPath);

	lea	eax, DWORD PTR _dumpPath$17[ebp]
	push	eax
	call	DWORD PTR __imp__DeleteFileW@4
$LN5@OBSExcepti:

; 554  :             }
; 555  :         }
; 556  :     }
; 557  :     else

	jmp	SHORT $LN2@OBSExcepti
$LN6@OBSExcepti:

; 558  :     {
; 559  :         crashDumpLog.WriteStr(TEXT("\r\nA minidump could not be created. Please check dbghelp.dll is present.\r\n"));

	push	OFFSET $SG4294929666
	lea	ecx, DWORD PTR _crashDumpLog$[ebp]
	call	DWORD PTR __imp_?WriteStr@XFile@@QAEHPB_W@Z
$LN2@OBSExcepti:

; 560  :     }
; 561  : 
; 562  :     crashDumpLog.WriteStr("\r\nList of loaded modules:\r\n");

	push	OFFSET $SG4294929665
	lea	ecx, DWORD PTR _crashDumpLog$[ebp]
	call	DWORD PTR __imp_?WriteStr@XFile@@QAEHPBD@Z

; 563  : #ifdef _WIN64
; 564  :     crashDumpLog.WriteStr("Base Address                      Module\r\n");
; 565  : #else
; 566  :     crashDumpLog.WriteStr("Base Address      Module\r\n");

	push	OFFSET $SG4294929664
	lea	ecx, DWORD PTR _crashDumpLog$[ebp]
	call	DWORD PTR __imp_?WriteStr@XFile@@QAEHPBD@Z

; 567  : #endif
; 568  :     crashDumpLog.WriteStr(strModuleInfo);

	lea	ecx, DWORD PTR _strModuleInfo$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	lea	ecx, DWORD PTR _crashDumpLog$[ebp]
	call	DWORD PTR __imp_?WriteStr@XFile@@QAEHPB_W@Z

; 569  : 
; 570  :     crashDumpLog.Close();

	lea	ecx, DWORD PTR _crashDumpLog$[ebp]
	call	DWORD PTR __imp_?Close@XFile@@QAEXXZ

; 571  : 
; 572  :     LocalFree (symInfo);

	mov	ecx, DWORD PTR _symInfo$[ebp]
	push	ecx
	call	DWORD PTR __imp__LocalFree@4

; 573  : 
; 574  :     fnSymCleanup (hProcess);

	mov	edx, DWORD PTR _hProcess$[ebp]
	push	edx
	call	DWORD PTR _fnSymCleanup$[ebp]

; 575  : 
; 576  :     if (OBSMessageBox(hwndMain, TEXT("Woops! OBS has crashed. Would you like to view a crash report?"), NULL, MB_ICONERROR | MB_YESNO) == IDYES)

	push	20					; 00000014H
	push	0
	push	OFFSET $SG4294929663
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	call	DWORD PTR __imp_?OBSMessageBox@@YAHPAUHWND__@@PB_W1I@Z
	add	esp, 16					; 00000010H
	cmp	eax, 6
	jne	SHORT $LN1@OBSExcepti

; 577  :         ShellExecute(NULL, NULL, logPath, NULL, searchPath, SW_SHOWDEFAULT);

	push	10					; 0000000aH
	lea	ecx, DWORD PTR _searchPath$[ebp]
	push	ecx
	push	0
	lea	edx, DWORD PTR _logPath$[ebp]
	push	edx
	push	0
	push	0
	call	DWORD PTR __imp__ShellExecuteW@24
$LN1@OBSExcepti:

; 578  : 
; 579  :     FreeLibrary (hDbgHelp);

	mov	eax, DWORD PTR _hDbgHelp$[ebp]
	push	eax
	call	DWORD PTR __imp__FreeLibrary@4

; 580  : 
; 581  :     //we really shouldn't be returning here, if we're at the bottom of the VEH chain this is a pretty legitimate crash
; 582  :     //and if we return we could end up invoking a second crash handler or other weird / annoying things
; 583  :     //ExitProcess(exceptionInfo->ExceptionRecord->ExceptionCode);
; 584  :     return EXCEPTION_CONTINUE_SEARCH;

	mov	DWORD PTR $T12[ebp], 0
	lea	ecx, DWORD PTR _crashMessage$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strModuleInfo$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _cpuInfo$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _crashDumpLog$[ebp]
	call	DWORD PTR __imp_??1XFile@@QAE@XZ
	mov	eax, DWORD PTR $T12[ebp]
$LN44@OBSExcepti:

; 585  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?OBSExceptionHandler@@YGJPAU_EXCEPTION_POINTERS@@@Z ENDP ; OBSExceptionHandler
_TEXT	ENDS
END

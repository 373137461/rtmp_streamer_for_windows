; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

	TITLE	F:\songmm_moon_stone_obs\OBS\Source\API.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	??_C@_1BA@GCDNCJOK@?$AAG?$AAe?$AAn?$AAe?$AAr?$AAa?$AAl?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CA@DHAOPEIL@?$AAS?$AAc?$AAe?$AAn?$AAe?$AAC?$AAo?$AAl?$AAl?$AAe?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@DEJKECHI@?$AAs?$AAc?$AAe?$AAn?$AAe?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BO@MNEEFODP@?$AAg?$AAl?$AAo?$AAb?$AAa?$AAl?$AA?5?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_17KABJEDEH@?$AAF?$AAP?$AAS?$AA?$AA@	; `string'
PUBLIC	??_C@_1M@BFEDDODL@?$AAV?$AAi?$AAd?$AAe?$AAo?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BI@DLGNLDGJ@?$AA?2?$AAp?$AAl?$AAu?$AAg?$AAi?$AAn?$AAD?$AAa?$AAt?$AAa?$AA?$AA@ ; `string'
PUBLIC	??_C@_1GK@DMMFIDMP@?$AAT?$AAr?$AAi?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAg?$AAe?$AAt?$AA?5?$AAa?$AAn?$AA?5?$AAa?$AAu?$AAx?$AA?5?$AAa?$AAu?$AAd?$AAi?$AAo?$AA?5?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe@ ; `string'
PUBLIC	??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_R2APIInterface@@8				; APIInterface::`RTTI Base Class Array'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2OBSAPIInterface@@8				; OBSAPIInterface::`RTTI Base Class Array'
PUBLIC	??_R0PAVSceneItem@@@8				; SceneItem * `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7OBSAPIInterface@@6B@			; OBSAPIInterface::`vftable'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_R0?AVOBSAPIInterface@@@8			; OBSAPIInterface `RTTI Type Descriptor'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4OBSAPIInterface@@6B@			; OBSAPIInterface::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUClassInfo@@@8				; ClassInfo `RTTI Type Descriptor'
PUBLIC	??_R0?AVAPIInterface@@@8			; APIInterface `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@OBSAPIInterface@@8		; OBSAPIInterface::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_7APIInterface@@6B@				; APIInterface::`vftable'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	_WinbaseIsolationAwarePrivateT_SpYRNahcpNYYRQ
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	_WinbaseIsolationAwarePrivateT_SpeRNgRQnPgpgk
PUBLIC	_WinbaseIsolationAwarePrivateT_UnPgpgk
PUBLIC	??_R0PAVAudioSource@@@8				; AudioSource * `RTTI Type Descriptor'
PUBLIC	??_R0?AUGlobalSourceInfo@@@8			; GlobalSourceInfo `RTTI Type Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	_IsolationAwarePrivateT_SqbjaYRiRY
PUBLIC	??_R0?AUHotkeyInfo@@@8				; HotkeyInfo `RTTI Type Descriptor'
PUBLIC	??_R4APIInterface@@6B@				; APIInterface::`RTTI Complete Object Locator'
PUBLIC	??_R3OBSAPIInterface@@8				; OBSAPIInterface::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3APIInterface@@8				; APIInterface::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AUStreamInfo@@@8				; StreamInfo `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@APIInterface@@8			; APIInterface::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
EXTRN	__imp_??8String@@QBEHABV0@@Z:PROC
EXTRN	__imp_?Array@String@@QBEPA_WXZ:PROC
EXTRN	__imp_??BString@@QBEPA_WXZ:PROC
EXTRN	__imp_?CopyList@StringList@@QAEXABV1@@Z:PROC
EXTRN	__imp_??0Vect2@@QAE@ABU0@@Z:PROC
EXTRN	__imp_??0Vect2@@QAE@MM@Z:PROC
EXTRN	__imp_?GetName@XBaseItem@@QBEPB_WXZ:PROC
EXTRN	__imp_?GetElement@XConfig@@QAEPAVXElement@@PB_W@Z:PROC
EXTRN	__imp_?GetElement@SceneItem@@QBEPAVXElement@@XZ:PROC
EXTRN	__imp_?HasMissingSources@Scene@@QBE_NXZ:PROC
EXTRN	__imp_??0StringList@@QAE@XZ:PROC
EXTRN	__imp_?API@@3PAVAPIInterface@@A:DWORD
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	__imp_??0String@@QAE@ABV0@@Z:PROC
EXTRN	__imp_??0String@@QAE@PB_W@Z:PROC
EXTRN	__imp_??0String@@QAE@PBD@Z:PROC
EXTRN	__imp_??0String@@QAE@XZ:PROC
EXTRN	__imp_??1String@@QAE@XZ:PROC
EXTRN	__imp_??4String@@QAEAAV0@ABV0@@Z:PROC
EXTRN	__imp_??4String@@QAEAAV0@PB_W@Z:PROC
EXTRN	__imp_??6String@@QAEAAV0@ABV0@@Z:PROC
EXTRN	__imp_??6String@@QAEAAV0@PB_W@Z:PROC
EXTRN	__imp_?CompareI@String@@QBEHPB_W@Z:PROC
EXTRN	__imp_?Clear@String@@QAEAAV1@XZ:PROC
EXTRN	__imp_?SetLength@String@@QAEAAV1@I@Z:PROC
EXTRN	__imp_?OSGetTime@@YGKXZ:PROC
EXTRN	__hypot:PROC
EXTRN	__imp__PostMessageW@16:PROC
EXTRN	__imp_?GetVolumeControlValue@@YAMPAUHWND__@@@Z:PROC
EXTRN	__imp_?OBSMessageBox@@YAHPAUHWND__@@PB_W1I@Z:PROC
EXTRN	__imp_?Open@XConfig@@QAE_NPB_W@Z:PROC
EXTRN	__imp_?Close@XConfig@@QAEX_N@Z:PROC
EXTRN	__imp_?Save@XConfig@@QAEXXZ:PROC
EXTRN	__imp_?SaveTo@XConfig@@QAEXPB_W@Z:PROC
EXTRN	__imp_?sdup@@YGPA_WPB_W@Z:PROC
EXTRN	__imp_?Log@@YAXPB_WZZ:PROC
EXTRN	__imp_?OSSleep@@YGXK@Z:PROC
EXTRN	__purecall:PROC
EXTRN	__imp_?GetString@XElement@@QBEPB_WPB_WPA_W@Z:PROC
EXTRN	__imp_?GetInt@XElement@@QBEHPB_WH@Z:PROC
EXTRN	__imp_?GetElement@XElement@@QBEPAV1@PB_W@Z:PROC
EXTRN	__imp_?GetElementByID@XElement@@QBEPAV1@K@Z:PROC
EXTRN	__imp_?NumElements@XElement@@QAEKPB_W@Z:PROC
EXTRN	__imp_?locale@@3PAVLocaleStringLookup@@A:DWORD
EXTRN	__imp_?OSLeaveMutex@@YGXPAX@Z:PROC
EXTRN	__imp__GetAsyncKeyState@4:PROC
EXTRN	_atexit:PROC
EXTRN	__imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z:PROC
EXTRN	__imp_?DumpError@@YAXPB_WZZ:PROC
EXTRN	__imp__GetDlgItem@8:PROC
EXTRN	__imp__RedrawWindow@16:PROC
EXTRN	__imp_?MainAllocator@@3PAVAlloc@@A:DWORD
EXTRN	__imp_?AppWarning@@YAXPB_WZZ:PROC
EXTRN	__imp__XInputGetState@8:PROC
EXTRN	__imp_?GetStringPtr@ConfigFile@@QAEPB_WPB_W00@Z:PROC
EXTRN	__imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z:PROC
EXTRN	__imp_?SetString@ConfigFile@@QAEXPB_W00@Z:PROC
EXTRN	__imp_?FormattedString@@YA?AVString@@PB_WZZ:PROC
EXTRN	__imp__SendMessageW@16:PROC
EXTRN	_memmove:PROC
EXTRN	__imp_?OSEnterMutex@@YGXPAX@Z:PROC
EXTRN	?name@type_info@@QBEPBDPAU__type_info_node@@@Z:PROC ; type_info::name
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAPBDH@Z:PROC		; std::_Winerror_map
EXTRN	?__type_info_root_node@@3U__type_info_node@@A:QWORD ; __type_info_root_node
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT _WinbaseIsolationAwarePrivateT_SpYRNahcpNYYRQ
_BSS	SEGMENT
_WinbaseIsolationAwarePrivateT_SpYRNahcpNYYRQ DD 01H DUP (?)
_BSS	ENDS
;	COMDAT _WinbaseIsolationAwarePrivateT_SpeRNgRQnPgpgk
_BSS	SEGMENT
_WinbaseIsolationAwarePrivateT_SpeRNgRQnPgpgk DD 01H DUP (?)
_BSS	ENDS
;	COMDAT _IsolationAwarePrivateT_SqbjaYRiRY
_BSS	SEGMENT
_IsolationAwarePrivateT_SqbjaYRiRY DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ?set_vars@?1??HandleHotkeys@OBSAPIInterface@@AAEXXZ@4_NA
_BSS	SEGMENT
?set_vars@?1??HandleHotkeys@OBSAPIInterface@@AAEXXZ@4_NA DB 01H DUP (?) ; `OBSAPIInterface::HandleHotkeys'::`2'::set_vars
_BSS	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@APIInterface@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@APIInterface@@8 DD FLAT:??_R0?AVAPIInterface@@@8 ; APIInterface::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3APIInterface@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUStreamInfo@@@8
data$r	SEGMENT
??_R0?AUStreamInfo@@@8 DD FLAT:??_7type_info@@6B@	; StreamInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUStreamInfo@@', 00H
data$r	ENDS
;	COMDAT ??_R3APIInterface@@8
rdata$r	SEGMENT
??_R3APIInterface@@8 DD 00H				; APIInterface::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2APIInterface@@8
rdata$r	ENDS
;	COMDAT ??_R3OBSAPIInterface@@8
rdata$r	SEGMENT
??_R3OBSAPIInterface@@8 DD 00H				; OBSAPIInterface::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2OBSAPIInterface@@8
rdata$r	ENDS
;	COMDAT ??_R4APIInterface@@6B@
rdata$r	SEGMENT
??_R4APIInterface@@6B@ DD 00H				; APIInterface::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVAPIInterface@@@8
	DD	FLAT:??_R3APIInterface@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUHotkeyInfo@@@8
data$r	SEGMENT
??_R0?AUHotkeyInfo@@@8 DD FLAT:??_7type_info@@6B@	; HotkeyInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUHotkeyInfo@@', 00H
data$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUGlobalSourceInfo@@@8
data$r	SEGMENT
??_R0?AUGlobalSourceInfo@@@8 DD FLAT:??_7type_info@@6B@	; GlobalSourceInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUGlobalSourceInfo@@', 00H
data$r	ENDS
;	COMDAT ??_R0PAVAudioSource@@@8
data$r	SEGMENT
??_R0PAVAudioSource@@@8 DD FLAT:??_7type_info@@6B@	; AudioSource * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAVAudioSource@@', 00H
data$r	ENDS
;	COMDAT _WinbaseIsolationAwarePrivateT_UnPgpgk
_DATA	SEGMENT
_WinbaseIsolationAwarePrivateT_UnPgpgk DD 0ffffffffH
_DATA	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
data$r	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_7APIInterface@@6B@
CONST	SEGMENT
??_7APIInterface@@6B@ DD FLAT:??_R4APIInterface@@6B@	; APIInterface::`vftable'
	DD	FLAT:?Invalid03@APIInterface@@UBEXXZ
	DD	FLAT:??_EAPIInterface@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?Invalid01@APIInterface@@UAEXXZ
	DD	FLAT:?Invalid02@APIInterface@@UAEXXZ
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@OBSAPIInterface@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@OBSAPIInterface@@8 DD FLAT:??_R0?AVOBSAPIInterface@@@8 ; OBSAPIInterface::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3OBSAPIInterface@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVAPIInterface@@@8
data$r	SEGMENT
??_R0?AVAPIInterface@@@8 DD FLAT:??_7type_info@@6B@	; APIInterface `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVAPIInterface@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AUClassInfo@@@8
data$r	SEGMENT
??_R0?AUClassInfo@@@8 DD FLAT:??_7type_info@@6B@	; ClassInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUClassInfo@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R4OBSAPIInterface@@6B@
rdata$r	SEGMENT
??_R4OBSAPIInterface@@6B@ DD 00H			; OBSAPIInterface::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVOBSAPIInterface@@@8
	DD	FLAT:??_R3OBSAPIInterface@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVOBSAPIInterface@@@8
data$r	SEGMENT
??_R0?AVOBSAPIInterface@@@8 DD FLAT:??_7type_info@@6B@	; OBSAPIInterface `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVOBSAPIInterface@@', 00H
data$r	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_7OBSAPIInterface@@6B@
CONST	SEGMENT
??_7OBSAPIInterface@@6B@ DD FLAT:??_R4OBSAPIInterface@@6B@ ; OBSAPIInterface::`vftable'
	DD	FLAT:?Invalid03@APIInterface@@UBEXXZ
	DD	FLAT:??_EOBSAPIInterface@@UAEPAXI@Z
	DD	FLAT:?EnterSceneMutex@OBSAPIInterface@@UAEXXZ
	DD	FLAT:?LeaveSceneMutex@OBSAPIInterface@@UAEXXZ
	DD	FLAT:?RegisterSceneClass@OBSAPIInterface@@UAEXPB_W0P6GPAXPAVXElement@@@ZP6G_N1_N@Z@Z
	DD	FLAT:?RegisterImageSourceClass@OBSAPIInterface@@UAEXPB_W0P6GPAXPAVXElement@@@ZP6G_N1_N@Z@Z
	DD	FLAT:?CreateImageSource@OBSAPIInterface@@UAEPAVImageSource@@PB_WPAVXElement@@@Z
	DD	FLAT:?GetSceneListElement@OBSAPIInterface@@UAEPAVXElement@@XZ
	DD	FLAT:?GetGlobalSourceListElement@OBSAPIInterface@@UAEPAVXElement@@XZ
	DD	FLAT:?SetScene@OBSAPIInterface@@UAE_NPB_W_N@Z
	DD	FLAT:?GetScene@OBSAPIInterface@@UBEPAVScene@@XZ
	DD	FLAT:?GetSceneName@OBSAPIInterface@@UBEPB_WXZ
	DD	FLAT:?GetSceneElement@OBSAPIInterface@@UAEPAVXElement@@XZ
	DD	FLAT:?CreateHotkey@OBSAPIInterface@@UAEIKP6GXKK_N@ZK@Z
	DD	FLAT:?DeleteHotkey@OBSAPIInterface@@UAEXI@Z
	DD	FLAT:?GetBaseSize@OBSAPIInterface@@UBEXAAI0@Z
	DD	FLAT:?GetBaseSize@OBSAPIInterface@@UBE?AUVect2@@XZ
	DD	FLAT:?GetRenderFrameSize@OBSAPIInterface@@UBEXAAI0@Z
	DD	FLAT:?GetRenderFrameSize@OBSAPIInterface@@UBE?AUVect2@@XZ
	DD	FLAT:?GetOutputSize@OBSAPIInterface@@UBEXAAI0@Z
	DD	FLAT:?GetOutputSize@OBSAPIInterface@@UBE?AUVect2@@XZ
	DD	FLAT:?GetMaxFPS@OBSAPIInterface@@UBEIXZ
	DD	FLAT:?GetLanguage@OBSAPIInterface@@UBEPB_WXZ
	DD	FLAT:?GetMainWindow@OBSAPIInterface@@UBEPAUHWND__@@XZ
	DD	FLAT:?GetAppDataPath@OBSAPIInterface@@UBEPB_WXZ
	DD	FLAT:?GetPluginDataPath@OBSAPIInterface@@UBE?AVString@@XZ
	DD	FLAT:?AddStreamInfo@OBSAPIInterface@@UAEIPB_WW4StreamInfoPriority@@@Z
	DD	FLAT:?SetStreamInfo@OBSAPIInterface@@UAEXIPB_W@Z
	DD	FLAT:?SetStreamInfoPriority@OBSAPIInterface@@UAEXIW4StreamInfoPriority@@@Z
	DD	FLAT:?RemoveStreamInfo@OBSAPIInterface@@UAEXI@Z
	DD	FLAT:?UseMultithreadedOptimizations@OBSAPIInterface@@UBE_NXZ
	DD	FLAT:?AddAudioSource@OBSAPIInterface@@UAEXPAVAudioSource@@@Z
	DD	FLAT:?RemoveAudioSource@OBSAPIInterface@@UAEXPAVAudioSource@@@Z
	DD	FLAT:?GetAudioTime@OBSAPIInterface@@UBE_KXZ
	DD	FLAT:?GetAppPath@OBSAPIInterface@@UBEPB_WXZ
	DD	FLAT:?StartStopStream@OBSAPIInterface@@UAEXXZ
	DD	FLAT:?StartStopPreview@OBSAPIInterface@@UAEXXZ
	DD	FLAT:?GetStreaming@OBSAPIInterface@@UAE_NXZ
	DD	FLAT:?GetPreviewOnly@OBSAPIInterface@@UAE_NXZ
	DD	FLAT:?SetSourceOrder@OBSAPIInterface@@UAEXAAVStringList@@@Z
	DD	FLAT:?SetSourceRender@OBSAPIInterface@@UAEXPB_W_N@Z
	DD	FLAT:?Invalid01@APIInterface@@UAEXXZ
	DD	FLAT:?Invalid02@APIInterface@@UAEXXZ
	DD	FLAT:?SetDesktopVolume@OBSAPIInterface@@UAEXM_N@Z
	DD	FLAT:?GetDesktopVolume@OBSAPIInterface@@UAEMXZ
	DD	FLAT:?ToggleDesktopMute@OBSAPIInterface@@UAEXXZ
	DD	FLAT:?GetDesktopMuted@OBSAPIInterface@@UAE_NXZ
	DD	FLAT:?SetMicVolume@OBSAPIInterface@@UAEXM_N@Z
	DD	FLAT:?GetMicVolume@OBSAPIInterface@@UAEMXZ
	DD	FLAT:?ToggleMicMute@OBSAPIInterface@@UAEXXZ
	DD	FLAT:?GetMicMuted@OBSAPIInterface@@UAE_NXZ
	DD	FLAT:?GetOBSVersion@OBSAPIInterface@@UBEKXZ
	DD	FLAT:?IsTestVersion@OBSAPIInterface@@UBE_NXZ
	DD	FLAT:?NumAuxAudioSources@OBSAPIInterface@@UBEIXZ
	DD	FLAT:?GetAuxAudioSource@OBSAPIInterface@@UAEPAVAudioSource@@I@Z
	DD	FLAT:?GetDesktopAudioSource@OBSAPIInterface@@UAEPAVAudioSource@@XZ
	DD	FLAT:?GetMicAudioSource@OBSAPIInterface@@UAEPAVAudioSource@@XZ
	DD	FLAT:?GetCurDesktopVolumeStats@OBSAPIInterface@@UBEXPAM00@Z
	DD	FLAT:?GetCurMicVolumeStats@OBSAPIInterface@@UBEXPAM00@Z
	DD	FLAT:?AddSettingsPane@OBSAPIInterface@@UAEXPAVSettingsPane@@@Z
	DD	FLAT:?RemoveSettingsPane@OBSAPIInterface@@UAEXPAVSettingsPane@@@Z
	DD	FLAT:?SetChangedSettings@OBSAPIInterface@@EAEX_N@Z
	DD	FLAT:?GetRenderFrameOffset@OBSAPIInterface@@UBEXAAI0@Z
	DD	FLAT:?GetRenderFrameOffset@OBSAPIInterface@@UBE?AUVect2@@XZ
	DD	FLAT:?GetRenderFrameControlSize@OBSAPIInterface@@UBEXAAI0@Z
	DD	FLAT:?GetRenderFrameControlSize@OBSAPIInterface@@UBE?AUVect2@@XZ
	DD	FLAT:?GetRenderFrameIn1To1Mode@OBSAPIInterface@@UBE_NXZ
	DD	FLAT:?MapWindowToFramePos@OBSAPIInterface@@UBE?AUVect2@@U2@@Z
	DD	FLAT:?MapFrameToWindowPos@OBSAPIInterface@@UBE?AUVect2@@U2@@Z
	DD	FLAT:?MapWindowToFrameSize@OBSAPIInterface@@UBE?AUVect2@@U2@@Z
	DD	FLAT:?MapFrameToWindowSize@OBSAPIInterface@@UBE?AUVect2@@U2@@Z
	DD	FLAT:?GetWindowToFrameScale@OBSAPIInterface@@UBE?AUVect2@@XZ
	DD	FLAT:?GetFrameToWindowScale@OBSAPIInterface@@UBE?AUVect2@@XZ
	DD	FLAT:?GetSampleRateHz@OBSAPIInterface@@UBEIXZ
	DD	FLAT:?SetAbortApplySettings@OBSAPIInterface@@EAEX_N@Z
	DD	FLAT:?StartStopRecording@OBSAPIInterface@@UAEXXZ
	DD	FLAT:?GetRecording@OBSAPIInterface@@UBE_NXZ
	DD	FLAT:?GetKeepRecording@OBSAPIInterface@@UBE_NXZ
	DD	FLAT:?GetCaptureFPS@OBSAPIInterface@@UBEIXZ
	DD	FLAT:?GetTotalFrames@OBSAPIInterface@@UBEIXZ
	DD	FLAT:?GetFramesDropped@OBSAPIInterface@@UBEIXZ
	DD	FLAT:?GetTotalStreamTime@OBSAPIInterface@@UBEIXZ
	DD	FLAT:?GetBytesPerSec@OBSAPIInterface@@UBEIXZ
	DD	FLAT:?SetCanOptimizeSettings@OBSAPIInterface@@EAEX_N@Z
	DD	FLAT:?StartStopRecordingReplayBuffer@OBSAPIInterface@@UAEXXZ
	DD	FLAT:?GetRecordingReplayBuffer@OBSAPIInterface@@UBE_NXZ
	DD	FLAT:?SaveReplayBuffer@OBSAPIInterface@@UAEXXZ
	DD	FLAT:?SetSceneCollection@OBSAPIInterface@@UAE_NPB_W0@Z
	DD	FLAT:?GetSceneCollectionName@OBSAPIInterface@@UBEPB_WXZ
	DD	FLAT:?GetSceneCollectionNames@OBSAPIInterface@@UBEXAAVStringList@@@Z
	DD	FLAT:?DisableTransitions@OBSAPIInterface@@UAEXXZ
	DD	FLAT:?EnableTransitions@OBSAPIInterface@@UAEXXZ
	DD	FLAT:?TransitionsEnabled@OBSAPIInterface@@UBE_NXZ
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0PAVSceneItem@@@8
data$r	SEGMENT
??_R0PAVSceneItem@@@8 DD FLAT:??_7type_info@@6B@	; SceneItem * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAVSceneItem@@', 00H
data$r	ENDS
;	COMDAT ??_R2OBSAPIInterface@@8
rdata$r	SEGMENT
??_R2OBSAPIInterface@@8 DD FLAT:??_R1A@?0A@EA@OBSAPIInterface@@8 ; OBSAPIInterface::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@APIInterface@@8
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2APIInterface@@8
rdata$r	SEGMENT
??_R2APIInterface@@8 DD FLAT:??_R1A@?0A@EA@APIInterface@@8 ; APIInterface::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@
CONST	SEGMENT
??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@ DB 'O'
	DB	00H, 'u', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H
	DB	'r', 00H, 'a', 00H, 'n', 00H, 'g', 00H, 'e', 00H, '!', 00H, ' '
	DB	00H, ' ', 00H, 'L', 00H, 'i', 00H, 's', 00H, 't', 00H, '<', 00H
	DB	'%', 00H, 'S', 00H, '>', 00H, ':', 00H, ':', 00H, 'o', 00H, 'p'
	DB	00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'[', 00H, ']', 00H, '(', 00H, '%', 00H, 'd', 00H, ')', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1GK@DMMFIDMP@?$AAT?$AAr?$AAi?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAg?$AAe?$AAt?$AA?5?$AAa?$AAn?$AA?5?$AAa?$AAu?$AAx?$AA?5?$AAa?$AAu?$AAd?$AAi?$AAo?$AA?5?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe@
CONST	SEGMENT
??_C@_1GK@DMMFIDMP@?$AAT?$AAr?$AAi?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAg?$AAe?$AAt?$AA?5?$AAa?$AAn?$AA?5?$AAa?$AAu?$AAx?$AA?5?$AAa?$AAu?$AAd?$AAi?$AAo?$AA?5?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe@ DB 'T'
	DB	00H, 'r', 00H, 'i', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 't', 00H
	DB	'o', 00H, ' ', 00H, 'g', 00H, 'e', 00H, 't', 00H, ' ', 00H, 'a'
	DB	00H, 'n', 00H, ' ', 00H, 'a', 00H, 'u', 00H, 'x', 00H, ' ', 00H
	DB	'a', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, ' ', 00H, 's'
	DB	00H, 'o', 00H, 'u', 00H, 'r', 00H, 'c', 00H, 'e', 00H, ' ', 00H
	DB	't', 00H, 'h', 00H, 'a', 00H, 't', 00H, ' ', 00H, 'd', 00H, 'o'
	DB	00H, 'e', 00H, 's', 00H, 'n', 00H, '''', 00H, 't', 00H, ' ', 00H
	DB	'e', 00H, 'x', 00H, 'i', 00H, 's', 00H, 't', 00H, '!', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@DLGNLDGJ@?$AA?2?$AAp?$AAl?$AAu?$AAg?$AAi?$AAn?$AAD?$AAa?$AAt?$AAa?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@DLGNLDGJ@?$AA?2?$AAp?$AAl?$AAu?$AAg?$AAi?$AAn?$AAD?$AAa?$AAt?$AAa?$AA?$AA@ DB '\'
	DB	00H, 'p', 00H, 'l', 00H, 'u', 00H, 'g', 00H, 'i', 00H, 'n', 00H
	DB	'D', 00H, 'a', 00H, 't', 00H, 'a', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@BFEDDODL@?$AAV?$AAi?$AAd?$AAe?$AAo?$AA?$AA@
CONST	SEGMENT
??_C@_1M@BFEDDODL@?$AAV?$AAi?$AAd?$AAe?$AAo?$AA?$AA@ DB 'V', 00H, 'i', 00H
	DB	'd', 00H, 'e', 00H, 'o', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_17KABJEDEH@?$AAF?$AAP?$AAS?$AA?$AA@
CONST	SEGMENT
??_C@_17KABJEDEH@?$AAF?$AAP?$AAS?$AA?$AA@ DB 'F', 00H, 'P', 00H, 'S', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@MNEEFODP@?$AAg?$AAl?$AAo?$AAb?$AAa?$AAl?$AA?5?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@MNEEFODP@?$AAg?$AAl?$AAo?$AAb?$AAa?$AAl?$AA?5?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AAs?$AA?$AA@ DB 'g'
	DB	00H, 'l', 00H, 'o', 00H, 'b', 00H, 'a', 00H, 'l', 00H, ' ', 00H
	DB	's', 00H, 'o', 00H, 'u', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 's'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@DEJKECHI@?$AAs?$AAc?$AAe?$AAn?$AAe?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1O@DEJKECHI@?$AAs?$AAc?$AAe?$AAn?$AAe?$AAs?$AA?$AA@ DB 's', 00H, 'c'
	DB	00H, 'e', 00H, 'n', 00H, 'e', 00H, 's', 00H, 00H, 00H ; `string'
$SG4294966871 DB 'O', 00H, 'B', 00H, 'S', 00H, ':', 00H, ':', 00H, 'R', 00H
	DB	'e', 00H, 'g', 00H, 'i', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, 'S', 00H, 'c', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'C', 00H
	DB	'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ':', 00H, ' ', 00H, 'N'
	DB	00H, 'o', 00H, ' ', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H
	DB	's', 00H, ' ', 00H, 'n', 00H, 'a', 00H, 'm', 00H, 'e', 00H, ' '
	DB	00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H, 'i', 00H, 'f', 00H
	DB	'i', 00H, 'e', 00H, 'd', 00H, 00H, 00H
$SG4294966862 DB 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, 00H, 00H
$SG4294966870 DB 'O', 00H, 'B', 00H, 'S', 00H, ':', 00H, ':', 00H, 'R', 00H
	DB	'e', 00H, 'g', 00H, 'i', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, 'S', 00H, 'c', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'C', 00H
	DB	'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ':', 00H, ' ', 00H, 'N'
	DB	00H, 'o', 00H, ' ', 00H, 'c', 00H, 'r', 00H, 'e', 00H, 'a', 00H
	DB	't', 00H, 'e', 00H, ' ', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'c'
	DB	00H, 'e', 00H, 'd', 00H, 'u', 00H, 'r', 00H, 'e', 00H, ' ', 00H
	DB	's', 00H, 'p', 00H, 'e', 00H, 'c', 00H, 'i', 00H, 'f', 00H, 'i'
	DB	00H, 'e', 00H, 'd', 00H, 00H, 00H
$SG4294966869 DB 'O', 00H, 'B', 00H, 'S', 00H, ':', 00H, ':', 00H, 'R', 00H
	DB	'e', 00H, 'g', 00H, 'i', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, 'S', 00H, 'c', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'C', 00H
	DB	'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ':', 00H, ' ', 00H, 'T'
	DB	00H, 'r', 00H, 'i', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 't', 00H
	DB	'o', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 'g', 00H, 'i', 00H, 's'
	DB	00H, 't', 00H, 'e', 00H, 'r', 00H, ' ', 00H, '''', 00H, '%', 00H
	DB	's', 00H, '''', 00H, ',', 00H, ' ', 00H, 'b', 00H, 'u', 00H, 't'
	DB	00H, ' ', 00H, 'i', 00H, 't', 00H, ' ', 00H, 'a', 00H, 'l', 00H
	DB	'r', 00H, 'e', 00H, 'a', 00H, 'd', 00H, 'y', 00H, ' ', 00H, 'e'
	DB	00H, 'x', 00H, 'i', 00H, 's', 00H, 't', 00H, 's', 00H, 00H, 00H
$SG4294966868 DB 'O', 00H, 'B', 00H, 'S', 00H, ':', 00H, ':', 00H, 'R', 00H
	DB	'e', 00H, 'g', 00H, 'i', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, 'I', 00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, 'S', 00H
	DB	'o', 00H, 'u', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'C', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ':', 00H, ' ', 00H, 'N', 00H
	DB	'o', 00H, ' ', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's'
	DB	00H, ' ', 00H, 'n', 00H, 'a', 00H, 'm', 00H, 'e', 00H, ' ', 00H
	DB	's', 00H, 'p', 00H, 'e', 00H, 'c', 00H, 'i', 00H, 'f', 00H, 'i'
	DB	00H, 'e', 00H, 'd', 00H, 00H, 00H
$SG4294966867 DB 'O', 00H, 'B', 00H, 'S', 00H, ':', 00H, ':', 00H, 'R', 00H
	DB	'e', 00H, 'g', 00H, 'i', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, 'I', 00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, 'S', 00H
	DB	'o', 00H, 'u', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'C', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ':', 00H, ' ', 00H, 'N', 00H
	DB	'o', 00H, ' ', 00H, 'c', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 't'
	DB	00H, 'e', 00H, ' ', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'c', 00H
	DB	'e', 00H, 'd', 00H, 'u', 00H, 'r', 00H, 'e', 00H, ' ', 00H, 's'
	DB	00H, 'p', 00H, 'e', 00H, 'c', 00H, 'i', 00H, 'f', 00H, 'i', 00H
	DB	'e', 00H, 'd', 00H, 00H, 00H
$SG4294966858 DB 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, 00H, 00H
$SG4294966866 DB 'O', 00H, 'B', 00H, 'S', 00H, ':', 00H, ':', 00H, 'R', 00H
	DB	'e', 00H, 'g', 00H, 'i', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, 'I', 00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, 'S', 00H
	DB	'o', 00H, 'u', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'C', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ':', 00H, ' ', 00H, 'T', 00H
	DB	'r', 00H, 'i', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 't', 00H, 'o'
	DB	00H, ' ', 00H, 'r', 00H, 'e', 00H, 'g', 00H, 'i', 00H, 's', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, ' ', 00H, '''', 00H, '%', 00H, 's'
	DB	00H, '''', 00H, ',', 00H, ' ', 00H, 'b', 00H, 'u', 00H, 't', 00H
	DB	' ', 00H, 'i', 00H, 't', 00H, ' ', 00H, 'a', 00H, 'l', 00H, 'r'
	DB	00H, 'e', 00H, 'a', 00H, 'd', 00H, 'y', 00H, ' ', 00H, 'e', 00H
	DB	'x', 00H, 'i', 00H, 's', 00H, 't', 00H, 's', 00H, 00H, 00H
$SG4294966854 DB 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, 00H, 00H
$SG4294966865 DB 'O', 00H, 'B', 00H, 'S', 00H, ':', 00H, ':', 00H, 'C', 00H
	DB	'r', 00H, 'e', 00H, 'a', 00H, 't', 00H, 'e', 00H, 'S', 00H, 'c'
	DB	00H, 'e', 00H, 'n', 00H, 'e', 00H, ':', 00H, ' ', 00H, 'C', 00H
	DB	'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, ' ', 00H, 'n', 00H, 'o'
	DB	00H, 't', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'n', 00H, 'd', 00H
	DB	' ', 00H, 's', 00H, 'c', 00H, 'e', 00H, 'n', 00H, 'e', 00H, ' '
	DB	00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H
	DB	'''', 00H, '%', 00H, 's', 00H, '''', 00H, 00H, 00H
$SG4294966850 DB 'd', 00H, 'a', 00H, 't', 00H, 'a', 00H, 00H, 00H
$SG4294966864 DB 'O', 00H, 'B', 00H, 'S', 00H, ':', 00H, ':', 00H, 'C', 00H
	DB	'r', 00H, 'e', 00H, 'a', 00H, 't', 00H, 'e', 00H, 'I', 00H, 'm'
	DB	00H, 'a', 00H, 'g', 00H, 'e', 00H, 'S', 00H, 'o', 00H, 'u', 00H
	DB	'r', 00H, 'c', 00H, 'e', 00H, ':', 00H, ' ', 00H, 'C', 00H, 'o'
	DB	00H, 'u', 00H, 'l', 00H, 'd', 00H, ' ', 00H, 'n', 00H, 'o', 00H
	DB	't', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'n', 00H, 'd', 00H, ' '
	DB	00H, 'i', 00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, ' ', 00H
	DB	's', 00H, 'o', 00H, 'u', 00H, 'r', 00H, 'c', 00H, 'e', 00H, ' '
	DB	00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H
	DB	'''', 00H, '%', 00H, 's', 00H, '''', 00H, 00H, 00H
$SG4294966863 DB 'O', 00H, 'B', 00H, 'S', 00H, ':', 00H, ':', 00H, 'C', 00H
	DB	'o', 00H, 'n', 00H, 'f', 00H, 'i', 00H, 'g', 00H, 'u', 00H, 'r'
	DB	00H, 'e', 00H, 'S', 00H, 'c', 00H, 'e', 00H, 'n', 00H, 'e', 00H
	DB	':', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, ' '
	DB	00H, 'e', 00H, 'l', 00H, 'e', 00H, 'm', 00H, 'e', 00H, 'n', 00H
	DB	't', 00H, ' ', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H, 'i'
	DB	00H, 'f', 00H, 'i', 00H, 'e', 00H, 'd', 00H, 00H, 00H
$SG4294966861 DB 'O', 00H, 'B', 00H, 'S', 00H, ':', 00H, ':', 00H, 'C', 00H
	DB	'o', 00H, 'n', 00H, 'f', 00H, 'i', 00H, 'g', 00H, 'u', 00H, 'r'
	DB	00H, 'e', 00H, 'S', 00H, 'c', 00H, 'e', 00H, 'n', 00H, 'e', 00H
	DB	':', 00H, ' ', 00H, 'N', 00H, 'o', 00H, ' ', 00H, 'c', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 's', 00H, 'p', 00H
	DB	'e', 00H, 'c', 00H, 'i', 00H, 'f', 00H, 'i', 00H, 'e', 00H, 'd'
	DB	00H, ' ', 00H, 'f', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 's', 00H
	DB	'c', 00H, 'e', 00H, 'n', 00H, 'e', 00H, ' ', 00H, '''', 00H, '%'
	DB	00H, 's', 00H, '''', 00H, 00H, 00H
	ORG $+2
$SG4294966860 DB 'O', 00H, 'B', 00H, 'S', 00H, ':', 00H, ':', 00H, 'C', 00H
	DB	'o', 00H, 'n', 00H, 'f', 00H, 'i', 00H, 'g', 00H, 'u', 00H, 'r'
	DB	00H, 'e', 00H, 'S', 00H, 'c', 00H, 'e', 00H, 'n', 00H, 'e', 00H
	DB	':', 00H, ' ', 00H, 'C', 00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd'
	DB	00H, ' ', 00H, 'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'f', 00H
	DB	'i', 00H, 'n', 00H, 'd', 00H, ' ', 00H, 's', 00H, 'c', 00H, 'e'
	DB	00H, 'n', 00H, 'e', 00H, ' ', 00H, 'c', 00H, 'l', 00H, 'a', 00H
	DB	's', 00H, 's', 00H, ' ', 00H, '''', 00H, '%', 00H, 's', 00H, ''''
	DB	00H, 00H, 00H
	ORG $+2
$SG4294966851 DB ' ', 00H, ' ', 00H, 'N', 00H, 'e', 00H, 'w', 00H, ' ', 00H
	DB	'S', 00H, 'c', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 00H, 00H
$SG4294966848 DB 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, 00H, 00H
$SG4294966859 DB 'O', 00H, 'B', 00H, 'S', 00H, ':', 00H, ':', 00H, 'C', 00H
	DB	'o', 00H, 'n', 00H, 'f', 00H, 'i', 00H, 'g', 00H, 'u', 00H, 'r'
	DB	00H, 'e', 00H, 'I', 00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H
	DB	'S', 00H, 'o', 00H, 'u', 00H, 'r', 00H, 'c', 00H, 'e', 00H, ':'
	DB	00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, ' ', 00H
	DB	'e', 00H, 'l', 00H, 'e', 00H, 'm', 00H, 'e', 00H, 'n', 00H, 't'
	DB	00H, ' ', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H, 'i', 00H
	DB	'f', 00H, 'i', 00H, 'e', 00H, 'd', 00H, 00H, 00H
$SG4294966845 DB 'S', 00H, 'c', 00H, 'e', 00H, 'n', 00H, 'e', 00H, '.', 00H
	DB	'M', 00H, 'i', 00H, 's', 00H, 's', 00H, 'i', 00H, 'n', 00H, 'g'
	DB	00H, 'S', 00H, 'o', 00H, 'u', 00H, 'r', 00H, 'c', 00H, 'e', 00H
	DB	's', 00H, 00H, 00H
	ORG $+2
$SG4294966857 DB 'O', 00H, 'B', 00H, 'S', 00H, ':', 00H, ':', 00H, 'C', 00H
	DB	'o', 00H, 'n', 00H, 'f', 00H, 'i', 00H, 'g', 00H, 'u', 00H, 'r'
	DB	00H, 'e', 00H, 'I', 00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H
	DB	'S', 00H, 'o', 00H, 'u', 00H, 'r', 00H, 'c', 00H, 'e', 00H, ':'
	DB	00H, ' ', 00H, 'N', 00H, 'o', 00H, ' ', 00H, 'c', 00H, 'l', 00H
	DB	'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 's', 00H, 'p', 00H, 'e'
	DB	00H, 'c', 00H, 'i', 00H, 'f', 00H, 'i', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 'f', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'i', 00H, 'm'
	DB	00H, 'a', 00H, 'g', 00H, 'e', 00H, ' ', 00H, 's', 00H, 'o', 00H
	DB	'u', 00H, 'r', 00H, 'c', 00H, 'e', 00H, ' ', 00H, '''', 00H, '%'
	DB	00H, 's', 00H, '''', 00H, 00H, 00H
$SG4294966856 DB 'O', 00H, 'B', 00H, 'S', 00H, ':', 00H, ':', 00H, 'C', 00H
	DB	'o', 00H, 'n', 00H, 'f', 00H, 'i', 00H, 'g', 00H, 'u', 00H, 'r'
	DB	00H, 'e', 00H, 'I', 00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H
	DB	'S', 00H, 'o', 00H, 'u', 00H, 'r', 00H, 'c', 00H, 'e', 00H, ':'
	DB	00H, ' ', 00H, 'C', 00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H
	DB	' ', 00H, 'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'f', 00H, 'i'
	DB	00H, 'n', 00H, 'd', 00H, ' ', 00H, 's', 00H, 'c', 00H, 'e', 00H
	DB	'n', 00H, 'e', 00H, ' ', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's'
	DB	00H, 's', 00H, ' ', 00H, '''', 00H, '%', 00H, 's', 00H, '''', 00H
	DB	00H, 00H
	ORG $+2
$SG4294966855 DB 's', 00H, 'c', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 's', 00H
	DB	00H, 00H
	ORG $+2
$SG4294966853 DB 'O', 00H, 'B', 00H, 'S', 00H, ':', 00H, ':', 00H, 'S', 00H
	DB	'e', 00H, 't', 00H, 'S', 00H, 'c', 00H, 'e', 00H, 'n', 00H, 'e'
	DB	00H, ':', 00H, ' ', 00H, 'n', 00H, 'o', 00H, ' ', 00H, 'c', 00H
	DB	'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'f', 00H, 'o'
	DB	00H, 'u', 00H, 'n', 00H, 'd', 00H, ' ', 00H, 'f', 00H, 'o', 00H
	DB	'r', 00H, ' ', 00H, 's', 00H, 'c', 00H, 'e', 00H, 'n', 00H, 'e'
	DB	00H, ' ', 00H, '''', 00H, '%', 00H, 's', 00H, '''', 00H, 00H, 00H
	ORG $+2
$SG4294966849 DB 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H, 'c', 00H, 'e', 00H
	DB	's', 00H, 00H, 00H
$SG4294966844 DB 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, 00H, 00H
$SG4294966852 DB '+', 00H, '+', 00H, '+', 00H, '+', 00H, '+', 00H, '+', 00H
	DB	'+', 00H, '+', 00H, '+', 00H, '+', 00H, '+', 00H, '+', 00H, '+'
	DB	00H, '+', 00H, '+', 00H, '+', 00H, '+', 00H, '+', 00H, '+', 00H
	DB	'+', 00H, '+', 00H, '+', 00H, '+', 00H, '+', 00H, '+', 00H, '+'
	DB	00H, '+', 00H, '+', 00H, '+', 00H, '+', 00H, '+', 00H, '+', 00H
	DB	'+', 00H, '+', 00H, '+', 00H, '+', 00H, '+', 00H, '+', 00H, '+'
	DB	00H, '+', 00H, '+', 00H, '+', 00H, '+', 00H, '+', 00H, '+', 00H
	DB	'+', 00H, '+', 00H, '+', 00H, '+', 00H, '+', 00H, '+', 00H, '+'
	DB	00H, '+', 00H, '+', 00H, 00H, 00H
	ORG $+2
$SG4294966847 DB 'DeviceCapture', 00H
	ORG $+2
$SG4294966846 DB 'r', 00H, 'e', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'r', 00H
	DB	00H, 00H
	ORG $+2
$SG4294966843 DB 'GlobalSource', 00H
	ORG $+3
$SG4294966842 DB 'd', 00H, 'a', 00H, 't', 00H, 'a', 00H, 00H, 00H
	ORG $+2
$SG4294966841 DB 'n', 00H, 'a', 00H, 'm', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG4294966840 DB 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, 00H, 00H
$SG4294966839 DB 'GlobalSource', 00H
	ORG $+3
$SG4294966838 DB 'd', 00H, 'a', 00H, 't', 00H, 'a', 00H, 00H, 00H
	ORG $+2
$SG4294966837 DB 'n', 00H, 'a', 00H, 'm', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG4294966835 DB '%', 00H, 's', 00H, '\', 00H, 's', 00H, 'c', 00H, 'e', 00H
	DB	'n', 00H, 'e', 00H, 'C', 00H, 'o', 00H, 'l', 00H, 'l', 00H, 'e'
	DB	00H, 'c', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, '\', 00H
	DB	'%', 00H, 's', 00H, '.', 00H, 'x', 00H, 'c', 00H, 'o', 00H, 'n'
	DB	00H, 'f', 00H, 'i', 00H, 'g', 00H, 00H, 00H
$SG4294966836 DB 'P', 00H, 'E', 00H, 'R', 00H, 'F', 00H, 'O', 00H, 'R', 00H
	DB	'M', 00H, 'A', 00H, 'N', 00H, 'C', 00H, 'E', 00H, ' ', 00H, 'W'
	DB	00H, 'A', 00H, 'R', 00H, 'N', 00H, 'I', 00H, 'N', 00H, 'G', 00H
	DB	':', 00H, ' ', 00H, 'S', 00H, 'c', 00H, 'e', 00H, 'n', 00H, 'e'
	DB	00H, ' ', 00H, 'c', 00H, 'h', 00H, 'a', 00H, 'n', 00H, 'g', 00H
	DB	'e', 00H, ' ', 00H, 't', 00H, 'o', 00H, 'o', 00H, 'k', 00H, ' '
	DB	00H, '%', 00H, 'u', 00H, ' ', 00H, 'm', 00H, 's', 00H, ',', 00H
	DB	' ', 00H, 'm', 00H, 'a', 00H, 'y', 00H, 'b', 00H, 'e', 00H, ' '
	DB	00H, 's', 00H, 'o', 00H, 'm', 00H, 'e', 00H, ' ', 00H, 's', 00H
	DB	'o', 00H, 'u', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 's', 00H, ' '
	DB	00H, 's', 00H, 'h', 00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H
	DB	' ', 00H, 'b', 00H, 'e', 00H, ' ', 00H, 'g', 00H, 'l', 00H, 'o'
	DB	00H, 'b', 00H, 'a', 00H, 'l', 00H, ' ', 00H, 's', 00H, 'o', 00H
	DB	'u', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 's', 00H, '?', 00H, 00H
	DB	00H
	ORG $+2
$SG4294966834 DB 'S', 00H, 'c', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'C', 00H
	DB	'o', 00H, 'l', 00H, 'l', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'i'
	DB	00H, 'o', 00H, 'n', 00H, 00H, 00H
$SG4294966833 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294966832 DB '\scenes.xconfig', 00H
$SG4294966819 DB 'h', 00H, 'o', 00H, 't', 00H, 'k', 00H, 'e', 00H, 'y', 00H
	DB	00H, 00H
	ORG $+2
$SG4294966818 DB 'A', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'w', 00H, 'O', 00H
	DB	't', 00H, 'h', 00H, 'e', 00H, 'r', 00H, 'H', 00H, 'o', 00H, 't'
	DB	00H, 'k', 00H, 'e', 00H, 'y', 00H, 'M', 00H, 'o', 00H, 'd', 00H
	DB	'i', 00H, 'f', 00H, 'i', 00H, 'e', 00H, 'r', 00H, 's', 00H, 00H
	DB	00H
$SG4294966817 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294966816 DB 'U', 00H, 'p', 00H, 'l', 00H, 'a', 00H, 'y', 00H, 'O', 00H
	DB	'v', 00H, 'e', 00H, 'r', 00H, 'l', 00H, 'a', 00H, 'y', 00H, 'C'
	DB	00H, 'o', 00H, 'm', 00H, 'p', 00H, 'a', 00H, 't', 00H, 'i', 00H
	DB	'b', 00H, 'i', 00H, 'l', 00H, 'i', 00H, 't', 00H, 'y', 00H, 00H
	DB	00H
$SG4294966815 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
CONST	ENDS
;	COMDAT ??_C@_1CA@DHAOPEIL@?$AAS?$AAc?$AAe?$AAn?$AAe?$AAC?$AAo?$AAl?$AAl?$AAe?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@DHAOPEIL@?$AAS?$AAc?$AAe?$AAn?$AAe?$AAC?$AAo?$AAl?$AAl?$AAe?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$AA@ DB 'S'
	DB	00H, 'c', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'C', 00H, 'o', 00H
	DB	'l', 00H, 'l', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'i', 00H, 'o'
	DB	00H, 'n', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BA@GCDNCJOK@?$AAG?$AAe?$AAn?$AAe?$AAr?$AAa?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1BA@GCDNCJOK@?$AAG?$AAe?$AAn?$AAe?$AAr?$AAa?$AAl?$AA?$AA@ DB 'G', 00H
	DB	'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 'l', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$addressof@VNetworkStream@@@std@@YAPAVNetworkStream@@AAV1@@Z ; std::addressof<NetworkStream>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?Clear@?$List@UClassInfo@@@@QAEXXZ		; List<ClassInfo>::Clear
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?pointer_to@?$pointer_traits@PAVNetworkStream@@@std@@SAPAVNetworkStream@@AAV3@@Z ; std::pointer_traits<NetworkStream *>::pointer_to
PUBLIC	?Clear@?$List@UHotkeyInfo@@@@QAEXXZ		; List<HotkeyInfo>::Clear
PUBLIC	?SetSize@?$List@UHotkeyInfo@@@@QAEHI@Z		; List<HotkeyInfo>::SetSize
PUBLIC	?SetSize@?$List@UStreamInfo@@@@QAEHI@Z		; List<StreamInfo>::SetSize
PUBLIC	?SetSize@?$List@UClassInfo@@@@QAEHI@Z		; List<ClassInfo>::SetSize
PUBLIC	?Remove@?$List@PAVAudioSource@@@@QAEXI@Z	; List<AudioSource *>::Remove
PUBLIC	?Add@?$List@PAVAudioSource@@@@QAEIABQAVAudioSource@@@Z ; List<AudioSource *>::Add
PUBLIC	??D?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QBEAAVNetworkStream@@XZ ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::operator*
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	??A?$List@UHotkeyInfo@@@@QAEAAUHotkeyInfo@@I@Z	; List<HotkeyInfo>::operator[]
PUBLIC	?CreateNew@?$List@UHotkeyInfo@@@@QAEPAUHotkeyInfo@@XZ ; List<HotkeyInfo>::CreateNew
PUBLIC	?Remove@?$List@UHotkeyInfo@@@@QAEXI@Z		; List<HotkeyInfo>::Remove
PUBLIC	?Num@?$List@UHotkeyInfo@@@@QBEIXZ		; List<HotkeyInfo>::Num
PUBLIC	??1?$List@UHotkeyInfo@@@@QAE@XZ			; List<HotkeyInfo>::~List<HotkeyInfo>
PUBLIC	??0?$List@UHotkeyInfo@@@@QAE@XZ			; List<HotkeyInfo>::List<HotkeyInfo>
PUBLIC	??A?$List@UStreamInfo@@@@QAEAAUStreamInfo@@I@Z	; List<StreamInfo>::operator[]
PUBLIC	?CreateNew@?$List@UStreamInfo@@@@QAEPAUStreamInfo@@XZ ; List<StreamInfo>::CreateNew
PUBLIC	?Clear@?$List@UStreamInfo@@@@QAEXXZ		; List<StreamInfo>::Clear
PUBLIC	?Remove@?$List@UStreamInfo@@@@QAEXI@Z		; List<StreamInfo>::Remove
PUBLIC	?Num@?$List@UStreamInfo@@@@QBEIXZ		; List<StreamInfo>::Num
PUBLIC	??A?$List@UGlobalSourceInfo@@@@QAEAAUGlobalSourceInfo@@I@Z ; List<GlobalSourceInfo>::operator[]
PUBLIC	?Num@?$List@UGlobalSourceInfo@@@@QBEIXZ		; List<GlobalSourceInfo>::Num
PUBLIC	??H?$List@UClassInfo@@@@QBEPAUClassInfo@@I@Z	; List<ClassInfo>::operator+
PUBLIC	??A?$List@UClassInfo@@@@QBEAAUClassInfo@@I@Z	; List<ClassInfo>::operator[]
PUBLIC	??A?$List@UClassInfo@@@@QAEAAUClassInfo@@I@Z	; List<ClassInfo>::operator[]
PUBLIC	?CreateNew@?$List@UClassInfo@@@@QAEPAUClassInfo@@XZ ; List<ClassInfo>::CreateNew
PUBLIC	?Num@?$List@UClassInfo@@@@QBEIXZ		; List<ClassInfo>::Num
PUBLIC	??A?$List@PAVAudioSource@@@@QAEAAPAVAudioSource@@I@Z ; List<AudioSource *>::operator[]
PUBLIC	??6?$List@PAVAudioSource@@@@QAEAAV0@ABQAVAudioSource@@@Z ; List<AudioSource *>::operator<<
PUBLIC	?RemoveItem@?$List@PAVAudioSource@@@@QAEXABQAVAudioSource@@@Z ; List<AudioSource *>::RemoveItem
PUBLIC	?Num@?$List@PAVAudioSource@@@@QBEIXZ		; List<AudioSource *>::Num
PUBLIC	??B?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QBE_NXZ ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::operator bool
PUBLIC	??C?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QBEPAVNetworkStream@@XZ ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::operator->
PUBLIC	??A?$List@PAVSceneItem@@@@QAEAAPAVSceneItem@@I@Z ; List<SceneItem *>::operator[]
PUBLIC	?Num@?$List@PAVSceneItem@@@@QBEIXZ		; List<SceneItem *>::Num
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?Clear@?$List@K@@QAEXXZ				; List<unsigned long>::Clear
PUBLIC	??1?$List@K@@QAE@XZ				; List<unsigned long>::~List<unsigned long>
PUBLIC	??0?$List@K@@QAE@XZ				; List<unsigned long>::List<unsigned long>
PUBLIC	?GetMicMuted@OBS@@UAE_NXZ			; OBS::GetMicMuted
PUBLIC	?ToggleMicMute@OBS@@UAEXXZ			; OBS::ToggleMicMute
PUBLIC	?GetMicVolume@OBS@@UAEMXZ			; OBS::GetMicVolume
PUBLIC	?SetMicVolume@OBS@@UAEXM_N@Z			; OBS::SetMicVolume
PUBLIC	?GetDesktopMuted@OBS@@UAE_NXZ			; OBS::GetDesktopMuted
PUBLIC	?ToggleDesktopMute@OBS@@UAEXXZ			; OBS::ToggleDesktopMute
PUBLIC	?GetDesktopVolume@OBS@@UAEMXZ			; OBS::GetDesktopVolume
PUBLIC	?SetDesktopVolume@OBS@@UAEXM_N@Z		; OBS::SetDesktopVolume
PUBLIC	?GetMostImportantInfo@OBS@@QAE?AVString@@AAW4StreamInfoPriority@@@Z ; OBS::GetMostImportantInfo
PUBLIC	?RemoveStreamInfo@OBS@@QAEXI@Z			; OBS::RemoveStreamInfo
PUBLIC	?SetStreamInfoPriority@OBS@@QAEXIW4StreamInfoPriority@@@Z ; OBS::SetStreamInfoPriority
PUBLIC	?SetStreamInfo@OBS@@QAEXIPB_W@Z			; OBS::SetStreamInfo
PUBLIC	?AddStreamInfo@OBS@@QAEIPB_WW4StreamInfoPriority@@@Z ; OBS::AddStreamInfo
PUBLIC	?HandleHotkeys@OBSAPIInterface@@AAEXXZ		; OBSAPIInterface::HandleHotkeys
PUBLIC	?DeleteHotkey@OBSAPIInterface@@UAEXI@Z		; OBSAPIInterface::DeleteHotkey
PUBLIC	?CreateHotkey@OBSAPIInterface@@UAEIKP6GXKK_N@ZK@Z ; OBSAPIInterface::CreateHotkey
PUBLIC	?CallHotkey@OBS@@AAEXK_N@Z			; OBS::CallHotkey
PUBLIC	?HotkeyThread@OBS@@CGKPAX@Z			; OBS::HotkeyThread
PUBLIC	?SceneHotkey@@YGXKK_N@Z				; SceneHotkey
PUBLIC	??1OBSAPIInterface@@UAE@XZ			; OBSAPIInterface::~OBSAPIInterface
PUBLIC	??0APIInterface@@QAE@XZ				; APIInterface::APIInterface
PUBLIC	??_GOBSAPIInterface@@UAEPAXI@Z			; OBSAPIInterface::`scalar deleting destructor'
PUBLIC	??0OBSAPIInterface@@QAE@XZ			; OBSAPIInterface::OBSAPIInterface
PUBLIC	?CreateOBSApiInterface@@YAPAVAPIInterface@@XZ	; CreateOBSApiInterface
PUBLIC	?TransitionsEnabled@OBSAPIInterface@@UBE_NXZ	; OBSAPIInterface::TransitionsEnabled
PUBLIC	?EnableTransitions@OBSAPIInterface@@UAEXXZ	; OBSAPIInterface::EnableTransitions
PUBLIC	?DisableTransitions@OBSAPIInterface@@UAEXXZ	; OBSAPIInterface::DisableTransitions
PUBLIC	?GetSceneCollectionNames@OBSAPIInterface@@UBEXAAVStringList@@@Z ; OBSAPIInterface::GetSceneCollectionNames
PUBLIC	?GetSceneCollectionName@OBSAPIInterface@@UBEPB_WXZ ; OBSAPIInterface::GetSceneCollectionName
PUBLIC	?SetSceneCollection@OBSAPIInterface@@UAE_NPB_W0@Z ; OBSAPIInterface::SetSceneCollection
PUBLIC	?GetBytesPerSec@OBSAPIInterface@@UBEIXZ		; OBSAPIInterface::GetBytesPerSec
PUBLIC	?GetTotalStreamTime@OBSAPIInterface@@UBEIXZ	; OBSAPIInterface::GetTotalStreamTime
PUBLIC	?GetFramesDropped@OBSAPIInterface@@UBEIXZ	; OBSAPIInterface::GetFramesDropped
PUBLIC	?GetTotalFrames@OBSAPIInterface@@UBEIXZ		; OBSAPIInterface::GetTotalFrames
PUBLIC	?GetCaptureFPS@OBSAPIInterface@@UBEIXZ		; OBSAPIInterface::GetCaptureFPS
PUBLIC	?GetSampleRateHz@OBSAPIInterface@@UBEIXZ	; OBSAPIInterface::GetSampleRateHz
PUBLIC	?RemoveSettingsPane@OBSAPIInterface@@UAEXPAVSettingsPane@@@Z ; OBSAPIInterface::RemoveSettingsPane
PUBLIC	?AddSettingsPane@OBSAPIInterface@@UAEXPAVSettingsPane@@@Z ; OBSAPIInterface::AddSettingsPane
PUBLIC	?GetCurMicVolumeStats@OBSAPIInterface@@UBEXPAM00@Z ; OBSAPIInterface::GetCurMicVolumeStats
PUBLIC	?GetCurDesktopVolumeStats@OBSAPIInterface@@UBEXPAM00@Z ; OBSAPIInterface::GetCurDesktopVolumeStats
PUBLIC	?GetMicAudioSource@OBSAPIInterface@@UAEPAVAudioSource@@XZ ; OBSAPIInterface::GetMicAudioSource
PUBLIC	?GetDesktopAudioSource@OBSAPIInterface@@UAEPAVAudioSource@@XZ ; OBSAPIInterface::GetDesktopAudioSource
PUBLIC	?GetAuxAudioSource@OBSAPIInterface@@UAEPAVAudioSource@@I@Z ; OBSAPIInterface::GetAuxAudioSource
PUBLIC	?NumAuxAudioSources@OBSAPIInterface@@UBEIXZ	; OBSAPIInterface::NumAuxAudioSources
PUBLIC	?IsTestVersion@OBSAPIInterface@@UBE_NXZ		; OBSAPIInterface::IsTestVersion
PUBLIC	?GetOBSVersion@OBSAPIInterface@@UBEKXZ		; OBSAPIInterface::GetOBSVersion
PUBLIC	?GetMicMuted@OBSAPIInterface@@UAE_NXZ		; OBSAPIInterface::GetMicMuted
PUBLIC	?ToggleMicMute@OBSAPIInterface@@UAEXXZ		; OBSAPIInterface::ToggleMicMute
PUBLIC	?GetMicVolume@OBSAPIInterface@@UAEMXZ		; OBSAPIInterface::GetMicVolume
PUBLIC	?SetMicVolume@OBSAPIInterface@@UAEXM_N@Z	; OBSAPIInterface::SetMicVolume
PUBLIC	?GetDesktopMuted@OBSAPIInterface@@UAE_NXZ	; OBSAPIInterface::GetDesktopMuted
PUBLIC	?ToggleDesktopMute@OBSAPIInterface@@UAEXXZ	; OBSAPIInterface::ToggleDesktopMute
PUBLIC	?GetDesktopVolume@OBSAPIInterface@@UAEMXZ	; OBSAPIInterface::GetDesktopVolume
PUBLIC	?SetDesktopVolume@OBSAPIInterface@@UAEXM_N@Z	; OBSAPIInterface::SetDesktopVolume
PUBLIC	?GetAppPath@OBSAPIInterface@@UBEPB_WXZ		; OBSAPIInterface::GetAppPath
PUBLIC	?GetAudioTime@OBSAPIInterface@@UBE_KXZ		; OBSAPIInterface::GetAudioTime
PUBLIC	?RemoveAudioSource@OBSAPIInterface@@UAEXPAVAudioSource@@@Z ; OBSAPIInterface::RemoveAudioSource
PUBLIC	?AddAudioSource@OBSAPIInterface@@UAEXPAVAudioSource@@@Z ; OBSAPIInterface::AddAudioSource
PUBLIC	?UseMultithreadedOptimizations@OBSAPIInterface@@UBE_NXZ ; OBSAPIInterface::UseMultithreadedOptimizations
PUBLIC	?RemoveStreamInfo@OBSAPIInterface@@UAEXI@Z	; OBSAPIInterface::RemoveStreamInfo
PUBLIC	?SetStreamInfoPriority@OBSAPIInterface@@UAEXIW4StreamInfoPriority@@@Z ; OBSAPIInterface::SetStreamInfoPriority
PUBLIC	?SetStreamInfo@OBSAPIInterface@@UAEXIPB_W@Z	; OBSAPIInterface::SetStreamInfo
PUBLIC	?AddStreamInfo@OBSAPIInterface@@UAEIPB_WW4StreamInfoPriority@@@Z ; OBSAPIInterface::AddStreamInfo
PUBLIC	?GetMainWindow@OBSAPIInterface@@UBEPAUHWND__@@XZ ; OBSAPIInterface::GetMainWindow
PUBLIC	?GetPluginDataPath@OBSAPIInterface@@UBE?AVString@@XZ ; OBSAPIInterface::GetPluginDataPath
PUBLIC	?GetAppDataPath@OBSAPIInterface@@UBEPB_WXZ	; OBSAPIInterface::GetAppDataPath
PUBLIC	?GetLanguage@OBSAPIInterface@@UBEPB_WXZ		; OBSAPIInterface::GetLanguage
PUBLIC	?GetRenderFrameIn1To1Mode@OBSAPIInterface@@UBE_NXZ ; OBSAPIInterface::GetRenderFrameIn1To1Mode
PUBLIC	?GetMaxFPS@OBSAPIInterface@@UBEIXZ		; OBSAPIInterface::GetMaxFPS
PUBLIC	?GetFrameToWindowScale@OBSAPIInterface@@UBE?AUVect2@@XZ ; OBSAPIInterface::GetFrameToWindowScale
PUBLIC	?GetWindowToFrameScale@OBSAPIInterface@@UBE?AUVect2@@XZ ; OBSAPIInterface::GetWindowToFrameScale
PUBLIC	?MapFrameToWindowSize@OBSAPIInterface@@UBE?AUVect2@@U2@@Z ; OBSAPIInterface::MapFrameToWindowSize
PUBLIC	?MapWindowToFrameSize@OBSAPIInterface@@UBE?AUVect2@@U2@@Z ; OBSAPIInterface::MapWindowToFrameSize
PUBLIC	?MapFrameToWindowPos@OBSAPIInterface@@UBE?AUVect2@@U2@@Z ; OBSAPIInterface::MapFrameToWindowPos
PUBLIC	?MapWindowToFramePos@OBSAPIInterface@@UBE?AUVect2@@U2@@Z ; OBSAPIInterface::MapWindowToFramePos
PUBLIC	?GetOutputSize@OBSAPIInterface@@UBEXAAI0@Z	; OBSAPIInterface::GetOutputSize
PUBLIC	?GetRenderFrameControlSize@OBSAPIInterface@@UBEXAAI0@Z ; OBSAPIInterface::GetRenderFrameControlSize
PUBLIC	?GetRenderFrameOffset@OBSAPIInterface@@UBEXAAI0@Z ; OBSAPIInterface::GetRenderFrameOffset
PUBLIC	?GetRenderFrameSize@OBSAPIInterface@@UBEXAAI0@Z	; OBSAPIInterface::GetRenderFrameSize
PUBLIC	?GetBaseSize@OBSAPIInterface@@UBEXAAI0@Z	; OBSAPIInterface::GetBaseSize
PUBLIC	?GetOutputSize@OBSAPIInterface@@UBE?AUVect2@@XZ	; OBSAPIInterface::GetOutputSize
PUBLIC	?GetRenderFrameControlSize@OBSAPIInterface@@UBE?AUVect2@@XZ ; OBSAPIInterface::GetRenderFrameControlSize
PUBLIC	?GetRenderFrameOffset@OBSAPIInterface@@UBE?AUVect2@@XZ ; OBSAPIInterface::GetRenderFrameOffset
PUBLIC	?GetRenderFrameSize@OBSAPIInterface@@UBE?AUVect2@@XZ ; OBSAPIInterface::GetRenderFrameSize
PUBLIC	?GetBaseSize@OBSAPIInterface@@UBE?AUVect2@@XZ	; OBSAPIInterface::GetBaseSize
PUBLIC	?GetSceneElement@OBSAPIInterface@@UAEPAVXElement@@XZ ; OBSAPIInterface::GetSceneElement
PUBLIC	?GetSceneName@OBSAPIInterface@@UBEPB_WXZ	; OBSAPIInterface::GetSceneName
PUBLIC	?GetScene@OBSAPIInterface@@UBEPAVScene@@XZ	; OBSAPIInterface::GetScene
PUBLIC	?SetScene@OBSAPIInterface@@UAE_NPB_W_N@Z	; OBSAPIInterface::SetScene
PUBLIC	?SetSourceRender@OBSAPIInterface@@UAEXPB_W_N@Z	; OBSAPIInterface::SetSourceRender
PUBLIC	?SetSourceOrder@OBSAPIInterface@@UAEXAAVStringList@@@Z ; OBSAPIInterface::SetSourceOrder
PUBLIC	?GetGlobalSourceListElement@OBSAPIInterface@@UAEPAVXElement@@XZ ; OBSAPIInterface::GetGlobalSourceListElement
PUBLIC	?GetSceneListElement@OBSAPIInterface@@UAEPAVXElement@@XZ ; OBSAPIInterface::GetSceneListElement
PUBLIC	?CreateImageSource@OBSAPIInterface@@UAEPAVImageSource@@PB_WPAVXElement@@@Z ; OBSAPIInterface::CreateImageSource
PUBLIC	?RegisterImageSourceClass@OBSAPIInterface@@UAEXPB_W0P6GPAXPAVXElement@@@ZP6G_N1_N@Z@Z ; OBSAPIInterface::RegisterImageSourceClass
PUBLIC	?RegisterSceneClass@OBSAPIInterface@@UAEXPB_W0P6GPAXPAVXElement@@@ZP6G_N1_N@Z@Z ; OBSAPIInterface::RegisterSceneClass
PUBLIC	?GetKeepRecording@OBSAPIInterface@@UBE_NXZ	; OBSAPIInterface::GetKeepRecording
PUBLIC	?GetRecordingReplayBuffer@OBSAPIInterface@@UBE_NXZ ; OBSAPIInterface::GetRecordingReplayBuffer
PUBLIC	?GetRecording@OBSAPIInterface@@UBE_NXZ		; OBSAPIInterface::GetRecording
PUBLIC	?GetPreviewOnly@OBSAPIInterface@@UAE_NXZ	; OBSAPIInterface::GetPreviewOnly
PUBLIC	?GetStreaming@OBSAPIInterface@@UAE_NXZ		; OBSAPIInterface::GetStreaming
PUBLIC	?SaveReplayBuffer@OBSAPIInterface@@UAEXXZ	; OBSAPIInterface::SaveReplayBuffer
PUBLIC	?StartStopRecordingReplayBuffer@OBSAPIInterface@@UAEXXZ ; OBSAPIInterface::StartStopRecordingReplayBuffer
PUBLIC	?StartStopRecording@OBSAPIInterface@@UAEXXZ	; OBSAPIInterface::StartStopRecording
PUBLIC	?StartStopPreview@OBSAPIInterface@@UAEXXZ	; OBSAPIInterface::StartStopPreview
PUBLIC	?StartStopStream@OBSAPIInterface@@UAEXXZ	; OBSAPIInterface::StartStopStream
PUBLIC	?LeaveSceneMutex@OBSAPIInterface@@UAEXXZ	; OBSAPIInterface::LeaveSceneMutex
PUBLIC	?EnterSceneMutex@OBSAPIInterface@@UAEXXZ	; OBSAPIInterface::EnterSceneMutex
PUBLIC	?SetCanOptimizeSettings@OBSAPIInterface@@EAEX_N@Z ; OBSAPIInterface::SetCanOptimizeSettings
PUBLIC	?SetAbortApplySettings@OBSAPIInterface@@EAEX_N@Z ; OBSAPIInterface::SetAbortApplySettings
PUBLIC	?SetChangedSettings@OBSAPIInterface@@EAEX_N@Z	; OBSAPIInterface::SetChangedSettings
PUBLIC	?SetSceneCollection@OBS@@UAE_NPB_W@Z		; OBS::SetSceneCollection
PUBLIC	?SetScene@OBS@@UAE_NPB_W@Z			; OBS::SetScene
PUBLIC	?InsertSourceItem@OBS@@UAEXIPA_W_N@Z		; OBS::InsertSourceItem
PUBLIC	?CreateImageSource@OBS@@UAEPAVImageSource@@PB_WPAVXElement@@@Z ; OBS::CreateImageSource
PUBLIC	?CreateScene@OBS@@AAEPAVScene@@PB_WPAVXElement@@@Z ; OBS::CreateScene
PUBLIC	?RegisterImageSourceClass@OBS@@UAEXPB_W0P6GPAXPAVXElement@@@ZP6G_N1_N@Z3@Z ; OBS::RegisterImageSourceClass
PUBLIC	?RegisterSceneClass@OBS@@UAEXPB_W0P6GPAXPAVXElement@@@ZP6G_N1_N@Z3@Z ; OBS::RegisterSceneClass
PUBLIC	?GetCurrentSceneCollection@OBS@@SAPB_WXZ	; OBS::GetCurrentSceneCollection
PUBLIC	?GetSceneElement@OBS@@QBEPAVXElement@@XZ	; OBS::GetSceneElement
PUBLIC	?LeaveSceneMutex@OBS@@QAEXXZ			; OBS::LeaveSceneMutex
PUBLIC	?EnterSceneMutex@OBS@@QAEXXZ			; OBS::EnterSceneMutex
PUBLIC	?GetOutputSize@OBS@@QBEXAAI0@Z			; OBS::GetOutputSize
PUBLIC	?GetRenderFrameControlSize@OBS@@QBEXAAI0@Z	; OBS::GetRenderFrameControlSize
PUBLIC	?GetRenderFrameOffset@OBS@@QBEXAAI0@Z		; OBS::GetRenderFrameOffset
PUBLIC	?GetRenderFrameSize@OBS@@QBEXAAI0@Z		; OBS::GetRenderFrameSize
PUBLIC	?GetVideoTime@OBS@@QBE_KXZ			; OBS::GetVideoTime
PUBLIC	?GetAudioTime@OBS@@QBE_KXZ			; OBS::GetAudioTime
PUBLIC	?GetSampleRateHz@OBS@@QBEIXZ			; OBS::GetSampleRateHz
PUBLIC	?RemoveAudioSource@OBS@@QAEXPAVAudioSource@@@Z	; OBS::RemoveAudioSource
PUBLIC	?AddAudioSource@OBS@@QAEXPAVAudioSource@@@Z	; OBS::AddAudioSource
PUBLIC	?GetImageSourceClass@OBS@@ABEPAUClassInfo@@PB_W@Z ; OBS::GetImageSourceClass
PUBLIC	?GetSceneClass@OBS@@ABEPAUClassInfo@@PB_W@Z	; OBS::GetSceneClass
PUBLIC	?GetGlobalSource@OBS@@AAEPAVImageSource@@PB_W@Z	; OBS::GetGlobalSource
PUBLIC	?FreeData@StreamInfo@@QAEXXZ			; StreamInfo::FreeData
PUBLIC	??_GAPIInterface@@UAEPAXI@Z			; APIInterface::`scalar deleting destructor'
PUBLIC	?Invalid02@APIInterface@@UAEXXZ			; APIInterface::Invalid02
PUBLIC	?Invalid01@APIInterface@@UAEXXZ			; APIInterface::Invalid01
PUBLIC	??1APIInterface@@UAE@XZ				; APIInterface::~APIInterface
PUBLIC	?Invalid03@APIInterface@@UBEXXZ			; APIInterface::Invalid03
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	??0_Ignore@std@@QAE@XZ				; std::_Ignore::_Ignore
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	??3@YAXPAX@Z					; operator delete
PUBLIC	??2@YAPAXI@Z					; operator new
PUBLIC	?Free@@YAXPAX@Z					; Free
PUBLIC	?zero@@YGXPAXI@Z				; zero
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@00800000
PUBLIC	__real@38d1b717
PUBLIC	__real@3c23d70a
PUBLIC	__real@3c8efa35
PUBLIC	__real@3d4ccccd
PUBLIC	__real@3dcccccd
PUBLIC	__real@3e112e0be826d695
PUBLIC	__real@3e19999a
PUBLIC	__real@3e7ad7f29abcaf48
PUBLIC	__real@3f000000
PUBLIC	__real@3f50624dd2f1a9fc
PUBLIC	__real@3f800000
PUBLIC	__real@3fa999999999999a
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@3ff028f5c28f5c29
PUBLIC	__real@3ff4000000000000
PUBLIC	__real@3ff8000000000000
PUBLIC	__real@40000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@4000147ae147ae14
PUBLIC	__real@4004666666666666
PUBLIC	__real@4008147ae147ae14
PUBLIC	__real@4014000000000000
PUBLIC	__real@4020000000000000
PUBLIC	__real@4024000000000000
PUBLIC	__real@402e000000000000
PUBLIC	__real@4030000000000000
PUBLIC	__real@4039000000000000
PUBLIC	__real@40400000
PUBLIC	__real@4049000000000000
PUBLIC	__real@4059000000000000
PUBLIC	__real@406fe00000000000
PUBLIC	__real@4079000000000000
PUBLIC	__real@40800000
PUBLIC	__real@408f400000000000
PUBLIC	__real@4090000000000000
PUBLIC	__real@40a00000
PUBLIC	__real@40bc200000000000
PUBLIC	__real@40e0000000000000
PUBLIC	__real@41200000
PUBLIC	__real@41400000
PUBLIC	__real@41a00000
PUBLIC	__real@41a80000
PUBLIC	__real@42000000
PUBLIC	__real@42b40000
PUBLIC	__real@42c80000
PUBLIC	__real@43340000
PUBLIC	__real@437f0000
PUBLIC	__real@43870000
PUBLIC	__real@44160000
PUBLIC	__real@447a0000
PUBLIC	__real@44af0000
PUBLIC	__real@46fa0000
PUBLIC	__real@46fffe00
PUBLIC	__real@7f7fffff
PUBLIC	__real@bf800000
PUBLIC	__real@c08f400000000000
PUBLIC	__real@c2c00000
PUBLIC	__real@c2c80000
PUBLIC	__xmm@0000ff000000ff000000ff000000ff00
PUBLIC	__xmm@00ff00ff00ff00ff00ff00ff00ff00ff
PUBLIC	__xmm@406f80000000000040a8ee0000000000
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@46fffe0046fffe0046fffe0046fffe00
PUBLIC	__xmm@7fffffffffffffff7fffffffffffffff
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	??_EOBSAPIInterface@@UAEPAXI@Z:PROC		; OBSAPIInterface::`vector deleting destructor'
EXTRN	??_EAPIInterface@@UAEPAXI@Z:PROC		; APIInterface::`vector deleting destructor'
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__alldiv:PROC
EXTRN	__allmul:PROC
EXTRN	__allshl:PROC
EXTRN	__aulldiv:PROC
EXTRN	__aullrem:PROC
EXTRN	__aullshr:PROC
EXTRN	__chkstk:PROC
EXTRN	__dtoui3:PROC
EXTRN	__dtoul3:PROC
EXTRN	__except_handler4:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	__ftoui3:PROC
EXTRN	__libm_sse2_log10_precise:PROC
EXTRN	__libm_sse2_sqrt_precise:PROC
EXTRN	__ltod3:PROC
EXTRN	__ultod3:PROC
EXTRN	_ceil:PROC
EXTRN	_memcmp:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	__tls_array:DWORD
EXTRN	__tls_index:DWORD
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
__Tuple_alloc DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
	ALIGN	4

_ignore	DB	01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
	ALIGN	4

_piecewise_construct DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?allow_other_hotkey_modifiers@?1??HandleHotkeys@OBSAPIInterface@@AAEXXZ@4_NA
_BSS	SEGMENT
?allow_other_hotkey_modifiers@?1??HandleHotkeys@OBSAPIInterface@@AAEXXZ@4_NA DB 01H DUP (?) ; `OBSAPIInterface::HandleHotkeys'::`2'::allow_other_hotkey_modifiers
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?uplay_overlay_compatibility@?1??HandleHotkeys@OBSAPIInterface@@AAEXXZ@4_NA
_BSS	SEGMENT
?uplay_overlay_compatibility@?1??HandleHotkeys@OBSAPIInterface@@AAEXXZ@4_NA DB 01H DUP (?) ; `OBSAPIInterface::HandleHotkeys'::`2'::uplay_overlay_compatibility
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@7fffffffffffffff7fffffffffffffff
CONST	SEGMENT
__xmm@7fffffffffffffff7fffffffffffffff DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
	DB	0ffH, 07fH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 07fH
CONST	ENDS
;	COMDAT __xmm@46fffe0046fffe0046fffe0046fffe00
CONST	SEGMENT
__xmm@46fffe0046fffe0046fffe0046fffe00 DB 00H, 0feH, 0ffH, 'F', 00H, 0feH
	DB	0ffH, 'F', 00H, 0feH, 0ffH, 'F', 00H, 0feH, 0ffH, 'F'
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __xmm@406f80000000000040a8ee0000000000
CONST	SEGMENT
__xmm@406f80000000000040a8ee0000000000 DB 00H, 00H, 00H, 00H, 00H, 0eeH, 0a8H
	DB	'@', 00H, 00H, 00H, 00H, 00H, 080H, 'o@'
CONST	ENDS
;	COMDAT __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
CONST	SEGMENT
__xmm@00ff00ff00ff00ff00ff00ff00ff00ff DB 0ffH, 00H, 0ffH, 00H, 0ffH, 00H
	DB	0ffH, 00H, 0ffH, 00H, 0ffH, 00H, 0ffH, 00H, 0ffH, 00H
CONST	ENDS
;	COMDAT __xmm@0000ff000000ff000000ff000000ff00
CONST	SEGMENT
__xmm@0000ff000000ff000000ff000000ff00 DB 00H, 0ffH, 00H, 00H, 00H, 0ffH, 00H
	DB	00H, 00H, 0ffH, 00H, 00H, 00H, 0ffH, 00H, 00H
CONST	ENDS
;	COMDAT __real@c2c80000
CONST	SEGMENT
__real@c2c80000 DD 0c2c80000r			; -100
CONST	ENDS
;	COMDAT __real@c2c00000
CONST	SEGMENT
__real@c2c00000 DD 0c2c00000r			; -96
CONST	ENDS
;	COMDAT __real@c08f400000000000
CONST	SEGMENT
__real@c08f400000000000 DQ 0c08f400000000000r	; -1000
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@7f7fffff
CONST	SEGMENT
__real@7f7fffff DD 07f7fffffr			; 3.40282e+038
CONST	ENDS
;	COMDAT __real@46fffe00
CONST	SEGMENT
__real@46fffe00 DD 046fffe00r			; 32767
CONST	ENDS
;	COMDAT __real@46fa0000
CONST	SEGMENT
__real@46fa0000 DD 046fa0000r			; 32000
CONST	ENDS
;	COMDAT __real@44af0000
CONST	SEGMENT
__real@44af0000 DD 044af0000r			; 1400
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@44160000
CONST	SEGMENT
__real@44160000 DD 044160000r			; 600
CONST	ENDS
;	COMDAT __real@43870000
CONST	SEGMENT
__real@43870000 DD 043870000r			; 270
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@43340000
CONST	SEGMENT
__real@43340000 DD 043340000r			; 180
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42b40000
CONST	SEGMENT
__real@42b40000 DD 042b40000r			; 90
CONST	ENDS
;	COMDAT __real@42000000
CONST	SEGMENT
__real@42000000 DD 042000000r			; 32
CONST	ENDS
;	COMDAT __real@41a80000
CONST	SEGMENT
__real@41a80000 DD 041a80000r			; 21
CONST	ENDS
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
CONST	ENDS
;	COMDAT __real@41400000
CONST	SEGMENT
__real@41400000 DD 041400000r			; 12
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@40e0000000000000
CONST	SEGMENT
__real@40e0000000000000 DQ 040e0000000000000r	; 32768
CONST	ENDS
;	COMDAT __real@40bc200000000000
CONST	SEGMENT
__real@40bc200000000000 DQ 040bc200000000000r	; 7200
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@4090000000000000
CONST	SEGMENT
__real@4090000000000000 DQ 04090000000000000r	; 1024
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@4079000000000000
CONST	SEGMENT
__real@4079000000000000 DQ 04079000000000000r	; 400
CONST	ENDS
;	COMDAT __real@406fe00000000000
CONST	SEGMENT
__real@406fe00000000000 DQ 0406fe00000000000r	; 255
CONST	ENDS
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
CONST	ENDS
;	COMDAT __real@4049000000000000
CONST	SEGMENT
__real@4049000000000000 DQ 04049000000000000r	; 50
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@4039000000000000
CONST	SEGMENT
__real@4039000000000000 DQ 04039000000000000r	; 25
CONST	ENDS
;	COMDAT __real@4030000000000000
CONST	SEGMENT
__real@4030000000000000 DQ 04030000000000000r	; 16
CONST	ENDS
;	COMDAT __real@402e000000000000
CONST	SEGMENT
__real@402e000000000000 DQ 0402e000000000000r	; 15
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@4020000000000000
CONST	SEGMENT
__real@4020000000000000 DQ 04020000000000000r	; 8
CONST	ENDS
;	COMDAT __real@4014000000000000
CONST	SEGMENT
__real@4014000000000000 DQ 04014000000000000r	; 5
CONST	ENDS
;	COMDAT __real@4008147ae147ae14
CONST	SEGMENT
__real@4008147ae147ae14 DQ 04008147ae147ae14r	; 3.01
CONST	ENDS
;	COMDAT __real@4004666666666666
CONST	SEGMENT
__real@4004666666666666 DQ 04004666666666666r	; 2.55
CONST	ENDS
;	COMDAT __real@4000147ae147ae14
CONST	SEGMENT
__real@4000147ae147ae14 DQ 04000147ae147ae14r	; 2.01
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff8000000000000
CONST	SEGMENT
__real@3ff8000000000000 DQ 03ff8000000000000r	; 1.5
CONST	ENDS
;	COMDAT __real@3ff4000000000000
CONST	SEGMENT
__real@3ff4000000000000 DQ 03ff4000000000000r	; 1.25
CONST	ENDS
;	COMDAT __real@3ff028f5c28f5c29
CONST	SEGMENT
__real@3ff028f5c28f5c29 DQ 03ff028f5c28f5c29r	; 1.01
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fa999999999999a
CONST	SEGMENT
__real@3fa999999999999a DQ 03fa999999999999ar	; 0.05
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f50624dd2f1a9fc
CONST	SEGMENT
__real@3f50624dd2f1a9fc DQ 03f50624dd2f1a9fcr	; 0.001
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3e7ad7f29abcaf48
CONST	SEGMENT
__real@3e7ad7f29abcaf48 DQ 03e7ad7f29abcaf48r	; 1e-007
CONST	ENDS
;	COMDAT __real@3e19999a
CONST	SEGMENT
__real@3e19999a DD 03e19999ar			; 0.15
CONST	ENDS
;	COMDAT __real@3e112e0be826d695
CONST	SEGMENT
__real@3e112e0be826d695 DQ 03e112e0be826d695r	; 1e-009
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3d4ccccd
CONST	SEGMENT
__real@3d4ccccd DD 03d4ccccdr			; 0.05
CONST	ENDS
;	COMDAT __real@3c8efa35
CONST	SEGMENT
__real@3c8efa35 DD 03c8efa35r			; 0.0174533
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@38d1b717
CONST	SEGMENT
__real@38d1b717 DD 038d1b717r			; 0.0001
CONST	ENDS
;	COMDAT __real@00800000
CONST	SEGMENT
__real@00800000 DD 000800000r			; 1.17549e-038
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_ignore$initializer$ DD FLAT:??__Eignore@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
__Tuple_alloc$initializer$ DD FLAT:??__E_Tuple_alloc@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@D@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<char>::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@_W@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<wchar_t>::id$initializer$
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\inline.h
;	COMDAT ?zero@@YGXPAXI@Z
_TEXT	SEGMENT
tv72 = -24						; size = 4
tv68 = -20						; size = 4
_destB$ = -16						; size = 4
_iLenMod4$ = -12					; size = 4
_iLenDiv4$ = -8						; size = 4
_destDW$ = -4						; size = 4
_pDest$ = 8						; size = 4
_iLen$ = 12						; size = 4
?zero@@YGXPAXI@Z PROC					; zero, COMDAT

; 200  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 201  :     assert(pDest);
; 202  : 
; 203  :     register size_t iLenMod4 = iLen&3;

	mov	eax, DWORD PTR _iLen$[ebp]
	and	eax, 3
	mov	DWORD PTR _iLenMod4$[ebp], eax

; 204  :     register size_t iLenDiv4 = iLen>>2;

	mov	ecx, DWORD PTR _iLen$[ebp]
	shr	ecx, 2
	mov	DWORD PTR _iLenDiv4$[ebp], ecx

; 205  : 
; 206  :     register DWORD *destDW = (DWORD*)pDest;

	mov	edx, DWORD PTR _pDest$[ebp]
	mov	DWORD PTR _destDW$[ebp], edx
$LN4@zero:

; 207  :     while(iLenDiv4--)

	mov	eax, DWORD PTR _iLenDiv4$[ebp]
	mov	DWORD PTR tv68[ebp], eax
	mov	ecx, DWORD PTR _iLenDiv4$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _iLenDiv4$[ebp], ecx
	cmp	DWORD PTR tv68[ebp], 0
	je	SHORT $LN3@zero

; 208  :         *(destDW++) = 0;

	mov	edx, DWORD PTR _destDW$[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR _destDW$[ebp]
	add	eax, 4
	mov	DWORD PTR _destDW$[ebp], eax
	jmp	SHORT $LN4@zero
$LN3@zero:

; 209  : 
; 210  :     register BYTE *destB = (BYTE*)destDW;

	mov	ecx, DWORD PTR _destDW$[ebp]
	mov	DWORD PTR _destB$[ebp], ecx
$LN2@zero:

; 211  :     while(iLenMod4--)

	mov	edx, DWORD PTR _iLenMod4$[ebp]
	mov	DWORD PTR tv72[ebp], edx
	mov	eax, DWORD PTR _iLenMod4$[ebp]
	sub	eax, 1
	mov	DWORD PTR _iLenMod4$[ebp], eax
	cmp	DWORD PTR tv72[ebp], 0
	je	SHORT $LN5@zero

; 212  :         *(destB++) = 0;

	mov	ecx, DWORD PTR _destB$[ebp]
	mov	BYTE PTR [ecx], 0
	mov	edx, DWORD PTR _destB$[ebp]
	add	edx, 1
	mov	DWORD PTR _destB$[ebp], edx
	jmp	SHORT $LN2@zero
$LN5@zero:

; 213  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?zero@@YGXPAXI@Z ENDP					; zero
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\alloc.h
;	COMDAT ?Free@@YAXPAX@Z
_TEXT	SEGMENT
_lpData$ = 8						; size = 4
?Free@@YAXPAX@Z PROC					; Free, COMDAT

; 66   : inline void Free(void *lpData)   {MainAllocator->_Free(lpData);}

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _lpData$[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	pop	ebp
	ret	0
?Free@@YAXPAX@Z ENDP					; Free
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\alloc.h
;	COMDAT ??2@YAPAXI@Z
_TEXT	SEGMENT
_val$ = -4						; size = 4
_dwSize$ = 8						; size = 4
??2@YAPAXI@Z PROC					; operator new, COMDAT

; 88   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 89   :     void* val = Allocate(dwSize);

	mov	eax, DWORD PTR _dwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	mov	DWORD PTR _val$[ebp], eax

; 90   :     zero(val, dwSize);

	mov	ecx, DWORD PTR _dwSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _val$[ebp]
	push	edx
	call	?zero@@YGXPAXI@Z			; zero

; 91   : 
; 92   :     return val;

	mov	eax, DWORD PTR _val$[ebp]

; 93   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??2@YAPAXI@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\alloc.h
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT
_lpData$ = 8						; size = 4
??3@YAXPAX@Z PROC					; operator delete, COMDAT

; 96   : {

	push	ebp
	mov	ebp, esp

; 97   :     Free(lpData);

	mov	eax, DWORD PTR _lpData$[ebp]
	push	eax
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4

; 98   : }

	pop	ebp
	ret	0
??3@YAXPAX@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -20						; size = 4
tv75 = -16						; size = 4
tv69 = -12						; size = 4
tv72 = -8						; size = 4
tv78 = -1						; size = 1
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv69[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR tv72[ebp], edx
	mov	eax, DWORD PTR tv72[ebp]
	add	eax, 1
	mov	DWORD PTR tv75[ebp], eax
$LL5@length:
	mov	ecx, DWORD PTR tv72[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv78[ebp], dl
	add	DWORD PTR tv72[ebp], 1
	cmp	BYTE PTR tv78[ebp], 0
	jne	SHORT $LL5@length
	mov	eax, DWORD PTR tv72[ebp]
	sub	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR tv68[ebp], eax
	mov	ecx, DWORD PTR tv68[ebp]
	mov	DWORD PTR tv69[ebp], ecx
$LN4@length:
	mov	eax, DWORD PTR tv69[ebp]

; 524  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 70   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3451 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\tuple
;	COMDAT ??0_Ignore@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Ignore@std@@QAE@XZ PROC				; std::_Ignore::_Ignore, COMDAT
; _this$ = ecx

; 49   : 	_Ignore()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 50   : 		{	// construct
; 51   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Ignore@std@@QAE@XZ ENDP				; std::_Ignore::_Ignore
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\tuple
;	COMDAT ??__Eignore@std@@YAXXZ
text$di	SEGMENT
??__Eignore@std@@YAXXZ PROC				; std::`dynamic initializer for 'ignore'', COMDAT

; 59   : const _Ignore ignore;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET _ignore
	call	??0_Ignore@std@@QAE@XZ			; std::_Ignore::_Ignore
	pop	ebp
	ret	0
??__Eignore@std@@YAXXZ ENDP				; std::`dynamic initializer for 'ignore''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\tuple
;	COMDAT ??__E_Tuple_alloc@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__E_Tuple_alloc@std@@YAXXZ PROC			; std::`dynamic initializer for '_Tuple_alloc'', COMDAT

; 66   : const _Tuple_alloc_t _Tuple_alloc = _Tuple_alloc_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__E_Tuple_alloc@std@@YAXXZ ENDP			; std::`dynamic initializer for '_Tuple_alloc''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 74   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 75   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 154  : 	error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 155  : 		{	// default constructor
; 156  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 160  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 176  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 177  : 		return (this == &_Right);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv65[ebp]

; 178  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 241  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 242  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 243  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 246  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 247  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 248  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 299  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [edx+4], eax

; 300  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 332  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 333  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 334  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 337  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 338  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 339  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 352  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 353  : 		return (category() == _Right.category()
; 354  : 			&& value() == _Right.value());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 355  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 377  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 378  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 379  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 384  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 385  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, eax
	call	??8error_condition@std@@QBE_NABV01@@Z	; std::error_condition::operator==

; 386  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 391  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 392  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 393  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 553  : 	_Generic_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0error_category@std@@QAE@XZ		; std::error_category::error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 554  : 		{	// default constructor
; 555  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 558  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 559  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 560  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 563  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		const char *_Name = _Syserror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 565  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 566  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 574  : 	_Iostream_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 575  : 		{	// default constructor
; 576  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 579  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 580  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 581  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 584  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 585  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 586  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 587  : 		else

	jmp	SHORT $LN3@message
$LN2@message:

; 588  : 			return (_Generic_error_category::message(_Errcode));

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 589  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 597  : 	_System_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 598  : 		{	// default constructor
; 599  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 602  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 603  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 604  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 607  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 608  : 		const char *_Name = _Winerror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Winerror_map@std@@YAPBDH@Z		; std::_Winerror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 609  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 610  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 614  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 615  : 		if (_Syserror_map(_Errval))

	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@default_er

; 616  : 			return (error_condition(_Errval, generic_category()));

	call	?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@default_er

; 617  : 		else

	jmp	SHORT $LN3@default_er
$LN2@default_er:

; 618  : 			return (error_condition(_Errval, system_category()));

	call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
	push	eax
	mov	edx, DWORD PTR __Errval$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 619  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 642  : 	{	// get generic_category

	push	ebp
	mov	ebp, esp

; 643  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 644  : 	}

	pop	ebp
	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 652  : 	{	// get system_category

	push	ebp
	mov	ebp, esp

; 653  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 654  : 	}

	pop	ebp
	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\apiinterface.h
;	COMDAT ?Invalid03@APIInterface@@UBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Invalid03@APIInterface@@UBEXXZ PROC			; APIInterface::Invalid03, COMDAT
; _this$ = ecx

; 50   :     virtual void Invalid03() const {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?Invalid03@APIInterface@@UBEXXZ ENDP			; APIInterface::Invalid03
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\apiinterface.h
;	COMDAT ??1APIInterface@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1APIInterface@@UAE@XZ PROC				; APIInterface::~APIInterface, COMDAT
; _this$ = ecx

; 52   :     virtual ~APIInterface() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7APIInterface@@6B@
	mov	esp, ebp
	pop	ebp
	ret	0
??1APIInterface@@UAE@XZ ENDP				; APIInterface::~APIInterface
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\apiinterface.h
;	COMDAT ?Invalid01@APIInterface@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Invalid01@APIInterface@@UAEXXZ PROC			; APIInterface::Invalid01, COMDAT
; _this$ = ecx

; 129  :     virtual void Invalid01() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?Invalid01@APIInterface@@UAEXXZ ENDP			; APIInterface::Invalid01
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\apiinterface.h
;	COMDAT ?Invalid02@APIInterface@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Invalid02@APIInterface@@UAEXXZ PROC			; APIInterface::Invalid02, COMDAT
; _this$ = ecx

; 130  :     virtual void Invalid02() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?Invalid02@APIInterface@@UAEXXZ ENDP			; APIInterface::Invalid02
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GAPIInterface@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GAPIInterface@@UAEPAXI@Z PROC			; APIInterface::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1APIInterface@@UAE@XZ			; APIInterface::~APIInterface
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GAPIInterface@@UAEPAXI@Z ENDP			; APIInterface::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ?FreeData@StreamInfo@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?FreeData@StreamInfo@@QAEXXZ PROC			; StreamInfo::FreeData, COMDAT
; _this$ = ecx

; 544  :     inline void FreeData() {strInfo.Clear();}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_?Clear@String@@QAEAAV1@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
?FreeData@StreamInfo@@QAEXXZ ENDP			; StreamInfo::FreeData
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ?GetGlobalSource@OBS@@AAEPAVImageSource@@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
_lpName$ = 8						; size = 4
?GetGlobalSource@OBS@@AAEPAVImageSource@@PB_W@Z PROC	; OBS::GetGlobalSource, COMDAT
; _this$ = ecx

; 1010 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1011 :         for(UINT i=0; i<globalSources.Num(); i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@GetGlobalS
$LN3@GetGlobalS:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@GetGlobalS:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1376				; 00000560H
	call	?Num@?$List@UGlobalSourceInfo@@@@QBEIXZ	; List<GlobalSourceInfo>::Num
	cmp	DWORD PTR _i$1[ebp], eax
	jae	SHORT $LN2@GetGlobalS

; 1012 :         {
; 1013 :             if(globalSources[i].strName.CompareI(lpName))

	mov	ecx, DWORD PTR _lpName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1376				; 00000560H
	call	??A?$List@UGlobalSourceInfo@@@@QAEAAUGlobalSourceInfo@@I@Z ; List<GlobalSourceInfo>::operator[]
	mov	ecx, eax
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN1@GetGlobalS

; 1014 :                 return globalSources[i].source;

	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1376				; 00000560H
	call	??A?$List@UGlobalSourceInfo@@@@QAEAAUGlobalSourceInfo@@I@Z ; List<GlobalSourceInfo>::operator[]
	mov	eax, DWORD PTR [eax+12]
	jmp	SHORT $LN5@GetGlobalS
$LN1@GetGlobalS:

; 1015 :         }

	jmp	SHORT $LN3@GetGlobalS
$LN2@GetGlobalS:

; 1016 : 
; 1017 :         return AddGlobalSourceToScene(lpName);

	mov	ecx, DWORD PTR _lpName$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddGlobalSourceToScene@OBS@@AAEPAVImageSource@@PB_W@Z ; OBS::AddGlobalSourceToScene
$LN5@GetGlobalS:

; 1018 :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetGlobalSource@OBS@@AAEPAVImageSource@@PB_W@Z ENDP	; OBS::GetGlobalSource
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ?GetSceneClass@OBS@@ABEPAUClassInfo@@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
_lpClass$ = 8						; size = 4
?GetSceneClass@OBS@@ABEPAUClassInfo@@PB_W@Z PROC	; OBS::GetSceneClass, COMDAT
; _this$ = ecx

; 1021 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1022 :         for(UINT i=0; i<sceneClasses.Num(); i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@GetSceneCl
$LN3@GetSceneCl:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@GetSceneCl:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1360				; 00000550H
	call	?Num@?$List@UClassInfo@@@@QBEIXZ	; List<ClassInfo>::Num
	cmp	DWORD PTR _i$1[ebp], eax
	jae	SHORT $LN2@GetSceneCl

; 1023 :         {
; 1024 :             if(sceneClasses[i].strClass.CompareI(lpClass))

	mov	ecx, DWORD PTR _lpClass$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1360				; 00000550H
	call	??A?$List@UClassInfo@@@@QBEAAUClassInfo@@I@Z ; List<ClassInfo>::operator[]
	mov	ecx, eax
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN1@GetSceneCl

; 1025 :                 return sceneClasses+i;

	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1360				; 00000550H
	call	??H?$List@UClassInfo@@@@QBEPAUClassInfo@@I@Z ; List<ClassInfo>::operator+
	jmp	SHORT $LN5@GetSceneCl
$LN1@GetSceneCl:

; 1026 :         }

	jmp	SHORT $LN3@GetSceneCl
$LN2@GetSceneCl:

; 1027 : 
; 1028 :         return NULL;

	xor	eax, eax
$LN5@GetSceneCl:

; 1029 :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetSceneClass@OBS@@ABEPAUClassInfo@@PB_W@Z ENDP	; OBS::GetSceneClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ?GetImageSourceClass@OBS@@ABEPAUClassInfo@@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
_lpClass$ = 8						; size = 4
?GetImageSourceClass@OBS@@ABEPAUClassInfo@@PB_W@Z PROC	; OBS::GetImageSourceClass, COMDAT
; _this$ = ecx

; 1032 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1033 :         for(UINT i=0; i<imageSourceClasses.Num(); i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@GetImageSo
$LN3@GetImageSo:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@GetImageSo:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1368				; 00000558H
	call	?Num@?$List@UClassInfo@@@@QBEIXZ	; List<ClassInfo>::Num
	cmp	DWORD PTR _i$1[ebp], eax
	jae	SHORT $LN2@GetImageSo

; 1034 :         {
; 1035 :             if(imageSourceClasses[i].strClass.CompareI(lpClass))

	mov	ecx, DWORD PTR _lpClass$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1368				; 00000558H
	call	??A?$List@UClassInfo@@@@QBEAAUClassInfo@@I@Z ; List<ClassInfo>::operator[]
	mov	ecx, eax
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN1@GetImageSo

; 1036 :                 return imageSourceClasses+i;

	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1368				; 00000558H
	call	??H?$List@UClassInfo@@@@QBEPAUClassInfo@@I@Z ; List<ClassInfo>::operator+
	jmp	SHORT $LN5@GetImageSo
$LN1@GetImageSo:

; 1037 :         }

	jmp	SHORT $LN3@GetImageSo
$LN2@GetImageSo:

; 1038 : 
; 1039 :         return NULL;

	xor	eax, eax
$LN5@GetImageSo:

; 1040 :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetImageSourceClass@OBS@@ABEPAUClassInfo@@PB_W@Z ENDP	; OBS::GetImageSourceClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ?AddAudioSource@OBS@@QAEXPAVAudioSource@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_source$ = 8						; size = 4
?AddAudioSource@OBS@@QAEXPAVAudioSource@@@Z PROC	; OBS::AddAudioSource, COMDAT
; _this$ = ecx

; 1186 :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1187 :         OSEnterMutex(hAuxAudioMutex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1228]
	push	ecx
	call	DWORD PTR __imp_?OSEnterMutex@@YGXPAX@Z

; 1188 :         auxAudioSources << source;

	lea	edx, DWORD PTR _source$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	call	??6?$List@PAVAudioSource@@@@QAEAAV0@ABQAVAudioSource@@@Z ; List<AudioSource *>::operator<<

; 1189 :         OSLeaveMutex(hAuxAudioMutex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1228]
	push	ecx
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z

; 1190 :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?AddAudioSource@OBS@@QAEXPAVAudioSource@@@Z ENDP	; OBS::AddAudioSource
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ?RemoveAudioSource@OBS@@QAEXPAVAudioSource@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_source$ = 8						; size = 4
?RemoveAudioSource@OBS@@QAEXPAVAudioSource@@@Z PROC	; OBS::RemoveAudioSource, COMDAT
; _this$ = ecx

; 1192 :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1193 :         OSEnterMutex(hAuxAudioMutex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1228]
	push	ecx
	call	DWORD PTR __imp_?OSEnterMutex@@YGXPAX@Z

; 1194 :         auxAudioSources.RemoveItem(source);

	lea	edx, DWORD PTR _source$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	call	?RemoveItem@?$List@PAVAudioSource@@@@QAEXABQAVAudioSource@@@Z ; List<AudioSource *>::RemoveItem

; 1195 :         OSLeaveMutex(hAuxAudioMutex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1228]
	push	ecx
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z

; 1196 :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?RemoveAudioSource@OBS@@QAEXPAVAudioSource@@@Z ENDP	; OBS::RemoveAudioSource
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ?GetSampleRateHz@OBS@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSampleRateHz@OBS@@QBEIXZ PROC			; OBS::GetSampleRateHz, COMDAT
; _this$ = ecx

; 1198 :     inline UINT GetSampleRateHz() const {return sampleRateHz;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+128]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSampleRateHz@OBS@@QBEIXZ ENDP			; OBS::GetSampleRateHz
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ?GetAudioTime@OBS@@QBE_KXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAudioTime@OBS@@QBE_KXZ PROC				; OBS::GetAudioTime, COMDAT
; _this$ = ecx

; 1201 :     inline QWORD GetAudioTime() const {return latestAudioTime;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+1160]
	mov	edx, DWORD PTR [ecx+1164]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAudioTime@OBS@@QBE_KXZ ENDP				; OBS::GetAudioTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ?GetVideoTime@OBS@@QBE_KXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetVideoTime@OBS@@QBE_KXZ PROC				; OBS::GetVideoTime, COMDAT
; _this$ = ecx

; 1202 :     inline QWORD GetVideoTime() const {return latestVideoTime;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+1008]
	mov	edx, DWORD PTR [ecx+1012]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetVideoTime@OBS@@QBE_KXZ ENDP				; OBS::GetVideoTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ?GetRenderFrameSize@OBS@@QBEXAAI0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_width$ = 8						; size = 4
_height$ = 12						; size = 4
?GetRenderFrameSize@OBS@@QBEXAAI0@Z PROC		; OBS::GetRenderFrameSize, COMDAT
; _this$ = ecx

; 1211 :     inline void GetRenderFrameSize(UINT &width, UINT &height) const         {width = renderFrameWidth; height = renderFrameHeight;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _width$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+636]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _height$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+640]
	mov	DWORD PTR [eax], edx
	mov	esp, ebp
	pop	ebp
	ret	8
?GetRenderFrameSize@OBS@@QBEXAAI0@Z ENDP		; OBS::GetRenderFrameSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ?GetRenderFrameOffset@OBS@@QBEXAAI0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?GetRenderFrameOffset@OBS@@QBEXAAI0@Z PROC		; OBS::GetRenderFrameOffset, COMDAT
; _this$ = ecx

; 1212 :     inline void GetRenderFrameOffset(UINT &x, UINT &y) const                {x = renderFrameX; y = renderFrameY;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+644]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+648]
	mov	DWORD PTR [eax], edx
	mov	esp, ebp
	pop	ebp
	ret	8
?GetRenderFrameOffset@OBS@@QBEXAAI0@Z ENDP		; OBS::GetRenderFrameOffset
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ?GetRenderFrameControlSize@OBS@@QBEXAAI0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_width$ = 8						; size = 4
_height$ = 12						; size = 4
?GetRenderFrameControlSize@OBS@@QBEXAAI0@Z PROC		; OBS::GetRenderFrameControlSize, COMDAT
; _this$ = ecx

; 1213 :     inline void GetRenderFrameControlSize(UINT &width, UINT &height) const  {width = renderFrameCtrlWidth; height = renderFrameCtrlHeight;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _width$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+652]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _height$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+656]
	mov	DWORD PTR [eax], edx
	mov	esp, ebp
	pop	ebp
	ret	8
?GetRenderFrameControlSize@OBS@@QBEXAAI0@Z ENDP		; OBS::GetRenderFrameControlSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ?GetOutputSize@OBS@@QBEXAAI0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_width$ = 8						; size = 4
_height$ = 12						; size = 4
?GetOutputSize@OBS@@QBEXAAI0@Z PROC			; OBS::GetOutputSize, COMDAT
; _this$ = ecx

; 1214 :     inline void GetOutputSize(UINT &width, UINT &height) const              {width = outputCX;         height = outputCY;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _width$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+872]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _height$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+876]
	mov	DWORD PTR [eax], edx
	mov	esp, ebp
	pop	ebp
	ret	8
?GetOutputSize@OBS@@QBEXAAI0@Z ENDP			; OBS::GetOutputSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ?EnterSceneMutex@OBS@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?EnterSceneMutex@OBS@@QAEXXZ PROC			; OBS::EnterSceneMutex, COMDAT
; _this$ = ecx

; 1231 :     inline void EnterSceneMutex() {OSEnterMutex(hSceneMutex);}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+956]
	push	ecx
	call	DWORD PTR __imp_?OSEnterMutex@@YGXPAX@Z
	mov	esp, ebp
	pop	ebp
	ret	0
?EnterSceneMutex@OBS@@QAEXXZ ENDP			; OBS::EnterSceneMutex
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ?LeaveSceneMutex@OBS@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?LeaveSceneMutex@OBS@@QAEXXZ PROC			; OBS::LeaveSceneMutex, COMDAT
; _this$ = ecx

; 1232 :     inline void LeaveSceneMutex() {OSLeaveMutex(hSceneMutex);}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+956]
	push	ecx
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z
	mov	esp, ebp
	pop	ebp
	ret	0
?LeaveSceneMutex@OBS@@QAEXXZ ENDP			; OBS::LeaveSceneMutex
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ?GetSceneElement@OBS@@QBEPAVXElement@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSceneElement@OBS@@QBEPAVXElement@@XZ PROC		; OBS::GetSceneElement, COMDAT
; _this$ = ecx

; 1243 :     inline XElement* GetSceneElement() const {return sceneElement;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+212]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSceneElement@OBS@@QBEPAVXElement@@XZ ENDP		; OBS::GetSceneElement
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ?GetCurrentSceneCollection@OBS@@SAPB_WXZ
_TEXT	SEGMENT
?GetCurrentSceneCollection@OBS@@SAPB_WXZ PROC		; OBS::GetCurrentSceneCollection, COMDAT

; 1268 :     inline static CTSTR GetCurrentSceneCollection() { return GlobalConfig->GetStringPtr(TEXT("General"), TEXT("SceneCollection")); }

	push	ebp
	mov	ebp, esp
	push	0
	push	OFFSET ??_C@_1CA@DHAOPEIL@?$AAS?$AAc?$AAe?$AAn?$AAe?$AAC?$AAo?$AAl?$AAl?$AAe?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$AA@
	push	OFFSET ??_C@_1BA@GCDNCJOK@?$AAG?$AAe?$AAn?$AAe?$AAr?$AAa?$AAl?$AA?$AA@
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?GetStringPtr@ConfigFile@@QAEPB_WPB_W00@Z
	pop	ebp
	ret	0
?GetCurrentSceneCollection@OBS@@SAPB_WXZ ENDP		; OBS::GetCurrentSceneCollection
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?RegisterSceneClass@OBS@@UAEXPB_W0P6GPAXPAVXElement@@@ZP6G_N1_N@Z3@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_classInfo$ = -4					; size = 4
_lpClassName$ = 8					; size = 4
_lpDisplayName$ = 12					; size = 4
_createProc$ = 16					; size = 4
_configProc$ = 20					; size = 4
_bDeprecated$ = 24					; size = 1
?RegisterSceneClass@OBS@@UAEXPB_W0P6GPAXPAVXElement@@@ZP6G_N1_N@Z3@Z PROC ; OBS::RegisterSceneClass, COMDAT
; _this$ = ecx

; 28   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 29   :     if(!lpClassName || !*lpClassName)

	cmp	DWORD PTR _lpClassName$[ebp], 0
	je	SHORT $LN3@RegisterSc
	mov	eax, DWORD PTR _lpClassName$[ebp]
	movzx	ecx, WORD PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN4@RegisterSc
$LN3@RegisterSc:

; 30   :     {
; 31   :         AppWarning(TEXT("OBS::RegisterSceneClass: No class name specified"));

	push	OFFSET $SG4294966871
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 4

; 32   :         return;

	jmp	$LN5@RegisterSc
$LN4@RegisterSc:

; 33   :     }
; 34   : 
; 35   :     if(!createProc)

	cmp	DWORD PTR _createProc$[ebp], 0
	jne	SHORT $LN2@RegisterSc

; 36   :     {
; 37   :         AppWarning(TEXT("OBS::RegisterSceneClass: No create procedure specified"));

	push	OFFSET $SG4294966870
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 4

; 38   :         return;

	jmp	SHORT $LN5@RegisterSc
$LN2@RegisterSc:

; 39   :     }
; 40   : 
; 41   :     if(GetSceneClass(lpClassName))

	mov	edx, DWORD PTR _lpClassName$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSceneClass@OBS@@ABEPAUClassInfo@@PB_W@Z ; OBS::GetSceneClass
	test	eax, eax
	je	SHORT $LN1@RegisterSc

; 42   :     {
; 43   :         AppWarning(TEXT("OBS::RegisterSceneClass: Tried to register '%s', but it already exists"), lpClassName);

	mov	eax, DWORD PTR _lpClassName$[ebp]
	push	eax
	push	OFFSET $SG4294966869
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 8

; 44   :         return;

	jmp	SHORT $LN5@RegisterSc
$LN1@RegisterSc:

; 45   :     }
; 46   : 
; 47   :     ClassInfo *classInfo   = sceneClasses.CreateNew();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1360				; 00000550H
	call	?CreateNew@?$List@UClassInfo@@@@QAEPAUClassInfo@@XZ ; List<ClassInfo>::CreateNew
	mov	DWORD PTR _classInfo$[ebp], eax

; 48   :     classInfo->strClass    = lpClassName;

	mov	ecx, DWORD PTR _lpClassName$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _classInfo$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z

; 49   :     classInfo->strName     = lpDisplayName;

	mov	edx, DWORD PTR _lpDisplayName$[ebp]
	push	edx
	mov	ecx, DWORD PTR _classInfo$[ebp]
	add	ecx, 8
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z

; 50   :     classInfo->createProc  = createProc;

	mov	eax, DWORD PTR _classInfo$[ebp]
	mov	ecx, DWORD PTR _createProc$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 51   :     classInfo->configProc  = configProc;

	mov	edx, DWORD PTR _classInfo$[ebp]
	mov	eax, DWORD PTR _configProc$[ebp]
	mov	DWORD PTR [edx+20], eax

; 52   :     classInfo->bDeprecated = bDeprecated;

	mov	ecx, DWORD PTR _classInfo$[ebp]
	mov	dl, BYTE PTR _bDeprecated$[ebp]
	mov	BYTE PTR [ecx+24], dl
$LN5@RegisterSc:

; 53   : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?RegisterSceneClass@OBS@@UAEXPB_W0P6GPAXPAVXElement@@@ZP6G_N1_N@Z3@Z ENDP ; OBS::RegisterSceneClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?RegisterImageSourceClass@OBS@@UAEXPB_W0P6GPAXPAVXElement@@@ZP6G_N1_N@Z3@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_classInfo$ = -4					; size = 4
_lpClassName$ = 8					; size = 4
_lpDisplayName$ = 12					; size = 4
_createProc$ = 16					; size = 4
_configProc$ = 20					; size = 4
_bDeprecated$ = 24					; size = 1
?RegisterImageSourceClass@OBS@@UAEXPB_W0P6GPAXPAVXElement@@@ZP6G_N1_N@Z3@Z PROC ; OBS::RegisterImageSourceClass, COMDAT
; _this$ = ecx

; 56   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 57   :     if(!lpClassName || !*lpClassName)

	cmp	DWORD PTR _lpClassName$[ebp], 0
	je	SHORT $LN3@RegisterIm
	mov	eax, DWORD PTR _lpClassName$[ebp]
	movzx	ecx, WORD PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN4@RegisterIm
$LN3@RegisterIm:

; 58   :     {
; 59   :         AppWarning(TEXT("OBS::RegisterImageSourceClass: No class name specified"));

	push	OFFSET $SG4294966868
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 4

; 60   :         return;

	jmp	$LN5@RegisterIm
$LN4@RegisterIm:

; 61   :     }
; 62   : 
; 63   :     if(!createProc)

	cmp	DWORD PTR _createProc$[ebp], 0
	jne	SHORT $LN2@RegisterIm

; 64   :     {
; 65   :         AppWarning(TEXT("OBS::RegisterImageSourceClass: No create procedure specified"));

	push	OFFSET $SG4294966867
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 4

; 66   :         return;

	jmp	SHORT $LN5@RegisterIm
$LN2@RegisterIm:

; 67   :     }
; 68   : 
; 69   :     if(GetImageSourceClass(lpClassName))

	mov	edx, DWORD PTR _lpClassName$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetImageSourceClass@OBS@@ABEPAUClassInfo@@PB_W@Z ; OBS::GetImageSourceClass
	test	eax, eax
	je	SHORT $LN1@RegisterIm

; 70   :     {
; 71   :         AppWarning(TEXT("OBS::RegisterImageSourceClass: Tried to register '%s', but it already exists"), lpClassName);

	mov	eax, DWORD PTR _lpClassName$[ebp]
	push	eax
	push	OFFSET $SG4294966866
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 8

; 72   :         return;

	jmp	SHORT $LN5@RegisterIm
$LN1@RegisterIm:

; 73   :     }
; 74   : 
; 75   :     ClassInfo *classInfo   = imageSourceClasses.CreateNew();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1368				; 00000558H
	call	?CreateNew@?$List@UClassInfo@@@@QAEPAUClassInfo@@XZ ; List<ClassInfo>::CreateNew
	mov	DWORD PTR _classInfo$[ebp], eax

; 76   :     classInfo->strClass    = lpClassName;

	mov	ecx, DWORD PTR _lpClassName$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _classInfo$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z

; 77   :     classInfo->strName     = lpDisplayName;

	mov	edx, DWORD PTR _lpDisplayName$[ebp]
	push	edx
	mov	ecx, DWORD PTR _classInfo$[ebp]
	add	ecx, 8
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z

; 78   :     classInfo->createProc  = createProc;

	mov	eax, DWORD PTR _classInfo$[ebp]
	mov	ecx, DWORD PTR _createProc$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 79   :     classInfo->configProc  = configProc;

	mov	edx, DWORD PTR _classInfo$[ebp]
	mov	eax, DWORD PTR _configProc$[ebp]
	mov	DWORD PTR [edx+20], eax

; 80   :     classInfo->bDeprecated = bDeprecated;

	mov	ecx, DWORD PTR _classInfo$[ebp]
	mov	dl, BYTE PTR _bDeprecated$[ebp]
	mov	BYTE PTR [ecx+24], dl
$LN5@RegisterIm:

; 81   : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?RegisterImageSourceClass@OBS@@UAEXPB_W0P6GPAXPAVXElement@@@ZP6G_N1_N@Z3@Z ENDP ; OBS::RegisterImageSourceClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?CreateScene@OBS@@AAEPAVScene@@PB_WPAVXElement@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
_lpClassName$ = 8					; size = 4
_data$ = 12						; size = 4
?CreateScene@OBS@@AAEPAVScene@@PB_WPAVXElement@@@Z PROC	; OBS::CreateScene, COMDAT
; _this$ = ecx

; 84   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 85   :     for(UINT i=0; i<sceneClasses.Num(); i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@CreateScen
$LN3@CreateScen:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@CreateScen:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1360				; 00000550H
	call	?Num@?$List@UClassInfo@@@@QBEIXZ	; List<ClassInfo>::Num
	cmp	DWORD PTR _i$1[ebp], eax
	jae	SHORT $LN2@CreateScen

; 86   :     {
; 87   :         if(sceneClasses[i].strClass.CompareI(lpClassName))

	mov	ecx, DWORD PTR _lpClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1360				; 00000550H
	call	??A?$List@UClassInfo@@@@QAEAAUClassInfo@@I@Z ; List<ClassInfo>::operator[]
	mov	ecx, eax
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN1@CreateScen

; 88   :             return (Scene*)sceneClasses[i].createProc(data);

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1360				; 00000550H
	call	??A?$List@UClassInfo@@@@QAEAAUClassInfo@@I@Z ; List<ClassInfo>::operator[]
	mov	edx, DWORD PTR [eax+16]
	call	edx
	jmp	SHORT $LN5@CreateScen
$LN1@CreateScen:

; 89   :     }

	jmp	SHORT $LN3@CreateScen
$LN2@CreateScen:

; 90   : 
; 91   :     AppWarning(TEXT("OBS::CreateScene: Could not find scene class '%s'"), lpClassName);

	mov	eax, DWORD PTR _lpClassName$[ebp]
	push	eax
	push	OFFSET $SG4294966865
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 8

; 92   :     return NULL;

	xor	eax, eax
$LN5@CreateScen:

; 93   : }

	mov	esp, ebp
	pop	ebp
	ret	8
?CreateScene@OBS@@AAEPAVScene@@PB_WPAVXElement@@@Z ENDP	; OBS::CreateScene
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?CreateImageSource@OBS@@UAEPAVImageSource@@PB_WPAVXElement@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
_lpClassName$ = 8					; size = 4
_data$ = 12						; size = 4
?CreateImageSource@OBS@@UAEPAVImageSource@@PB_WPAVXElement@@@Z PROC ; OBS::CreateImageSource, COMDAT
; _this$ = ecx

; 96   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 97   :     for(UINT i=0; i<imageSourceClasses.Num(); i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@CreateImag
$LN3@CreateImag:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@CreateImag:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1368				; 00000558H
	call	?Num@?$List@UClassInfo@@@@QBEIXZ	; List<ClassInfo>::Num
	cmp	DWORD PTR _i$1[ebp], eax
	jae	SHORT $LN2@CreateImag

; 98   :     {
; 99   :         if(imageSourceClasses[i].strClass.CompareI(lpClassName))

	mov	ecx, DWORD PTR _lpClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1368				; 00000558H
	call	??A?$List@UClassInfo@@@@QAEAAUClassInfo@@I@Z ; List<ClassInfo>::operator[]
	mov	ecx, eax
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN1@CreateImag

; 100  :             return (ImageSource*)imageSourceClasses[i].createProc(data);

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1368				; 00000558H
	call	??A?$List@UClassInfo@@@@QAEAAUClassInfo@@I@Z ; List<ClassInfo>::operator[]
	mov	edx, DWORD PTR [eax+16]
	call	edx
	jmp	SHORT $LN5@CreateImag
$LN1@CreateImag:

; 101  :     }

	jmp	SHORT $LN3@CreateImag
$LN2@CreateImag:

; 102  : 
; 103  :     AppWarning(TEXT("OBS::CreateImageSource: Could not find image source class '%s'"), lpClassName);

	mov	eax, DWORD PTR _lpClassName$[ebp]
	push	eax
	push	OFFSET $SG4294966864
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 8

; 104  :     return NULL;

	xor	eax, eax
$LN5@CreateImag:

; 105  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?CreateImageSource@OBS@@UAEPAVImageSource@@PB_WPAVXElement@@@Z ENDP ; OBS::CreateImageSource
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?InsertSourceItem@OBS@@UAEXIPA_W_N@Z
_TEXT	SEGMENT
__macro_lvi$1 = -132					; size = 60
_lvI$ = -72						; size = 60
_this$ = -12						; size = 4
tv73 = -8						; size = 4
_hwndSources$ = -4					; size = 4
_index$ = 8						; size = 4
_name$ = 12						; size = 4
_checked$ = 16						; size = 1
?InsertSourceItem@OBS@@UAEXIPA_W_N@Z PROC		; OBS::InsertSourceItem, COMDAT
; _this$ = ecx

; 164  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	mov	DWORD PTR _this$[ebp], ecx

; 165  :     LVITEM lvI;
; 166  :     // Initialize LVITEM members that are common to all items.
; 167  :     lvI.mask      = LVIF_TEXT | LVIF_IMAGE | LVIF_STATE;

	mov	DWORD PTR _lvI$[ebp], 11		; 0000000bH

; 168  :     lvI.stateMask = 0;

	mov	DWORD PTR _lvI$[ebp+16], 0

; 169  :     lvI.iSubItem  = 0;

	mov	DWORD PTR _lvI$[ebp+8], 0

; 170  :     lvI.state     = 0;

	mov	DWORD PTR _lvI$[ebp+12], 0

; 171  :     lvI.pszText = name;

	mov	eax, DWORD PTR _name$[ebp]
	mov	DWORD PTR _lvI$[ebp+20], eax

; 172  :     lvI.iItem = index;

	mov	ecx, DWORD PTR _index$[ebp]
	mov	DWORD PTR _lvI$[ebp+4], ecx

; 173  : 
; 174  : 
; 175  :     HWND hwndSources = GetDlgItem(hwndMain, ID_SOURCES);

	push	5013					; 00001395H
	mov	edx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	edx
	call	DWORD PTR __imp__GetDlgItem@8
	mov	DWORD PTR _hwndSources$[ebp], eax

; 176  : 
; 177  :     ListView_InsertItem(hwndSources, &lvI);

	lea	eax, DWORD PTR _lvI$[ebp]
	push	eax
	push	0
	push	4173					; 0000104dH
	mov	ecx, DWORD PTR _hwndSources$[ebp]
	push	ecx
	call	DWORD PTR __imp__SendMessageW@16

; 178  :     ListView_SetCheckState(hwndSources, index, checked);   

	mov	DWORD PTR __macro_lvi$1[ebp+16], 61440	; 0000f000H
	movzx	edx, BYTE PTR _checked$[ebp]
	test	edx, edx
	je	SHORT $LN3@InsertSour
	mov	DWORD PTR tv73[ebp], 2
	jmp	SHORT $LN4@InsertSour
$LN3@InsertSour:
	mov	DWORD PTR tv73[ebp], 1
$LN4@InsertSour:
	mov	eax, DWORD PTR tv73[ebp]
	shl	eax, 12					; 0000000cH
	mov	DWORD PTR __macro_lvi$1[ebp+12], eax
	lea	ecx, DWORD PTR __macro_lvi$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	push	4139					; 0000102bH
	mov	eax, DWORD PTR _hwndSources$[ebp]
	push	eax
	call	DWORD PTR __imp__SendMessageW@16

; 179  :     ListView_SetColumnWidth(hwndSources, 0, LVSCW_AUTOSIZE_USEHEADER);

	push	65534					; 0000fffeH
	push	0
	push	4126					; 0000101eH
	mov	ecx, DWORD PTR _hwndSources$[ebp]
	push	ecx
	call	DWORD PTR __imp__SendMessageW@16

; 180  :     ListView_SetColumnWidth(hwndSources, 1, LVSCW_AUTOSIZE_USEHEADER);

	push	65534					; 0000fffeH
	push	1
	push	4126					; 0000101eH
	mov	edx, DWORD PTR _hwndSources$[ebp]
	push	edx
	call	DWORD PTR __imp__SendMessageW@16

; 181  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?InsertSourceItem@OBS@@UAEXIPA_W_N@Z ENDP		; OBS::InsertSourceItem
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?SetScene@OBS@@UAE_NPB_W@Z
_TEXT	SEGMENT
_className$1 = -264					; size = 8
$T2 = -256						; size = 8
$T3 = -248						; size = 8
_className$4 = -240					; size = 8
_className$5 = -232					; size = 8
$T6 = -224						; size = 8
$T7 = -216						; size = 4
_textLen$8 = -212					; size = 4
_sourceElement$9 = -208					; size = 4
_sourceElement$10 = -204				; size = 4
tv421 = -200						; size = 4
_globalSourceData$11 = -196				; size = 4
_globalSourceName$12 = -192				; size = 8
_numSources$13 = -184					; size = 4
_globalSourceName$14 = -180				; size = 8
$T15 = -172						; size = 4
_scenes$ = -168						; size = 4
$T16 = -164						; size = 4
_sceneChangeStartTime$ = -160				; size = 4
_sceneData$ = -156					; size = 4
tv527 = -152						; size = 4
_globalSourceData$17 = -148				; size = 4
_id$18 = -144						; size = 4
tv250 = -140						; size = 4
_sceneChangeTime$19 = -136				; size = 4
_id$20 = -132						; size = 4
_previousScene$21 = -128				; size = 4
_lpClass$ = -124					; size = 4
tv507 = -120						; size = 4
tv341 = -116						; size = 4
_source$22 = -112					; size = 4
tv205 = -108						; size = 4
tv480 = -104						; size = 4
_strLBName$23 = -100					; size = 8
tv400 = -92						; size = 4
_source$24 = -88					; size = 4
$T25 = -84						; size = 4
_curSel$ = -80						; size = 4
_numSources$26 = -76					; size = 4
_numSources$27 = -72					; size = 4
$T28 = -68						; size = 4
_sourceElement$29 = -64					; size = 4
_i$30 = -60						; size = 4
_i$31 = -56						; size = 4
_i$32 = -52						; size = 4
_newSceneElement$ = -48					; size = 4
_i$33 = -44						; size = 4
_hwndSources$ = -40					; size = 4
_i$34 = -36						; size = 4
_sources$ = -32						; size = 4
$T35 = -25						; size = 1
_hwndScenes$ = -24					; size = 4
_render$36 = -19					; size = 1
$T37 = -18						; size = 1
$T38 = -17						; size = 1
$T39 = -16						; size = 4
_newScene$ = -12					; size = 4
_bSkipTransition$ = -5					; size = 1
_this$ = -4						; size = 4
_lpScene$ = 8						; size = 4
?SetScene@OBS@@UAE_NPB_W@Z PROC				; OBS::SetScene, COMDAT
; _this$ = ecx

; 184  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T39[ebp], 0

; 185  :     if(bDisableSceneSwitching)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+704]
	test	ecx, ecx
	je	SHORT $LN43@SetScene

; 186  :         return false;

	xor	al, al
	jmp	$LN44@SetScene
$LN43@SetScene:

; 187  : 
; 188  :     HWND hwndScenes = GetDlgItem(hwndMain, ID_SCENES);

	push	5011					; 00001393H
	mov	edx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	edx
	call	DWORD PTR __imp__GetDlgItem@8
	mov	DWORD PTR _hwndScenes$[ebp], eax

; 189  :     UINT curSel = (UINT)SendMessage(hwndScenes, LB_GETCURSEL, 0, 0);

	push	0
	push	0
	push	392					; 00000188H
	mov	eax, DWORD PTR _hwndScenes$[ebp]
	push	eax
	call	DWORD PTR __imp__SendMessageW@16
	mov	DWORD PTR _curSel$[ebp], eax

; 190  : 
; 191  :     //-------------------------
; 192  : 
; 193  :     if(curSel != LB_ERR)

	cmp	DWORD PTR _curSel$[ebp], -1
	je	$LN42@SetScene

; 194  :     {
; 195  :         UINT textLen = (UINT)SendMessage(hwndScenes, LB_GETTEXTLEN, curSel, 0);

	push	0
	mov	ecx, DWORD PTR _curSel$[ebp]
	push	ecx
	push	394					; 0000018aH
	mov	edx, DWORD PTR _hwndScenes$[ebp]
	push	edx
	call	DWORD PTR __imp__SendMessageW@16
	mov	DWORD PTR _textLen$8[ebp], eax

; 196  : 
; 197  :         String strLBName;

	lea	ecx, DWORD PTR _strLBName$23[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 198  :         strLBName.SetLength(textLen);

	mov	eax, DWORD PTR _textLen$8[ebp]
	push	eax
	lea	ecx, DWORD PTR _strLBName$23[ebp]
	call	DWORD PTR __imp_?SetLength@String@@QAEAAV1@I@Z

; 199  : 
; 200  :         SendMessage(hwndScenes, LB_GETTEXT, curSel, (LPARAM)strLBName.Array());

	lea	ecx, DWORD PTR _strLBName$23[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	mov	ecx, DWORD PTR _curSel$[ebp]
	push	ecx
	push	393					; 00000189H
	mov	edx, DWORD PTR _hwndScenes$[ebp]
	push	edx
	call	DWORD PTR __imp__SendMessageW@16

; 201  :         if(!strLBName.CompareI(lpScene))

	mov	eax, DWORD PTR _lpScene$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strLBName$23[ebp]
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	test	eax, eax
	jne	SHORT $LN41@SetScene

; 202  :         {
; 203  :             UINT id = (UINT)SendMessage(hwndScenes, LB_FINDSTRINGEXACT, -1, (LPARAM)lpScene);

	mov	ecx, DWORD PTR _lpScene$[ebp]
	push	ecx
	push	-1
	push	418					; 000001a2H
	mov	edx, DWORD PTR _hwndScenes$[ebp]
	push	edx
	call	DWORD PTR __imp__SendMessageW@16
	mov	DWORD PTR _id$20[ebp], eax

; 204  :             if(id == LB_ERR)

	cmp	DWORD PTR _id$20[ebp], -1
	jne	SHORT $LN40@SetScene

; 205  :                 return false;

	mov	BYTE PTR $T37[ebp], 0
	lea	ecx, DWORD PTR _strLBName$23[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	al, BYTE PTR $T37[ebp]
	jmp	$LN44@SetScene
$LN40@SetScene:

; 206  : 
; 207  :             SendMessage(hwndScenes, LB_SETCURSEL, id, 0);

	push	0
	mov	eax, DWORD PTR _id$20[ebp]
	push	eax
	push	390					; 00000186H
	mov	ecx, DWORD PTR _hwndScenes$[ebp]
	push	ecx
	call	DWORD PTR __imp__SendMessageW@16
$LN41@SetScene:

; 208  :         }
; 209  :     }

	lea	ecx, DWORD PTR _strLBName$23[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 210  :     else

	jmp	SHORT $LN39@SetScene
$LN42@SetScene:

; 211  :     {
; 212  :         UINT id = (UINT)SendMessage(hwndScenes, LB_FINDSTRINGEXACT, -1, (LPARAM)lpScene);

	mov	edx, DWORD PTR _lpScene$[ebp]
	push	edx
	push	-1
	push	418					; 000001a2H
	mov	eax, DWORD PTR _hwndScenes$[ebp]
	push	eax
	call	DWORD PTR __imp__SendMessageW@16
	mov	DWORD PTR _id$18[ebp], eax

; 213  :         if(id == LB_ERR)

	cmp	DWORD PTR _id$18[ebp], -1
	jne	SHORT $LN38@SetScene

; 214  :             return false;

	xor	al, al
	jmp	$LN44@SetScene
$LN38@SetScene:

; 215  : 
; 216  :         SendMessage(hwndScenes, LB_SETCURSEL, id, 0);

	push	0
	mov	ecx, DWORD PTR _id$18[ebp]
	push	ecx
	push	390					; 00000186H
	mov	edx, DWORD PTR _hwndScenes$[ebp]
	push	edx
	call	DWORD PTR __imp__SendMessageW@16
$LN39@SetScene:

; 217  :     }
; 218  : 
; 219  :     //-------------------------
; 220  : 
; 221  :     XElement *scenes = scenesConfig.GetElement(TEXT("scenes"));

	push	OFFSET $SG4294966855
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 168				; 000000a8H
	call	DWORD PTR __imp_?GetElement@XConfig@@QAEPAVXElement@@PB_W@Z
	mov	DWORD PTR _scenes$[ebp], eax

; 222  :     XElement *newSceneElement = scenes->GetElement(lpScene);

	mov	eax, DWORD PTR _lpScene$[ebp]
	push	eax
	mov	ecx, DWORD PTR _scenes$[ebp]
	call	DWORD PTR __imp_?GetElement@XElement@@QBEPAV1@PB_W@Z
	mov	DWORD PTR _newSceneElement$[ebp], eax

; 223  :     if(!newSceneElement)

	cmp	DWORD PTR _newSceneElement$[ebp], 0
	jne	SHORT $LN37@SetScene

; 224  :         return false;

	xor	al, al
	jmp	$LN44@SetScene
$LN37@SetScene:

; 225  : 
; 226  :     if(sceneElement == newSceneElement)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+212]
	cmp	edx, DWORD PTR _newSceneElement$[ebp]
	jne	SHORT $LN36@SetScene

; 227  :         return true;

	mov	al, 1
	jmp	$LN44@SetScene
$LN36@SetScene:

; 228  : 
; 229  :     sceneElement = newSceneElement;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newSceneElement$[ebp]
	mov	DWORD PTR [eax+212], ecx

; 230  : 
; 231  :     CTSTR lpClass = sceneElement->GetString(TEXT("class"));

	push	0
	push	OFFSET $SG4294966854
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+212]
	call	DWORD PTR __imp_?GetString@XElement@@QBEPB_WPB_WPA_W@Z
	mov	DWORD PTR _lpClass$[ebp], eax

; 232  :     if(!lpClass)

	cmp	DWORD PTR _lpClass$[ebp], 0
	jne	SHORT $LN35@SetScene

; 233  :     {
; 234  :         AppWarning(TEXT("OBS::SetScene: no class found for scene '%s'"), newSceneElement->GetName());

	mov	ecx, DWORD PTR _newSceneElement$[ebp]
	call	DWORD PTR __imp_?GetName@XBaseItem@@QBEPB_WXZ
	push	eax
	push	OFFSET $SG4294966853
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 8

; 235  :         return false;

	xor	al, al
	jmp	$LN44@SetScene
$LN35@SetScene:

; 236  :     }
; 237  : 
; 238  :     DWORD sceneChangeStartTime;
; 239  : 
; 240  :     if(bRunning)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+622]
	test	ecx, ecx
	je	SHORT $LN34@SetScene

; 241  :     {
; 242  :         Log(TEXT("++++++++++++++++++++++++++++++++++++++++++++++++++++++"));

	push	OFFSET $SG4294966852
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 4

; 243  :         Log(TEXT("  New Scene"));

	push	OFFSET $SG4294966851
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 4

; 244  : 
; 245  :         sceneChangeStartTime = OSGetTime();

	call	DWORD PTR __imp_?OSGetTime@@YGKXZ
	mov	DWORD PTR _sceneChangeStartTime$[ebp], eax
$LN34@SetScene:

; 246  :     }
; 247  : 
; 248  :     XElement *sceneData = newSceneElement->GetElement(TEXT("data"));

	push	OFFSET $SG4294966850
	mov	ecx, DWORD PTR _newSceneElement$[ebp]
	call	DWORD PTR __imp_?GetElement@XElement@@QBEPAV1@PB_W@Z
	mov	DWORD PTR _sceneData$[ebp], eax

; 249  : 
; 250  :     //-------------------------
; 251  : 
; 252  :     Scene *newScene = NULL;

	mov	DWORD PTR _newScene$[ebp], 0

; 253  :     if(bRunning)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+622]
	test	eax, eax
	je	SHORT $LN33@SetScene

; 254  :         newScene = CreateScene(lpClass, sceneData);

	mov	ecx, DWORD PTR _sceneData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpClass$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CreateScene@OBS@@AAEPAVScene@@PB_WPAVXElement@@@Z ; OBS::CreateScene
	mov	DWORD PTR _newScene$[ebp], eax
$LN33@SetScene:

; 255  : 
; 256  :     //-------------------------
; 257  : 
; 258  :     HWND hwndSources = GetDlgItem(hwndMain, ID_SOURCES);

	push	5013					; 00001395H
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	call	DWORD PTR __imp__GetDlgItem@8
	mov	DWORD PTR _hwndSources$[ebp], eax

; 259  : 
; 260  :     SendMessage(hwndSources, WM_SETREDRAW, (WPARAM)FALSE, (LPARAM) 0);

	push	0
	push	0
	push	11					; 0000000bH
	mov	ecx, DWORD PTR _hwndSources$[ebp]
	push	ecx
	call	DWORD PTR __imp__SendMessageW@16

; 261  : 
; 262  :     App->scaleItem = NULL;

	mov	edx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	DWORD PTR [edx+772], 0

; 263  : 
; 264  :     bChangingSources = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+705], 1

; 265  :     ListView_DeleteAllItems(hwndSources);

	push	0
	push	0
	push	4105					; 00001009H
	mov	ecx, DWORD PTR _hwndSources$[ebp]
	push	ecx
	call	DWORD PTR __imp__SendMessageW@16

; 266  : 
; 267  :     bool bSkipTransition = !performTransition;

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+44]
	test	eax, eax
	jne	SHORT $LN46@SetScene
	mov	DWORD PTR tv205[ebp], 1
	jmp	SHORT $LN47@SetScene
$LN46@SetScene:
	mov	DWORD PTR tv205[ebp], 0
$LN47@SetScene:
	mov	cl, BYTE PTR tv205[ebp]
	mov	BYTE PTR _bSkipTransition$[ebp], cl

; 268  : 
; 269  :     XElement *sources = sceneElement->GetElement(TEXT("sources"));

	push	OFFSET $SG4294966849
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+212]
	call	DWORD PTR __imp_?GetElement@XElement@@QBEPAV1@PB_W@Z
	mov	DWORD PTR _sources$[ebp], eax

; 270  :     if(sources)

	cmp	DWORD PTR _sources$[ebp], 0
	je	$LN25@SetScene

; 271  :     {
; 272  :         UINT numSources = sources->NumElements();

	push	0
	mov	ecx, DWORD PTR _sources$[ebp]
	call	DWORD PTR __imp_?NumElements@XElement@@QAEKPB_W@Z
	mov	DWORD PTR _numSources$27[ebp], eax

; 273  :         ListView_SetItemCount(hwndSources, numSources);

	push	0
	mov	eax, DWORD PTR _numSources$27[ebp]
	push	eax
	push	4143					; 0000102fH
	mov	ecx, DWORD PTR _hwndSources$[ebp]
	push	ecx
	call	DWORD PTR __imp__SendMessageW@16

; 274  : 
; 275  :         for(UINT i=0; i<numSources; i++)

	mov	DWORD PTR _i$30[ebp], 0
	jmp	SHORT $LN31@SetScene
$LN30@SetScene:
	mov	edx, DWORD PTR _i$30[ebp]
	add	edx, 1
	mov	DWORD PTR _i$30[ebp], edx
$LN31@SetScene:
	mov	eax, DWORD PTR _i$30[ebp]
	cmp	eax, DWORD PTR _numSources$27[ebp]
	jae	$LN29@SetScene

; 276  :         {
; 277  :             XElement *sourceElement = sources->GetElementByID(i);

	mov	ecx, DWORD PTR _i$30[ebp]
	push	ecx
	mov	ecx, DWORD PTR _sources$[ebp]
	call	DWORD PTR __imp_?GetElementByID@XElement@@QBEPAV1@K@Z
	mov	DWORD PTR _sourceElement$10[ebp], eax

; 278  :             String className = sourceElement->GetString(TEXT("class"));

	push	0
	push	OFFSET $SG4294966848
	mov	ecx, DWORD PTR _sourceElement$10[ebp]
	call	DWORD PTR __imp_?GetString@XElement@@QBEPB_WPB_WPA_W@Z
	push	eax
	lea	ecx, DWORD PTR _className$4[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PB_W@Z

; 279  : 
; 280  :             if(className == "DeviceCapture") {

	push	OFFSET $SG4294966847
	lea	ecx, DWORD PTR $T6[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PBD@Z
	lea	edx, DWORD PTR $T6[ebp]
	push	edx
	lea	ecx, DWORD PTR _className$4[ebp]
	call	DWORD PTR __imp_??8String@@QBEHABV0@@Z
	mov	DWORD PTR $T16[ebp], eax
	lea	ecx, DWORD PTR $T6[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	cmp	DWORD PTR $T16[ebp], 0
	je	SHORT $LN28@SetScene

; 281  :                 // There's a capture device in the next scene that isn't a global source,
; 282  :                 // so let's skip the transition since it won't work anyway.
; 283  :                 bSkipTransition = true;

	mov	BYTE PTR _bSkipTransition$[ebp], 1
$LN28@SetScene:

; 284  :             }
; 285  :         }

	lea	ecx, DWORD PTR _className$4[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	jmp	$LN30@SetScene
$LN29@SetScene:

; 286  : 
; 287  :         for(UINT i=0; i<numSources; i++)

	mov	DWORD PTR _i$34[ebp], 0
	jmp	SHORT $LN27@SetScene
$LN26@SetScene:
	mov	eax, DWORD PTR _i$34[ebp]
	add	eax, 1
	mov	DWORD PTR _i$34[ebp], eax
$LN27@SetScene:
	mov	ecx, DWORD PTR _i$34[ebp]
	cmp	ecx, DWORD PTR _numSources$27[ebp]
	jae	$LN25@SetScene

; 288  :         {
; 289  :             XElement *sourceElement = sources->GetElementByID(i);

	mov	edx, DWORD PTR _i$34[ebp]
	push	edx
	mov	ecx, DWORD PTR _sources$[ebp]
	call	DWORD PTR __imp_?GetElementByID@XElement@@QBEPAV1@K@Z
	mov	DWORD PTR _sourceElement$29[ebp], eax

; 290  :             bool render = sourceElement->GetInt(TEXT("render"), 1) > 0;

	push	1
	push	OFFSET $SG4294966846
	mov	ecx, DWORD PTR _sourceElement$29[ebp]
	call	DWORD PTR __imp_?GetInt@XElement@@QBEHPB_WH@Z
	test	eax, eax
	jle	SHORT $LN48@SetScene
	mov	DWORD PTR tv250[ebp], 1
	jmp	SHORT $LN49@SetScene
$LN48@SetScene:
	mov	DWORD PTR tv250[ebp], 0
$LN49@SetScene:
	mov	al, BYTE PTR tv250[ebp]
	mov	BYTE PTR _render$36[ebp], al

; 291  : 
; 292  :             InsertSourceItem(i, (LPWSTR)sourceElement->GetName(), render);

	movzx	ecx, BYTE PTR _render$36[ebp]
	push	ecx
	mov	ecx, DWORD PTR _sourceElement$29[ebp]
	call	DWORD PTR __imp_?GetName@XBaseItem@@QBEPB_WXZ
	push	eax
	mov	edx, DWORD PTR _i$34[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	call	eax

; 293  : 
; 294  :             // Do not add image sources yet in case we're skipping the transition.
; 295  :             // This fixes the issue where capture devices sources that used the
; 296  :             // same device as one in the previous scene would just go blank
; 297  :             // after switching.
; 298  :             if(bRunning && newScene && !bSkipTransition)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+622]
	test	edx, edx
	je	SHORT $LN24@SetScene
	cmp	DWORD PTR _newScene$[ebp], 0
	je	SHORT $LN24@SetScene
	movzx	eax, BYTE PTR _bSkipTransition$[ebp]
	test	eax, eax
	jne	SHORT $LN24@SetScene

; 299  :                 newScene->AddImageSource(sourceElement);

	mov	ecx, DWORD PTR _sourceElement$29[ebp]
	push	ecx
	mov	edx, DWORD PTR _newScene$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _newScene$[ebp]
	mov	edx, DWORD PTR [eax+8]
	call	edx
$LN24@SetScene:

; 300  :         }

	jmp	$LN26@SetScene
$LN25@SetScene:

; 301  :     }
; 302  : 
; 303  :     bChangingSources = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+705], 0

; 304  :     SendMessage(hwndSources, WM_SETREDRAW, (WPARAM)TRUE, (LPARAM) 0);

	push	0
	push	1
	push	11					; 0000000bH
	mov	ecx, DWORD PTR _hwndSources$[ebp]
	push	ecx
	call	DWORD PTR __imp__SendMessageW@16

; 305  :     RedrawWindow(hwndSources, NULL, NULL, RDW_ERASE | RDW_FRAME | RDW_INVALIDATE | RDW_ALLCHILDREN);

	push	1157					; 00000485H
	push	0
	push	0
	mov	edx, DWORD PTR _hwndSources$[ebp]
	push	edx
	call	DWORD PTR __imp__RedrawWindow@16

; 306  : 
; 307  :     if(scene && newScene && newScene->HasMissingSources())

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+144], 0
	je	SHORT $LN23@SetScene
	cmp	DWORD PTR _newScene$[ebp], 0
	je	SHORT $LN23@SetScene
	mov	ecx, DWORD PTR _newScene$[ebp]
	call	DWORD PTR __imp_?HasMissingSources@Scene@@QBE_NXZ
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN23@SetScene

; 308  :         OBSMessageBox(hwndMain, Str("Scene.MissingSources"), NULL, 0);

	push	0
	push	0
	push	OFFSET $SG4294966845
	mov	edx, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [edx]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	call	DWORD PTR __imp_?OBSMessageBox@@YAHPAUHWND__@@PB_W1I@Z
	add	esp, 16					; 00000010H
$LN23@SetScene:

; 309  : 
; 310  :     if(bRunning)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+622]
	test	edx, edx
	je	$LN2@SetScene

; 311  :     {
; 312  :         //todo: cache scenes maybe?  undecided.  not really as necessary with global sources
; 313  :         OSEnterMutex(hSceneMutex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+956]
	push	ecx
	call	DWORD PTR __imp_?OSEnterMutex@@YGXPAX@Z

; 314  : 
; 315  :         UINT numSources;
; 316  : 
; 317  :         if (scene)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+144], 0
	je	$LN21@SetScene

; 318  :         {
; 319  :             //shutdown previous scene, if any
; 320  :             numSources = scene->sceneItems.Num();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	add	ecx, 8
	call	?Num@?$List@PAVSceneItem@@@@QBEIXZ	; List<SceneItem *>::Num
	mov	DWORD PTR _numSources$26[ebp], eax

; 321  :             for(UINT i=0; i<numSources; i++)

	mov	DWORD PTR _i$33[ebp], 0
	jmp	SHORT $LN20@SetScene
$LN19@SetScene:
	mov	ecx, DWORD PTR _i$33[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$33[ebp], ecx
$LN20@SetScene:
	mov	edx, DWORD PTR _i$33[ebp]
	cmp	edx, DWORD PTR _numSources$26[ebp]
	jae	$LN18@SetScene

; 322  :             {
; 323  :                 XElement *source = scene->sceneItems[i]->GetElement();

	mov	eax, DWORD PTR _i$33[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+144]
	add	ecx, 8
	call	??A?$List@PAVSceneItem@@@@QAEAAPAVSceneItem@@I@Z ; List<SceneItem *>::operator[]
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR __imp_?GetElement@SceneItem@@QBEPAVXElement@@XZ
	mov	DWORD PTR _source$24[ebp], eax

; 324  :                 String className = source->GetString(TEXT("class"));

	push	0
	push	OFFSET $SG4294966844
	mov	ecx, DWORD PTR _source$24[ebp]
	call	DWORD PTR __imp_?GetString@XElement@@QBEPB_WPB_WPA_W@Z
	push	eax
	lea	ecx, DWORD PTR _className$5[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PB_W@Z

; 325  :                 if(scene->sceneItems[i]->bRender && className == "GlobalSource") {

	mov	edx, DWORD PTR _i$33[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	add	ecx, 8
	call	??A?$List@PAVSceneItem@@@@QAEAAPAVSceneItem@@I@Z ; List<SceneItem *>::operator[]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx+65]
	test	edx, edx
	je	SHORT $LN50@SetScene
	push	OFFSET $SG4294966843
	lea	ecx, DWORD PTR $T2[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PBD@Z
	or	DWORD PTR $T39[ebp], 1
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _className$5[ebp]
	call	DWORD PTR __imp_??8String@@QBEHABV0@@Z
	test	eax, eax
	je	SHORT $LN50@SetScene
	mov	DWORD PTR tv341[ebp], 1
	jmp	SHORT $LN51@SetScene
$LN50@SetScene:
	mov	DWORD PTR tv341[ebp], 0
$LN51@SetScene:
	mov	cl, BYTE PTR tv341[ebp]
	mov	BYTE PTR $T35[ebp], cl
	mov	edx, DWORD PTR $T39[ebp]
	and	edx, 1
	je	SHORT $LN58@SetScene
	and	DWORD PTR $T39[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN58@SetScene:
	movzx	eax, BYTE PTR $T35[ebp]
	test	eax, eax
	je	$LN17@SetScene

; 326  :                     XElement *globalSourceData = source->GetElement(TEXT("data"));

	push	OFFSET $SG4294966842
	mov	ecx, DWORD PTR _source$24[ebp]
	call	DWORD PTR __imp_?GetElement@XElement@@QBEPAV1@PB_W@Z
	mov	DWORD PTR _globalSourceData$17[ebp], eax

; 327  :                     String globalSourceName = globalSourceData->GetString(TEXT("name"));

	push	0
	push	OFFSET $SG4294966841
	mov	ecx, DWORD PTR _globalSourceData$17[ebp]
	call	DWORD PTR __imp_?GetString@XElement@@QBEPB_WPB_WPA_W@Z
	push	eax
	lea	ecx, DWORD PTR _globalSourceName$14[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PB_W@Z

; 328  :                     if(App->GetGlobalSource(globalSourceName) != NULL) {

	lea	ecx, DWORD PTR _globalSourceName$14[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?GetGlobalSource@OBS@@AAEPAVImageSource@@PB_W@Z ; OBS::GetGlobalSource
	test	eax, eax
	je	SHORT $LN16@SetScene

; 329  :                         App->GetGlobalSource(globalSourceName)->GlobalSourceLeaveScene();

	lea	ecx, DWORD PTR _globalSourceName$14[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?GetGlobalSource@OBS@@AAEPAVImageSource@@PB_W@Z ; OBS::GetGlobalSource
	mov	DWORD PTR tv400[ebp], eax
	mov	ecx, DWORD PTR tv400[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv400[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax
$LN16@SetScene:

; 330  :                     }
; 331  :                 }

	lea	ecx, DWORD PTR _globalSourceName$14[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN17@SetScene:

; 332  :             }

	lea	ecx, DWORD PTR _className$5[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	jmp	$LN19@SetScene
$LN18@SetScene:

; 333  : 
; 334  :             scene->EndScene();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+144]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+144]
	mov	eax, DWORD PTR [edx+40]
	call	eax
$LN21@SetScene:

; 335  :         }
; 336  : 
; 337  :         Scene *previousScene = scene;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+144]
	mov	DWORD PTR _previousScene$21[ebp], edx

; 338  :         scene = newScene;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newScene$[ebp]
	mov	DWORD PTR [eax+144], ecx

; 339  : 
; 340  :         if(newScene && bSkipTransition) {

	cmp	DWORD PTR _newScene$[ebp], 0
	je	$LN11@SetScene
	movzx	edx, BYTE PTR _bSkipTransition$[ebp]
	test	edx, edx
	je	$LN11@SetScene

; 341  :             // If we're skipping the transition because of a non-global
; 342  :             // DirectShow device, delete the scene here and add the
; 343  :             // ImageSources at this point instead.
; 344  :             delete previousScene;

	mov	eax, DWORD PTR _previousScene$21[ebp]
	mov	DWORD PTR $T15[ebp], eax
	mov	ecx, DWORD PTR $T15[ebp]
	mov	DWORD PTR $T28[ebp], ecx
	cmp	DWORD PTR $T28[ebp], 0
	je	SHORT $LN52@SetScene
	push	1
	mov	edx, DWORD PTR $T28[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T28[ebp]
	mov	edx, DWORD PTR [eax]
	call	edx
	mov	DWORD PTR tv421[ebp], eax
	jmp	SHORT $LN53@SetScene
$LN52@SetScene:
	mov	DWORD PTR tv421[ebp], 0
$LN53@SetScene:

; 345  : 
; 346  :             if(sources)

	cmp	DWORD PTR _sources$[ebp], 0
	je	SHORT $LN11@SetScene

; 347  :             {
; 348  :                 UINT numSources = sources->NumElements();

	push	0
	mov	ecx, DWORD PTR _sources$[ebp]
	call	DWORD PTR __imp_?NumElements@XElement@@QAEKPB_W@Z
	mov	DWORD PTR _numSources$13[ebp], eax

; 349  : 
; 350  :                 for(UINT i=0; i<numSources; i++)

	mov	DWORD PTR _i$31[ebp], 0
	jmp	SHORT $LN13@SetScene
$LN12@SetScene:
	mov	eax, DWORD PTR _i$31[ebp]
	add	eax, 1
	mov	DWORD PTR _i$31[ebp], eax
$LN13@SetScene:
	mov	ecx, DWORD PTR _i$31[ebp]
	cmp	ecx, DWORD PTR _numSources$13[ebp]
	jae	SHORT $LN11@SetScene

; 351  :                 {
; 352  :                     XElement *sourceElement = sources->GetElementByID(i);

	mov	edx, DWORD PTR _i$31[ebp]
	push	edx
	mov	ecx, DWORD PTR _sources$[ebp]
	call	DWORD PTR __imp_?GetElementByID@XElement@@QBEPAV1@K@Z
	mov	DWORD PTR _sourceElement$9[ebp], eax

; 353  : 
; 354  :                     if(newScene)

	cmp	DWORD PTR _newScene$[ebp], 0
	je	SHORT $LN10@SetScene

; 355  :                         newScene->AddImageSource(sourceElement);

	mov	eax, DWORD PTR _sourceElement$9[ebp]
	push	eax
	mov	ecx, DWORD PTR _newScene$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _newScene$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
$LN10@SetScene:

; 356  :                 }

	jmp	SHORT $LN12@SetScene
$LN11@SetScene:

; 357  :             }
; 358  :         }
; 359  : 
; 360  :         scene->BeginScene();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+144]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+144]
	mov	eax, DWORD PTR [edx+36]
	call	eax

; 361  : 
; 362  :         numSources = scene->sceneItems.Num();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+144]
	add	ecx, 8
	call	?Num@?$List@PAVSceneItem@@@@QBEIXZ	; List<SceneItem *>::Num
	mov	DWORD PTR _numSources$26[ebp], eax

; 363  :         for(UINT i=0; i<numSources; i++)

	mov	DWORD PTR _i$32[ebp], 0
	jmp	SHORT $LN9@SetScene
$LN8@SetScene:
	mov	edx, DWORD PTR _i$32[ebp]
	add	edx, 1
	mov	DWORD PTR _i$32[ebp], edx
$LN9@SetScene:
	mov	eax, DWORD PTR _i$32[ebp]
	cmp	eax, DWORD PTR _numSources$26[ebp]
	jae	$LN7@SetScene

; 364  :         {
; 365  :             XElement *source = scene->sceneItems[i]->GetElement();

	mov	ecx, DWORD PTR _i$32[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+144]
	add	ecx, 8
	call	??A?$List@PAVSceneItem@@@@QAEAAPAVSceneItem@@I@Z ; List<SceneItem *>::operator[]
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR __imp_?GetElement@SceneItem@@QBEPAVXElement@@XZ
	mov	DWORD PTR _source$22[ebp], eax

; 366  : 
; 367  :             String className = source->GetString(TEXT("class"));

	push	0
	push	OFFSET $SG4294966840
	mov	ecx, DWORD PTR _source$22[ebp]
	call	DWORD PTR __imp_?GetString@XElement@@QBEPB_WPB_WPA_W@Z
	push	eax
	lea	ecx, DWORD PTR _className$1[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PB_W@Z

; 368  :             if(scene->sceneItems[i]->bRender && className == "GlobalSource") {

	mov	eax, DWORD PTR _i$32[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+144]
	add	ecx, 8
	call	??A?$List@PAVSceneItem@@@@QAEAAPAVSceneItem@@I@Z ; List<SceneItem *>::operator[]
	mov	edx, DWORD PTR [eax]
	movzx	eax, BYTE PTR [edx+65]
	test	eax, eax
	je	SHORT $LN54@SetScene
	push	OFFSET $SG4294966839
	lea	ecx, DWORD PTR $T3[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PBD@Z
	or	DWORD PTR $T39[ebp], 2
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	lea	ecx, DWORD PTR _className$1[ebp]
	call	DWORD PTR __imp_??8String@@QBEHABV0@@Z
	test	eax, eax
	je	SHORT $LN54@SetScene
	mov	DWORD PTR tv480[ebp], 1
	jmp	SHORT $LN55@SetScene
$LN54@SetScene:
	mov	DWORD PTR tv480[ebp], 0
$LN55@SetScene:
	mov	dl, BYTE PTR tv480[ebp]
	mov	BYTE PTR $T38[ebp], dl
	mov	eax, DWORD PTR $T39[ebp]
	and	eax, 2
	je	SHORT $LN59@SetScene
	and	DWORD PTR $T39[ebp], -3			; fffffffdH
	lea	ecx, DWORD PTR $T3[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN59@SetScene:
	movzx	ecx, BYTE PTR $T38[ebp]
	test	ecx, ecx
	je	$LN6@SetScene

; 369  :                 XElement *globalSourceData = source->GetElement(TEXT("data"));

	push	OFFSET $SG4294966838
	mov	ecx, DWORD PTR _source$22[ebp]
	call	DWORD PTR __imp_?GetElement@XElement@@QBEPAV1@PB_W@Z
	mov	DWORD PTR _globalSourceData$11[ebp], eax

; 370  :                 String globalSourceName = globalSourceData->GetString(TEXT("name"));

	push	0
	push	OFFSET $SG4294966837
	mov	ecx, DWORD PTR _globalSourceData$11[ebp]
	call	DWORD PTR __imp_?GetString@XElement@@QBEPB_WPB_WPA_W@Z
	push	eax
	lea	ecx, DWORD PTR _globalSourceName$12[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PB_W@Z

; 371  :                 if(App->GetGlobalSource(globalSourceName) != NULL) {

	lea	ecx, DWORD PTR _globalSourceName$12[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?GetGlobalSource@OBS@@AAEPAVImageSource@@PB_W@Z ; OBS::GetGlobalSource
	test	eax, eax
	je	SHORT $LN5@SetScene

; 372  :                     App->GetGlobalSource(globalSourceName)->GlobalSourceEnterScene();

	lea	ecx, DWORD PTR _globalSourceName$12[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?GetGlobalSource@OBS@@AAEPAVImageSource@@PB_W@Z ; OBS::GetGlobalSource
	mov	DWORD PTR tv507[ebp], eax
	mov	edx, DWORD PTR tv507[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv507[ebp]
	mov	edx, DWORD PTR [eax+36]
	call	edx
$LN5@SetScene:

; 373  :                 }
; 374  :             }

	lea	ecx, DWORD PTR _globalSourceName$12[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN6@SetScene:

; 375  :         }

	lea	ecx, DWORD PTR _className$1[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	jmp	$LN8@SetScene
$LN7@SetScene:

; 376  : 
; 377  :         if(!bTransitioning && !bSkipTransition)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+45]
	test	ecx, ecx
	jne	SHORT $LN4@SetScene
	movzx	edx, BYTE PTR _bSkipTransition$[ebp]
	test	edx, edx
	jne	SHORT $LN4@SetScene

; 378  :         {
; 379  :             bTransitioning = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+45], 1

; 380  :             transitionAlpha = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+48], xmm0
$LN4@SetScene:

; 381  :         }
; 382  : 
; 383  :         OSLeaveMutex(hSceneMutex);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+956]
	push	eax
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z

; 384  : 
; 385  :         if(!bSkipTransition) {

	movzx	ecx, BYTE PTR _bSkipTransition$[ebp]
	test	ecx, ecx
	jne	SHORT $LN57@SetScene

; 386  :             // Do not delete the previous scene here, since it has already
; 387  :             // been deleted.
; 388  :             delete previousScene;

	mov	edx, DWORD PTR _previousScene$21[ebp]
	mov	DWORD PTR $T7[ebp], edx
	mov	eax, DWORD PTR $T7[ebp]
	mov	DWORD PTR $T25[ebp], eax
	cmp	DWORD PTR $T25[ebp], 0
	je	SHORT $LN56@SetScene
	push	1
	mov	ecx, DWORD PTR $T25[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T25[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv527[ebp], eax
	jmp	SHORT $LN57@SetScene
$LN56@SetScene:
	mov	DWORD PTR tv527[ebp], 0
$LN57@SetScene:

; 389  :         }
; 390  : 
; 391  :         DWORD sceneChangeTime = OSGetTime() - sceneChangeStartTime;

	call	DWORD PTR __imp_?OSGetTime@@YGKXZ
	sub	eax, DWORD PTR _sceneChangeStartTime$[ebp]
	mov	DWORD PTR _sceneChangeTime$19[ebp], eax

; 392  :         if (sceneChangeTime >= 500)

	cmp	DWORD PTR _sceneChangeTime$19[ebp], 500	; 000001f4H
	jb	SHORT $LN2@SetScene

; 393  :             Log(TEXT("PERFORMANCE WARNING: Scene change took %u ms, maybe some sources should be global sources?"), sceneChangeTime);

	mov	ecx, DWORD PTR _sceneChangeTime$19[ebp]
	push	ecx
	push	OFFSET $SG4294966836
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8
$LN2@SetScene:

; 394  :     }
; 395  : 
; 396  :     if(API != NULL)

	mov	edx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN1@SetScene

; 397  :        ReportSwitchScenes(lpScene);

	mov	eax, DWORD PTR _lpScene$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
$LN1@SetScene:

; 398  : 
; 399  :     return true;

	mov	al, 1
$LN44@SetScene:

; 400  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetScene@OBS@@UAE_NPB_W@Z ENDP				; OBS::SetScene
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?SetSceneCollection@OBS@@UAE_NPB_W@Z
_TEXT	SEGMENT
$T1 = -44						; size = 8
$T2 = -36						; size = 8
$T3 = -28						; size = 8
_strSceneCollectionPath$ = -20				; size = 8
_collection$ = -12					; size = 4
_this$ = -8						; size = 4
$T4 = -2						; size = 1
$T5 = -1						; size = 1
_lpCollection$ = 8					; size = 4
?SetSceneCollection@OBS@@UAE_NPB_W@Z PROC		; OBS::SetSceneCollection, COMDAT
; _this$ = ecx

; 402  : bool OBS::SetSceneCollection(CTSTR lpCollection) {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 403  :     if (bRunning)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+622]
	test	ecx, ecx
	je	SHORT $LN3@SetSceneCo

; 404  :         return false;

	xor	al, al
	jmp	$LN4@SetSceneCo
$LN3@SetSceneCo:

; 405  : 
; 406  :     App->scenesConfig.Save();

	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	add	ecx, 168				; 000000a8H
	call	DWORD PTR __imp_?Save@XConfig@@QAEXXZ

; 407  :     CTSTR collection = GetCurrentSceneCollection();

	call	?GetCurrentSceneCollection@OBS@@SAPB_WXZ ; OBS::GetCurrentSceneCollection
	mov	DWORD PTR _collection$[ebp], eax

; 408  :     String strSceneCollectionPath;

	lea	ecx, DWORD PTR _strSceneCollectionPath$[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 409  :     strSceneCollectionPath = FormattedString(L"%s\\sceneCollection\\%s.xconfig", lpAppDataPath, collection);

	mov	edx, DWORD PTR _collection$[ebp]
	push	edx
	push	OFFSET ?lpAppDataPath@@3PA_WA		; lpAppDataPath
	push	OFFSET $SG4294966835
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR _strSceneCollectionPath$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 410  : 
; 411  :     if (!App->scenesConfig.Open(strSceneCollectionPath))

	lea	ecx, DWORD PTR _strSceneCollectionPath$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	add	ecx, 168				; 000000a8H
	call	DWORD PTR __imp_?Open@XConfig@@QAE_NPB_W@Z
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@SetSceneCo

; 412  :     {
; 413  :         return false;

	mov	BYTE PTR $T5[ebp], 0
	lea	ecx, DWORD PTR _strSceneCollectionPath$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	al, BYTE PTR $T5[ebp]
	jmp	$LN4@SetSceneCo
$LN2@SetSceneCo:

; 414  :     }
; 415  : 
; 416  :     GlobalConfig->SetString(TEXT("General"), TEXT("SceneCollection"), lpCollection);

	mov	edx, DWORD PTR _lpCollection$[ebp]
	push	edx
	push	OFFSET $SG4294966834
	push	OFFSET $SG4294966833
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?SetString@ConfigFile@@QAEXPB_W00@Z

; 417  :     App->scenesConfig.Close();

	push	0
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	add	ecx, 168				; 000000a8H
	call	DWORD PTR __imp_?Close@XConfig@@QAEX_N@Z

; 418  :     App->ReloadSceneCollection();

	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?ReloadSceneCollection@OBS@@AAEXXZ	; OBS::ReloadSceneCollection

; 419  :     ResetSceneCollectionMenu();

	call	?ResetSceneCollectionMenu@OBS@@CAXXZ	; OBS::ResetSceneCollectionMenu

; 420  :     ResetApplicationName();

	call	?ResetApplicationName@OBS@@CAXXZ	; OBS::ResetApplicationName

; 421  :     App->UpdateNotificationAreaIcon();

	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?UpdateNotificationAreaIcon@OBS@@QAEHXZ	; OBS::UpdateNotificationAreaIcon

; 422  :     App->scenesConfig.SaveTo(String() << lpAppDataPath << "\\scenes.xconfig");

	push	OFFSET $SG4294966832
	lea	ecx, DWORD PTR $T3[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PBD@Z
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	push	OFFSET ?lpAppDataPath@@3PA_WA		; lpAppDataPath
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	add	ecx, 168				; 000000a8H
	call	DWORD PTR __imp_?SaveTo@XConfig@@QAEXPB_W@Z
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR $T3[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 423  : 
; 424  :     if (API != NULL)

	mov	ecx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN1@SetSceneCo

; 425  :         ReportSwitchSceneCollections(lpCollection);

	mov	edx, DWORD PTR _lpCollection$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
$LN1@SetSceneCo:

; 426  : 
; 427  :     return true;

	mov	BYTE PTR $T4[ebp], 1
	lea	ecx, DWORD PTR _strSceneCollectionPath$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	al, BYTE PTR $T4[ebp]
$LN4@SetSceneCo:

; 428  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetSceneCollection@OBS@@UAE_NPB_W@Z ENDP		; OBS::SetSceneCollection
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?SetChangedSettings@OBSAPIInterface@@EAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_isModified$ = 8					; size = 1
?SetChangedSettings@OBSAPIInterface@@EAEX_N@Z PROC	; OBSAPIInterface::SetChangedSettings, COMDAT
; _this$ = ecx

; 448  :     virtual void SetChangedSettings(bool isModified) {App->SetChangedSettings(isModified);}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	movzx	eax, BYTE PTR _isModified$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?SetChangedSettings@OBS@@AAEX_N@Z	; OBS::SetChangedSettings
	mov	esp, ebp
	pop	ebp
	ret	4
?SetChangedSettings@OBSAPIInterface@@EAEX_N@Z ENDP	; OBSAPIInterface::SetChangedSettings
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?SetAbortApplySettings@OBSAPIInterface@@EAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_abort$ = 8						; size = 1
?SetAbortApplySettings@OBSAPIInterface@@EAEX_N@Z PROC	; OBSAPIInterface::SetAbortApplySettings, COMDAT
; _this$ = ecx

; 449  :     virtual void SetAbortApplySettings(bool abort) { App->SetAbortApplySettings(abort); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	movzx	eax, BYTE PTR _abort$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?SetAbortApplySettings@OBS@@AAEX_N@Z	; OBS::SetAbortApplySettings
	mov	esp, ebp
	pop	ebp
	ret	4
?SetAbortApplySettings@OBSAPIInterface@@EAEX_N@Z ENDP	; OBSAPIInterface::SetAbortApplySettings
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?SetCanOptimizeSettings@OBSAPIInterface@@EAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_canOptimize$ = 8					; size = 1
?SetCanOptimizeSettings@OBSAPIInterface@@EAEX_N@Z PROC	; OBSAPIInterface::SetCanOptimizeSettings, COMDAT
; _this$ = ecx

; 450  :     virtual void SetCanOptimizeSettings(bool canOptimize) override { App->SetCanOptimizeSettings(canOptimize); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	movzx	eax, BYTE PTR _canOptimize$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?SetCanOptimizeSettings@OBS@@AAEX_N@Z	; OBS::SetCanOptimizeSettings
	mov	esp, ebp
	pop	ebp
	ret	4
?SetCanOptimizeSettings@OBSAPIInterface@@EAEX_N@Z ENDP	; OBSAPIInterface::SetCanOptimizeSettings
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?EnterSceneMutex@OBSAPIInterface@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?EnterSceneMutex@OBSAPIInterface@@UAEXXZ PROC		; OBSAPIInterface::EnterSceneMutex, COMDAT
; _this$ = ecx

; 453  :     virtual void EnterSceneMutex() {App->EnterSceneMutex();}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?EnterSceneMutex@OBS@@QAEXXZ		; OBS::EnterSceneMutex
	mov	esp, ebp
	pop	ebp
	ret	0
?EnterSceneMutex@OBSAPIInterface@@UAEXXZ ENDP		; OBSAPIInterface::EnterSceneMutex
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?LeaveSceneMutex@OBSAPIInterface@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?LeaveSceneMutex@OBSAPIInterface@@UAEXXZ PROC		; OBSAPIInterface::LeaveSceneMutex, COMDAT
; _this$ = ecx

; 454  :     virtual void LeaveSceneMutex() {App->LeaveSceneMutex();}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?LeaveSceneMutex@OBS@@QAEXXZ		; OBS::LeaveSceneMutex
	mov	esp, ebp
	pop	ebp
	ret	0
?LeaveSceneMutex@OBSAPIInterface@@UAEXXZ ENDP		; OBSAPIInterface::LeaveSceneMutex
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?StartStopStream@OBSAPIInterface@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?StartStopStream@OBSAPIInterface@@UAEXXZ PROC		; OBSAPIInterface::StartStopStream, COMDAT
; _this$ = ecx

; 457  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 458  :         PostMessage(hwndMain, WM_COMMAND, MAKEWPARAM(ID_STARTSTOP, 0), 0);

	push	0
	push	5003					; 0000138bH
	push	273					; 00000111H
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	call	DWORD PTR __imp__PostMessageW@16

; 459  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?StartStopStream@OBSAPIInterface@@UAEXXZ ENDP		; OBSAPIInterface::StartStopStream
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?StartStopPreview@OBSAPIInterface@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?StartStopPreview@OBSAPIInterface@@UAEXXZ PROC		; OBSAPIInterface::StartStopPreview, COMDAT
; _this$ = ecx

; 462  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 463  :         PostMessage(hwndMain, WM_COMMAND, MAKEWPARAM(ID_TESTSTREAM, 0), 0);

	push	0
	push	5015					; 00001397H
	push	273					; 00000111H
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	call	DWORD PTR __imp__PostMessageW@16

; 464  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?StartStopPreview@OBSAPIInterface@@UAEXXZ ENDP		; OBSAPIInterface::StartStopPreview
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?StartStopRecording@OBSAPIInterface@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?StartStopRecording@OBSAPIInterface@@UAEXXZ PROC	; OBSAPIInterface::StartStopRecording, COMDAT
; _this$ = ecx

; 467  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 468  :         PostMessage(hwndMain, WM_COMMAND, MAKEWPARAM(ID_TOGGLERECORDING, 0), 0);

	push	0
	push	5002					; 0000138aH
	push	273					; 00000111H
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	call	DWORD PTR __imp__PostMessageW@16

; 469  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?StartStopRecording@OBSAPIInterface@@UAEXXZ ENDP	; OBSAPIInterface::StartStopRecording
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?StartStopRecordingReplayBuffer@OBSAPIInterface@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?StartStopRecordingReplayBuffer@OBSAPIInterface@@UAEXXZ PROC ; OBSAPIInterface::StartStopRecordingReplayBuffer, COMDAT
; _this$ = ecx

; 472  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 473  :         PostMessage(hwndMain, WM_COMMAND, MAKEWPARAM(ID_TOGGLERECORDINGREPLAYBUFFER, 0), 0);

	push	0
	push	5001					; 00001389H
	push	273					; 00000111H
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	call	DWORD PTR __imp__PostMessageW@16

; 474  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?StartStopRecordingReplayBuffer@OBSAPIInterface@@UAEXXZ ENDP ; OBSAPIInterface::StartStopRecordingReplayBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?SaveReplayBuffer@OBSAPIInterface@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SaveReplayBuffer@OBSAPIInterface@@UAEXXZ PROC		; OBSAPIInterface::SaveReplayBuffer, COMDAT
; _this$ = ecx

; 477  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 478  :         ::SaveReplayBuffer(App->replayBuffer, (DWORD)(App->GetVideoTime() - App->firstFrameTimestamp));

	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?GetVideoTime@OBS@@QBE_KXZ		; OBS::GetVideoTime
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	sub	eax, DWORD PTR [ecx+1112]
	sbb	edx, DWORD PTR [ecx+1116]
	push	eax
	mov	edx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	eax, DWORD PTR [edx+1068]
	push	eax
	call	?SaveReplayBuffer@@YAXPAUReplayBuffer@@K@Z ; SaveReplayBuffer
	add	esp, 8

; 479  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?SaveReplayBuffer@OBSAPIInterface@@UAEXXZ ENDP		; OBSAPIInterface::SaveReplayBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetStreaming@OBSAPIInterface@@UAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetStreaming@OBSAPIInterface@@UAE_NXZ PROC		; OBSAPIInterface::GetStreaming, COMDAT
; _this$ = ecx

; 482  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 483  :         return App->bRunning;

	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	al, BYTE PTR [eax+622]

; 484  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetStreaming@OBSAPIInterface@@UAE_NXZ ENDP		; OBSAPIInterface::GetStreaming
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetPreviewOnly@OBSAPIInterface@@UAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPreviewOnly@OBSAPIInterface@@UAE_NXZ PROC		; OBSAPIInterface::GetPreviewOnly, COMDAT
; _this$ = ecx

; 487  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 488  :         return App->bTestStream;

	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	al, BYTE PTR [eax+620]

; 489  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPreviewOnly@OBSAPIInterface@@UAE_NXZ ENDP		; OBSAPIInterface::GetPreviewOnly
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetRecording@OBSAPIInterface@@UBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRecording@OBSAPIInterface@@UBE_NXZ PROC		; OBSAPIInterface::GetRecording, COMDAT
; _this$ = ecx

; 492  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 493  :         return App->bRecording;

	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	al, BYTE PTR [eax+623]

; 494  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetRecording@OBSAPIInterface@@UBE_NXZ ENDP		; OBSAPIInterface::GetRecording
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetRecordingReplayBuffer@OBSAPIInterface@@UBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRecordingReplayBuffer@OBSAPIInterface@@UBE_NXZ PROC	; OBSAPIInterface::GetRecordingReplayBuffer, COMDAT
; _this$ = ecx

; 497  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 498  :         return App->bRecordingReplayBuffer;

	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	al, BYTE PTR [eax+624]

; 499  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetRecordingReplayBuffer@OBSAPIInterface@@UBE_NXZ ENDP	; OBSAPIInterface::GetRecordingReplayBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetKeepRecording@OBSAPIInterface@@UBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetKeepRecording@OBSAPIInterface@@UBE_NXZ PROC		; OBSAPIInterface::GetKeepRecording, COMDAT
; _this$ = ecx

; 502  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 503  :         return App->bKeepRecording;

	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	al, BYTE PTR [eax+629]

; 504  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetKeepRecording@OBSAPIInterface@@UBE_NXZ ENDP		; OBSAPIInterface::GetKeepRecording
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?RegisterSceneClass@OBSAPIInterface@@UAEXPB_W0P6GPAXPAVXElement@@@ZP6G_N1_N@Z@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpClassName$ = 8					; size = 4
_lpDisplayName$ = 12					; size = 4
_createProc$ = 16					; size = 4
_configProc$ = 20					; size = 4
?RegisterSceneClass@OBSAPIInterface@@UAEXPB_W0P6GPAXPAVXElement@@@ZP6G_N1_N@Z@Z PROC ; OBSAPIInterface::RegisterSceneClass, COMDAT
; _this$ = ecx

; 507  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 508  :         App->RegisterSceneClass(lpClassName, lpDisplayName, createProc, configProc, false);

	push	0
	mov	eax, DWORD PTR _configProc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _createProc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpDisplayName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 509  :     }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?RegisterSceneClass@OBSAPIInterface@@UAEXPB_W0P6GPAXPAVXElement@@@ZP6G_N1_N@Z@Z ENDP ; OBSAPIInterface::RegisterSceneClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?RegisterImageSourceClass@OBSAPIInterface@@UAEXPB_W0P6GPAXPAVXElement@@@ZP6G_N1_N@Z@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpClassName$ = 8					; size = 4
_lpDisplayName$ = 12					; size = 4
_createProc$ = 16					; size = 4
_configProc$ = 20					; size = 4
?RegisterImageSourceClass@OBSAPIInterface@@UAEXPB_W0P6GPAXPAVXElement@@@ZP6G_N1_N@Z@Z PROC ; OBSAPIInterface::RegisterImageSourceClass, COMDAT
; _this$ = ecx

; 512  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 513  :         App->RegisterImageSourceClass(lpClassName, lpDisplayName, createProc, configProc, false);

	push	0
	mov	eax, DWORD PTR _configProc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _createProc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpDisplayName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	eax, DWORD PTR [edx+16]
	call	eax

; 514  :     }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?RegisterImageSourceClass@OBSAPIInterface@@UAEXPB_W0P6GPAXPAVXElement@@@ZP6G_N1_N@Z@Z ENDP ; OBSAPIInterface::RegisterImageSourceClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?CreateImageSource@OBSAPIInterface@@UAEPAVImageSource@@PB_WPAVXElement@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpClassName$ = 8					; size = 4
_data$ = 12						; size = 4
?CreateImageSource@OBSAPIInterface@@UAEPAVImageSource@@PB_WPAVXElement@@@Z PROC ; OBSAPIInterface::CreateImageSource, COMDAT
; _this$ = ecx

; 517  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 518  :         return App->CreateImageSource(lpClassName, data);

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	edx, DWORD PTR [eax+20]
	call	edx

; 519  :     }

	mov	esp, ebp
	pop	ebp
	ret	8
?CreateImageSource@OBSAPIInterface@@UAEPAVImageSource@@PB_WPAVXElement@@@Z ENDP ; OBSAPIInterface::CreateImageSource
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetSceneListElement@OBSAPIInterface@@UAEPAVXElement@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSceneListElement@OBSAPIInterface@@UAEPAVXElement@@XZ PROC ; OBSAPIInterface::GetSceneListElement, COMDAT
; _this$ = ecx

; 521  :     virtual XElement* GetSceneListElement()         {return App->scenesConfig.GetElement(TEXT("scenes"));}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET ??_C@_1O@DEJKECHI@?$AAs?$AAc?$AAe?$AAn?$AAe?$AAs?$AA?$AA@
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	add	ecx, 168				; 000000a8H
	call	DWORD PTR __imp_?GetElement@XConfig@@QAEPAVXElement@@PB_W@Z
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSceneListElement@OBSAPIInterface@@UAEPAVXElement@@XZ ENDP ; OBSAPIInterface::GetSceneListElement
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetGlobalSourceListElement@OBSAPIInterface@@UAEPAVXElement@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGlobalSourceListElement@OBSAPIInterface@@UAEPAVXElement@@XZ PROC ; OBSAPIInterface::GetGlobalSourceListElement, COMDAT
; _this$ = ecx

; 522  :     virtual XElement* GetGlobalSourceListElement()  {return App->scenesConfig.GetElement(TEXT("global sources"));}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET ??_C@_1BO@MNEEFODP@?$AAg?$AAl?$AAo?$AAb?$AAa?$AAl?$AA?5?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AAs?$AA?$AA@
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	add	ecx, 168				; 000000a8H
	call	DWORD PTR __imp_?GetElement@XConfig@@QAEPAVXElement@@PB_W@Z
	mov	esp, ebp
	pop	ebp
	ret	0
?GetGlobalSourceListElement@OBSAPIInterface@@UAEPAVXElement@@XZ ENDP ; OBSAPIInterface::GetGlobalSourceListElement
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?SetSourceOrder@OBSAPIInterface@@UAEXAAVStringList@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
_order$ = -12						; size = 4
tv69 = -8						; size = 4
$T1 = -4						; size = 4
_sourceNames$ = 8					; size = 4
?SetSourceOrder@OBSAPIInterface@@UAEXAAVStringList@@@Z PROC ; OBSAPIInterface::SetSourceOrder, COMDAT
; _this$ = ecx

; 525  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 526  :         StringList* order = new StringList();

	push	8
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN3@SetSourceO
	mov	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??0StringList@@QAE@XZ
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@SetSourceO
$LN3@SetSourceO:
	mov	DWORD PTR tv69[ebp], 0
$LN4@SetSourceO:
	mov	eax, DWORD PTR tv69[ebp]
	mov	DWORD PTR _order$[ebp], eax

; 527  :         order->CopyList(sourceNames);

	mov	ecx, DWORD PTR _sourceNames$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _order$[ebp]
	call	DWORD PTR __imp_?CopyList@StringList@@QAEXABV1@@Z

; 528  :         PostMessage(hwndMain, OBS_SETSOURCEORDER, 0, (LPARAM) order);

	mov	edx, DWORD PTR _order$[ebp]
	push	edx
	push	0
	push	1029					; 00000405H
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	call	DWORD PTR __imp__PostMessageW@16

; 529  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetSourceOrder@OBSAPIInterface@@UAEXAAVStringList@@@Z ENDP ; OBSAPIInterface::SetSourceOrder
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?SetSourceRender@OBSAPIInterface@@UAEXPB_W_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpSource$ = 8						; size = 4
_render$ = 12						; size = 1
?SetSourceRender@OBSAPIInterface@@UAEXPB_W_N@Z PROC	; OBSAPIInterface::SetSourceRender, COMDAT
; _this$ = ecx

; 532  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 533  :         if(!lpSource || !*lpSource)

	cmp	DWORD PTR _lpSource$[ebp], 0
	je	SHORT $LN1@SetSourceR
	mov	eax, DWORD PTR _lpSource$[ebp]
	movzx	ecx, WORD PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@SetSourceR
$LN1@SetSourceR:

; 534  :             return;

	jmp	SHORT $LN3@SetSourceR
$LN2@SetSourceR:

; 535  : 
; 536  :         PostMessage(hwndMain, OBS_SETSOURCERENDER, (WPARAM)sdup(lpSource), (LPARAM) render);

	movzx	edx, BYTE PTR _render$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSource$[ebp]
	push	eax
	call	DWORD PTR __imp_?sdup@@YGPA_WPB_W@Z
	push	eax
	push	1030					; 00000406H
	mov	ecx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	ecx
	call	DWORD PTR __imp__PostMessageW@16
$LN3@SetSourceR:

; 537  :     }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetSourceRender@OBSAPIInterface@@UAEXPB_W_N@Z ENDP	; OBSAPIInterface::SetSourceRender
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?SetScene@OBSAPIInterface@@UAE_NPB_W_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpScene$ = 8						; size = 4
_bPost$ = 12						; size = 1
?SetScene@OBSAPIInterface@@UAE_NPB_W_N@Z PROC		; OBSAPIInterface::SetScene, COMDAT
; _this$ = ecx

; 540  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 541  :         assert(lpScene && *lpScene);
; 542  : 
; 543  :         if(!lpScene || !*lpScene)

	cmp	DWORD PTR _lpScene$[ebp], 0
	je	SHORT $LN2@SetScene
	mov	eax, DWORD PTR _lpScene$[ebp]
	movzx	ecx, WORD PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@SetScene
$LN2@SetScene:

; 544  :             return false;

	xor	al, al
	jmp	SHORT $LN4@SetScene
$LN3@SetScene:

; 545  : 
; 546  :         if(bPost)

	movzx	edx, BYTE PTR _bPost$[ebp]
	test	edx, edx
	je	SHORT $LN1@SetScene

; 547  :         {
; 548  :             PostMessage(hwndMain, OBS_SETSCENE, 0, (LPARAM)sdup(lpScene));

	mov	eax, DWORD PTR _lpScene$[ebp]
	push	eax
	call	DWORD PTR __imp_?sdup@@YGPA_WPB_W@Z
	push	eax
	push	0
	push	1028					; 00000404H
	mov	ecx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	ecx
	call	DWORD PTR __imp__PostMessageW@16

; 549  :             return true;

	mov	al, 1
	jmp	SHORT $LN4@SetScene
$LN1@SetScene:

; 550  :         }
; 551  : 
; 552  :         return App->SetScene(lpScene);

	mov	edx, DWORD PTR _lpScene$[ebp]
	push	edx
	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	eax, DWORD PTR [edx+24]
	call	eax
$LN4@SetScene:

; 553  :     }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetScene@OBSAPIInterface@@UAE_NPB_W_N@Z ENDP		; OBSAPIInterface::SetScene
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetScene@OBSAPIInterface@@UBEPAVScene@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetScene@OBSAPIInterface@@UBEPAVScene@@XZ PROC		; OBSAPIInterface::GetScene, COMDAT
; _this$ = ecx

; 554  :     virtual Scene* GetScene() const             {return App->scene;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	eax, DWORD PTR [eax+144]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetScene@OBSAPIInterface@@UBEPAVScene@@XZ ENDP		; OBSAPIInterface::GetScene
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetSceneName@OBSAPIInterface@@UBEPB_WXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSceneName@OBSAPIInterface@@UBEPB_WXZ PROC		; OBSAPIInterface::GetSceneName, COMDAT
; _this$ = ecx

; 556  :     virtual CTSTR GetSceneName() const          {return App->GetSceneElement()->GetName();}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?GetSceneElement@OBS@@QBEPAVXElement@@XZ ; OBS::GetSceneElement
	mov	ecx, eax
	call	DWORD PTR __imp_?GetName@XBaseItem@@QBEPB_WXZ
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSceneName@OBSAPIInterface@@UBEPB_WXZ ENDP		; OBSAPIInterface::GetSceneName
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetSceneElement@OBSAPIInterface@@UAEPAVXElement@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSceneElement@OBSAPIInterface@@UAEPAVXElement@@XZ PROC ; OBSAPIInterface::GetSceneElement, COMDAT
; _this$ = ecx

; 557  :     virtual XElement* GetSceneElement()         {return App->GetSceneElement();}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?GetSceneElement@OBS@@QBEPAVXElement@@XZ ; OBS::GetSceneElement
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSceneElement@OBSAPIInterface@@UAEPAVXElement@@XZ ENDP ; OBSAPIInterface::GetSceneElement
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetBaseSize@OBSAPIInterface@@UBE?AUVect2@@XZ
_TEXT	SEGMENT
tv86 = -28						; size = 8
tv76 = -20						; size = 8
_this$ = -12						; size = 4
tv82 = -8						; size = 4
tv72 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetBaseSize@OBSAPIInterface@@UBE?AUVect2@@XZ PROC	; OBSAPIInterface::GetBaseSize, COMDAT
; _this$ = ecx

; 562  :     virtual Vect2 GetBaseSize() const               {return Vect2(float(App->baseCX), float(App->baseCY));}

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	ecx, DWORD PTR [eax+860]
	mov	DWORD PTR tv72[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv72[ebp]
	mov	edx, DWORD PTR tv72[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv76[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv76[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	ecx, DWORD PTR [eax+856]
	mov	DWORD PTR tv82[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv82[ebp]
	mov	edx, DWORD PTR tv82[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv86[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv86[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0Vect2@@QAE@MM@Z
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetBaseSize@OBSAPIInterface@@UBE?AUVect2@@XZ ENDP	; OBSAPIInterface::GetBaseSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetRenderFrameSize@OBSAPIInterface@@UBE?AUVect2@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetRenderFrameSize@OBSAPIInterface@@UBE?AUVect2@@XZ PROC ; OBSAPIInterface::GetRenderFrameSize, COMDAT
; _this$ = ecx

; 563  :     virtual Vect2 GetRenderFrameSize() const        {return Vect2(float(App->renderFrameWidth), float(App->renderFrameHeight));}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	cvtsi2ss xmm0, DWORD PTR [eax+640]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	cvtsi2ss xmm0, DWORD PTR [ecx+636]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0Vect2@@QAE@MM@Z
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetRenderFrameSize@OBSAPIInterface@@UBE?AUVect2@@XZ ENDP ; OBSAPIInterface::GetRenderFrameSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetRenderFrameOffset@OBSAPIInterface@@UBE?AUVect2@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetRenderFrameOffset@OBSAPIInterface@@UBE?AUVect2@@XZ PROC ; OBSAPIInterface::GetRenderFrameOffset, COMDAT
; _this$ = ecx

; 564  :     virtual Vect2 GetRenderFrameOffset() const      {return Vect2(float(App->renderFrameX), float(App->renderFrameY));}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	cvtsi2ss xmm0, DWORD PTR [eax+648]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	cvtsi2ss xmm0, DWORD PTR [ecx+644]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0Vect2@@QAE@MM@Z
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetRenderFrameOffset@OBSAPIInterface@@UBE?AUVect2@@XZ ENDP ; OBSAPIInterface::GetRenderFrameOffset
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetRenderFrameControlSize@OBSAPIInterface@@UBE?AUVect2@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetRenderFrameControlSize@OBSAPIInterface@@UBE?AUVect2@@XZ PROC ; OBSAPIInterface::GetRenderFrameControlSize, COMDAT
; _this$ = ecx

; 565  :     virtual Vect2 GetRenderFrameControlSize() const {return Vect2(float(App->renderFrameCtrlWidth), float(App->renderFrameCtrlHeight));}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	cvtsi2ss xmm0, DWORD PTR [eax+656]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	cvtsi2ss xmm0, DWORD PTR [ecx+652]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0Vect2@@QAE@MM@Z
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetRenderFrameControlSize@OBSAPIInterface@@UBE?AUVect2@@XZ ENDP ; OBSAPIInterface::GetRenderFrameControlSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetOutputSize@OBSAPIInterface@@UBE?AUVect2@@XZ
_TEXT	SEGMENT
tv86 = -28						; size = 8
tv76 = -20						; size = 8
_this$ = -12						; size = 4
tv82 = -8						; size = 4
tv72 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOutputSize@OBSAPIInterface@@UBE?AUVect2@@XZ PROC	; OBSAPIInterface::GetOutputSize, COMDAT
; _this$ = ecx

; 566  :     virtual Vect2 GetOutputSize() const             {return Vect2(float(App->outputCX), float(App->outputCY));}

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	ecx, DWORD PTR [eax+876]
	mov	DWORD PTR tv72[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv72[ebp]
	mov	edx, DWORD PTR tv72[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv76[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv76[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	ecx, DWORD PTR [eax+872]
	mov	DWORD PTR tv82[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv82[ebp]
	mov	edx, DWORD PTR tv82[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv86[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv86[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0Vect2@@QAE@MM@Z
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetOutputSize@OBSAPIInterface@@UBE?AUVect2@@XZ ENDP	; OBSAPIInterface::GetOutputSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetBaseSize@OBSAPIInterface@@UBEXAAI0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_width$ = 8						; size = 4
_height$ = 12						; size = 4
?GetBaseSize@OBSAPIInterface@@UBEXAAI0@Z PROC		; OBSAPIInterface::GetBaseSize, COMDAT
; _this$ = ecx

; 568  :     virtual void GetBaseSize(UINT &width, UINT &height) const               {App->GetBaseSize(width, height);}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?GetBaseSize@OBS@@QBEXAAI0@Z		; OBS::GetBaseSize
	mov	esp, ebp
	pop	ebp
	ret	8
?GetBaseSize@OBSAPIInterface@@UBEXAAI0@Z ENDP		; OBSAPIInterface::GetBaseSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetRenderFrameSize@OBSAPIInterface@@UBEXAAI0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_width$ = 8						; size = 4
_height$ = 12						; size = 4
?GetRenderFrameSize@OBSAPIInterface@@UBEXAAI0@Z PROC	; OBSAPIInterface::GetRenderFrameSize, COMDAT
; _this$ = ecx

; 569  :     virtual void GetRenderFrameSize(UINT &width, UINT &height) const        {App->GetRenderFrameSize(width, height);}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?GetRenderFrameSize@OBS@@QBEXAAI0@Z	; OBS::GetRenderFrameSize
	mov	esp, ebp
	pop	ebp
	ret	8
?GetRenderFrameSize@OBSAPIInterface@@UBEXAAI0@Z ENDP	; OBSAPIInterface::GetRenderFrameSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetRenderFrameOffset@OBSAPIInterface@@UBEXAAI0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?GetRenderFrameOffset@OBSAPIInterface@@UBEXAAI0@Z PROC	; OBSAPIInterface::GetRenderFrameOffset, COMDAT
; _this$ = ecx

; 570  :     virtual void GetRenderFrameOffset(UINT &x, UINT &y) const               {App->GetRenderFrameOffset(x, y);}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?GetRenderFrameOffset@OBS@@QBEXAAI0@Z	; OBS::GetRenderFrameOffset
	mov	esp, ebp
	pop	ebp
	ret	8
?GetRenderFrameOffset@OBSAPIInterface@@UBEXAAI0@Z ENDP	; OBSAPIInterface::GetRenderFrameOffset
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetRenderFrameControlSize@OBSAPIInterface@@UBEXAAI0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_width$ = 8						; size = 4
_height$ = 12						; size = 4
?GetRenderFrameControlSize@OBSAPIInterface@@UBEXAAI0@Z PROC ; OBSAPIInterface::GetRenderFrameControlSize, COMDAT
; _this$ = ecx

; 571  :     virtual void GetRenderFrameControlSize(UINT &width, UINT &height) const {App->GetRenderFrameControlSize(width, height);}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?GetRenderFrameControlSize@OBS@@QBEXAAI0@Z ; OBS::GetRenderFrameControlSize
	mov	esp, ebp
	pop	ebp
	ret	8
?GetRenderFrameControlSize@OBSAPIInterface@@UBEXAAI0@Z ENDP ; OBSAPIInterface::GetRenderFrameControlSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetOutputSize@OBSAPIInterface@@UBEXAAI0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_width$ = 8						; size = 4
_height$ = 12						; size = 4
?GetOutputSize@OBSAPIInterface@@UBEXAAI0@Z PROC		; OBSAPIInterface::GetOutputSize, COMDAT
; _this$ = ecx

; 572  :     virtual void GetOutputSize(UINT &width, UINT &height) const             {App->GetOutputSize(width, height);}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?GetOutputSize@OBS@@QBEXAAI0@Z		; OBS::GetOutputSize
	mov	esp, ebp
	pop	ebp
	ret	8
?GetOutputSize@OBSAPIInterface@@UBEXAAI0@Z ENDP		; OBSAPIInterface::GetOutputSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?MapWindowToFramePos@OBSAPIInterface@@UBE?AUVect2@@U2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_mousePos$ = 12						; size = 8
?MapWindowToFramePos@OBSAPIInterface@@UBE?AUVect2@@U2@@Z PROC ; OBSAPIInterface::MapWindowToFramePos, COMDAT
; _this$ = ecx

; 574  :     virtual Vect2 MapWindowToFramePos(Vect2 mousePos) const     {return App->MapWindowToFramePos(mousePos);}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	sub	esp, 8
	mov	ecx, esp
	lea	eax, DWORD PTR _mousePos$[ebp]
	push	eax
	call	DWORD PTR __imp_??0Vect2@@QAE@ABU0@@Z
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	?MapWindowToFramePos@OBS@@CA?AUVect2@@U2@@Z ; OBS::MapWindowToFramePos
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?MapWindowToFramePos@OBSAPIInterface@@UBE?AUVect2@@U2@@Z ENDP ; OBSAPIInterface::MapWindowToFramePos
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?MapFrameToWindowPos@OBSAPIInterface@@UBE?AUVect2@@U2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_framePos$ = 12						; size = 8
?MapFrameToWindowPos@OBSAPIInterface@@UBE?AUVect2@@U2@@Z PROC ; OBSAPIInterface::MapFrameToWindowPos, COMDAT
; _this$ = ecx

; 575  :     virtual Vect2 MapFrameToWindowPos(Vect2 framePos) const     {return App->MapFrameToWindowPos(framePos);}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	sub	esp, 8
	mov	ecx, esp
	lea	eax, DWORD PTR _framePos$[ebp]
	push	eax
	call	DWORD PTR __imp_??0Vect2@@QAE@ABU0@@Z
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	?MapFrameToWindowPos@OBS@@CA?AUVect2@@U2@@Z ; OBS::MapFrameToWindowPos
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?MapFrameToWindowPos@OBSAPIInterface@@UBE?AUVect2@@U2@@Z ENDP ; OBSAPIInterface::MapFrameToWindowPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?MapWindowToFrameSize@OBSAPIInterface@@UBE?AUVect2@@U2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_windowSize$ = 12					; size = 8
?MapWindowToFrameSize@OBSAPIInterface@@UBE?AUVect2@@U2@@Z PROC ; OBSAPIInterface::MapWindowToFrameSize, COMDAT
; _this$ = ecx

; 576  :     virtual Vect2 MapWindowToFrameSize(Vect2 windowSize) const  {return App->MapWindowToFrameSize(windowSize);}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	sub	esp, 8
	mov	ecx, esp
	lea	eax, DWORD PTR _windowSize$[ebp]
	push	eax
	call	DWORD PTR __imp_??0Vect2@@QAE@ABU0@@Z
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	?MapWindowToFrameSize@OBS@@CA?AUVect2@@U2@@Z ; OBS::MapWindowToFrameSize
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?MapWindowToFrameSize@OBSAPIInterface@@UBE?AUVect2@@U2@@Z ENDP ; OBSAPIInterface::MapWindowToFrameSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?MapFrameToWindowSize@OBSAPIInterface@@UBE?AUVect2@@U2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_frameSize$ = 12					; size = 8
?MapFrameToWindowSize@OBSAPIInterface@@UBE?AUVect2@@U2@@Z PROC ; OBSAPIInterface::MapFrameToWindowSize, COMDAT
; _this$ = ecx

; 577  :     virtual Vect2 MapFrameToWindowSize(Vect2 frameSize) const   {return App->MapFrameToWindowSize(frameSize);}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	sub	esp, 8
	mov	ecx, esp
	lea	eax, DWORD PTR _frameSize$[ebp]
	push	eax
	call	DWORD PTR __imp_??0Vect2@@QAE@ABU0@@Z
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	?MapFrameToWindowSize@OBS@@CA?AUVect2@@U2@@Z ; OBS::MapFrameToWindowSize
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?MapFrameToWindowSize@OBSAPIInterface@@UBE?AUVect2@@U2@@Z ENDP ; OBSAPIInterface::MapFrameToWindowSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetWindowToFrameScale@OBSAPIInterface@@UBE?AUVect2@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetWindowToFrameScale@OBSAPIInterface@@UBE?AUVect2@@XZ PROC ; OBSAPIInterface::GetWindowToFrameScale, COMDAT
; _this$ = ecx

; 578  :     virtual Vect2 GetWindowToFrameScale() const                 {return App->GetWindowToFrameScale();}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	?GetWindowToFrameScale@OBS@@CA?AUVect2@@XZ ; OBS::GetWindowToFrameScale
	add	esp, 4
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetWindowToFrameScale@OBSAPIInterface@@UBE?AUVect2@@XZ ENDP ; OBSAPIInterface::GetWindowToFrameScale
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetFrameToWindowScale@OBSAPIInterface@@UBE?AUVect2@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetFrameToWindowScale@OBSAPIInterface@@UBE?AUVect2@@XZ PROC ; OBSAPIInterface::GetFrameToWindowScale, COMDAT
; _this$ = ecx

; 579  :     virtual Vect2 GetFrameToWindowScale() const                 {return App->GetFrameToWindowScale();}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	?GetFrameToWindowScale@OBS@@CA?AUVect2@@XZ ; OBS::GetFrameToWindowScale
	add	esp, 4
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetFrameToWindowScale@OBSAPIInterface@@UBE?AUVect2@@XZ ENDP ; OBSAPIInterface::GetFrameToWindowScale
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetMaxFPS@OBSAPIInterface@@UBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv73 = -4						; size = 4
?GetMaxFPS@OBSAPIInterface@@UBEIXZ PROC			; OBSAPIInterface::GetMaxFPS, COMDAT
; _this$ = ecx

; 581  :     virtual UINT GetMaxFPS() const                  {return App->bRunning ? App->fps : AppConfig->GetInt(TEXT("Video"), TEXT("FPS"), 30);}

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	movzx	ecx, BYTE PTR [eax+622]
	test	ecx, ecx
	je	SHORT $LN3@GetMaxFPS
	mov	edx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	eax, DWORD PTR [edx+892]
	mov	DWORD PTR tv73[ebp], eax
	jmp	SHORT $LN4@GetMaxFPS
$LN3@GetMaxFPS:
	push	30					; 0000001eH
	push	OFFSET ??_C@_17KABJEDEH@?$AAF?$AAP?$AAS?$AA?$AA@
	push	OFFSET ??_C@_1M@BFEDDODL@?$AAV?$AAi?$AAd?$AAe?$AAo?$AA?$AA@
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR tv73[ebp], eax
$LN4@GetMaxFPS:
	mov	eax, DWORD PTR tv73[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMaxFPS@OBSAPIInterface@@UBEIXZ ENDP			; OBSAPIInterface::GetMaxFPS
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetRenderFrameIn1To1Mode@OBSAPIInterface@@UBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRenderFrameIn1To1Mode@OBSAPIInterface@@UBE_NXZ PROC	; OBSAPIInterface::GetRenderFrameIn1To1Mode, COMDAT
; _this$ = ecx

; 582  :     virtual bool GetRenderFrameIn1To1Mode() const   {return App->renderFrameIn1To1Mode;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	al, BYTE PTR [eax+668]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetRenderFrameIn1To1Mode@OBSAPIInterface@@UBE_NXZ ENDP	; OBSAPIInterface::GetRenderFrameIn1To1Mode
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetLanguage@OBSAPIInterface@@UBEPB_WXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLanguage@OBSAPIInterface@@UBEPB_WXZ PROC		; OBSAPIInterface::GetLanguage, COMDAT
; _this$ = ecx

; 584  :     virtual CTSTR GetLanguage() const           {return App->strLanguage;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	add	ecx, 612				; 00000264H
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLanguage@OBSAPIInterface@@UBEPB_WXZ ENDP		; OBSAPIInterface::GetLanguage
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetAppDataPath@OBSAPIInterface@@UBEPB_WXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAppDataPath@OBSAPIInterface@@UBEPB_WXZ PROC		; OBSAPIInterface::GetAppDataPath, COMDAT
; _this$ = ecx

; 586  :     virtual CTSTR GetAppDataPath() const        {return lpAppDataPath;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?lpAppDataPath@@3PA_WA	; lpAppDataPath
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAppDataPath@OBSAPIInterface@@UBEPB_WXZ ENDP		; OBSAPIInterface::GetAppDataPath
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetPluginDataPath@OBSAPIInterface@@UBE?AVString@@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetPluginDataPath@OBSAPIInterface@@UBE?AVString@@XZ PROC ; OBSAPIInterface::GetPluginDataPath, COMDAT
; _this$ = ecx

; 587  :     virtual String GetPluginDataPath() const    {return String() << lpAppDataPath << TEXT("\\pluginData");}

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET ??_C@_1BI@DLGNLDGJ@?$AA?2?$AAp?$AAl?$AAu?$AAg?$AAi?$AAn?$AAD?$AAa?$AAt?$AAa?$AA?$AA@
	push	OFFSET ?lpAppDataPath@@3PA_WA		; lpAppDataPath
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0String@@QAE@ABV0@@Z
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetPluginDataPath@OBSAPIInterface@@UBE?AVString@@XZ ENDP ; OBSAPIInterface::GetPluginDataPath
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetMainWindow@OBSAPIInterface@@UBEPAUHWND__@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMainWindow@OBSAPIInterface@@UBEPAUHWND__@@XZ PROC	; OBSAPIInterface::GetMainWindow, COMDAT
; _this$ = ecx

; 589  :     virtual HWND GetMainWindow() const          {return hwndMain;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMainWindow@OBSAPIInterface@@UBEPAUHWND__@@XZ ENDP	; OBSAPIInterface::GetMainWindow
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?AddStreamInfo@OBSAPIInterface@@UAEIPB_WW4StreamInfoPriority@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpInfo$ = 8						; size = 4
_priority$ = 12						; size = 4
?AddStreamInfo@OBSAPIInterface@@UAEIPB_WW4StreamInfoPriority@@@Z PROC ; OBSAPIInterface::AddStreamInfo, COMDAT
; _this$ = ecx

; 591  :     virtual UINT AddStreamInfo(CTSTR lpInfo, StreamInfoPriority priority)           {return App->AddStreamInfo(lpInfo, priority);}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _priority$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpInfo$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?AddStreamInfo@OBS@@QAEIPB_WW4StreamInfoPriority@@@Z ; OBS::AddStreamInfo
	mov	esp, ebp
	pop	ebp
	ret	8
?AddStreamInfo@OBSAPIInterface@@UAEIPB_WW4StreamInfoPriority@@@Z ENDP ; OBSAPIInterface::AddStreamInfo
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?SetStreamInfo@OBSAPIInterface@@UAEXIPB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_infoID$ = 8						; size = 4
_lpInfo$ = 12						; size = 4
?SetStreamInfo@OBSAPIInterface@@UAEXIPB_W@Z PROC	; OBSAPIInterface::SetStreamInfo, COMDAT
; _this$ = ecx

; 592  :     virtual void SetStreamInfo(UINT infoID, CTSTR lpInfo)                           {App->SetStreamInfo(infoID, lpInfo);}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _lpInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _infoID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?SetStreamInfo@OBS@@QAEXIPB_W@Z		; OBS::SetStreamInfo
	mov	esp, ebp
	pop	ebp
	ret	8
?SetStreamInfo@OBSAPIInterface@@UAEXIPB_W@Z ENDP	; OBSAPIInterface::SetStreamInfo
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?SetStreamInfoPriority@OBSAPIInterface@@UAEXIW4StreamInfoPriority@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_infoID$ = 8						; size = 4
_priority$ = 12						; size = 4
?SetStreamInfoPriority@OBSAPIInterface@@UAEXIW4StreamInfoPriority@@@Z PROC ; OBSAPIInterface::SetStreamInfoPriority, COMDAT
; _this$ = ecx

; 593  :     virtual void SetStreamInfoPriority(UINT infoID, StreamInfoPriority priority)    {App->SetStreamInfoPriority(infoID, priority);}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _priority$[ebp]
	push	eax
	mov	ecx, DWORD PTR _infoID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?SetStreamInfoPriority@OBS@@QAEXIW4StreamInfoPriority@@@Z ; OBS::SetStreamInfoPriority
	mov	esp, ebp
	pop	ebp
	ret	8
?SetStreamInfoPriority@OBSAPIInterface@@UAEXIW4StreamInfoPriority@@@Z ENDP ; OBSAPIInterface::SetStreamInfoPriority
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?RemoveStreamInfo@OBSAPIInterface@@UAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_infoID$ = 8						; size = 4
?RemoveStreamInfo@OBSAPIInterface@@UAEXI@Z PROC		; OBSAPIInterface::RemoveStreamInfo, COMDAT
; _this$ = ecx

; 594  :     virtual void RemoveStreamInfo(UINT infoID)                                      {App->RemoveStreamInfo(infoID);}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _infoID$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?RemoveStreamInfo@OBS@@QAEXI@Z		; OBS::RemoveStreamInfo
	mov	esp, ebp
	pop	ebp
	ret	4
?RemoveStreamInfo@OBSAPIInterface@@UAEXI@Z ENDP		; OBSAPIInterface::RemoveStreamInfo
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?UseMultithreadedOptimizations@OBSAPIInterface@@UBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?UseMultithreadedOptimizations@OBSAPIInterface@@UBE_NXZ PROC ; OBSAPIInterface::UseMultithreadedOptimizations, COMDAT
; _this$ = ecx

; 596  :     virtual bool UseMultithreadedOptimizations() const {return App->bUseMultithreadedOptimizations;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	al, BYTE PTR [eax+621]
	mov	esp, ebp
	pop	ebp
	ret	0
?UseMultithreadedOptimizations@OBSAPIInterface@@UBE_NXZ ENDP ; OBSAPIInterface::UseMultithreadedOptimizations
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?AddAudioSource@OBSAPIInterface@@UAEXPAVAudioSource@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_source$ = 8						; size = 4
?AddAudioSource@OBSAPIInterface@@UAEXPAVAudioSource@@@Z PROC ; OBSAPIInterface::AddAudioSource, COMDAT
; _this$ = ecx

; 598  :     virtual void AddAudioSource(AudioSource *source) {App->AddAudioSource(source);}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _source$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?AddAudioSource@OBS@@QAEXPAVAudioSource@@@Z ; OBS::AddAudioSource
	mov	esp, ebp
	pop	ebp
	ret	4
?AddAudioSource@OBSAPIInterface@@UAEXPAVAudioSource@@@Z ENDP ; OBSAPIInterface::AddAudioSource
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?RemoveAudioSource@OBSAPIInterface@@UAEXPAVAudioSource@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_source$ = 8						; size = 4
?RemoveAudioSource@OBSAPIInterface@@UAEXPAVAudioSource@@@Z PROC ; OBSAPIInterface::RemoveAudioSource, COMDAT
; _this$ = ecx

; 599  :     virtual void RemoveAudioSource(AudioSource *source) {App->RemoveAudioSource(source);}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _source$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?RemoveAudioSource@OBS@@QAEXPAVAudioSource@@@Z ; OBS::RemoveAudioSource
	mov	esp, ebp
	pop	ebp
	ret	4
?RemoveAudioSource@OBSAPIInterface@@UAEXPAVAudioSource@@@Z ENDP ; OBSAPIInterface::RemoveAudioSource
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetAudioTime@OBSAPIInterface@@UBE_KXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAudioTime@OBSAPIInterface@@UBE_KXZ PROC		; OBSAPIInterface::GetAudioTime, COMDAT
; _this$ = ecx

; 601  :     virtual QWORD GetAudioTime() const          {return App->GetAudioTime();}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?GetAudioTime@OBS@@QBE_KXZ		; OBS::GetAudioTime
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAudioTime@OBSAPIInterface@@UBE_KXZ ENDP		; OBSAPIInterface::GetAudioTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetAppPath@OBSAPIInterface@@UBEPB_WXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAppPath@OBSAPIInterface@@UBEPB_WXZ PROC		; OBSAPIInterface::GetAppPath, COMDAT
; _this$ = ecx

; 603  :     virtual CTSTR GetAppPath() const            {return lpAppPath;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?lpAppPath@@3PA_WA		; lpAppPath
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAppPath@OBSAPIInterface@@UBEPB_WXZ ENDP		; OBSAPIInterface::GetAppPath
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?SetDesktopVolume@OBSAPIInterface@@UAEXM_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_val$ = 8						; size = 4
_finalValue$ = 12					; size = 1
?SetDesktopVolume@OBSAPIInterface@@UAEXM_N@Z PROC	; OBSAPIInterface::SetDesktopVolume, COMDAT
; _this$ = ecx

; 605  :     virtual void SetDesktopVolume(float val, bool finalValue)        {App->SetDesktopVolume(val, finalValue);}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	movzx	eax, BYTE PTR _finalValue$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _val$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	eax, DWORD PTR [edx+36]
	call	eax
	mov	esp, ebp
	pop	ebp
	ret	8
?SetDesktopVolume@OBSAPIInterface@@UAEXM_N@Z ENDP	; OBSAPIInterface::SetDesktopVolume
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetDesktopVolume@OBSAPIInterface@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDesktopVolume@OBSAPIInterface@@UAEMXZ PROC		; OBSAPIInterface::GetDesktopVolume, COMDAT
; _this$ = ecx

; 606  :     virtual float GetDesktopVolume()                                 {return App->GetDesktopVolume();}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	eax, DWORD PTR [edx+40]
	call	eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDesktopVolume@OBSAPIInterface@@UAEMXZ ENDP		; OBSAPIInterface::GetDesktopVolume
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?ToggleDesktopMute@OBSAPIInterface@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ToggleDesktopMute@OBSAPIInterface@@UAEXXZ PROC		; OBSAPIInterface::ToggleDesktopMute, COMDAT
; _this$ = ecx

; 607  :     virtual void ToggleDesktopMute()                                 {App->ToggleDesktopMute();}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	eax, DWORD PTR [edx+44]
	call	eax
	mov	esp, ebp
	pop	ebp
	ret	0
?ToggleDesktopMute@OBSAPIInterface@@UAEXXZ ENDP		; OBSAPIInterface::ToggleDesktopMute
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetDesktopMuted@OBSAPIInterface@@UAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDesktopMuted@OBSAPIInterface@@UAE_NXZ PROC		; OBSAPIInterface::GetDesktopMuted, COMDAT
; _this$ = ecx

; 608  :     virtual bool GetDesktopMuted()                                   {return App->GetDesktopMuted();}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	eax, DWORD PTR [edx+48]
	call	eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDesktopMuted@OBSAPIInterface@@UAE_NXZ ENDP		; OBSAPIInterface::GetDesktopMuted
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?SetMicVolume@OBSAPIInterface@@UAEXM_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_val$ = 8						; size = 4
_finalValue$ = 12					; size = 1
?SetMicVolume@OBSAPIInterface@@UAEXM_N@Z PROC		; OBSAPIInterface::SetMicVolume, COMDAT
; _this$ = ecx

; 610  :     virtual void SetMicVolume(float val, bool finalValue)            {App->SetMicVolume(val, finalValue);}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	movzx	eax, BYTE PTR _finalValue$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _val$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	eax, DWORD PTR [edx+52]
	call	eax
	mov	esp, ebp
	pop	ebp
	ret	8
?SetMicVolume@OBSAPIInterface@@UAEXM_N@Z ENDP		; OBSAPIInterface::SetMicVolume
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetMicVolume@OBSAPIInterface@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMicVolume@OBSAPIInterface@@UAEMXZ PROC		; OBSAPIInterface::GetMicVolume, COMDAT
; _this$ = ecx

; 611  :     virtual float GetMicVolume()                                     {return App->GetMicVolume();}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	eax, DWORD PTR [edx+56]
	call	eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMicVolume@OBSAPIInterface@@UAEMXZ ENDP		; OBSAPIInterface::GetMicVolume
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?ToggleMicMute@OBSAPIInterface@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ToggleMicMute@OBSAPIInterface@@UAEXXZ PROC		; OBSAPIInterface::ToggleMicMute, COMDAT
; _this$ = ecx

; 612  :     virtual void ToggleMicMute()                                     {App->ToggleMicMute();}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	eax, DWORD PTR [edx+60]
	call	eax
	mov	esp, ebp
	pop	ebp
	ret	0
?ToggleMicMute@OBSAPIInterface@@UAEXXZ ENDP		; OBSAPIInterface::ToggleMicMute
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetMicMuted@OBSAPIInterface@@UAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMicMuted@OBSAPIInterface@@UAE_NXZ PROC		; OBSAPIInterface::GetMicMuted, COMDAT
; _this$ = ecx

; 613  :     virtual bool GetMicMuted()                                       {return App->GetMicMuted();}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	eax, DWORD PTR [edx+64]
	call	eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMicMuted@OBSAPIInterface@@UAE_NXZ ENDP		; OBSAPIInterface::GetMicMuted
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetOBSVersion@OBSAPIInterface@@UBEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetOBSVersion@OBSAPIInterface@@UBEKXZ PROC		; OBSAPIInterface::GetOBSVersion, COMDAT
; _this$ = ecx

; 615  :     virtual DWORD GetOBSVersion() const {return OBS_VERSION;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 25863				; 00006507H
	mov	esp, ebp
	pop	ebp
	ret	0
?GetOBSVersion@OBSAPIInterface@@UBEKXZ ENDP		; OBSAPIInterface::GetOBSVersion
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?IsTestVersion@OBSAPIInterface@@UBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsTestVersion@OBSAPIInterface@@UBE_NXZ PROC		; OBSAPIInterface::IsTestVersion, COMDAT
; _this$ = ecx

; 620  :     virtual bool IsTestVersion() const {return 0;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	al, al
	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestVersion@OBSAPIInterface@@UBE_NXZ ENDP		; OBSAPIInterface::IsTestVersion
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?NumAuxAudioSources@OBSAPIInterface@@UBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?NumAuxAudioSources@OBSAPIInterface@@UBEIXZ PROC	; OBSAPIInterface::NumAuxAudioSources, COMDAT
; _this$ = ecx

; 624  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 625  :         return App->auxAudioSources.Num();

	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	add	ecx, 120				; 00000078H
	call	?Num@?$List@PAVAudioSource@@@@QBEIXZ	; List<AudioSource *>::Num

; 626  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?NumAuxAudioSources@OBSAPIInterface@@UBEIXZ ENDP	; OBSAPIInterface::NumAuxAudioSources
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetAuxAudioSource@OBSAPIInterface@@UAEPAVAudioSource@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_id$ = 8						; size = 4
?GetAuxAudioSource@OBSAPIInterface@@UAEPAVAudioSource@@I@Z PROC ; OBSAPIInterface::GetAuxAudioSource, COMDAT
; _this$ = ecx

; 629  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 630  :         if(App->auxAudioSources.Num() > id)

	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	add	ecx, 120				; 00000078H
	call	?Num@?$List@PAVAudioSource@@@@QBEIXZ	; List<AudioSource *>::Num
	cmp	eax, DWORD PTR _id$[ebp]
	jbe	SHORT $LN1@GetAuxAudi

; 631  :             return App->auxAudioSources[id];

	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	add	ecx, 120				; 00000078H
	call	??A?$List@PAVAudioSource@@@@QAEAAPAVAudioSource@@I@Z ; List<AudioSource *>::operator[]
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN2@GetAuxAudi
$LN1@GetAuxAudi:

; 632  : 
; 633  :         AppWarning(TEXT("Tried to get an aux audio source that doesn't exist!"));

	push	OFFSET ??_C@_1GK@DMMFIDMP@?$AAT?$AAr?$AAi?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAg?$AAe?$AAt?$AA?5?$AAa?$AAn?$AA?5?$AAa?$AAu?$AAx?$AA?5?$AAa?$AAu?$AAd?$AAi?$AAo?$AA?5?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe@
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 4

; 634  :         return NULL;

	xor	eax, eax
$LN2@GetAuxAudi:

; 635  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetAuxAudioSource@OBSAPIInterface@@UAEPAVAudioSource@@I@Z ENDP ; OBSAPIInterface::GetAuxAudioSource
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetDesktopAudioSource@OBSAPIInterface@@UAEPAVAudioSource@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDesktopAudioSource@OBSAPIInterface@@UAEPAVAudioSource@@XZ PROC ; OBSAPIInterface::GetDesktopAudioSource, COMDAT
; _this$ = ecx

; 637  :     virtual AudioSource* GetDesktopAudioSource()    {return App->desktopAudio;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	eax, DWORD PTR [eax+112]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDesktopAudioSource@OBSAPIInterface@@UAEPAVAudioSource@@XZ ENDP ; OBSAPIInterface::GetDesktopAudioSource
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetMicAudioSource@OBSAPIInterface@@UAEPAVAudioSource@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMicAudioSource@OBSAPIInterface@@UAEPAVAudioSource@@XZ PROC ; OBSAPIInterface::GetMicAudioSource, COMDAT
; _this$ = ecx

; 638  :     virtual AudioSource* GetMicAudioSource()        {return App->micAudio;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	eax, DWORD PTR [eax+116]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMicAudioSource@OBSAPIInterface@@UAEPAVAudioSource@@XZ ENDP ; OBSAPIInterface::GetMicAudioSource
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetCurDesktopVolumeStats@OBSAPIInterface@@UBEXPAM00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rms$ = 8						; size = 4
_max$ = 12						; size = 4
_peak$ = 16						; size = 4
?GetCurDesktopVolumeStats@OBSAPIInterface@@UBEXPAM00@Z PROC ; OBSAPIInterface::GetCurDesktopVolumeStats, COMDAT
; _this$ = ecx

; 641  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  :         *rms = App->desktopMag;

	mov	eax, DWORD PTR _rms$[ebp]
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	edx, DWORD PTR [ecx+1200]
	mov	DWORD PTR [eax], edx

; 643  :         *max = App->desktopMax;

	mov	eax, DWORD PTR _max$[ebp]
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	edx, DWORD PTR [ecx+1192]
	mov	DWORD PTR [eax], edx

; 644  :         *peak = App->desktopPeak;

	mov	eax, DWORD PTR _peak$[ebp]
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	edx, DWORD PTR [ecx+1184]
	mov	DWORD PTR [eax], edx

; 645  :     }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetCurDesktopVolumeStats@OBSAPIInterface@@UBEXPAM00@Z ENDP ; OBSAPIInterface::GetCurDesktopVolumeStats
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetCurMicVolumeStats@OBSAPIInterface@@UBEXPAM00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rms$ = 8						; size = 4
_max$ = 12						; size = 4
_peak$ = 16						; size = 4
?GetCurMicVolumeStats@OBSAPIInterface@@UBEXPAM00@Z PROC	; OBSAPIInterface::GetCurMicVolumeStats, COMDAT
; _this$ = ecx

; 648  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 649  :         *rms = App->micMag;

	mov	eax, DWORD PTR _rms$[ebp]
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	edx, DWORD PTR [ecx+1204]
	mov	DWORD PTR [eax], edx

; 650  :         *max = App->micMax;

	mov	eax, DWORD PTR _max$[ebp]
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	edx, DWORD PTR [ecx+1196]
	mov	DWORD PTR [eax], edx

; 651  :         *peak = App->micPeak;

	mov	eax, DWORD PTR _peak$[ebp]
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	edx, DWORD PTR [ecx+1188]
	mov	DWORD PTR [eax], edx

; 652  :     }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetCurMicVolumeStats@OBSAPIInterface@@UBEXPAM00@Z ENDP	; OBSAPIInterface::GetCurMicVolumeStats
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?AddSettingsPane@OBSAPIInterface@@UAEXPAVSettingsPane@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pane$ = 8						; size = 4
?AddSettingsPane@OBSAPIInterface@@UAEXPAVSettingsPane@@@Z PROC ; OBSAPIInterface::AddSettingsPane, COMDAT
; _this$ = ecx

; 654  :     virtual void AddSettingsPane(SettingsPane *pane)    {App->AddSettingsPane(pane);}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _pane$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?AddSettingsPane@OBS@@QAEXPAVSettingsPane@@@Z ; OBS::AddSettingsPane
	mov	esp, ebp
	pop	ebp
	ret	4
?AddSettingsPane@OBSAPIInterface@@UAEXPAVSettingsPane@@@Z ENDP ; OBSAPIInterface::AddSettingsPane
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?RemoveSettingsPane@OBSAPIInterface@@UAEXPAVSettingsPane@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pane$ = 8						; size = 4
?RemoveSettingsPane@OBSAPIInterface@@UAEXPAVSettingsPane@@@Z PROC ; OBSAPIInterface::RemoveSettingsPane, COMDAT
; _this$ = ecx

; 655  :     virtual void RemoveSettingsPane(SettingsPane *pane) {App->RemoveSettingsPane(pane);}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _pane$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?RemoveSettingsPane@OBS@@QAEXPAVSettingsPane@@@Z ; OBS::RemoveSettingsPane
	mov	esp, ebp
	pop	ebp
	ret	4
?RemoveSettingsPane@OBSAPIInterface@@UAEXPAVSettingsPane@@@Z ENDP ; OBSAPIInterface::RemoveSettingsPane
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetSampleRateHz@OBSAPIInterface@@UBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSampleRateHz@OBSAPIInterface@@UBEIXZ PROC		; OBSAPIInterface::GetSampleRateHz, COMDAT
; _this$ = ecx

; 657  :     virtual UINT GetSampleRateHz() const {return App->GetSampleRateHz();}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?GetSampleRateHz@OBS@@QBEIXZ		; OBS::GetSampleRateHz
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSampleRateHz@OBSAPIInterface@@UBEIXZ ENDP		; OBSAPIInterface::GetSampleRateHz
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetCaptureFPS@OBSAPIInterface@@UBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCaptureFPS@OBSAPIInterface@@UBEIXZ PROC		; OBSAPIInterface::GetCaptureFPS, COMDAT
; _this$ = ecx

; 659  :     virtual UINT GetCaptureFPS() const        {return App->captureFPS;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	eax, DWORD PTR [eax+920]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCaptureFPS@OBSAPIInterface@@UBEIXZ ENDP		; OBSAPIInterface::GetCaptureFPS
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetTotalFrames@OBSAPIInterface@@UBEIXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv77 = -8						; size = 4
tv71 = -4						; size = 4
?GetTotalFrames@OBSAPIInterface@@UBEIXZ PROC		; OBSAPIInterface::GetTotalFrames, COMDAT
; _this$ = ecx

; 660  :     virtual UINT GetTotalFrames() const       {return App->network ? App->network->NumTotalVideoFrames() : 0;}

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	add	ecx, 76					; 0000004cH
	call	??B?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QBE_NXZ ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@GetTotalFr
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	add	ecx, 76					; 0000004cH
	call	??C?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QBEPAVNetworkStream@@XZ ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::operator->
	mov	DWORD PTR tv71[ebp], eax
	mov	ecx, DWORD PTR tv71[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv71[ebp]
	mov	eax, DWORD PTR [edx+24]
	call	eax
	mov	DWORD PTR tv77[ebp], eax
	jmp	SHORT $LN4@GetTotalFr
$LN3@GetTotalFr:
	mov	DWORD PTR tv77[ebp], 0
$LN4@GetTotalFr:
	mov	eax, DWORD PTR tv77[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTotalFrames@OBSAPIInterface@@UBEIXZ ENDP		; OBSAPIInterface::GetTotalFrames
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetFramesDropped@OBSAPIInterface@@UBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFramesDropped@OBSAPIInterface@@UBEIXZ PROC		; OBSAPIInterface::GetFramesDropped, COMDAT
; _this$ = ecx

; 661  :     virtual UINT GetFramesDropped() const     {return App->curFramesDropped;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	eax, DWORD PTR [eax+924]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFramesDropped@OBSAPIInterface@@UBEIXZ ENDP		; OBSAPIInterface::GetFramesDropped
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetTotalStreamTime@OBSAPIInterface@@UBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTotalStreamTime@OBSAPIInterface@@UBEIXZ PROC	; OBSAPIInterface::GetTotalStreamTime, COMDAT
; _this$ = ecx

; 662  :     virtual UINT GetTotalStreamTime() const   {return App->totalStreamTime;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	eax, DWORD PTR [eax+928]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTotalStreamTime@OBSAPIInterface@@UBEIXZ ENDP	; OBSAPIInterface::GetTotalStreamTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetBytesPerSec@OBSAPIInterface@@UBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBytesPerSec@OBSAPIInterface@@UBEIXZ PROC		; OBSAPIInterface::GetBytesPerSec, COMDAT
; _this$ = ecx

; 663  :     virtual UINT GetBytesPerSec() const       {return App->bytesPerSec;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	eax, DWORD PTR [eax+916]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBytesPerSec@OBSAPIInterface@@UBEIXZ ENDP		; OBSAPIInterface::GetBytesPerSec
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?SetSceneCollection@OBSAPIInterface@@UAE_NPB_W0@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_success$ = -1						; size = 1
_lpCollection$ = 8					; size = 4
_lpScene$ = 12						; size = 4
?SetSceneCollection@OBSAPIInterface@@UAE_NPB_W0@Z PROC	; OBSAPIInterface::SetSceneCollection, COMDAT
; _this$ = ecx

; 666  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 667  :         assert(lpCollection && *lpCollection);
; 668  : 
; 669  :         if (!lpCollection || !*lpCollection)

	cmp	DWORD PTR _lpCollection$[ebp], 0
	je	SHORT $LN2@SetSceneCo
	mov	eax, DWORD PTR _lpCollection$[ebp]
	movzx	ecx, WORD PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@SetSceneCo
$LN2@SetSceneCo:

; 670  :             return false;

	xor	al, al
	jmp	SHORT $LN4@SetSceneCo
$LN3@SetSceneCo:

; 671  : 
; 672  :         bool success = App->SetSceneCollection(lpCollection);

	mov	edx, DWORD PTR _lpCollection$[ebp]
	push	edx
	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	eax, DWORD PTR [edx+32]
	call	eax
	mov	BYTE PTR _success$[ebp], al

; 673  :         if (lpScene != NULL && success)

	cmp	DWORD PTR _lpScene$[ebp], 0
	je	SHORT $LN1@SetSceneCo
	movzx	ecx, BYTE PTR _success$[ebp]
	test	ecx, ecx
	je	SHORT $LN1@SetSceneCo

; 674  :         {
; 675  :             SetScene(lpScene, true);

	push	1
	mov	edx, DWORD PTR _lpScene$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	call	eax
$LN1@SetSceneCo:

; 676  :         }
; 677  : 
; 678  :         return success;

	mov	al, BYTE PTR _success$[ebp]
$LN4@SetSceneCo:

; 679  :     }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetSceneCollection@OBSAPIInterface@@UAE_NPB_W0@Z ENDP	; OBSAPIInterface::SetSceneCollection
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetSceneCollectionName@OBSAPIInterface@@UBEPB_WXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSceneCollectionName@OBSAPIInterface@@UBEPB_WXZ PROC	; OBSAPIInterface::GetSceneCollectionName, COMDAT
; _this$ = ecx

; 680  :     virtual CTSTR GetSceneCollectionName() const { return App->GetCurrentSceneCollection(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	call	?GetCurrentSceneCollection@OBS@@SAPB_WXZ ; OBS::GetCurrentSceneCollection
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSceneCollectionName@OBSAPIInterface@@UBEPB_WXZ ENDP	; OBSAPIInterface::GetSceneCollectionName
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetSceneCollectionNames@OBSAPIInterface@@UBEXAAVStringList@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_list$ = 8						; size = 4
?GetSceneCollectionNames@OBSAPIInterface@@UBEXAAVStringList@@@Z PROC ; OBSAPIInterface::GetSceneCollectionNames, COMDAT
; _this$ = ecx

; 681  :     virtual void GetSceneCollectionNames(StringList &list) const { return App->GetSceneCollection(list); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _list$[ebp]
	push	eax
	call	?GetSceneCollection@OBS@@SAXAAVStringList@@@Z ; OBS::GetSceneCollection
	add	esp, 4
	mov	esp, ebp
	pop	ebp
	ret	4
?GetSceneCollectionNames@OBSAPIInterface@@UBEXAAVStringList@@@Z ENDP ; OBSAPIInterface::GetSceneCollectionNames
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?DisableTransitions@OBSAPIInterface@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DisableTransitions@OBSAPIInterface@@UAEXXZ PROC	; OBSAPIInterface::DisableTransitions, COMDAT
; _this$ = ecx

; 682  :     virtual void DisableTransitions()          { App->performTransition = false; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	BYTE PTR [eax+44], 0
	mov	esp, ebp
	pop	ebp
	ret	0
?DisableTransitions@OBSAPIInterface@@UAEXXZ ENDP	; OBSAPIInterface::DisableTransitions
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?EnableTransitions@OBSAPIInterface@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?EnableTransitions@OBSAPIInterface@@UAEXXZ PROC		; OBSAPIInterface::EnableTransitions, COMDAT
; _this$ = ecx

; 683  :     virtual void EnableTransitions()           { App->performTransition = true; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	BYTE PTR [eax+44], 1
	mov	esp, ebp
	pop	ebp
	ret	0
?EnableTransitions@OBSAPIInterface@@UAEXXZ ENDP		; OBSAPIInterface::EnableTransitions
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?TransitionsEnabled@OBSAPIInterface@@UBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?TransitionsEnabled@OBSAPIInterface@@UBE_NXZ PROC	; OBSAPIInterface::TransitionsEnabled, COMDAT
; _this$ = ecx

; 684  :     virtual bool TransitionsEnabled() const    { return App->performTransition; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	al, BYTE PTR [eax+44]
	mov	esp, ebp
	pop	ebp
	ret	0
?TransitionsEnabled@OBSAPIInterface@@UBE_NXZ ENDP	; OBSAPIInterface::TransitionsEnabled
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?CreateOBSApiInterface@@YAPAVAPIInterface@@XZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
$T1 = -4						; size = 4
?CreateOBSApiInterface@@YAPAVAPIInterface@@XZ PROC	; CreateOBSApiInterface, COMDAT

; 688  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 689  :     return new OBSAPIInterface;

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN3@CreateOBSA
	mov	ecx, DWORD PTR $T1[ebp]
	call	??0OBSAPIInterface@@QAE@XZ
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@CreateOBSA
$LN3@CreateOBSA:
	mov	DWORD PTR tv72[ebp], 0
$LN4@CreateOBSA:
	mov	eax, DWORD PTR tv72[ebp]

; 690  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CreateOBSApiInterface@@YAPAVAPIInterface@@XZ ENDP	; CreateOBSApiInterface
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0OBSAPIInterface@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0OBSAPIInterface@@QAE@XZ PROC				; OBSAPIInterface::OBSAPIInterface, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0APIInterface@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7OBSAPIInterface@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0?$List@UHotkeyInfo@@@@QAE@XZ		; List<HotkeyInfo>::List<HotkeyInfo>
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0OBSAPIInterface@@QAE@XZ ENDP				; OBSAPIInterface::OBSAPIInterface
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GOBSAPIInterface@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GOBSAPIInterface@@UAEPAXI@Z PROC			; OBSAPIInterface::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1OBSAPIInterface@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GOBSAPIInterface@@UAEPAXI@Z ENDP			; OBSAPIInterface::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0APIInterface@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0APIInterface@@QAE@XZ PROC				; APIInterface::APIInterface, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7APIInterface@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0APIInterface@@QAE@XZ ENDP				; APIInterface::APIInterface
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1OBSAPIInterface@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1OBSAPIInterface@@UAE@XZ PROC				; OBSAPIInterface::~OBSAPIInterface, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??1?$List@UHotkeyInfo@@@@QAE@XZ		; List<HotkeyInfo>::~List<HotkeyInfo>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1APIInterface@@UAE@XZ			; APIInterface::~APIInterface
	mov	esp, ebp
	pop	ebp
	ret	0
??1OBSAPIInterface@@UAE@XZ ENDP				; OBSAPIInterface::~OBSAPIInterface
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?SceneHotkey@@YGXKK_N@Z
_TEXT	SEGMENT
_sceneHotkey$1 = -20					; size = 4
_numScenes$2 = -16					; size = 4
_scene$3 = -12						; size = 4
_scenes$ = -8						; size = 4
_i$4 = -4						; size = 4
_hotkey$ = 8						; size = 4
_param$ = 12						; size = 4
_bDown$ = 16						; size = 1
?SceneHotkey@@YGXKK_N@Z PROC				; SceneHotkey, COMDAT

; 694  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 695  :     if(!bDown) return;

	movzx	eax, BYTE PTR _bDown$[ebp]
	test	eax, eax
	jne	SHORT $LN6@SceneHotke
	jmp	$LN7@SceneHotke
$LN6@SceneHotke:

; 696  : 
; 697  :     XElement *scenes = API->GetSceneListElement();

	mov	ecx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+28]
	call	eax
	mov	DWORD PTR _scenes$[ebp], eax

; 698  :     if(scenes)

	cmp	DWORD PTR _scenes$[ebp], 0
	je	SHORT $LN7@SceneHotke

; 699  :     {
; 700  :         UINT numScenes = scenes->NumElements();

	push	0
	mov	ecx, DWORD PTR _scenes$[ebp]
	call	DWORD PTR __imp_?NumElements@XElement@@QAEKPB_W@Z
	mov	DWORD PTR _numScenes$2[ebp], eax

; 701  :         for(UINT i=0; i<numScenes; i++)

	mov	DWORD PTR _i$4[ebp], 0
	jmp	SHORT $LN4@SceneHotke
$LN3@SceneHotke:
	mov	ecx, DWORD PTR _i$4[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$4[ebp], ecx
$LN4@SceneHotke:
	mov	edx, DWORD PTR _i$4[ebp]
	cmp	edx, DWORD PTR _numScenes$2[ebp]
	jae	SHORT $LN7@SceneHotke

; 702  :         {
; 703  :             XElement *scene = scenes->GetElementByID(i);

	mov	eax, DWORD PTR _i$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _scenes$[ebp]
	call	DWORD PTR __imp_?GetElementByID@XElement@@QBEPAV1@K@Z
	mov	DWORD PTR _scene$3[ebp], eax

; 704  :             DWORD sceneHotkey = (DWORD)scene->GetInt(TEXT("hotkey"));

	push	0
	push	OFFSET $SG4294966819
	mov	ecx, DWORD PTR _scene$3[ebp]
	call	DWORD PTR __imp_?GetInt@XElement@@QBEHPB_WH@Z
	mov	DWORD PTR _sceneHotkey$1[ebp], eax

; 705  :             if(sceneHotkey == hotkey)

	mov	ecx, DWORD PTR _sceneHotkey$1[ebp]
	cmp	ecx, DWORD PTR _hotkey$[ebp]
	jne	SHORT $LN1@SceneHotke

; 706  :             {
; 707  :                 App->SetScene(scene->GetName());

	mov	ecx, DWORD PTR _scene$3[ebp]
	call	DWORD PTR __imp_?GetName@XBaseItem@@QBEPB_WXZ
	push	eax
	mov	edx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	edx, DWORD PTR [eax+24]
	call	edx

; 708  :                 return;

	jmp	SHORT $LN7@SceneHotke
$LN1@SceneHotke:

; 709  :             }
; 710  :         }

	jmp	SHORT $LN3@SceneHotke
$LN7@SceneHotke:

; 711  :     }
; 712  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SceneHotkey@@YGXKK_N@Z ENDP				; SceneHotkey
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?HotkeyThread@OBS@@CGKPAX@Z
_TEXT	SEGMENT
_lpUseless$ = 8						; size = 4
?HotkeyThread@OBS@@CGKPAX@Z PROC			; OBS::HotkeyThread, COMDAT

; 715  : {

	push	ebp
	mov	ebp, esp
$LN2@HotkeyThre:

; 716  :     //-----------------------------------------------
; 717  :     // check hotkeys.
; 718  :     //   Why are we handling hotkeys like this?  Because RegisterHotkey and WM_HOTKEY
; 719  :     // does not work with fullscreen apps.  Therefore, we use GetAsyncKeyState once
; 720  :     // per frame instead.
; 721  : 
; 722  :     while(!App->bShuttingDown)

	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	movzx	ecx, BYTE PTR [eax+1412]
	test	ecx, ecx
	jne	SHORT $LN1@HotkeyThre

; 723  :     {
; 724  :         static_cast<OBSAPIInterface*>(API)->HandleHotkeys();

	mov	edx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	ecx, DWORD PTR [edx]
	call	?HandleHotkeys@OBSAPIInterface@@AAEXXZ	; OBSAPIInterface::HandleHotkeys

; 725  :         OSSleep(30);

	push	30					; 0000001eH
	call	DWORD PTR __imp_?OSSleep@@YGXK@Z

; 726  :     }

	jmp	SHORT $LN2@HotkeyThre
$LN1@HotkeyThre:

; 727  : 
; 728  :     return 0;

	xor	eax, eax

; 729  : }

	pop	ebp
	ret	4
?HotkeyThread@OBS@@CGKPAX@Z ENDP			; OBS::HotkeyThread
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?CallHotkey@OBS@@AAEXK_N@Z
_TEXT	SEGMENT
_hotkey$ = -28						; size = 4
_param$ = -24						; size = 4
_apiInterface$ = -20					; size = 4
_hotkeyProc$ = -16					; size = 4
_this$ = -12						; size = 4
_i$1 = -8						; size = 4
_hi$2 = -4						; size = 4
_hotkeyID$ = 8						; size = 4
_bDown$ = 12						; size = 1
?CallHotkey@OBS@@AAEXK_N@Z PROC				; OBS::CallHotkey, COMDAT
; _this$ = ecx

; 732  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 733  :     OBSAPIInterface *apiInterface = (OBSAPIInterface*)API;

	mov	eax, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _apiInterface$[ebp], ecx

; 734  :     OBSHOTKEYPROC hotkeyProc = NULL;

	mov	DWORD PTR _hotkeyProc$[ebp], 0

; 735  :     DWORD hotkey = 0;

	mov	DWORD PTR _hotkey$[ebp], 0

; 736  :     UPARAM param = NULL;

	mov	DWORD PTR _param$[ebp], 0

; 737  : 
; 738  :     OSEnterMutex(hHotkeyMutex);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1232]
	push	eax
	call	DWORD PTR __imp_?OSEnterMutex@@YGXPAX@Z

; 739  : 
; 740  :     for(UINT i=0; i<apiInterface->hotkeys.Num(); i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN6@CallHotkey
$LN5@CallHotkey:
	mov	ecx, DWORD PTR _i$1[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$1[ebp], ecx
$LN6@CallHotkey:
	mov	ecx, DWORD PTR _apiInterface$[ebp]
	add	ecx, 4
	call	?Num@?$List@UHotkeyInfo@@@@QBEIXZ	; List<HotkeyInfo>::Num
	cmp	DWORD PTR _i$1[ebp], eax
	jae	SHORT $LN4@CallHotkey

; 741  :     {
; 742  :         HotkeyInfo &hi = apiInterface->hotkeys[i];

	mov	edx, DWORD PTR _i$1[ebp]
	push	edx
	mov	ecx, DWORD PTR _apiInterface$[ebp]
	add	ecx, 4
	call	??A?$List@UHotkeyInfo@@@@QAEAAUHotkeyInfo@@I@Z ; List<HotkeyInfo>::operator[]
	mov	DWORD PTR _hi$2[ebp], eax

; 743  :         if(hi.hotkeyID == hotkeyID)

	mov	eax, DWORD PTR _hi$2[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _hotkeyID$[ebp]
	jne	SHORT $LN3@CallHotkey

; 744  :         {
; 745  :             if (!hi.hotkeyProc)

	mov	edx, DWORD PTR _hi$2[ebp]
	cmp	DWORD PTR [edx+8], 0
	jne	SHORT $LN2@CallHotkey

; 746  :             {
; 747  :                 OSLeaveMutex(hHotkeyMutex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1232]
	push	ecx
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z

; 748  :                 return;

	jmp	SHORT $LN7@CallHotkey
$LN2@CallHotkey:

; 749  :             }
; 750  : 
; 751  :             hotkeyProc  = hi.hotkeyProc;

	mov	edx, DWORD PTR _hi$2[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _hotkeyProc$[ebp], eax

; 752  :             param       = hi.param;

	mov	ecx, DWORD PTR _hi$2[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _param$[ebp], edx

; 753  :             hotkey      = hi.hotkey;

	mov	eax, DWORD PTR _hi$2[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _hotkey$[ebp], ecx

; 754  :             break;

	jmp	SHORT $LN4@CallHotkey
$LN3@CallHotkey:

; 755  :         }
; 756  :     }

	jmp	SHORT $LN5@CallHotkey
$LN4@CallHotkey:

; 757  : 
; 758  :     OSLeaveMutex(hHotkeyMutex);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1232]
	push	eax
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z

; 759  : 
; 760  :     if (!hotkeyProc)

	cmp	DWORD PTR _hotkeyProc$[ebp], 0
	jne	SHORT $LN1@CallHotkey

; 761  :         return;

	jmp	SHORT $LN7@CallHotkey
$LN1@CallHotkey:

; 762  : 
; 763  :     hotkeyProc(hotkey, param, bDown);

	movzx	ecx, BYTE PTR _bDown$[ebp]
	push	ecx
	mov	edx, DWORD PTR _param$[ebp]
	push	edx
	mov	eax, DWORD PTR _hotkey$[ebp]
	push	eax
	call	DWORD PTR _hotkeyProc$[ebp]
$LN7@CallHotkey:

; 764  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?CallHotkey@OBS@@AAEXK_N@Z ENDP				; OBS::CallHotkey
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?CreateHotkey@OBSAPIInterface@@UAEIKP6GXKK_N@ZK@Z
_TEXT	SEGMENT
_vk$ = -24						; size = 4
tv89 = -20						; size = 4
_modifier$ = -16					; size = 4
_this$ = -12						; size = 4
_hi$ = -8						; size = 4
_fsModifiers$ = -4					; size = 4
_hotkey$ = 8						; size = 4
_hotkeyProc$ = 12					; size = 4
_param$ = 16						; size = 4
?CreateHotkey@OBSAPIInterface@@UAEIKP6GXKK_N@ZK@Z PROC	; OBSAPIInterface::CreateHotkey, COMDAT
; _this$ = ecx

; 767  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 768  :     if(!hotkey)

	cmp	DWORD PTR _hotkey$[ebp], 0
	jne	SHORT $LN4@CreateHotk

; 769  :         return 0;

	xor	eax, eax
	jmp	$LN5@CreateHotk
$LN4@CreateHotk:

; 770  : 
; 771  :     //FIXME: vk and fsModifiers aren't used?
; 772  :     DWORD vk = LOBYTE(hotkey);

	mov	eax, DWORD PTR _hotkey$[ebp]
	and	eax, 255				; 000000ffH
	movzx	ecx, al
	mov	DWORD PTR _vk$[ebp], ecx

; 773  :     DWORD modifier = HIBYTE(hotkey);

	mov	edx, DWORD PTR _hotkey$[ebp]
	shr	edx, 8
	and	edx, 255				; 000000ffH
	movzx	eax, dl
	mov	DWORD PTR _modifier$[ebp], eax

; 774  :     DWORD fsModifiers = 0;

	mov	DWORD PTR _fsModifiers$[ebp], 0

; 775  : 
; 776  :     if(modifier & HOTKEYF_ALT)

	mov	ecx, DWORD PTR _modifier$[ebp]
	and	ecx, 4
	je	SHORT $LN3@CreateHotk

; 777  :         fsModifiers |= MOD_ALT;

	mov	edx, DWORD PTR _fsModifiers$[ebp]
	or	edx, 1
	mov	DWORD PTR _fsModifiers$[ebp], edx
$LN3@CreateHotk:

; 778  :     if(modifier & HOTKEYF_CONTROL)

	mov	eax, DWORD PTR _modifier$[ebp]
	and	eax, 2
	je	SHORT $LN2@CreateHotk

; 779  :         fsModifiers |= MOD_CONTROL;

	mov	ecx, DWORD PTR _fsModifiers$[ebp]
	or	ecx, 2
	mov	DWORD PTR _fsModifiers$[ebp], ecx
$LN2@CreateHotk:

; 780  :     if(modifier & HOTKEYF_SHIFT)

	mov	edx, DWORD PTR _modifier$[ebp]
	and	edx, 1
	je	SHORT $LN1@CreateHotk

; 781  :         fsModifiers |= MOD_SHIFT;

	mov	eax, DWORD PTR _fsModifiers$[ebp]
	or	eax, 4
	mov	DWORD PTR _fsModifiers$[ebp], eax
$LN1@CreateHotk:

; 782  : 
; 783  :     OSEnterMutex(App->hHotkeyMutex);

	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	edx, DWORD PTR [ecx+1232]
	push	edx
	call	DWORD PTR __imp_?OSEnterMutex@@YGXPAX@Z

; 784  :     HotkeyInfo &hi      = *hotkeys.CreateNew();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?CreateNew@?$List@UHotkeyInfo@@@@QAEPAUHotkeyInfo@@XZ ; List<HotkeyInfo>::CreateNew
	mov	DWORD PTR _hi$[ebp], eax

; 785  :     hi.hotkeyID         = ++curHotkeyIDVal;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 1
	mov	DWORD PTR tv89[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv89[ebp]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR _hi$[ebp]
	mov	edx, DWORD PTR tv89[ebp]
	mov	DWORD PTR [ecx], edx

; 786  :     hi.hotkey           = hotkey;

	mov	eax, DWORD PTR _hi$[ebp]
	mov	ecx, DWORD PTR _hotkey$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 787  :     hi.hotkeyProc       = hotkeyProc;

	mov	edx, DWORD PTR _hi$[ebp]
	mov	eax, DWORD PTR _hotkeyProc$[ebp]
	mov	DWORD PTR [edx+8], eax

; 788  :     hi.param            = param;

	mov	ecx, DWORD PTR _hi$[ebp]
	mov	edx, DWORD PTR _param$[ebp]
	mov	DWORD PTR [ecx+12], edx

; 789  :     hi.bModifiersDown   = false;

	mov	eax, DWORD PTR _hi$[ebp]
	mov	BYTE PTR [eax+16], 0

; 790  :     hi.bHotkeyDown      = false;

	mov	ecx, DWORD PTR _hi$[ebp]
	mov	BYTE PTR [ecx+17], 0

; 791  :     OSLeaveMutex(App->hHotkeyMutex);

	mov	edx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	eax, DWORD PTR [edx+1232]
	push	eax
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z

; 792  : 
; 793  :     return curHotkeyIDVal;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
$LN5@CreateHotk:

; 794  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?CreateHotkey@OBSAPIInterface@@UAEIKP6GXKK_N@ZK@Z ENDP	; OBSAPIInterface::CreateHotkey
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?DeleteHotkey@OBSAPIInterface@@UAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
_hotkeyID$ = 8						; size = 4
?DeleteHotkey@OBSAPIInterface@@UAEXI@Z PROC		; OBSAPIInterface::DeleteHotkey, COMDAT
; _this$ = ecx

; 797  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 798  :     OSEnterMutex(App->hHotkeyMutex);

	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	ecx, DWORD PTR [eax+1232]
	push	ecx
	call	DWORD PTR __imp_?OSEnterMutex@@YGXPAX@Z

; 799  :     for(UINT i=0; i<hotkeys.Num(); i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@DeleteHotk
$LN3@DeleteHotk:
	mov	edx, DWORD PTR _i$1[ebp]
	add	edx, 1
	mov	DWORD PTR _i$1[ebp], edx
$LN4@DeleteHotk:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Num@?$List@UHotkeyInfo@@@@QBEIXZ	; List<HotkeyInfo>::Num
	cmp	DWORD PTR _i$1[ebp], eax
	jae	SHORT $LN2@DeleteHotk

; 800  :     {
; 801  :         if(hotkeys[i].hotkeyID == hotkeyID)

	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$List@UHotkeyInfo@@@@QAEAAUHotkeyInfo@@I@Z ; List<HotkeyInfo>::operator[]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _hotkeyID$[ebp]
	jne	SHORT $LN1@DeleteHotk

; 802  :         {
; 803  :             hotkeys.Remove(i);

	mov	edx, DWORD PTR _i$1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Remove@?$List@UHotkeyInfo@@@@QAEXI@Z	; List<HotkeyInfo>::Remove

; 804  :             break;

	jmp	SHORT $LN2@DeleteHotk
$LN1@DeleteHotk:

; 805  :         }
; 806  :     }

	jmp	SHORT $LN3@DeleteHotk
$LN2@DeleteHotk:

; 807  :     OSLeaveMutex(App->hHotkeyMutex);

	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	ecx, DWORD PTR [eax+1232]
	push	ecx
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z

; 808  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?DeleteHotkey@OBSAPIInterface@@UAEXI@Z ENDP		; OBSAPIInterface::DeleteHotkey
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?HandleHotkeys@OBSAPIInterface@@AAEXXZ
_TEXT	SEGMENT
_hitKeys$ = -96						; size = 8
_xinputNum$1 = -88					; size = 4
_xinputButton$2 = -84					; size = 4
tv83 = -80						; size = 4
tv203 = -76						; size = 4
tv200 = -72						; size = 4
tv234 = -68						; size = 4
_this$ = -64						; size = 4
tv229 = -60						; size = 4
tv75 = -56						; size = 4
_hotkeyVK$3 = -52					; size = 4
_i$4 = -48						; size = 4
_keyState$5 = -44					; size = 2
_bWasPressed$6 = -37					; size = 1
_hotkeyModifiers$7 = -36				; size = 4
_modifiers$ = -32					; size = 4
_bDown$8 = -26						; size = 1
_bModifiersMatch$9 = -25				; size = 1
_info$10 = -24						; size = 4
_state$11 = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
?HandleHotkeys@OBSAPIInterface@@AAEXXZ PROC		; OBSAPIInterface::HandleHotkeys, COMDAT
; _this$ = ecx

; 811  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 812  :     List<DWORD> hitKeys;

	lea	ecx, DWORD PTR _hitKeys$[ebp]
	call	??0?$List@K@@QAE@XZ			; List<unsigned long>::List<unsigned long>

; 813  : 
; 814  :     static bool allow_other_hotkey_modifiers;
; 815  :     static bool uplay_overlay_compatibility;
; 816  :     static bool set_vars = false;
; 817  : 
; 818  :     /* only query these config variables once */
; 819  :     if (!set_vars)

	movzx	eax, BYTE PTR ?set_vars@?1??HandleHotkeys@OBSAPIInterface@@AAEXXZ@4_NA
	test	eax, eax
	jne	SHORT $LN28@HandleHotk

; 820  :     {
; 821  :         allow_other_hotkey_modifiers = !!GlobalConfig->GetInt(TEXT("General"), TEXT("AllowOtherHotkeyModifiers"), true);

	push	1
	push	OFFSET $SG4294966818
	push	OFFSET $SG4294966817
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	test	eax, eax
	je	SHORT $LN31@HandleHotk
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN32@HandleHotk
$LN31@HandleHotk:
	mov	DWORD PTR tv75[ebp], 0
$LN32@HandleHotk:
	mov	cl, BYTE PTR tv75[ebp]
	mov	BYTE PTR ?allow_other_hotkey_modifiers@?1??HandleHotkeys@OBSAPIInterface@@AAEXXZ@4_NA, cl

; 822  :         uplay_overlay_compatibility = !!GlobalConfig->GetInt(L"General", L"UplayOverlayCompatibility", false);

	push	0
	push	OFFSET $SG4294966816
	push	OFFSET $SG4294966815
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	test	eax, eax
	je	SHORT $LN33@HandleHotk
	mov	DWORD PTR tv83[ebp], 1
	jmp	SHORT $LN34@HandleHotk
$LN33@HandleHotk:
	mov	DWORD PTR tv83[ebp], 0
$LN34@HandleHotk:
	mov	dl, BYTE PTR tv83[ebp]
	mov	BYTE PTR ?uplay_overlay_compatibility@?1??HandleHotkeys@OBSAPIInterface@@AAEXXZ@4_NA, dl

; 823  :         set_vars = true;

	mov	BYTE PTR ?set_vars@?1??HandleHotkeys@OBSAPIInterface@@AAEXXZ@4_NA, 1
$LN28@HandleHotk:

; 824  :     }
; 825  : 
; 826  :     DWORD modifiers = 0;

	mov	DWORD PTR _modifiers$[ebp], 0

; 827  :     if(GetAsyncKeyState(VK_MENU) & 0x8000)

	push	18					; 00000012H
	call	DWORD PTR __imp__GetAsyncKeyState@4
	cwde
	and	eax, 32768				; 00008000H
	je	SHORT $LN27@HandleHotk

; 828  :         modifiers |= HOTKEYF_ALT;

	mov	ecx, DWORD PTR _modifiers$[ebp]
	or	ecx, 4
	mov	DWORD PTR _modifiers$[ebp], ecx
$LN27@HandleHotk:

; 829  :     if(GetAsyncKeyState(VK_CONTROL) & 0x8000)

	push	17					; 00000011H
	call	DWORD PTR __imp__GetAsyncKeyState@4
	movsx	edx, ax
	and	edx, 32768				; 00008000H
	je	SHORT $LN26@HandleHotk

; 830  :         modifiers |= HOTKEYF_CONTROL;

	mov	eax, DWORD PTR _modifiers$[ebp]
	or	eax, 2
	mov	DWORD PTR _modifiers$[ebp], eax
$LN26@HandleHotk:

; 831  :     if (!uplay_overlay_compatibility)

	movzx	ecx, BYTE PTR ?uplay_overlay_compatibility@?1??HandleHotkeys@OBSAPIInterface@@AAEXXZ@4_NA
	test	ecx, ecx
	jne	SHORT $LN25@HandleHotk

; 832  :         if (GetAsyncKeyState(VK_SHIFT) & 0x8000)

	push	16					; 00000010H
	call	DWORD PTR __imp__GetAsyncKeyState@4
	movsx	edx, ax
	and	edx, 32768				; 00008000H
	je	SHORT $LN25@HandleHotk

; 833  :             modifiers |= HOTKEYF_SHIFT;

	mov	eax, DWORD PTR _modifiers$[ebp]
	or	eax, 1
	mov	DWORD PTR _modifiers$[ebp], eax
$LN25@HandleHotk:

; 834  : 
; 835  :     OSEnterMutex(App->hHotkeyMutex);

	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	edx, DWORD PTR [ecx+1232]
	push	edx
	call	DWORD PTR __imp_?OSEnterMutex@@YGXPAX@Z

; 836  : 
; 837  :     for(UINT i=0; i<hotkeys.Num(); i++)

	mov	DWORD PTR _i$4[ebp], 0
	jmp	SHORT $LN23@HandleHotk
$LN22@HandleHotk:
	mov	eax, DWORD PTR _i$4[ebp]
	add	eax, 1
	mov	DWORD PTR _i$4[ebp], eax
$LN23@HandleHotk:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Num@?$List@UHotkeyInfo@@@@QBEIXZ	; List<HotkeyInfo>::Num
	cmp	DWORD PTR _i$4[ebp], eax
	jae	$LN21@HandleHotk

; 838  :     {
; 839  :         HotkeyInfo &info = hotkeys[i];

	mov	ecx, DWORD PTR _i$4[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$List@UHotkeyInfo@@@@QAEAAUHotkeyInfo@@I@Z ; List<HotkeyInfo>::operator[]
	mov	DWORD PTR _info$10[ebp], eax

; 840  : 
; 841  :         DWORD hotkeyVK          = LOBYTE(info.hotkey);

	mov	edx, DWORD PTR _info$10[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, 255				; 000000ffH
	movzx	ecx, al
	mov	DWORD PTR _hotkeyVK$3[ebp], ecx

; 842  :         DWORD hotkeyModifiers   = HIBYTE(info.hotkey);

	mov	edx, DWORD PTR _info$10[ebp]
	mov	eax, DWORD PTR [edx+4]
	shr	eax, 8
	and	eax, 255				; 000000ffH
	movzx	ecx, al
	mov	DWORD PTR _hotkeyModifiers$7[ebp], ecx

; 843  :         DWORD xinputNum         = LOWORD(info.hotkey);

	mov	edx, DWORD PTR _info$10[ebp]
	movzx	eax, WORD PTR [edx+4]
	mov	DWORD PTR _xinputNum$1[ebp], eax

; 844  :         DWORD xinputButton      = HIWORD(info.hotkey);

	mov	ecx, DWORD PTR _info$10[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shr	edx, 16					; 00000010H
	movzx	eax, dx
	mov	DWORD PTR _xinputButton$2[ebp], eax

; 845  : 
; 846  :         hotkeyModifiers &= ~(HOTKEYF_EXT);

	mov	ecx, DWORD PTR _hotkeyModifiers$7[ebp]
	and	ecx, -9					; fffffff7H
	mov	DWORD PTR _hotkeyModifiers$7[ebp], ecx

; 847  : 
; 848  :         if(xinputButton)

	cmp	DWORD PTR _xinputButton$2[ebp], 0
	je	$LN20@HandleHotk

; 849  :         {
; 850  :             XINPUT_STATE state = { 0 };

	mov	DWORD PTR _state$11[ebp], 0
	xor	edx, edx
	mov	DWORD PTR _state$11[ebp+4], edx
	mov	DWORD PTR _state$11[ebp+8], edx
	mov	DWORD PTR _state$11[ebp+12], edx

; 851  : 
; 852  :             if(XInputGetState(xinputNum, &state) == ERROR_SUCCESS)

	lea	eax, DWORD PTR _state$11[ebp]
	push	eax
	mov	ecx, DWORD PTR _xinputNum$1[ebp]
	push	ecx
	call	DWORD PTR __imp__XInputGetState@8
	test	eax, eax
	jne	SHORT $LN19@HandleHotk

; 853  :             {
; 854  :                 if(state.Gamepad.bLeftTrigger >= 85)

	movzx	edx, BYTE PTR _state$11[ebp+6]
	cmp	edx, 85					; 00000055H
	jl	SHORT $LN18@HandleHotk

; 855  :                     state.Gamepad.wButtons |= XINPUT_GAMEPAD_LEFT_TRIGGER;

	movzx	eax, WORD PTR _state$11[ebp+4]
	or	eax, 1024				; 00000400H
	mov	WORD PTR _state$11[ebp+4], ax
$LN18@HandleHotk:

; 856  : 
; 857  :                 if(state.Gamepad.bRightTrigger >= 85)

	movzx	ecx, BYTE PTR _state$11[ebp+7]
	cmp	ecx, 85					; 00000055H
	jl	SHORT $LN17@HandleHotk

; 858  :                     state.Gamepad.wButtons |= XINPUT_GAMEPAD_RIGHT_TRIGGER;

	movzx	edx, WORD PTR _state$11[ebp+4]
	or	edx, 2048				; 00000800H
	mov	WORD PTR _state$11[ebp+4], dx
$LN17@HandleHotk:

; 859  : 
; 860  :                 if((state.Gamepad.wButtons & xinputButton) != 0 && !info.bHotkeyDown)

	movzx	eax, WORD PTR _state$11[ebp+4]
	and	eax, DWORD PTR _xinputButton$2[ebp]
	je	SHORT $LN19@HandleHotk
	mov	ecx, DWORD PTR _info$10[ebp]
	movzx	edx, BYTE PTR [ecx+17]
	test	edx, edx
	jne	SHORT $LN19@HandleHotk

; 861  :                 {
; 862  :                     PostMessage(hwndMain, OBS_CALLHOTKEY, TRUE, info.hotkeyID);

	mov	eax, DWORD PTR _info$10[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	1
	push	1026					; 00000402H
	mov	edx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	edx
	call	DWORD PTR __imp__PostMessageW@16

; 863  :                     info.bDownSent = true;

	mov	eax, DWORD PTR _info$10[ebp]
	mov	BYTE PTR [eax+18], 1

; 864  :                     info.bHotkeyDown = true;

	mov	ecx, DWORD PTR _info$10[ebp]
	mov	BYTE PTR [ecx+17], 1
$LN19@HandleHotk:

; 865  :                 }
; 866  :             }
; 867  : 
; 868  :             info.bModifiersDown = 0;

	mov	edx, DWORD PTR _info$10[ebp]
	mov	BYTE PTR [edx+16], 0

; 869  :         }
; 870  :         else

	jmp	$LN15@HandleHotk
$LN20@HandleHotk:

; 871  :         {
; 872  :             bool bModifiersMatch = false;

	mov	BYTE PTR _bModifiersMatch$9[ebp], 0

; 873  :             if(allow_other_hotkey_modifiers)

	movzx	eax, BYTE PTR ?allow_other_hotkey_modifiers@?1??HandleHotkeys@OBSAPIInterface@@AAEXXZ@4_NA
	test	eax, eax
	je	SHORT $LN14@HandleHotk

; 874  :                 bModifiersMatch = ((hotkeyModifiers & modifiers) == hotkeyModifiers); //allows other modifiers to be pressed

	mov	ecx, DWORD PTR _hotkeyModifiers$7[ebp]
	and	ecx, DWORD PTR _modifiers$[ebp]
	cmp	ecx, DWORD PTR _hotkeyModifiers$7[ebp]
	jne	SHORT $LN35@HandleHotk
	mov	DWORD PTR tv200[ebp], 1
	jmp	SHORT $LN36@HandleHotk
$LN35@HandleHotk:
	mov	DWORD PTR tv200[ebp], 0
$LN36@HandleHotk:
	mov	dl, BYTE PTR tv200[ebp]
	mov	BYTE PTR _bModifiersMatch$9[ebp], dl

; 875  :             else

	jmp	SHORT $LN13@HandleHotk
$LN14@HandleHotk:

; 876  :                 bModifiersMatch = (hotkeyModifiers == modifiers);

	mov	eax, DWORD PTR _hotkeyModifiers$7[ebp]
	cmp	eax, DWORD PTR _modifiers$[ebp]
	jne	SHORT $LN37@HandleHotk
	mov	DWORD PTR tv203[ebp], 1
	jmp	SHORT $LN38@HandleHotk
$LN37@HandleHotk:
	mov	DWORD PTR tv203[ebp], 0
$LN38@HandleHotk:
	mov	cl, BYTE PTR tv203[ebp]
	mov	BYTE PTR _bModifiersMatch$9[ebp], cl
$LN13@HandleHotk:

; 877  : 
; 878  :             if(hotkeyModifiers && !hotkeyVK) //modifier-only hotkey

	cmp	DWORD PTR _hotkeyModifiers$7[ebp], 0
	je	SHORT $LN12@HandleHotk
	cmp	DWORD PTR _hotkeyVK$3[ebp], 0
	jne	SHORT $LN12@HandleHotk

; 879  :             {
; 880  :                 if((hotkeyModifiers & modifiers) == hotkeyModifiers)

	mov	edx, DWORD PTR _hotkeyModifiers$7[ebp]
	and	edx, DWORD PTR _modifiers$[ebp]
	cmp	edx, DWORD PTR _hotkeyModifiers$7[ebp]
	jne	SHORT $LN11@HandleHotk

; 881  :                 {
; 882  :                     if(!info.bHotkeyDown)

	mov	eax, DWORD PTR _info$10[ebp]
	movzx	ecx, BYTE PTR [eax+17]
	test	ecx, ecx
	jne	SHORT $LN10@HandleHotk

; 883  :                     {
; 884  :                         PostMessage(hwndMain, OBS_CALLHOTKEY, TRUE, info.hotkeyID);

	mov	edx, DWORD PTR _info$10[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	1
	push	1026					; 00000402H
	mov	ecx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	ecx
	call	DWORD PTR __imp__PostMessageW@16

; 885  :                         info.bDownSent = true;

	mov	edx, DWORD PTR _info$10[ebp]
	mov	BYTE PTR [edx+18], 1

; 886  :                         info.bHotkeyDown = true;

	mov	eax, DWORD PTR _info$10[ebp]
	mov	BYTE PTR [eax+17], 1
$LN10@HandleHotk:

; 887  :                     }
; 888  : 
; 889  :                     continue;

	jmp	$LN22@HandleHotk
$LN11@HandleHotk:

; 890  :                 }
; 891  :             }
; 892  :             else

	jmp	$LN9@HandleHotk
$LN12@HandleHotk:

; 893  :             {
; 894  :                 if (bModifiersMatch && !(uplay_overlay_compatibility && hotkeyVK == VK_F2))

	movzx	ecx, BYTE PTR _bModifiersMatch$9[ebp]
	test	ecx, ecx
	je	$LN9@HandleHotk
	movzx	edx, BYTE PTR ?uplay_overlay_compatibility@?1??HandleHotkeys@OBSAPIInterface@@AAEXXZ@4_NA
	test	edx, edx
	je	SHORT $LN7@HandleHotk
	cmp	DWORD PTR _hotkeyVK$3[ebp], 113		; 00000071H
	je	$LN9@HandleHotk
$LN7@HandleHotk:

; 895  :                 {
; 896  :                     short keyState = GetAsyncKeyState(hotkeyVK);

	mov	eax, DWORD PTR _hotkeyVK$3[ebp]
	push	eax
	call	DWORD PTR __imp__GetAsyncKeyState@4
	mov	WORD PTR _keyState$5[ebp], ax

; 897  :                     bool bDown = (keyState & 0x8000) != 0;

	movsx	ecx, WORD PTR _keyState$5[ebp]
	and	ecx, 32768				; 00008000H
	je	SHORT $LN39@HandleHotk
	mov	DWORD PTR tv229[ebp], 1
	jmp	SHORT $LN40@HandleHotk
$LN39@HandleHotk:
	mov	DWORD PTR tv229[ebp], 0
$LN40@HandleHotk:
	mov	dl, BYTE PTR tv229[ebp]
	mov	BYTE PTR _bDown$8[ebp], dl

; 898  :                     bool bWasPressed = (keyState & 0x1) != 0;

	movsx	eax, WORD PTR _keyState$5[ebp]
	and	eax, 1
	je	SHORT $LN41@HandleHotk
	mov	DWORD PTR tv234[ebp], 1
	jmp	SHORT $LN42@HandleHotk
$LN41@HandleHotk:
	mov	DWORD PTR tv234[ebp], 0
$LN42@HandleHotk:
	mov	cl, BYTE PTR tv234[ebp]
	mov	BYTE PTR _bWasPressed$6[ebp], cl

; 899  : 
; 900  :                     if(bDown || bWasPressed)

	movzx	edx, BYTE PTR _bDown$8[ebp]
	test	edx, edx
	jne	SHORT $LN5@HandleHotk
	movzx	eax, BYTE PTR _bWasPressed$6[ebp]
	test	eax, eax
	je	SHORT $LN9@HandleHotk
$LN5@HandleHotk:

; 901  :                     {
; 902  :                         if(!info.bHotkeyDown && info.bModifiersDown) //only triggers the hotkey if the actual main key was pressed second

	mov	ecx, DWORD PTR _info$10[ebp]
	movzx	edx, BYTE PTR [ecx+17]
	test	edx, edx
	jne	SHORT $LN4@HandleHotk
	mov	eax, DWORD PTR _info$10[ebp]
	movzx	ecx, BYTE PTR [eax+16]
	test	ecx, ecx
	je	SHORT $LN4@HandleHotk

; 903  :                         {
; 904  :                             PostMessage(hwndMain, OBS_CALLHOTKEY, TRUE, info.hotkeyID);

	mov	edx, DWORD PTR _info$10[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	1
	push	1026					; 00000402H
	mov	ecx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	ecx
	call	DWORD PTR __imp__PostMessageW@16

; 905  :                             info.bDownSent = true;

	mov	edx, DWORD PTR _info$10[ebp]
	mov	BYTE PTR [edx+18], 1
$LN4@HandleHotk:

; 906  :                         }
; 907  : 
; 908  :                         info.bHotkeyDown = true;

	mov	eax, DWORD PTR _info$10[ebp]
	mov	BYTE PTR [eax+17], 1

; 909  :                         if(bDown)

	movzx	ecx, BYTE PTR _bDown$8[ebp]
	test	ecx, ecx
	je	SHORT $LN9@HandleHotk

; 910  :                             continue;

	jmp	$LN22@HandleHotk
$LN9@HandleHotk:

; 911  :                     }
; 912  :                 }
; 913  :             }
; 914  : 
; 915  :             info.bModifiersDown = bModifiersMatch;

	mov	edx, DWORD PTR _info$10[ebp]
	mov	al, BYTE PTR _bModifiersMatch$9[ebp]
	mov	BYTE PTR [edx+16], al
$LN15@HandleHotk:

; 916  :         }
; 917  : 
; 918  :         if(info.bHotkeyDown) //key up

	mov	ecx, DWORD PTR _info$10[ebp]
	movzx	edx, BYTE PTR [ecx+17]
	test	edx, edx
	je	SHORT $LN2@HandleHotk

; 919  :         {
; 920  :             if(info.bDownSent)

	mov	eax, DWORD PTR _info$10[ebp]
	movzx	ecx, BYTE PTR [eax+18]
	test	ecx, ecx
	je	SHORT $LN1@HandleHotk

; 921  :             {
; 922  :                 PostMessage(hwndMain, OBS_CALLHOTKEY, FALSE, info.hotkeyID);

	mov	edx, DWORD PTR _info$10[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	0
	push	1026					; 00000402H
	mov	ecx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	ecx
	call	DWORD PTR __imp__PostMessageW@16

; 923  :                 info.bDownSent = false;

	mov	edx, DWORD PTR _info$10[ebp]
	mov	BYTE PTR [edx+18], 0
$LN1@HandleHotk:

; 924  :             }
; 925  : 
; 926  :             info.bHotkeyDown = false;

	mov	eax, DWORD PTR _info$10[ebp]
	mov	BYTE PTR [eax+17], 0
$LN2@HandleHotk:

; 927  :         }
; 928  :     }

	jmp	$LN22@HandleHotk
$LN21@HandleHotk:

; 929  : 
; 930  :     OSLeaveMutex(App->hHotkeyMutex);

	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	edx, DWORD PTR [ecx+1232]
	push	edx
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z

; 931  : }

	lea	ecx, DWORD PTR _hitKeys$[ebp]
	call	??1?$List@K@@QAE@XZ			; List<unsigned long>::~List<unsigned long>
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?HandleHotkeys@OBSAPIInterface@@AAEXXZ ENDP		; OBSAPIInterface::HandleHotkeys
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?AddStreamInfo@OBS@@QAEIPB_WW4StreamInfoPriority@@@Z
_TEXT	SEGMENT
_id$ = -16						; size = 4
_streamInfo$ = -12					; size = 4
tv72 = -8						; size = 4
_this$ = -4						; size = 4
_lpInfo$ = 8						; size = 4
_priority$ = 12						; size = 4
?AddStreamInfo@OBS@@QAEIPB_WW4StreamInfoPriority@@@Z PROC ; OBS::AddStreamInfo, COMDAT
; _this$ = ecx

; 934  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 935  :     OSEnterMutex(hInfoMutex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1384]
	push	ecx
	call	DWORD PTR __imp_?OSEnterMutex@@YGXPAX@Z

; 936  : 
; 937  :     StreamInfo &streamInfo = *streamInfoList.CreateNew();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1388				; 0000056cH
	call	?CreateNew@?$List@UStreamInfo@@@@QAEPAUStreamInfo@@XZ ; List<StreamInfo>::CreateNew
	mov	DWORD PTR _streamInfo$[ebp], eax

; 938  :     UINT id = streamInfo.id = ++streamInfoIDCounter;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1396]
	add	eax, 1
	mov	DWORD PTR tv72[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv72[ebp]
	mov	DWORD PTR [ecx+1396], edx
	mov	eax, DWORD PTR _streamInfo$[ebp]
	mov	ecx, DWORD PTR tv72[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR tv72[ebp]
	mov	DWORD PTR _id$[ebp], edx

; 939  :     streamInfo.priority = priority;

	mov	eax, DWORD PTR _streamInfo$[ebp]
	mov	ecx, DWORD PTR _priority$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 940  :     streamInfo.strInfo = lpInfo;

	mov	edx, DWORD PTR _lpInfo$[ebp]
	push	edx
	mov	ecx, DWORD PTR _streamInfo$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z

; 941  : 
; 942  :     OSLeaveMutex(hInfoMutex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1384]
	push	ecx
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z

; 943  : 
; 944  :     return id;

	mov	eax, DWORD PTR _id$[ebp]

; 945  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?AddStreamInfo@OBS@@QAEIPB_WW4StreamInfoPriority@@@Z ENDP ; OBS::AddStreamInfo
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?SetStreamInfo@OBS@@QAEXIPB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
_infoID$ = 8						; size = 4
_lpInfo$ = 12						; size = 4
?SetStreamInfo@OBS@@QAEXIPB_W@Z PROC			; OBS::SetStreamInfo, COMDAT
; _this$ = ecx

; 948  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 949  :     OSEnterMutex(hInfoMutex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1384]
	push	ecx
	call	DWORD PTR __imp_?OSEnterMutex@@YGXPAX@Z

; 950  : 
; 951  :     for(UINT i=0; i<streamInfoList.Num(); i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@SetStreamI
$LN3@SetStreamI:
	mov	edx, DWORD PTR _i$1[ebp]
	add	edx, 1
	mov	DWORD PTR _i$1[ebp], edx
$LN4@SetStreamI:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1388				; 0000056cH
	call	?Num@?$List@UStreamInfo@@@@QBEIXZ	; List<StreamInfo>::Num
	cmp	DWORD PTR _i$1[ebp], eax
	jae	SHORT $LN2@SetStreamI

; 952  :     {
; 953  :         if(streamInfoList[i].id == infoID)

	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1388				; 0000056cH
	call	??A?$List@UStreamInfo@@@@QAEAAUStreamInfo@@I@Z ; List<StreamInfo>::operator[]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _infoID$[ebp]
	jne	SHORT $LN1@SetStreamI

; 954  :         {
; 955  :             streamInfoList[i].strInfo = lpInfo;

	mov	edx, DWORD PTR _lpInfo$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1388				; 0000056cH
	call	??A?$List@UStreamInfo@@@@QAEAAUStreamInfo@@I@Z ; List<StreamInfo>::operator[]
	add	eax, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z

; 956  :             break;

	jmp	SHORT $LN2@SetStreamI
$LN1@SetStreamI:

; 957  :         }
; 958  :     }

	jmp	SHORT $LN3@SetStreamI
$LN2@SetStreamI:

; 959  : 
; 960  :     OSLeaveMutex(hInfoMutex);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1384]
	push	edx
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z

; 961  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetStreamInfo@OBS@@QAEXIPB_W@Z ENDP			; OBS::SetStreamInfo
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?SetStreamInfoPriority@OBS@@QAEXIW4StreamInfoPriority@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
_infoID$ = 8						; size = 4
_priority$ = 12						; size = 4
?SetStreamInfoPriority@OBS@@QAEXIW4StreamInfoPriority@@@Z PROC ; OBS::SetStreamInfoPriority, COMDAT
; _this$ = ecx

; 964  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 965  :     OSEnterMutex(hInfoMutex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1384]
	push	ecx
	call	DWORD PTR __imp_?OSEnterMutex@@YGXPAX@Z

; 966  : 
; 967  :     for(UINT i=0; i<streamInfoList.Num(); i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@SetStreamI
$LN3@SetStreamI:
	mov	edx, DWORD PTR _i$1[ebp]
	add	edx, 1
	mov	DWORD PTR _i$1[ebp], edx
$LN4@SetStreamI:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1388				; 0000056cH
	call	?Num@?$List@UStreamInfo@@@@QBEIXZ	; List<StreamInfo>::Num
	cmp	DWORD PTR _i$1[ebp], eax
	jae	SHORT $LN2@SetStreamI

; 968  :     {
; 969  :         if(streamInfoList[i].id == infoID)

	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1388				; 0000056cH
	call	??A?$List@UStreamInfo@@@@QAEAAUStreamInfo@@I@Z ; List<StreamInfo>::operator[]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _infoID$[ebp]
	jne	SHORT $LN1@SetStreamI

; 970  :         {
; 971  :             streamInfoList[i].priority = priority;

	mov	edx, DWORD PTR _i$1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1388				; 0000056cH
	call	??A?$List@UStreamInfo@@@@QAEAAUStreamInfo@@I@Z ; List<StreamInfo>::operator[]
	mov	ecx, DWORD PTR _priority$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 972  :             break;

	jmp	SHORT $LN2@SetStreamI
$LN1@SetStreamI:

; 973  :         }
; 974  :     }

	jmp	SHORT $LN3@SetStreamI
$LN2@SetStreamI:

; 975  : 
; 976  :     OSLeaveMutex(hInfoMutex);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1384]
	push	eax
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z

; 977  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetStreamInfoPriority@OBS@@QAEXIW4StreamInfoPriority@@@Z ENDP ; OBS::SetStreamInfoPriority
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?RemoveStreamInfo@OBS@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
_infoID$ = 8						; size = 4
?RemoveStreamInfo@OBS@@QAEXI@Z PROC			; OBS::RemoveStreamInfo, COMDAT
; _this$ = ecx

; 980  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 981  :     OSEnterMutex(hInfoMutex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1384]
	push	ecx
	call	DWORD PTR __imp_?OSEnterMutex@@YGXPAX@Z

; 982  : 
; 983  :     for(UINT i=0; i<streamInfoList.Num(); i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@RemoveStre
$LN3@RemoveStre:
	mov	edx, DWORD PTR _i$1[ebp]
	add	edx, 1
	mov	DWORD PTR _i$1[ebp], edx
$LN4@RemoveStre:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1388				; 0000056cH
	call	?Num@?$List@UStreamInfo@@@@QBEIXZ	; List<StreamInfo>::Num
	cmp	DWORD PTR _i$1[ebp], eax
	jae	SHORT $LN2@RemoveStre

; 984  :     {
; 985  :         if(streamInfoList[i].id == infoID)

	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1388				; 0000056cH
	call	??A?$List@UStreamInfo@@@@QAEAAUStreamInfo@@I@Z ; List<StreamInfo>::operator[]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _infoID$[ebp]
	jne	SHORT $LN1@RemoveStre

; 986  :         {
; 987  :             streamInfoList[i].FreeData();

	mov	edx, DWORD PTR _i$1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1388				; 0000056cH
	call	??A?$List@UStreamInfo@@@@QAEAAUStreamInfo@@I@Z ; List<StreamInfo>::operator[]
	mov	ecx, eax
	call	?FreeData@StreamInfo@@QAEXXZ		; StreamInfo::FreeData

; 988  :             streamInfoList.Remove(i);

	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1388				; 0000056cH
	call	?Remove@?$List@UStreamInfo@@@@QAEXI@Z	; List<StreamInfo>::Remove

; 989  :             break;

	jmp	SHORT $LN2@RemoveStre
$LN1@RemoveStre:

; 990  :         }
; 991  :     }

	jmp	SHORT $LN3@RemoveStre
$LN2@RemoveStre:

; 992  : 
; 993  :     OSLeaveMutex(hInfoMutex);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1384]
	push	edx
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z

; 994  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?RemoveStreamInfo@OBS@@QAEXI@Z ENDP			; OBS::RemoveStreamInfo
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetMostImportantInfo@OBS@@QAE?AVString@@AAW4StreamInfoPriority@@@Z
_TEXT	SEGMENT
_strInfo$ = -24						; size = 8
_lpBestInfo$ = -16					; size = 4
_bestInfoPriority$ = -12				; size = 4
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_priority$ = 12						; size = 4
?GetMostImportantInfo@OBS@@QAE?AVString@@AAW4StreamInfoPriority@@@Z PROC ; OBS::GetMostImportantInfo, COMDAT
; _this$ = ecx

; 998  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 999  :     OSEnterMutex(hInfoMutex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1384]
	push	ecx
	call	DWORD PTR __imp_?OSEnterMutex@@YGXPAX@Z

; 1000 : 
; 1001 :     int bestInfoPriority = -1;

	mov	DWORD PTR _bestInfoPriority$[ebp], -1

; 1002 :     CTSTR lpBestInfo = NULL;

	mov	DWORD PTR _lpBestInfo$[ebp], 0

; 1003 : 
; 1004 :     for(UINT i=0; i<streamInfoList.Num(); i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@GetMostImp
$LN3@GetMostImp:
	mov	edx, DWORD PTR _i$1[ebp]
	add	edx, 1
	mov	DWORD PTR _i$1[ebp], edx
$LN4@GetMostImp:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1388				; 0000056cH
	call	?Num@?$List@UStreamInfo@@@@QBEIXZ	; List<StreamInfo>::Num
	cmp	DWORD PTR _i$1[ebp], eax
	jae	SHORT $LN2@GetMostImp

; 1005 :     {
; 1006 :         if((int)streamInfoList[i].priority > bestInfoPriority)

	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1388				; 0000056cH
	call	??A?$List@UStreamInfo@@@@QAEAAUStreamInfo@@I@Z ; List<StreamInfo>::operator[]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR _bestInfoPriority$[ebp]
	jle	SHORT $LN1@GetMostImp

; 1007 :         {
; 1008 :             lpBestInfo = streamInfoList[i].strInfo;

	mov	edx, DWORD PTR _i$1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1388				; 0000056cH
	call	??A?$List@UStreamInfo@@@@QAEAAUStreamInfo@@I@Z ; List<StreamInfo>::operator[]
	add	eax, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	DWORD PTR _lpBestInfo$[ebp], eax

; 1009 :             bestInfoPriority = streamInfoList[i].priority;

	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1388				; 0000056cH
	call	??A?$List@UStreamInfo@@@@QAEAAUStreamInfo@@I@Z ; List<StreamInfo>::operator[]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _bestInfoPriority$[ebp], ecx
$LN1@GetMostImp:

; 1010 :         }
; 1011 :     }

	jmp	SHORT $LN3@GetMostImp
$LN2@GetMostImp:

; 1012 : 
; 1013 :     priority = (StreamInfoPriority)bestInfoPriority;

	mov	edx, DWORD PTR _priority$[ebp]
	mov	eax, DWORD PTR _bestInfoPriority$[ebp]
	mov	DWORD PTR [edx], eax

; 1014 :     String strInfo = lpBestInfo;

	mov	ecx, DWORD PTR _lpBestInfo$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strInfo$[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PB_W@Z

; 1015 :     OSLeaveMutex(hInfoMutex);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1384]
	push	eax
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z

; 1016 : 
; 1017 :     return strInfo;

	lea	ecx, DWORD PTR _strInfo$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0String@@QAE@ABV0@@Z
	lea	ecx, DWORD PTR _strInfo$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1018 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetMostImportantInfo@OBS@@QAE?AVString@@AAW4StreamInfoPriority@@@Z ENDP ; OBS::GetMostImportantInfo
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?SetDesktopVolume@OBS@@UAEXM_N@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
_desktop$ = -28						; size = 4
_temp$ = -24						; size = 4
_tempFloatPointer$ = -20				; size = 4
tv77 = -16						; size = 4
tv69 = -12						; size = 4
tv68 = -8						; size = 4
tv65 = -4						; size = 4
_val$ = 8						; size = 4
_finalValue$ = 12					; size = 1
?SetDesktopVolume@OBS@@UAEXM_N@Z PROC			; OBS::SetDesktopVolume, COMDAT
; _this$ = ecx

; 1021 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1022 :     val = min(1.0f, max(0, val));

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _val$[ebp]
	jbe	SHORT $LN3@SetDesktop
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv65[ebp], xmm0
	jmp	SHORT $LN4@SetDesktop
$LN3@SetDesktop:
	movss	xmm0, DWORD PTR _val$[ebp]
	movss	DWORD PTR tv65[ebp], xmm0
$LN4@SetDesktop:
	movss	xmm0, DWORD PTR tv65[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN7@SetDesktop
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv69[ebp], xmm0
	jmp	SHORT $LN8@SetDesktop
$LN7@SetDesktop:
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _val$[ebp]
	jbe	SHORT $LN5@SetDesktop
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv68[ebp], xmm0
	jmp	SHORT $LN6@SetDesktop
$LN5@SetDesktop:
	movss	xmm0, DWORD PTR _val$[ebp]
	movss	DWORD PTR tv68[ebp], xmm0
$LN6@SetDesktop:
	movss	xmm0, DWORD PTR tv68[ebp]
	movss	DWORD PTR tv69[ebp], xmm0
$LN8@SetDesktop:
	movss	xmm0, DWORD PTR tv69[ebp]
	movss	DWORD PTR _val$[ebp], xmm0

; 1023 :     HWND desktop = GetDlgItem(hwndMain, ID_DESKTOPVOLUME);

	push	5006					; 0000138eH
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	call	DWORD PTR __imp__GetDlgItem@8
	mov	DWORD PTR _desktop$[ebp], eax

; 1024 :     
; 1025 : 	/* float in lParam hack */
; 1026 :     LPARAM temp;
; 1027 : 	float* tempFloatPointer = (float*)&temp;

	lea	ecx, DWORD PTR _temp$[ebp]
	mov	DWORD PTR _tempFloatPointer$[ebp], ecx

; 1028 : 	*tempFloatPointer = val;

	mov	edx, DWORD PTR _tempFloatPointer$[ebp]
	movss	xmm0, DWORD PTR _val$[ebp]
	movss	DWORD PTR [edx], xmm0

; 1029 :     
; 1030 :     /*Send message to desktop volume control and have it handle it*/
; 1031 :     PostMessage(desktop, WM_COMMAND, 
; 1032 :         MAKEWPARAM(ID_DESKTOPVOLUME, finalValue?VOLN_FINALVALUE:VOLN_ADJUSTING),
; 1033 :         (LPARAM)temp);

	movzx	eax, BYTE PTR _finalValue$[ebp]
	test	eax, eax
	je	SHORT $LN9@SetDesktop
	mov	DWORD PTR tv77[ebp], 769		; 00000301H
	jmp	SHORT $LN10@SetDesktop
$LN9@SetDesktop:
	mov	DWORD PTR tv77[ebp], 768		; 00000300H
$LN10@SetDesktop:
	mov	ecx, DWORD PTR _temp$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv77[ebp]
	and	edx, 65535				; 0000ffffH
	movzx	eax, dx
	shl	eax, 16					; 00000010H
	or	eax, 5006				; 0000138eH
	push	eax
	push	273					; 00000111H
	mov	ecx, DWORD PTR _desktop$[ebp]
	push	ecx
	call	DWORD PTR __imp__PostMessageW@16

; 1034 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetDesktopVolume@OBS@@UAEXM_N@Z ENDP			; OBS::SetDesktopVolume
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetDesktopVolume@OBS@@UAEMXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_desktop$ = -4						; size = 4
?GetDesktopVolume@OBS@@UAEMXZ PROC			; OBS::GetDesktopVolume, COMDAT
; _this$ = ecx

; 1037 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1038 :     HWND desktop = GetDlgItem(hwndMain, ID_DESKTOPVOLUME);

	push	5006					; 0000138eH
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	call	DWORD PTR __imp__GetDlgItem@8
	mov	DWORD PTR _desktop$[ebp], eax

; 1039 :     return GetVolumeControlValue(desktop);

	mov	ecx, DWORD PTR _desktop$[ebp]
	push	ecx
	call	DWORD PTR __imp_?GetVolumeControlValue@@YAMPAUHWND__@@@Z
	add	esp, 4

; 1040 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetDesktopVolume@OBS@@UAEMXZ ENDP			; OBS::GetDesktopVolume
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?ToggleDesktopMute@OBS@@UAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_desktop$ = -4						; size = 4
?ToggleDesktopMute@OBS@@UAEXXZ PROC			; OBS::ToggleDesktopMute, COMDAT
; _this$ = ecx

; 1043 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1044 :     HWND desktop = GetDlgItem(hwndMain, ID_DESKTOPVOLUME);

	push	5006					; 0000138eH
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	call	DWORD PTR __imp__GetDlgItem@8
	mov	DWORD PTR _desktop$[ebp], eax

; 1045 :     
; 1046 :     /*Send message to desktop volume control and have it handle it*/
; 1047 :     PostMessage(desktop, WM_COMMAND, MAKEWPARAM(ID_DESKTOPVOLUME, VOLN_TOGGLEMUTE), 0);

	push	0
	push	50467726				; 0302138eH
	push	273					; 00000111H
	mov	ecx, DWORD PTR _desktop$[ebp]
	push	ecx
	call	DWORD PTR __imp__PostMessageW@16

; 1048 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ToggleDesktopMute@OBS@@UAEXXZ ENDP			; OBS::ToggleDesktopMute
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetDesktopMuted@OBS@@UAE_NXZ
_TEXT	SEGMENT
tv77 = -12						; size = 4
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?GetDesktopMuted@OBS@@UAE_NXZ PROC			; OBS::GetDesktopMuted, COMDAT
; _this$ = ecx

; 1051 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1052 :     return GetDesktopVolume() < VOLN_MUTELEVEL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	call	eax
	fstp	DWORD PTR tv77[ebp]
	movss	xmm0, DWORD PTR __real@3d4ccccd
	comiss	xmm0, DWORD PTR tv77[ebp]
	jbe	SHORT $LN3@GetDesktop
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@GetDesktop
$LN3@GetDesktop:
	mov	DWORD PTR tv69[ebp], 0
$LN4@GetDesktop:
	mov	al, BYTE PTR tv69[ebp]

; 1053 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetDesktopMuted@OBS@@UAE_NXZ ENDP			; OBS::GetDesktopMuted
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?SetMicVolume@OBS@@UAEXM_N@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
_mic$ = -28						; size = 4
_temp$ = -24						; size = 4
_tempFloatPointer$ = -20				; size = 4
tv77 = -16						; size = 4
tv69 = -12						; size = 4
tv68 = -8						; size = 4
tv65 = -4						; size = 4
_val$ = 8						; size = 4
_finalValue$ = 12					; size = 1
?SetMicVolume@OBS@@UAEXM_N@Z PROC			; OBS::SetMicVolume, COMDAT
; _this$ = ecx

; 1056 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1057 :     val = min(1.0f, max(0, val));

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _val$[ebp]
	jbe	SHORT $LN3@SetMicVolu
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv65[ebp], xmm0
	jmp	SHORT $LN4@SetMicVolu
$LN3@SetMicVolu:
	movss	xmm0, DWORD PTR _val$[ebp]
	movss	DWORD PTR tv65[ebp], xmm0
$LN4@SetMicVolu:
	movss	xmm0, DWORD PTR tv65[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN7@SetMicVolu
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv69[ebp], xmm0
	jmp	SHORT $LN8@SetMicVolu
$LN7@SetMicVolu:
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _val$[ebp]
	jbe	SHORT $LN5@SetMicVolu
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv68[ebp], xmm0
	jmp	SHORT $LN6@SetMicVolu
$LN5@SetMicVolu:
	movss	xmm0, DWORD PTR _val$[ebp]
	movss	DWORD PTR tv68[ebp], xmm0
$LN6@SetMicVolu:
	movss	xmm0, DWORD PTR tv68[ebp]
	movss	DWORD PTR tv69[ebp], xmm0
$LN8@SetMicVolu:
	movss	xmm0, DWORD PTR tv69[ebp]
	movss	DWORD PTR _val$[ebp], xmm0

; 1058 :     HWND mic = GetDlgItem(hwndMain, ID_MICVOLUME);

	push	5007					; 0000138fH
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	call	DWORD PTR __imp__GetDlgItem@8
	mov	DWORD PTR _mic$[ebp], eax

; 1059 :     
; 1060 : 	/* float in lParam hack */
; 1061 :     LPARAM temp;
; 1062 : 	float* tempFloatPointer = (float*)&temp;

	lea	ecx, DWORD PTR _temp$[ebp]
	mov	DWORD PTR _tempFloatPointer$[ebp], ecx

; 1063 : 	*tempFloatPointer = val;

	mov	edx, DWORD PTR _tempFloatPointer$[ebp]
	movss	xmm0, DWORD PTR _val$[ebp]
	movss	DWORD PTR [edx], xmm0

; 1064 : 
; 1065 :     /*Send message to microphone volume control and have it handle it*/
; 1066 :     PostMessage(mic, WM_COMMAND ,
; 1067 :         MAKEWPARAM(ID_MICVOLUME, finalValue?VOLN_FINALVALUE:VOLN_ADJUSTING),
; 1068 :         (LPARAM)temp);

	movzx	eax, BYTE PTR _finalValue$[ebp]
	test	eax, eax
	je	SHORT $LN9@SetMicVolu
	mov	DWORD PTR tv77[ebp], 769		; 00000301H
	jmp	SHORT $LN10@SetMicVolu
$LN9@SetMicVolu:
	mov	DWORD PTR tv77[ebp], 768		; 00000300H
$LN10@SetMicVolu:
	mov	ecx, DWORD PTR _temp$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv77[ebp]
	and	edx, 65535				; 0000ffffH
	movzx	eax, dx
	shl	eax, 16					; 00000010H
	or	eax, 5007				; 0000138fH
	push	eax
	push	273					; 00000111H
	mov	ecx, DWORD PTR _mic$[ebp]
	push	ecx
	call	DWORD PTR __imp__PostMessageW@16

; 1069 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetMicVolume@OBS@@UAEXM_N@Z ENDP			; OBS::SetMicVolume
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetMicVolume@OBS@@UAEMXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_mic$ = -4						; size = 4
?GetMicVolume@OBS@@UAEMXZ PROC				; OBS::GetMicVolume, COMDAT
; _this$ = ecx

; 1072 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1073 :     HWND mic = GetDlgItem(hwndMain, ID_MICVOLUME);

	push	5007					; 0000138fH
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	call	DWORD PTR __imp__GetDlgItem@8
	mov	DWORD PTR _mic$[ebp], eax

; 1074 :     return GetVolumeControlValue(mic);

	mov	ecx, DWORD PTR _mic$[ebp]
	push	ecx
	call	DWORD PTR __imp_?GetVolumeControlValue@@YAMPAUHWND__@@@Z
	add	esp, 4

; 1075 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMicVolume@OBS@@UAEMXZ ENDP				; OBS::GetMicVolume
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?ToggleMicMute@OBS@@UAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_mic$ = -4						; size = 4
?ToggleMicMute@OBS@@UAEXXZ PROC				; OBS::ToggleMicMute, COMDAT
; _this$ = ecx

; 1078 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1079 :     HWND mic = GetDlgItem(hwndMain, ID_MICVOLUME);

	push	5007					; 0000138fH
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	call	DWORD PTR __imp__GetDlgItem@8
	mov	DWORD PTR _mic$[ebp], eax

; 1080 :     
; 1081 :     /*Send message to microphone volume control and have it handle it*/
; 1082 :     PostMessage(mic, WM_COMMAND, MAKEWPARAM(ID_MICVOLUME, VOLN_TOGGLEMUTE), 0);

	push	0
	push	50467727				; 0302138fH
	push	273					; 00000111H
	mov	ecx, DWORD PTR _mic$[ebp]
	push	ecx
	call	DWORD PTR __imp__PostMessageW@16

; 1083 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ToggleMicMute@OBS@@UAEXXZ ENDP				; OBS::ToggleMicMute
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\api.cpp
;	COMDAT ?GetMicMuted@OBS@@UAE_NXZ
_TEXT	SEGMENT
tv77 = -12						; size = 4
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?GetMicMuted@OBS@@UAE_NXZ PROC				; OBS::GetMicMuted, COMDAT
; _this$ = ecx

; 1086 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1087 :     return GetMicVolume() < VOLN_MUTELEVEL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax
	fstp	DWORD PTR tv77[ebp]
	movss	xmm0, DWORD PTR __real@3d4ccccd
	comiss	xmm0, DWORD PTR tv77[ebp]
	jbe	SHORT $LN3@GetMicMute
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@GetMicMute
$LN3@GetMicMute:
	mov	DWORD PTR tv69[ebp], 0
$LN4@GetMicMute:
	mov	al, BYTE PTR tv69[ebp]

; 1088 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMicMuted@OBS@@UAE_NXZ ENDP				; OBS::GetMicMuted
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??0?$List@K@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$List@K@@QAE@XZ PROC				; List<unsigned long>::List<unsigned long>, COMDAT
; _this$ = ecx

; 35   :     inline List() : array(NULL), num(0) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@K@@QAE@XZ ENDP				; List<unsigned long>::List<unsigned long>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??1?$List@K@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$List@K@@QAE@XZ PROC				; List<unsigned long>::~List<unsigned long>, COMDAT
; _this$ = ecx

; 37   :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 38   :         Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@K@@QAEXXZ			; List<unsigned long>::Clear

; 39   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@K@@QAE@XZ ENDP				; List<unsigned long>::~List<unsigned long>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Clear@?$List@K@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@?$List@K@@QAEXXZ PROC				; List<unsigned long>::Clear, COMDAT
; _this$ = ecx

; 334  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 335  :         if(array)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Clear

; 336  :         {
; 337  :             /*if(IsBadWritePtr(array, sizeof(T)*num))
; 338  :                 CrashError(TEXT("what the.."));*/
; 339  :             Free(array);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4

; 340  :             array = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 341  :             num = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$LN2@Clear:

; 342  :         }
; 343  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$List@K@@QAEXXZ ENDP				; List<unsigned long>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 780  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 781  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 782  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 783  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 990  : 		{	// destroy the string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 991  : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 992  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Num@?$List@PAVSceneItem@@@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Num@?$List@PAVSceneItem@@@@QBEIXZ PROC			; List<SceneItem *>::Num, COMDAT
; _this$ = ecx

; 42   :     inline unsigned int Num() const     {return num;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?Num@?$List@PAVSceneItem@@@@QBEIXZ ENDP			; List<SceneItem *>::Num
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??A?$List@PAVSceneItem@@@@QAEAAPAVSceneItem@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$List@PAVSceneItem@@@@QAEAAPAVSceneItem@@I@Z PROC	; List<SceneItem *>::operator[], COMDAT
; _this$ = ecx

; 379  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  :         assert(index < num);
; 381  :         if(index >= num) {DumpError(TEXT("Out of range!  List<%S>::operator[](%d)"), typeid(T).name(), index); return array[0];}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN1@operator
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	push	OFFSET ?__type_info_root_node@@3U__type_info_node@@A ; __type_info_root_node
	mov	ecx, OFFSET ??_R0PAVSceneItem@@@8
	call	?name@type_info@@QBEPBDPAU__type_info_node@@@Z ; type_info::name
	push	eax
	push	OFFSET ??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp_?DumpError@@YAXPB_WZZ
	mov	eax, 4
	imul	eax, eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN3@operator
$LN1@operator:

; 382  :         return array[index];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _index$[ebp]
	lea	eax, DWORD PTR [eax+ecx*4]
$LN3@operator:

; 383  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@PAVSceneItem@@@@QAEAAPAVSceneItem@@I@Z ENDP	; List<SceneItem *>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ??C?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QBEPAVNetworkStream@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??C?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QBEPAVNetworkStream@@XZ PROC ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::operator->, COMDAT
; _this$ = ecx

; 1457 : 		{	// return pointer to class object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1458 : 		return (_STD pointer_traits<pointer>::pointer_to(**this));

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QBEAAVNetworkStream@@XZ ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::operator*
	push	eax
	call	?pointer_to@?$pointer_traits@PAVNetworkStream@@@std@@SAPAVNetworkStream@@AAV3@@Z ; std::pointer_traits<NetworkStream *>::pointer_to
	add	esp, 4

; 1459 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??C?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QBEPAVNetworkStream@@XZ ENDP ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::operator->
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ??B?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv70 = -4						; size = 4
??B?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QBE_NXZ PROC ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::operator bool, COMDAT
; _this$ = ecx

; 1467 : 		{	// test for non-null pointer

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1468 : 		return (this->_Myptr != pointer());

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@operator
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv70[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv70[ebp]

; 1469 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QBE_NXZ ENDP ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Num@?$List@PAVAudioSource@@@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Num@?$List@PAVAudioSource@@@@QBEIXZ PROC		; List<AudioSource *>::Num, COMDAT
; _this$ = ecx

; 42   :     inline unsigned int Num() const     {return num;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?Num@?$List@PAVAudioSource@@@@QBEIXZ ENDP		; List<AudioSource *>::Num
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?RemoveItem@?$List@PAVAudioSource@@@@QAEXABQAVAudioSource@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
_obj$ = 8						; size = 4
?RemoveItem@?$List@PAVAudioSource@@@@QAEXABQAVAudioSource@@@Z PROC ; List<AudioSource *>::RemoveItem, COMDAT
; _this$ = ecx

; 100  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 101  :         for(UINT i=0; i<num; i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@RemoveItem
$LN3@RemoveItem:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@RemoveItem:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$1[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jae	SHORT $LN5@RemoveItem

; 102  :         {
; 103  :             if(array[i] == obj)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN1@RemoveItem

; 104  :             {
; 105  :                 Remove(i);

	mov	edx, DWORD PTR _i$1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Remove@?$List@PAVAudioSource@@@@QAEXI@Z ; List<AudioSource *>::Remove

; 106  :                 break;

	jmp	SHORT $LN5@RemoveItem
$LN1@RemoveItem:

; 107  :             }
; 108  :         }

	jmp	SHORT $LN3@RemoveItem
$LN5@RemoveItem:

; 109  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?RemoveItem@?$List@PAVAudioSource@@@@QAEXABQAVAudioSource@@@Z ENDP ; List<AudioSource *>::RemoveItem
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??6?$List@PAVAudioSource@@@@QAEAAV0@ABQAVAudioSource@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_val$ = 8						; size = 4
??6?$List@PAVAudioSource@@@@QAEAAV0@ABQAVAudioSource@@@Z PROC ; List<AudioSource *>::operator<<, COMDAT
; _this$ = ecx

; 366  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 367  :         Add(val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Add@?$List@PAVAudioSource@@@@QAEIABQAVAudioSource@@@Z ; List<AudioSource *>::Add

; 368  :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 369  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??6?$List@PAVAudioSource@@@@QAEAAV0@ABQAVAudioSource@@@Z ENDP ; List<AudioSource *>::operator<<
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??A?$List@PAVAudioSource@@@@QAEAAPAVAudioSource@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$List@PAVAudioSource@@@@QAEAAPAVAudioSource@@I@Z PROC ; List<AudioSource *>::operator[], COMDAT
; _this$ = ecx

; 379  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  :         assert(index < num);
; 381  :         if(index >= num) {DumpError(TEXT("Out of range!  List<%S>::operator[](%d)"), typeid(T).name(), index); return array[0];}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN1@operator
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	push	OFFSET ?__type_info_root_node@@3U__type_info_node@@A ; __type_info_root_node
	mov	ecx, OFFSET ??_R0PAVAudioSource@@@8
	call	?name@type_info@@QBEPBDPAU__type_info_node@@@Z ; type_info::name
	push	eax
	push	OFFSET ??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp_?DumpError@@YAXPB_WZZ
	mov	eax, 4
	imul	eax, eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN3@operator
$LN1@operator:

; 382  :         return array[index];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _index$[ebp]
	lea	eax, DWORD PTR [eax+ecx*4]
$LN3@operator:

; 383  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@PAVAudioSource@@@@QAEAAPAVAudioSource@@I@Z ENDP ; List<AudioSource *>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Num@?$List@UClassInfo@@@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Num@?$List@UClassInfo@@@@QBEIXZ PROC			; List<ClassInfo>::Num, COMDAT
; _this$ = ecx

; 42   :     inline unsigned int Num() const     {return num;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?Num@?$List@UClassInfo@@@@QBEIXZ ENDP			; List<ClassInfo>::Num
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?CreateNew@?$List@UClassInfo@@@@QAEPAUClassInfo@@XZ
_TEXT	SEGMENT
_value$ = -8						; size = 4
_this$ = -4						; size = 4
?CreateNew@?$List@UClassInfo@@@@QAEPAUClassInfo@@XZ PROC ; List<ClassInfo>::CreateNew, COMDAT
; _this$ = ecx

; 346  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 347  :         SetSize(num+1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSize@?$List@UClassInfo@@@@QAEHI@Z	; List<ClassInfo>::SetSize

; 348  : 
; 349  :         T *value = &array[num-1];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	imul	ecx, eax, 28
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR _value$[ebp], ecx

; 350  : 
; 351  :         return value;

	mov	eax, DWORD PTR _value$[ebp]

; 352  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?CreateNew@?$List@UClassInfo@@@@QAEPAUClassInfo@@XZ ENDP ; List<ClassInfo>::CreateNew
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??A?$List@UClassInfo@@@@QAEAAUClassInfo@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$List@UClassInfo@@@@QAEAAUClassInfo@@I@Z PROC	; List<ClassInfo>::operator[], COMDAT
; _this$ = ecx

; 379  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  :         assert(index < num);
; 381  :         if(index >= num) {DumpError(TEXT("Out of range!  List<%S>::operator[](%d)"), typeid(T).name(), index); return array[0];}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN1@operator
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	push	OFFSET ?__type_info_root_node@@3U__type_info_node@@A ; __type_info_root_node
	mov	ecx, OFFSET ??_R0?AUClassInfo@@@8
	call	?name@type_info@@QBEPBDPAU__type_info_node@@@Z ; type_info::name
	push	eax
	push	OFFSET ??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp_?DumpError@@YAXPB_WZZ
	mov	eax, 28					; 0000001cH
	imul	eax, eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN3@operator
$LN1@operator:

; 382  :         return array[index];

	imul	eax, DWORD PTR _index$[ebp], 28
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx]
$LN3@operator:

; 383  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@UClassInfo@@@@QAEAAUClassInfo@@I@Z ENDP	; List<ClassInfo>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??A?$List@UClassInfo@@@@QBEAAUClassInfo@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$List@UClassInfo@@@@QBEAAUClassInfo@@I@Z PROC	; List<ClassInfo>::operator[], COMDAT
; _this$ = ecx

; 386  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 387  :         assert(index < num);
; 388  :         if (index >= num) { DumpError(TEXT("Out of range!  List<%S>::operator[](%d)"), typeid(T).name(), index); return array[0]; }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN1@operator
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	push	OFFSET ?__type_info_root_node@@3U__type_info_node@@A ; __type_info_root_node
	mov	ecx, OFFSET ??_R0?AUClassInfo@@@8
	call	?name@type_info@@QBEPBDPAU__type_info_node@@@Z ; type_info::name
	push	eax
	push	OFFSET ??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp_?DumpError@@YAXPB_WZZ
	mov	eax, 28					; 0000001cH
	imul	eax, eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN3@operator
$LN1@operator:

; 389  :         return array[index];

	imul	eax, DWORD PTR _index$[ebp], 28
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx]
$LN3@operator:

; 390  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@UClassInfo@@@@QBEAAUClassInfo@@I@Z ENDP	; List<ClassInfo>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??H?$List@UClassInfo@@@@QBEPAUClassInfo@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??H?$List@UClassInfo@@@@QBEPAUClassInfo@@I@Z PROC	; List<ClassInfo>::operator+, COMDAT
; _this$ = ecx

; 400  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 401  :         assert(index < num);
; 402  :         if (index >= num) { DumpError(TEXT("Out of range!  List<%S>::operator[](%d)"), typeid(T).name(), index); return NULL; }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN1@operator
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	push	OFFSET ?__type_info_root_node@@3U__type_info_node@@A ; __type_info_root_node
	mov	ecx, OFFSET ??_R0?AUClassInfo@@@8
	call	?name@type_info@@QBEPBDPAU__type_info_node@@@Z ; type_info::name
	push	eax
	push	OFFSET ??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp_?DumpError@@YAXPB_WZZ
	xor	eax, eax
	jmp	SHORT $LN3@operator
$LN1@operator:

; 403  :         return array+index;

	imul	eax, DWORD PTR _index$[ebp], 28
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
$LN3@operator:

; 404  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??H?$List@UClassInfo@@@@QBEPAUClassInfo@@I@Z ENDP	; List<ClassInfo>::operator+
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Num@?$List@UGlobalSourceInfo@@@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Num@?$List@UGlobalSourceInfo@@@@QBEIXZ PROC		; List<GlobalSourceInfo>::Num, COMDAT
; _this$ = ecx

; 42   :     inline unsigned int Num() const     {return num;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?Num@?$List@UGlobalSourceInfo@@@@QBEIXZ ENDP		; List<GlobalSourceInfo>::Num
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??A?$List@UGlobalSourceInfo@@@@QAEAAUGlobalSourceInfo@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$List@UGlobalSourceInfo@@@@QAEAAUGlobalSourceInfo@@I@Z PROC ; List<GlobalSourceInfo>::operator[], COMDAT
; _this$ = ecx

; 379  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  :         assert(index < num);
; 381  :         if(index >= num) {DumpError(TEXT("Out of range!  List<%S>::operator[](%d)"), typeid(T).name(), index); return array[0];}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN1@operator
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	push	OFFSET ?__type_info_root_node@@3U__type_info_node@@A ; __type_info_root_node
	mov	ecx, OFFSET ??_R0?AUGlobalSourceInfo@@@8
	call	?name@type_info@@QBEPBDPAU__type_info_node@@@Z ; type_info::name
	push	eax
	push	OFFSET ??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp_?DumpError@@YAXPB_WZZ
	mov	eax, 16					; 00000010H
	imul	eax, eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN3@operator
$LN1@operator:

; 382  :         return array[index];

	mov	eax, DWORD PTR _index$[ebp]
	shl	eax, 4
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx]
$LN3@operator:

; 383  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@UGlobalSourceInfo@@@@QAEAAUGlobalSourceInfo@@I@Z ENDP ; List<GlobalSourceInfo>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Num@?$List@UStreamInfo@@@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Num@?$List@UStreamInfo@@@@QBEIXZ PROC			; List<StreamInfo>::Num, COMDAT
; _this$ = ecx

; 42   :     inline unsigned int Num() const     {return num;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?Num@?$List@UStreamInfo@@@@QBEIXZ ENDP			; List<StreamInfo>::Num
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Remove@?$List@UStreamInfo@@@@QAEXI@Z
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?Remove@?$List@UStreamInfo@@@@QAEXI@Z PROC		; List<StreamInfo>::Remove, COMDAT
; _this$ = ecx

; 88   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 89   :         assert(index < num);
; 90   :         if(index >= num) return;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN2@Remove
	jmp	$LN3@Remove
$LN2@Remove:

; 91   : 
; 92   :         if(!--num) {Free(array); array=NULL; return;}

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	mov	DWORD PTR tv68[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv68[ebp]
	mov	DWORD PTR [ecx+4], edx
	cmp	DWORD PTR tv68[ebp], 0
	jne	SHORT $LN1@Remove
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 0
	jmp	SHORT $LN3@Remove
$LN1@Remove:

; 93   : 
; 94   :         mcpy(&array[index], &array[index+1], sizeof(T)*(num-index));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR _index$[ebp]
	shl	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _index$[ebp]
	add	edx, 1
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _index$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 95   : 
; 96   :         array = (T*)ReAllocate(array, sizeof(T)*num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$LN3@Remove:

; 97   :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?Remove@?$List@UStreamInfo@@@@QAEXI@Z ENDP		; List<StreamInfo>::Remove
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Clear@?$List@UStreamInfo@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@?$List@UStreamInfo@@@@QAEXXZ PROC		; List<StreamInfo>::Clear, COMDAT
; _this$ = ecx

; 334  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 335  :         if(array)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Clear

; 336  :         {
; 337  :             /*if(IsBadWritePtr(array, sizeof(T)*num))
; 338  :                 CrashError(TEXT("what the.."));*/
; 339  :             Free(array);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4

; 340  :             array = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 341  :             num = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$LN2@Clear:

; 342  :         }
; 343  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$List@UStreamInfo@@@@QAEXXZ ENDP		; List<StreamInfo>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?CreateNew@?$List@UStreamInfo@@@@QAEPAUStreamInfo@@XZ
_TEXT	SEGMENT
_value$ = -8						; size = 4
_this$ = -4						; size = 4
?CreateNew@?$List@UStreamInfo@@@@QAEPAUStreamInfo@@XZ PROC ; List<StreamInfo>::CreateNew, COMDAT
; _this$ = ecx

; 346  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 347  :         SetSize(num+1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSize@?$List@UStreamInfo@@@@QAEHI@Z	; List<StreamInfo>::SetSize

; 348  : 
; 349  :         T *value = &array[num-1];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR _value$[ebp], eax

; 350  : 
; 351  :         return value;

	mov	eax, DWORD PTR _value$[ebp]

; 352  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?CreateNew@?$List@UStreamInfo@@@@QAEPAUStreamInfo@@XZ ENDP ; List<StreamInfo>::CreateNew
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??A?$List@UStreamInfo@@@@QAEAAUStreamInfo@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$List@UStreamInfo@@@@QAEAAUStreamInfo@@I@Z PROC	; List<StreamInfo>::operator[], COMDAT
; _this$ = ecx

; 379  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  :         assert(index < num);
; 381  :         if(index >= num) {DumpError(TEXT("Out of range!  List<%S>::operator[](%d)"), typeid(T).name(), index); return array[0];}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN1@operator
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	push	OFFSET ?__type_info_root_node@@3U__type_info_node@@A ; __type_info_root_node
	mov	ecx, OFFSET ??_R0?AUStreamInfo@@@8
	call	?name@type_info@@QBEPBDPAU__type_info_node@@@Z ; type_info::name
	push	eax
	push	OFFSET ??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp_?DumpError@@YAXPB_WZZ
	mov	eax, 16					; 00000010H
	imul	eax, eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN3@operator
$LN1@operator:

; 382  :         return array[index];

	mov	eax, DWORD PTR _index$[ebp]
	shl	eax, 4
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx]
$LN3@operator:

; 383  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@UStreamInfo@@@@QAEAAUStreamInfo@@I@Z ENDP	; List<StreamInfo>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??0?$List@UHotkeyInfo@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$List@UHotkeyInfo@@@@QAE@XZ PROC			; List<HotkeyInfo>::List<HotkeyInfo>, COMDAT
; _this$ = ecx

; 35   :     inline List() : array(NULL), num(0) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@UHotkeyInfo@@@@QAE@XZ ENDP			; List<HotkeyInfo>::List<HotkeyInfo>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??1?$List@UHotkeyInfo@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$List@UHotkeyInfo@@@@QAE@XZ PROC			; List<HotkeyInfo>::~List<HotkeyInfo>, COMDAT
; _this$ = ecx

; 37   :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 38   :         Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@UHotkeyInfo@@@@QAEXXZ	; List<HotkeyInfo>::Clear

; 39   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@UHotkeyInfo@@@@QAE@XZ ENDP			; List<HotkeyInfo>::~List<HotkeyInfo>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Num@?$List@UHotkeyInfo@@@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Num@?$List@UHotkeyInfo@@@@QBEIXZ PROC			; List<HotkeyInfo>::Num, COMDAT
; _this$ = ecx

; 42   :     inline unsigned int Num() const     {return num;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?Num@?$List@UHotkeyInfo@@@@QBEIXZ ENDP			; List<HotkeyInfo>::Num
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Remove@?$List@UHotkeyInfo@@@@QAEXI@Z
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?Remove@?$List@UHotkeyInfo@@@@QAEXI@Z PROC		; List<HotkeyInfo>::Remove, COMDAT
; _this$ = ecx

; 88   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 89   :         assert(index < num);
; 90   :         if(index >= num) return;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN2@Remove
	jmp	$LN3@Remove
$LN2@Remove:

; 91   : 
; 92   :         if(!--num) {Free(array); array=NULL; return;}

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	mov	DWORD PTR tv68[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv68[ebp]
	mov	DWORD PTR [ecx+4], edx
	cmp	DWORD PTR tv68[ebp], 0
	jne	SHORT $LN1@Remove
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 0
	jmp	SHORT $LN3@Remove
$LN1@Remove:

; 93   : 
; 94   :         mcpy(&array[index], &array[index+1], sizeof(T)*(num-index));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR _index$[ebp]
	imul	edx, ecx, 20
	push	edx
	mov	eax, DWORD PTR _index$[ebp]
	add	eax, 1
	imul	ecx, eax, 20
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	push	ecx
	imul	eax, DWORD PTR _index$[ebp], 20
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 95   : 
; 96   :         array = (T*)ReAllocate(array, sizeof(T)*num);

	mov	edx, DWORD PTR _this$[ebp]
	imul	eax, DWORD PTR [edx+4], 20
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+8]
	call	edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$LN3@Remove:

; 97   :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?Remove@?$List@UHotkeyInfo@@@@QAEXI@Z ENDP		; List<HotkeyInfo>::Remove
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?CreateNew@?$List@UHotkeyInfo@@@@QAEPAUHotkeyInfo@@XZ
_TEXT	SEGMENT
_value$ = -8						; size = 4
_this$ = -4						; size = 4
?CreateNew@?$List@UHotkeyInfo@@@@QAEPAUHotkeyInfo@@XZ PROC ; List<HotkeyInfo>::CreateNew, COMDAT
; _this$ = ecx

; 346  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 347  :         SetSize(num+1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSize@?$List@UHotkeyInfo@@@@QAEHI@Z	; List<HotkeyInfo>::SetSize

; 348  : 
; 349  :         T *value = &array[num-1];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	imul	ecx, eax, 20
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR _value$[ebp], ecx

; 350  : 
; 351  :         return value;

	mov	eax, DWORD PTR _value$[ebp]

; 352  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?CreateNew@?$List@UHotkeyInfo@@@@QAEPAUHotkeyInfo@@XZ ENDP ; List<HotkeyInfo>::CreateNew
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??A?$List@UHotkeyInfo@@@@QAEAAUHotkeyInfo@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$List@UHotkeyInfo@@@@QAEAAUHotkeyInfo@@I@Z PROC	; List<HotkeyInfo>::operator[], COMDAT
; _this$ = ecx

; 379  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  :         assert(index < num);
; 381  :         if(index >= num) {DumpError(TEXT("Out of range!  List<%S>::operator[](%d)"), typeid(T).name(), index); return array[0];}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN1@operator
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	push	OFFSET ?__type_info_root_node@@3U__type_info_node@@A ; __type_info_root_node
	mov	ecx, OFFSET ??_R0?AUHotkeyInfo@@@8
	call	?name@type_info@@QBEPBDPAU__type_info_node@@@Z ; type_info::name
	push	eax
	push	OFFSET ??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp_?DumpError@@YAXPB_WZZ
	mov	eax, 20					; 00000014H
	imul	eax, eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN3@operator
$LN1@operator:

; 382  :         return array[index];

	imul	eax, DWORD PTR _index$[ebp], 20
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx]
$LN3@operator:

; 383  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@UHotkeyInfo@@@@QAEAAUHotkeyInfo@@I@Z ENDP	; List<HotkeyInfo>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1130 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1131 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1132 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1133 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1134 : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1135 : 
; 1136 : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1138 : 		else if (_Grow(_Num))

	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1142 : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1143 : 			}
; 1144 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1145 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1167 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1170 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1753 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1754 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 1755 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2272 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2273 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Ptr$1[ebp], eax

; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2279 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$1[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2285 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2286 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 552  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 630  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 631  : 		{	// construct allocator from _Al
; 632  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 683  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 684  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 685  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 517  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 518  : 		return (this->_BUF_SIZE <= this->_Myres
; 519  : 			? _STD addressof(*this->_Bx._Ptr)
; 520  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 521  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ??D?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QBEAAVNetworkStream@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QBEAAVNetworkStream@@XZ PROC ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::operator*, COMDAT
; _this$ = ecx

; 1452 : 		{	// return reference to object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1453 : 		return (*this->_Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 1454 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??D?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QBEAAVNetworkStream@@XZ ENDP ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Add@?$List@PAVAudioSource@@@@QAEIABQAVAudioSource@@@Z
_TEXT	SEGMENT
tv73 = -8						; size = 4
_this$ = -4						; size = 4
_val$ = 8						; size = 4
?Add@?$List@PAVAudioSource@@@@QAEIABQAVAudioSource@@@Z PROC ; List<AudioSource *>::Add, COMDAT
; _this$ = ecx

; 45   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 46   :         array = (T*)ReAllocate(array, sizeof(T)*++num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	DWORD PTR tv73[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR tv73[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 47   :         mcpy(&array[(num-1)], (void*)&val, sizeof(T));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [edx+eax*4-4], ecx

; 48   :         return num-1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1

; 49   :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?Add@?$List@PAVAudioSource@@@@QAEIABQAVAudioSource@@@Z ENDP ; List<AudioSource *>::Add
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Remove@?$List@PAVAudioSource@@@@QAEXI@Z
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?Remove@?$List@PAVAudioSource@@@@QAEXI@Z PROC		; List<AudioSource *>::Remove, COMDAT
; _this$ = ecx

; 88   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 89   :         assert(index < num);
; 90   :         if(index >= num) return;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN2@Remove
	jmp	$LN3@Remove
$LN2@Remove:

; 91   : 
; 92   :         if(!--num) {Free(array); array=NULL; return;}

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	mov	DWORD PTR tv68[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv68[ebp]
	mov	DWORD PTR [ecx+4], edx
	cmp	DWORD PTR tv68[ebp], 0
	jne	SHORT $LN1@Remove
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 0
	jmp	SHORT $LN3@Remove
$LN1@Remove:

; 93   : 
; 94   :         mcpy(&array[index], &array[index+1], sizeof(T)*(num-index));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR _index$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _index$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _index$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 95   : 
; 96   :         array = (T*)ReAllocate(array, sizeof(T)*num);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$LN3@Remove:

; 97   :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?Remove@?$List@PAVAudioSource@@@@QAEXI@Z ENDP		; List<AudioSource *>::Remove
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?SetSize@?$List@UClassInfo@@@@QAEHI@Z
_TEXT	SEGMENT
_bClear$ = -16						; size = 4
_oldNum$ = -12						; size = 4
tv70 = -8						; size = 4
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?SetSize@?$List@UClassInfo@@@@QAEHI@Z PROC		; List<ClassInfo>::SetSize, COMDAT
; _this$ = ecx

; 205  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 206  :         if(num == n)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _n$[ebp]
	jne	SHORT $LN4@SetSize

; 207  :             return FALSE;

	xor	eax, eax
	jmp	$LN5@SetSize
	jmp	SHORT $LN3@SetSize
$LN4@SetSize:

; 208  :         else if(!n)

	cmp	DWORD PTR _n$[ebp], 0
	jne	SHORT $LN3@SetSize

; 209  :         {
; 210  :             Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@UClassInfo@@@@QAEXXZ	; List<ClassInfo>::Clear

; 211  :             return TRUE;

	mov	eax, 1
	jmp	$LN5@SetSize
$LN3@SetSize:

; 212  :         }
; 213  : 
; 214  :         BOOL bClear=(n>num);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jbe	SHORT $LN7@SetSize
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN8@SetSize
$LN7@SetSize:
	mov	DWORD PTR tv70[ebp], 0
$LN8@SetSize:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _bClear$[ebp], ecx

; 215  :         UINT oldNum=num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _oldNum$[ebp], eax

; 216  : 
; 217  :         num = n;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 218  :         array = (T*)ReAllocate(array, sizeof(T)*num);

	mov	eax, DWORD PTR _this$[ebp]
	imul	ecx, DWORD PTR [eax+4], 28
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 219  : 
; 220  :         if(bClear)

	cmp	DWORD PTR _bClear$[ebp], 0
	je	SHORT $LN1@SetSize

; 221  :             zero(&array[oldNum], sizeof(T)*(num-oldNum));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, DWORD PTR _oldNum$[ebp]
	imul	ecx, eax, 28
	push	ecx
	imul	edx, DWORD PTR _oldNum$[ebp], 28
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax]
	push	edx
	call	?zero@@YGXPAXI@Z			; zero
$LN1@SetSize:

; 222  : 
; 223  :         return TRUE;

	mov	eax, 1
$LN5@SetSize:

; 224  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetSize@?$List@UClassInfo@@@@QAEHI@Z ENDP		; List<ClassInfo>::SetSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?SetSize@?$List@UStreamInfo@@@@QAEHI@Z
_TEXT	SEGMENT
_bClear$ = -16						; size = 4
_oldNum$ = -12						; size = 4
tv70 = -8						; size = 4
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?SetSize@?$List@UStreamInfo@@@@QAEHI@Z PROC		; List<StreamInfo>::SetSize, COMDAT
; _this$ = ecx

; 205  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 206  :         if(num == n)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _n$[ebp]
	jne	SHORT $LN4@SetSize

; 207  :             return FALSE;

	xor	eax, eax
	jmp	$LN5@SetSize
	jmp	SHORT $LN3@SetSize
$LN4@SetSize:

; 208  :         else if(!n)

	cmp	DWORD PTR _n$[ebp], 0
	jne	SHORT $LN3@SetSize

; 209  :         {
; 210  :             Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@UStreamInfo@@@@QAEXXZ	; List<StreamInfo>::Clear

; 211  :             return TRUE;

	mov	eax, 1
	jmp	$LN5@SetSize
$LN3@SetSize:

; 212  :         }
; 213  : 
; 214  :         BOOL bClear=(n>num);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jbe	SHORT $LN7@SetSize
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN8@SetSize
$LN7@SetSize:
	mov	DWORD PTR tv70[ebp], 0
$LN8@SetSize:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _bClear$[ebp], ecx

; 215  :         UINT oldNum=num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _oldNum$[ebp], eax

; 216  : 
; 217  :         num = n;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 218  :         array = (T*)ReAllocate(array, sizeof(T)*num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 219  : 
; 220  :         if(bClear)

	cmp	DWORD PTR _bClear$[ebp], 0
	je	SHORT $LN1@SetSize

; 221  :             zero(&array[oldNum], sizeof(T)*(num-oldNum));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, DWORD PTR _oldNum$[ebp]
	shl	eax, 4
	push	eax
	mov	ecx, DWORD PTR _oldNum$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	push	ecx
	call	?zero@@YGXPAXI@Z			; zero
$LN1@SetSize:

; 222  : 
; 223  :         return TRUE;

	mov	eax, 1
$LN5@SetSize:

; 224  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetSize@?$List@UStreamInfo@@@@QAEHI@Z ENDP		; List<StreamInfo>::SetSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?SetSize@?$List@UHotkeyInfo@@@@QAEHI@Z
_TEXT	SEGMENT
_bClear$ = -16						; size = 4
_oldNum$ = -12						; size = 4
tv70 = -8						; size = 4
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?SetSize@?$List@UHotkeyInfo@@@@QAEHI@Z PROC		; List<HotkeyInfo>::SetSize, COMDAT
; _this$ = ecx

; 205  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 206  :         if(num == n)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _n$[ebp]
	jne	SHORT $LN4@SetSize

; 207  :             return FALSE;

	xor	eax, eax
	jmp	$LN5@SetSize
	jmp	SHORT $LN3@SetSize
$LN4@SetSize:

; 208  :         else if(!n)

	cmp	DWORD PTR _n$[ebp], 0
	jne	SHORT $LN3@SetSize

; 209  :         {
; 210  :             Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@UHotkeyInfo@@@@QAEXXZ	; List<HotkeyInfo>::Clear

; 211  :             return TRUE;

	mov	eax, 1
	jmp	$LN5@SetSize
$LN3@SetSize:

; 212  :         }
; 213  : 
; 214  :         BOOL bClear=(n>num);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jbe	SHORT $LN7@SetSize
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN8@SetSize
$LN7@SetSize:
	mov	DWORD PTR tv70[ebp], 0
$LN8@SetSize:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _bClear$[ebp], ecx

; 215  :         UINT oldNum=num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _oldNum$[ebp], eax

; 216  : 
; 217  :         num = n;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 218  :         array = (T*)ReAllocate(array, sizeof(T)*num);

	mov	eax, DWORD PTR _this$[ebp]
	imul	ecx, DWORD PTR [eax+4], 20
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 219  : 
; 220  :         if(bClear)

	cmp	DWORD PTR _bClear$[ebp], 0
	je	SHORT $LN1@SetSize

; 221  :             zero(&array[oldNum], sizeof(T)*(num-oldNum));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, DWORD PTR _oldNum$[ebp]
	imul	ecx, eax, 20
	push	ecx
	imul	edx, DWORD PTR _oldNum$[ebp], 20
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax]
	push	edx
	call	?zero@@YGXPAXI@Z			; zero
$LN1@SetSize:

; 222  : 
; 223  :         return TRUE;

	mov	eax, 1
$LN5@SetSize:

; 224  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetSize@?$List@UHotkeyInfo@@@@QAEHI@Z ENDP		; List<HotkeyInfo>::SetSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Clear@?$List@UHotkeyInfo@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@?$List@UHotkeyInfo@@@@QAEXXZ PROC		; List<HotkeyInfo>::Clear, COMDAT
; _this$ = ecx

; 334  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 335  :         if(array)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Clear

; 336  :         {
; 337  :             /*if(IsBadWritePtr(array, sizeof(T)*num))
; 338  :                 CrashError(TEXT("what the.."));*/
; 339  :             Free(array);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4

; 340  :             array = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 341  :             num = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$LN2@Clear:

; 342  :         }
; 343  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$List@UHotkeyInfo@@@@QAEXXZ ENDP		; List<HotkeyInfo>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PAVNetworkStream@@@std@@SAPAVNetworkStream@@AAV3@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?pointer_to@?$pointer_traits@PAVNetworkStream@@@std@@SAPAVNetworkStream@@AAV3@@Z PROC ; std::pointer_traits<NetworkStream *>::pointer_to, COMDAT

; 233  : 		{	// convert raw reference to pointer

	push	ebp
	mov	ebp, esp

; 234  : 		return (_STD addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$addressof@VNetworkStream@@@std@@YAPAVNetworkStream@@AAV1@@Z ; std::addressof<NetworkStream>
	add	esp, 4

; 235  : 		}

	pop	ebp
	ret	0
?pointer_to@?$pointer_traits@PAVNetworkStream@@@std@@SAPAVNetworkStream@@AAV3@@Z ENDP ; std::pointer_traits<NetworkStream *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN3@assign
$LN2@assign:

; 1157 : 
; 1158 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1161 : 			_Eos(_Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1162 : 			}
; 1163 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 1164 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1334 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1335 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1336 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1337 : 		_Eos(_Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1338 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1339 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -12					; size = 4
__Ptr$2 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1342 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1343 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1344 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1345 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1347 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1350 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], eax

; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$2[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1352 : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1353 : 			}
; 1354 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1355 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2236 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2238 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -12						; size = 4
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2243 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2244 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2245 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2250 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2251 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2252 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2253 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2256 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2259 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2260 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2261 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2262 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2289 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2290 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 2291 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2294 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2295 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 2296 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 801  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 802  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 859  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 492  : 	_String_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 493  : 		{	// initialize values
; 494  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 495  : 		_Myres = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 496  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 510  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 511  : 		return (this->_BUF_SIZE <= this->_Myres
; 512  : 			? _STD addressof(*this->_Bx._Ptr)
; 513  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 514  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Clear@?$List@UClassInfo@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@?$List@UClassInfo@@@@QAEXXZ PROC			; List<ClassInfo>::Clear, COMDAT
; _this$ = ecx

; 334  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 335  :         if(array)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Clear

; 336  :         {
; 337  :             /*if(IsBadWritePtr(array, sizeof(T)*num))
; 338  :                 CrashError(TEXT("what the.."));*/
; 339  :             Free(array);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4

; 340  :             array = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 341  :             num = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$LN2@Clear:

; 342  :         }
; 343  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$List@UClassInfo@@@@QAEXXZ ENDP			; List<ClassInfo>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv75 = -12						; size = 4
__Num$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1758 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1759 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	ecx, DWORD PTR __Num$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv75[ebp], ecx
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1761 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
__Ptr$ = -32						; size = 4
__Newres$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2203 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2204 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	esi, 3
	div	esi
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	sub	eax, ecx
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+20], eax
	ja	SHORT $LN5@Copy

; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	shr	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+20]
	mov	DWORD PTR __Newres$[ebp], ecx

; 2210 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2211 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR __Ptr$[ebp], eax
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2216 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], edx

; 2218 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR __Ptr$[ebp], eax
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2222 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2223 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2224 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2225 : 
; 2226 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements

	mov	edx, DWORD PTR __Oldlen$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2229 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2231 : 		this->_Myres = _Newres;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [ecx+20], edx

; 2232 : 		_Eos(_Oldlen);

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2233 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 573  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 574  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 847  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 848  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 884  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 885  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 578  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 579  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 734  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 735  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 736  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 611  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 613  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$di	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 611  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$di	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 611  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category
	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$di	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 611  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??0_System_error_category@std@@QAE@XZ	; std::_System_error_category::_System_error_category
	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH

; 873  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 877  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 880  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 92   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 96   : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstddef
;	COMDAT ??$addressof@VNetworkStream@@@std@@YAPAVNetworkStream@@AAV1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@VNetworkStream@@@std@@YAPAVNetworkStream@@AAV1@@Z PROC ; std::addressof<NetworkStream>, COMDAT

; 92   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 96   : 	}

	pop	ebp
	ret	0
??$addressof@VNetworkStream@@@std@@YAPAVNetworkStream@@AAV1@@Z ENDP ; std::addressof<NetworkStream>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??1_System_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??1_Iostream_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<wchar_t>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<wchar_t>::id''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

	push	ebp
	mov	ebp, esp

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>

; 724  : 		}

	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 728  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 731  : 		}

	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv70 = -8						; size = 4
$T1 = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T1[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR tv70[ebp], ecx
	jmp	SHORT $LN1@construct
$LN3@construct:
	mov	DWORD PTR tv70[ebp], 0
$LN1@construct:

; 601  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 605  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
END
